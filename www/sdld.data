/*-------------------------------------------------------------------------
   wctomb.c - convert a wide character to a multibyte sequence

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

int wctomb(char *s, wchar_t wc)
{
	if(!s)
		return(0);

	if(wc < 0x80)
	{
		s[0] = wc;
		return(1);
	}
	else if(wc < 0x800)
	{
		s[0] = (wc >> 6) & 0x1f | 0xc0;
		s[1] = (wc >> 0) & 0x3f | 0x80;
		return(2);
	}
	else if(wc >= 0xd800 && wc < 0xe000) // Unpaired surrogate
		return(-1);
	else if(wc < 0x10000)
	{
		s[0] = (wc >> 12) & 0x0f | 0xe0;
		s[1] = (wc >> 6) & 0x3f  | 0x80;
		s[2] = (wc >> 0) & 0x3f  | 0x80;
		return(3);
	}
	else if(wc < 0x110000)
	{
		s[0] = (wc >> 18) & 0x07 | 0xf0;
		s[1] = (wc >> 12) & 0x3f | 0x80;
		s[2] = (wc >> 6) & 0x3f  | 0x80;
		s[3] = (wc >> 0) & 0x3f  | 0x80;
		return(4);
	}
	else
		return(-1);
}

/*-------------------------------------------------------------------------
   tanf.c - Computes tan(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <stdbool.h>

float tancotf(float x, bool iscotan);

float tanf(float x) _FLOAT_FUNC_REENTRANT
{
    return tancotf(x, 0);
}
/*-------------------------------------------------------------------------
   _mulint.c - routine for (unsigned) int (16 bit) multiplication

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Signed and unsigned multiplication are the same - as long as the output
   has the same precision as the input.

   Assembler-functions are provided for:
     ds390
     mcs51 small
     mcs51 small stack-auto
     mcs51 large
*/

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_ds390)
#    if !defined(__SDCC_STACK_AUTO)
#      define _MULINT_ASM_LARGE
#    endif
#  elif defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO) && !defined(__SDCC_PARMS_IN_BANK1)
#        define _MULINT_ASM_SMALL_AUTO
#      else
#        define _MULINT_ASM_SMALL
#      endif
#    else // must be __SDCC_MODEL_LARGE
#      if !defined(__SDCC_STACK_AUTO)
#        define _MULINT_ASM_LARGE
#     endif
#   endif
#  endif
#endif

#if defined(_MULINT_ASM_LARGE)

#pragma save
#pragma less_pedantic
int
_mulint (int a, int b)
{
  a*b; // hush the compiler

  /* mulint=
      (int)(lsb_a*lsb_b) +
      (char)(msb_a*lsb_b)<<8 +
      (char)(lsb_a*msb_b)<<8
  */

  __asm
    mov r2,dph ; msb_a
    mov r3,dpl ; lsb_a

    mov b,r3 ; lsb_a
#if defined(__SDCC_PARMS_IN_BANK1)
    mov a,b1_0
#else
    mov dptr,#__mulint_PARM_2
    movx a,@dptr ; lsb_b
#endif
    mul ab ; lsb_a*lsb_b
    mov r0,a
    mov r1,b

    mov b,r2 ; msb_a
#if defined(__SDCC_PARMS_IN_BANK1)
    mov a,b1_0
#else
    movx a,@dptr ; lsb_b
#endif
    mul ab ; msb_a*lsb_b
    add a,r1
    mov r1,a

    mov b,r3 ; lsb_a
#if defined(__SDCC_PARMS_IN_BANK1)
    mov a,b1_1
#else
    inc dptr
    movx a,@dptr ; msb_b
#endif
    mul ab ; lsb_a*msb_b
    add a,r1

    mov dph,a
    mov dpl,r0
    ret
  __endasm;
}
#pragma restore

#elif defined(_MULINT_ASM_SMALL) || defined(_MULINT_ASM_SMALL_AUTO)

#pragma save
#pragma less_pedantic
int
_mulint_dummy (void) __naked
{
	__asm

__mulint:

	.globl __mulint

#if !defined(__SDCC_STACK_AUTO) || defined(__SDCC_PARMS_IN_BANK1)

#if defined(__SDCC_NOOVERLAY)
	.area DSEG    (DATA)
#else
	.area OSEG    (OVR,DATA)
#endif
#if defined(__SDCC_PARMS_IN_BANK1)
	#define bl 	(b1_0)
	#define bh 	(b1_1)
#else
	#define bl 	(__mulint_PARM_2)
	#define bh 	(__mulint_PARM_2 + 1)
__mulint_PARM_2:

	.globl __mulint_PARM_2

	.ds	2
#endif

	.area CSEG    (CODE)

	; globbered registers none

	mov	a,dpl			;  1  al
	mov	b,bl			;  2  bl
	mul	ab			;  4  al * bl
	xch	a,dpl			;  1  store low-byte of return value, fetch al
	push	b			;  2

	mov	b,bh			;  2  bh
	mul	ab			;  4  al * bh
	pop	b			;  2
	add	a,b			;  1
	xch	a,dph			;  1  ah -> acc

	mov	b,bl			;  2  bl
	mul	ab			;  4  ah * bl
	add	a,dph			;  1
	mov	dph,a			;  1
	ret				;  2
					; 30

#else // __SDCC_STACK_AUTO

	; globbered registers r0

	mov	a,#-2			;  1  return address 2 bytes
	add	a,sp			;  1
	mov	r0,a			;  1  r0 points to bh

	mov	a,@r0			;  1  bh
	mov	b,dpl			;  2  al
	mul	ab			;  4  al * bh
	push	acc			;  2

	mov	b,dpl			;  2  al
	dec	r0			;  1
	mov	a,@r0			;  1  bl
	mul	ab			;  4  al * bl

	mov	dpl,a			;  1  low-byte of return-value

	pop	acc			;  2
	add	a,b			;  1
	xch	a,dph			;  1  ah -> acc

	mov	b,@r0			;  2  bl
	mul	ab			;  4  ah * bl
	add	a,dph			;  1
	mov	dph,a			;  1

	ret

#endif // __SDCC_STACK_AUTO

	__endasm;
}
#pragma restore

#else

#if defined(__SDCC_hc08) || defined(__SDCC_s08) || defined(__SDCC_stm8)
// Big-endian
union uu {
	struct { unsigned char hi, lo ;} s;
        unsigned int t;
};
#else
// Little-endian
union uu {
	struct { unsigned char lo,hi ;} s;
        unsigned int t;
};
#endif

int
_mulint (int a, int b)
{
#if !defined(__SDCC_STACK_AUTO) && (defined(__SDCC_MODEL_LARGE) || defined(__SDCC_ds390))	// still needed for large
	union uu __xdata *x;
	union uu __xdata *y;
	union uu t;
        x = (union uu __xdata *)&a;
        y = (union uu __xdata *)&b;
#else
	register union uu *x;
	register union uu *y;
	union uu t;
        x = (union uu *)&a;
        y = (union uu *)&b;
#endif

  // sdcc is bad at handling union accesses. So we use (unsigned char)a instead of x->s.lo here.
  t.t = (unsigned char)a * (unsigned char)b;
  t.s.hi += ((unsigned char)a * y->s.hi) + (x->s.hi * (unsigned char)b);

  return t.t;
}

#endif

#undef _MULINT_ASM
/*-------------------------------------------------------------------------
   free.c - deallocate memory.

   Copyright (C) 2015, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stddef.h>

#if defined(__SDCC_mcs51) || defined(__SDCC_ds390) || defined(__SDCC_ds400)
#define HEAPSPACE __xdata
#elif defined(__SDCC_pdk13) || defined(__SDCC_pdk14) || defined(__SDCC_pdk15)
#define HEAPSPACE __near
#else
#define HEAPSPACE
#endif

typedef struct header HEAPSPACE header_t;

struct header
{
	header_t *next;
	header_t *next_free;
};

extern header_t *HEAPSPACE __sdcc_heap_free;

void free(void *ptr)
{
	header_t *h, *next_free, *prev_free;
	header_t *HEAPSPACE *f;

	if(!ptr)
		return;

	prev_free = 0;
	for(h = __sdcc_heap_free, f = &__sdcc_heap_free; h && h < ptr; prev_free = h, f = &(h->next_free), h = h->next_free); // Find adjacent blocks in free list
	next_free = h;

	h = (void HEAPSPACE *)((char HEAPSPACE *)(ptr) - offsetof(struct header, next_free));

	// Insert into free list.
	h->next_free = next_free;
	*f = h;

	if(next_free == h->next) // Merge with next block
	{
		h->next_free = h->next->next_free;
		h->next = h->next->next;
	}

	if (prev_free && prev_free->next == h) // Merge with previous block
	{
		prev_free->next = h->next;
		prev_free->next_free = h->next_free;
	}
}

/*-------------------------------------------------------------------------
   realloc.c - allocate memory.
   
   Always behaves according to C90 (i.e. does not take advantage of
   undefined behaviour introduced in C2X or implementation-defined
   behaviour introduced in C17.

   Copyright (C) 2015-2020, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stddef.h>
#include <string.h>

#if defined(__SDCC_mcs51) || defined(__SDCC_ds390) || defined(__SDCC_ds400)
#define HEAPSPACE __xdata
#elif defined(__SDCC_pdk13) || defined(__SDCC_pdk14) || defined(__SDCC_pdk15)
#define HEAPSPACE __near
#else
#define HEAPSPACE
#endif

typedef struct header HEAPSPACE header_t;

struct header
{
	header_t *next;
	header_t *next_free;
};

extern header_t *HEAPSPACE __sdcc_heap_free;

void __sdcc_heap_init(void);

#if defined(__SDCC_mcs51) || defined(__SDCC_ds390) || defined(__SDCC_ds400)
void HEAPSPACE *realloc(void *ptr, size_t size)
#else
void *realloc(void *ptr, size_t size)
#endif
{
	void HEAPSPACE *ret;
	header_t *h, *next_free, *prev_free;
	header_t *HEAPSPACE *f, *HEAPSPACE *pf;
	size_t blocksize, oldblocksize, maxblocksize;

#if defined(__SDCC_mcs51) || defined(__SDCC_ds390) || defined(__SDCC_ds400) || defined(__SDCC_hc08) || defined(__SDCC_s08)
	if(!__sdcc_heap_free)
		__sdcc_heap_init();
#endif

	if(!ptr)
		return(malloc(size));

	if(!size)
	{
		free(ptr);
		return(0);
	}

	prev_free = 0, pf = 0;
	for(h = __sdcc_heap_free, f = &__sdcc_heap_free; h && h < ptr; prev_free = h, pf = f, f = &(h->next_free), h = h->next_free); // Find adjacent blocks in free list
	next_free = h;

	if(size + offsetof(struct header, next_free) < size) // Handle overflow
		return(0);
	blocksize = size + offsetof(struct header, next_free);
	if(blocksize < sizeof(struct header)) // Requiring a minimum size makes it easier to implement free(), and avoid memory leaks.
		blocksize = sizeof(struct header);

	h = (void HEAPSPACE *)((char HEAPSPACE *)(ptr) - offsetof(struct header, next_free));
	oldblocksize = (char HEAPSPACE *)(h->next) - (char HEAPSPACE *)h;

	maxblocksize = oldblocksize;
	if(prev_free && prev_free->next == h) // Can merge with previous block
		maxblocksize += (char HEAPSPACE *)h - (char HEAPSPACE *)prev_free;
	if(next_free == h->next) // Can merge with next block
		maxblocksize += (char HEAPSPACE *)(next_free->next) - (char HEAPSPACE *)next_free;

	if(blocksize <= maxblocksize) // Can resize in place.
	{
		if(prev_free && prev_free->next == h) // Always move into previous block to defragment
		{
			memmove(prev_free, h, blocksize <= oldblocksize ? blocksize : oldblocksize);
			h = prev_free;
			*pf = next_free;
			f = pf;
		}

		if(next_free && next_free == h->next) // Merge with following block
		{
			h->next = next_free->next;
			*f = next_free->next_free;
		}

		if(maxblocksize >= blocksize + sizeof(struct header)) // Create new block from free space
		{
			header_t *const newheader = (header_t *const)((char HEAPSPACE *)h + blocksize);
			newheader->next = h->next;
			newheader->next_free = *f;
			*f = newheader;
			h->next = newheader;
		}

		return(&(h->next_free));
	}

	if(ret = malloc(size))
	{
		size_t oldsize = oldblocksize - offsetof(struct header, next_free);
		memcpy(ret, ptr, size <= oldsize ? size : oldsize);
		free(ptr);
		return(ret);
	}

	return(0);
}

/*-------------------------------------------------------------------------
   errno.c - just declares errno as a variable

   Copyright (C) 2003, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

int errno;
/*-------------------------------------------------------------------------
   expf.c - Computes e**x of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

/* Version 1.0 - Initial release */

#define __SDCC_MATH_LIB
#include <math.h>
#include <errno.h>
#include <stdbool.h>

#ifdef MATH_ASM_MCS51

#define __SDCC_FLOAT_LIB
#include <float.h>

// TODO: share with other temps
static __bit sign_bit;
static __data unsigned char expf_y[4];
static __data unsigned char n;

float expf(float x)
{
	x;
	__asm
	mov	c, acc.7
	mov	_sign_bit, c	// remember sign
	clr	acc.7		// and make input positive
	mov	r0, a
	mov	c, b.7
	rlc	a		// extract exponent
	add	a, #153
	jc	expf_not_zero
	// input is a very small number, so e^x is 1.000000
	mov	dptr, #0
	mov	b, #0x80
	mov	a, #0x3F
	ljmp	expf_exit
expf_not_zero:
	// TODO: check exponent for very small values, and return zero
	mov	_n, #0
	mov	a, dpl
	add	a, #0xE8	// is x >= 0.69314718
	mov	a, dph
	addc	a, #0x8D
	mov	a, b
	addc	a, #0xCE
	mov	a, r0
	addc	a, #0xC0
	mov	a, r0
	jnc	expf_no_range_reduction
expf_range_reduction:
	mov	(_expf_y + 0), dpl	// keep copy of x in "exp_y"
	mov	(_expf_y + 1), dph
	mov	(_expf_y + 2), b
	mov	(_expf_y + 3), a
	mov     r0, #0x3B
	push    ar0
	mov     r0, #0xAA
	push    ar0
	mov     r0, #0xB8
	push    ar0
	mov     r0, #0x3F
	push    ar0
	lcall	___fsmul	// x * 1.442695041 = x / ln(2)
	dec	sp
	dec	sp
	dec	sp
	dec	sp
	lcall	___fs2uchar	// n = int(x * 1.442695041)
	mov	a, dpl
	mov	_n, a
	add	a, #128
	jnc	expf_range_ok
	lcall	fs_return_inf	// exponent overflow
	ljmp	expf_exit
expf_range_ok:
	mov     r0,#0x00
	mov     r1,#0x80
	mov     r2,#0x31
	mov     r3,#0xBF
	lcall	expf_scale_and_add
	mov	(_expf_y + 0), dpl
	mov	(_expf_y + 1), dph
	mov	(_expf_y + 2), b
	mov	(_expf_y + 3), a
	mov     r0,#0x83
	mov     r1,#0x80
	mov     r2,#0x5E
	mov     r3,#0x39
	lcall	expf_scale_and_add
expf_no_range_reduction:


// Compute e^x using the cordic algorithm.  This works over an
// input range of 0 to 0.69314712.  Can be extended to work from
// 0 to 1.0 if the results are normalized, but over the range
// we use, the result is always from 1.0 to 1.99999988 (fixed
// exponent of 127)

expf_cordic_begin:
	mov	c, b.7
	rlc	a		// extract exponent to acc
	setb	b.7
	mov	r1, dpl		// mantissa to r4/r3/r2/r1
	mov	r2, dph
	mov	r3, b
	mov	r4, #0

	// first, align the input into a 32 bit long
	cjne	a, #121, exp_lshift
	sjmp	exp_noshift
exp_lshift:
	jc	exp_rshift
	// exp_a is greater than 121, so left shift
	add	a, #135
	lcall	fs_lshift_a
	sjmp	exp_noshift
exp_rshift:
	// exp_a is less than 121, so right shift
	cpl	a
	add	a, #122
	lcall	fs_rshift_a
exp_noshift:				// r4/r3/r2/r1 = x
	clr	a
	mov	(_expf_y + 0), a	// y = 1.0;
	mov	(_expf_y + 1), a
	mov	(_expf_y + 2), a
	mov	(_expf_y + 3), #0x20
	mov	dptr, #__fs_natural_log_table
	mov	r0, a			// r0 = i
exp_cordic_loop:
	clr	a
	movc	a, @a+dptr
	mov	b, a
	inc	dptr
	clr	a
	movc	a, @a+dptr		// r7/r6/r5/b = table[i]
	mov	r5, a
	inc	dptr
	clr	a
	movc	a, @a+dptr
	mov	r6, a
	inc	dptr
	clr	a
	movc	a, @a+dptr
	mov	r7, a
	inc	dptr
	clr	c
	mov	a, r1
	subb	a, b			// compare x to table[i]
	mov	a, r2
	subb	a, r5
	mov	a, r3
	subb	a, r6
	mov	a, r4
	subb	a, r7
	jc	exp_cordic_skip		// if table[i] < x
	clr	c
	mov	a, r1
	subb	a, b
	mov	r1, a			// x -= table[i]
	mov	a, r2
	subb	a, r5
	mov	r2, a
	mov	a, r3
	subb	a, r6
	mov	r3, a
	mov	a, r4
	subb	a, r7
	mov	r4, a
	mov	b,  (_expf_y + 0)
	mov	r5, (_expf_y + 1)	// r7/r6/r5/b = y >> i
	mov	r6, (_expf_y + 2)
	mov	r7, (_expf_y + 3)
	mov	a, r0
	lcall	__fs_cordic_rshift_r765_unsigned
	mov	a, (_expf_y + 0)
	add	a, b
	mov	(_expf_y + 0), a
	mov	a, (_expf_y + 1)
	addc	a, r5
	mov	(_expf_y + 1), a	// y += (y >> i)
	mov	a, (_expf_y + 2)
	addc	a, r6
	mov	(_expf_y + 2), a
	mov	a, (_expf_y + 3)
	addc	a, r7
	mov	(_expf_y + 3), a
exp_cordic_skip:
	inc	r0
	cjne	r0, #27, exp_cordic_loop
	mov	r4, (_expf_y + 3)
	mov	r3, (_expf_y + 2)
	mov	r2, (_expf_y + 1)
	mov	r1, (_expf_y + 0)
	mov	exp_a, #121
	lcall	fs_normalize_a		// end of cordic

	mov	a, #127
	add	a, _n			// ldexpf(x, n)
	mov	exp_a, a
	lcall	fs_round_and_return

	jnb	_sign_bit, expf_done
	push	dpl
	push	dph
	push	b
	push	acc
	mov	dptr, #0
	mov	b, #0x80
	mov	a, #0x3F
	lcall	___fsdiv		// 1.0 / x
	dec	sp
	dec	sp
	dec	sp
	dec	sp
expf_done:
	clr	acc.7		// Result is always positive!
expf_exit:
	__endasm;
#pragma less_pedantic
}

static void dummy1(void) __naked
{
	__asm
	.globl	fs_lshift_a
expf_scale_and_add:
	push    ar0
	push    ar1
	push    ar2
	push    ar3
	mov	dpl, _n
	lcall	___uchar2fs	// turn n into float
	lcall	___fsmul	// n * scale_factor
	dec	sp
	dec	sp
	dec	sp
	dec	sp
	push	dpl
	push	dph
	push	b
	push	acc
	mov	dpl, (_expf_y + 0)
	mov	dph, (_expf_y + 1)
	mov	b,   (_expf_y + 2)
	mov	a,   (_expf_y + 3)
	lcall	___fsadd	// x += (n * scale_factor)
	dec	sp
	dec	sp
	dec	sp
	dec	sp
	ret
	__endasm;
}

static void dummy(void) __naked
{
	__asm
	.globl	fs_lshift_a
fs_lshift_a:
	jz	fs_lshift_done
	push	ar0
	mov	r0, a
fs_lshift_loop:
	clr	c
	mov	a, r1
	rlc	a
	mov	r1, a
	mov	a, r2
	rlc	a
	mov	r2, a
	mov	a, r3
	rlc	a
	mov	r3, a
	mov	a, r4
	rlc	a
	mov	r4, a
	djnz	r0, fs_lshift_loop
	pop	ar0
fs_lshift_done:
	ret
	__endasm;
}

#else // not MATH_ASM_MCS51

#define P0      0.2499999995E+0
#define P1      0.4160288626E-2
#define Q0      0.5000000000E+0
#define Q1      0.4998717877E-1

#define P(z) ((P1*z)+P0)
#define Q(z) ((Q1*z)+Q0)

#define C1       0.693359375
#define C2      -2.1219444005469058277e-4

#define BIGX    88.72283911  /* ln(HUGE_VALF) */
#define EXPEPS  1.0E-7       /* exp(1.0E-7)=0.0000001 */
#define K1      1.4426950409 /* 1/ln(2) */

float expf(float x) _FLOAT_FUNC_REENTRANT
{
    int n;
    float xn, g, r, z, y;
    bool sign;

    if(x>=0.0)
        { y=x;  sign=0; }
    else
        { y=-x; sign=1; }

    if(y<EXPEPS) return 1.0;

    if(y>BIGX)
    {
        if(sign)
        {
            errno=ERANGE;
            return HUGE_VALF
            ;
        }
        else
        {
            return 0.0;
        }
    }

    z=y*K1;
    n=z;

    if(n<0) --n;
    if(z-n>=0.5) ++n;
    xn=n;
    g=((y-xn*C1))-xn*C2;
    z=g*g;
    r=P(z)*g;
    r=0.5+(r/(Q(z)-r));

    n++;
    z=ldexpf(r, n);
    if(sign)
        return 1.0/z;
    else
        return z;
}

#endif
/*-------------------------------------------------------------------------
   isnan.c - Check if a float value is an NaN (Not a Number)

   Copyright (C) 2016, Ben Shi, powerstudio1st@163.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#define __SDCC_FLOAT_LIB
#include <float.h>
#include <math.h>

int isnan (float f)
{
  unsigned long *pl = (unsigned long *) &f;
  //return (*pl & 0x7f800000) == 0x7f800000 && (*pl & 0x007fffff) != 0;
  return (*pl & 0x7fffffff) > 0x7f800000;
}
/*-------------------------------------------------------------------------
   _memchr.c - part of string library functions

   Copyright (C) 2009-2019, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

void *memchr(const void *s, int c, size_t n)
{
	unsigned char *p = (unsigned char *)s;
	unsigned char *end = p + n;
	for(; p != end; p++)
		if(*p == (unsigned char)c)
			return((void *)p);
	return(0);
}

/*-------------------------------------------------------------------------
   _strchr.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

#undef strchr /* Avoid conflict with builtin strchr() in Z80 and some related ports */

#ifdef __SDCC_BROKEN_STRING_FUNCTIONS
char * strchr ( const char * string, char ch )
#else
char * strchr ( const char * string, int ch )
#endif
{
	while (*string && *string != ch)
		string++;

	if (*string == ch)
		return((char *)string);
	return ( NULL );
}
/*-------------------------------------------------------------------------
   isslower.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* it is important to declare this function extern before including
   the inline definition to give it external linkage */
extern int islower (int c);

/* also include stdio.h before ctype.h here so ctype can perform a
   _Static_assert on EOF */
#include <stdio.h>

#include <ctype.h>
/*-------------------------------------------------------------------------
   _mulschar.c :- routine for signed char (8 bit) multiplication. just calls
                  routine for signed int multiplication after sign extension

   Copyright (C) 2013, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

signed int
_mulschar (signed char x, signed char y)
{
  return ((int)x * (int)y);
}

signed int
_muluschar (unsigned char x, unsigned char y)
{
  return ((int)((signed char)x) * (int)y);
}

unsigned int
_mulsuchar (signed char x, signed char y)
{
  return ((int)((unsigned char)x) * (int)y);
}

/*-------------------------------------------------------------------------
   ldexpf.c - Build a float from a mantisa and exponent.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>

float ldexpf(float x, int pw2)
{
    union float_long fl;
    long e;

    fl.f = x;

    e=(fl.l >> 23) & 0x000000ff;
    e+=pw2;
    fl.l= ((e & 0xff) << 23) | (fl.l & 0x807fffff);

    return(fl.f);
}
/*-------------------------------------------------------------------------
   mbrlen.c - determine number of bytes in next multibyte character

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <wchar.h>

size_t mbrlen(const char *restrict s, size_t n, mbstate_t *restrict ps)
{
	static mbstate_t sps;

	return(mbrtowc(0, s, n, ps ? ps : &sps));
}

/*-------------------------------------------------------------------------
   atomic_flag_clear.c

   Philipp Klaus Krause, pkk@spth.de 2020

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdatomic.h>

void atomic_flag_clear(volatile atomic_flag *object)
{
#if defined(__SDCC_z80) || defined(__SDCC_z180) || defined(__SDCC_ez80_z80) || defined(__SDCC_z80n) || defined(__SDCC_gbz80) || defined(__SDCC_tlcs90) || defined(__SDCC_r2k) || defined(__SDCC_r2ka) || defined(__SDCC_r3ka) || defined(__SDCC_stm8) || defined(__SDCC_hc08) || defined(__SDCC_s08)
	object->flag = 1;
#elif defined(__SDCC_mcs51)
	object->flag = 0;
#else
#error Support for atomic_flag not implemented
#endif
}

/*---------------------------------------------------------------------
   atol() - convert a string to a long integer and return it

   Copyright (C) 2015, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#include <ctype.h>
#include <stdbool.h>

long int atol(const char *nptr)
{
  long int ret = 0;
  bool neg;

  while (isblank (*nptr))
    nptr++;

  neg = (*nptr == '-');

  if (*nptr == '-' || *nptr == '+')
    nptr++;

  while (isdigit (*nptr))
    ret = ret * 10 + (*(nptr++) - '0');

  return (neg ? -ret : ret); // Since -LONG_MIN is LONG_MIN in sdcc, the result value always turns out ok.
}

/*-------------------------------------------------------------------------
   _fsget1arg.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

static void dummy(void) __naked
{
	// input passed in a,b,dph,dpl
	__asm
	.globl	fsgetarg
fsgetarg:
	// extract the input, placing it into:
	//      sign     exponent   mantissa
	//      ----     --------   --------
	//  a:  sign_a   exp_a      r4/r3/r2
	//
	mov	r2, dpl
	mov	r3, dph
	mov	c, b.7
	rlc	a
	mov	sign_a, c
	mov	exp_a, a
	jz	00001$
	setb	b.7
00001$:
	mov	r4, b
	ret
	__endasm;
}

#endif
/*-------------------------------------------------------------------------
   _schar2fs.c - Floating point library in optimized assembly for 8051

   Copyright (C) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// float __schar2fs (char c)
static void dummy(void) __naked
{
	__asm
	.globl	___schar2fs
___schar2fs:
	mov	r4, dpl
	clr	a
	mov	r3, a
	mov	r2, a
	mov	r1, a
	mov	a, #134
	ljmp	slong2fs_doit
	__endasm;
}

#else

/* convert signed char to float */
float __schar2fs (signed char sc) {
  return __slong2fs(sc);
}

#endif
/*-------------------------------------------------------------------------
   mbrtowc.c - convert a multibyte sequence to a wide character

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <wchar.h>
#include <errno.h>

size_t mbrtowc(wchar_t *restrict pwc, const char *restrict s, size_t n, mbstate_t *restrict ps)
{
	unsigned char first_byte;
	unsigned char seqlen;
	char mbseq[4];
	wchar_t codepoint;
	unsigned char i, j;
	static mbstate_t sps;

	if(!s)
		return(mbrtowc(0, "", 1, ps));
	if(!n)
		goto eilseq;
	if(!ps)
	{
		ps = &sps;
	}

	for(i = 0; ps->c[i] && i < 3; i++)
		mbseq[i] = ps->c[i];

	seqlen = 1;
	first_byte = ps->c[0] ? ps->c[0] : *s;

	if(first_byte & 0x80)
	{
		while (first_byte & (0x80 >> seqlen))
			seqlen++;
		first_byte &= (0xff >> (seqlen + 1));
	}

	if(seqlen > 4)
		goto eilseq;

	if(i + n < seqlen) // Incomplete multibyte character
	{
		for(;n-- ; i++)
			ps->c[i] = *s++;
		return(-2);
	}

	for(j = 0; j < i; j++)
		ps->c[j] = 0;

	for(n = 1, i = i ? i : 1; i < seqlen; i++, n++)
	{
		mbseq[i] = *s++;
		if((mbseq[i] & 0xc0) != 0x80)
			goto eilseq;
	}

	codepoint = first_byte;

	for(s = mbseq + 1, seqlen--; seqlen; seqlen--)
	{
		codepoint <<= 6;
		codepoint |= (*s & 0x3f);
		s++;
	}

	if(codepoint >= 0xd800 && codepoint <= 0xdfff) // UTF-16 surrogate.
		return(-1);

	if(pwc)
		*pwc = codepoint;
	return(n);

eilseq:
	errno = EILSEQ;
	return(-1);
}

/*-------------------------------------------------------------------------
   printf_tiny.c - Tiny printf routine for use with sdcc/mcs51

   Copyright (C) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * This tiny printf uses minimal code space, and it is fully reentrant
 * and register bank neutral (usually safe to call from within an
 * interrupt routine).  Code size is under 270 bytes.  Only one library
 * function is called (_gptrget, 41 bytes), in addition to calls to
 * putchar().
 *
 * Five simple formats are supported
 *
 *	%d	signed 16 bit integer decimal (-32768 to 32767)
 *	%u	unsigned 16 bit integer decimal (0 to 65535)
 *	%s	string, takes a 24 bit generic pointer
 *	%c	character.  You must explicitly cast to char in SDCC
 *	%x	16 bit integer in hex (0 to FFFF)
 *
 * For a more complete printf that supports longs, floating point and
 * field width, try using printf_fast() or printf_large().
 */


/* This removes the negative number code, causing "%d" to be the same
   as "%u".  If you don't care about printing negative numbers, this
   will save 21 bytes of code. */
/* #define ALWAYS_PRINT_UNSIGNED */

/* Directly output characters to the serial port using simple polling,
   rather than calling putchar().  This saves 14 bytes, plus the size
   of putchar. */
/* #define DIRECT_SERIAL_OUTPUT */



/* extern void putchar(char ); */


#define print_zero_flag PSW.5


#if !defined(__SDCC_mcs51) || defined(__SDCC_USE_XSTACK) || defined(_SDCC_NO_ASM_LIB_FUNCS)
/* Does printf_tiny really work on ds390 and ds400?
   If it does, enable them in the line above */
#if defined(_SDCC_BUILD_LIB)
/* Disable all warnings if building a library */
#pragma disable_warning 190
#elif defined(__SDCC_USE_XSTACK)
#warning "printf_tiny not built, does not support --xstack"
#elif defined(_SDCC_NO_ASM_LIB_FUNCS)
#warning "printf_tiny not built, _SDCC_NO_ASM_LIB_FUNCS defined"
#else
/* Disable "ISO C forbids an empty source file" warning message */
#pragma disable_warning 190
#endif
#else /* defines are compatible with printf_tiny */



void printf_tiny(__code const char *fmt, ...) __reentrant
{
	fmt;	/* suppress unreferenced variable warning */

	__asm

printf_begin:
	mov	a, _bp		/* r0 will point to va_args (stack) */
	add	a, #253
	mov	r0, a		/* r0 points to MSB of fmt */
	mov	dph, @r0
	dec	r0
	mov	dpl, @r0	/* dptr has address of fmt */
	dec	r0


printf_main_loop:
	clr	a
	movc	a, @a+dptr	/* get next byte of fmt string */
	inc	dptr
	add	a, #256 - 37
	jz	printf_format	/* check for '%' */
	add	a, #37
	jz	printf_end_h
	lcall	printf_putchar
	sjmp	printf_main_loop
printf_end_h:
	ljmp	printf_end


printf_format:
	setb	print_zero_flag
	clr	a
	movc	a, @a+dptr	/* get next byte of data format */
	inc	dptr
	push	dph
	push	dpl


printf_format_s:
	/*cjne	a, #'s', printf_format_c*/
	cjne	a, #115, printf_format_c
printf_string:
	/* print a string... just grab each byte with __gptrget */
	/* the user much pass a 24 bit generic pointer */
	mov	b, @r0		/* b has type of address (generic *) */
	dec	r0
	mov	dph, @r0
	dec	r0
	mov	dpl, @r0	/* dptr has address of user's string */
	dec	r0
printf_str_loop:
	lcall	__gptrget
	jz	printf_format_done
	inc	dptr
	lcall	printf_putchar
	sjmp	printf_str_loop


printf_format_c:
	/*cjne	a, #'c', printf_format_d*/
	cjne	a, #99, printf_format_d
	dec	r0
	mov	a, @r0		/* Acc has the character to print */
	dec	r0
	lcall	printf_putchar
	sjmp	printf_format_done


printf_format_d:
	/*cjne	a, #'d', printf_format_u*/
	cjne	a, #100, printf_format_x
#ifndef ALWAYS_PRINT_UNSIGNED
	mov	a, @r0
	jnb	acc.7, printf_uint
	dec	r0
	mov	a, @r0
	cpl	a
	add	a, #1
	mov	@r0, a
	inc	r0
	mov	a, @r0
	cpl	a
	addc	a, #0
	mov	@r0, a
	/*mov	a, #'-'*/
	mov	a, #45
	lcall	printf_putchar
#endif
	sjmp	printf_uint


printf_format_x:
	/*cjne	a, #'x', printf_format_u*/
	cjne	a, #120, printf_format_u
	mov	dph, @r0
	dec	r0
	mov	dpl, @r0
	dec	r0
	clr	a
printf_hex:
	lcall	printf_phex_lsn
	mov	a, dph
	lcall	printf_phex_msn
	mov	a, dph
	lcall	printf_phex_lsn
	mov	a, dpl
	lcall	printf_phex_msn
	mov	a, dpl
	lcall	printf_phex_lsn
	jnb	print_zero_flag, printf_format_done
	/*mov	a, #'0'*/
	mov	a, #48
	lcall	printf_putchar
printf_format_done:
	pop	dpl
	pop	dph
	ljmp	printf_main_loop


printf_format_u:
	/*cjne	a, #'u', printf_format_done*/
	cjne	a, #117, printf_format_done
printf_uint:
	mov	a, @r0
	mov	r2, a
	dec	r0
	mov	a, @r0
	mov	r1, a
	dec	r0
printf_int2bcd:
	mov	r4, #16
	mov	r5, #39
	lcall	div_by_sub
	mov	r7, a
	mov	r4, #232
	mov	r5, #3
	lcall	div_by_sub
	swap	a
	mov	dph, a
	mov	r4, #100
	mov	r5, #0
	lcall	div_by_sub
	orl	dph, a
	mov	a, r1
	mov	b, #10
	div	ab
	swap	a
	orl	a, b
	mov	dpl, a
	mov	a, r7
	sjmp	printf_hex


	/* Divide r2/r1 by r5/r4 using successive subtraction
	   returns quotient in r2/r1 and remainder in acc. */
div_by_sub:
	mov     r3, #0
div_by_sub_loop:
	inc     r3
        clr     c
        mov     a, r1
        subb    a, r4
        mov     r1, a
        mov     a, r2
        subb    a, r5
        mov     r2, a
        jnc     div_by_sub_loop
        dec     r3
        mov     a, r1
        add     a, r4
        mov     r1, a
        mov     a, r2
        addc    a, r5
        mov     r2, a
        mov     a, r3
        ret


	/* print a hex digit, either upper 4 bit (msn) or lower 4 bits (lsn) */
printf_phex_msn:
	swap	a
printf_phex_lsn:
	anl	a, #15
	jnz	printf_phex_ok
	jb	print_zero_flag, printf_ret
printf_phex_ok:
	clr	print_zero_flag
	add	a, #0x90
	da	a
	addc    a, #0x40
	da	a
printf_putchar:
#ifdef DIRECT_SERIAL_OUTPUT
	jnb	ti, printf_putchar
	clr	ti
	mov	sbuf, a
#else
	push	dph
	push	dpl
	push	b
	mov	dpl, a
	mov	a, r0
	push	acc
	lcall	_putchar
	pop	acc
	mov	r0, a
	pop	b
	pop	dpl
	pop	dph
#endif
printf_ret:
	ret


printf_end:
	__endasm;
}


#endif /* defines compatible with printf_tiny */
/*---------------------------------------------------------------------
   atoi() - convert a string to an integer and return it

   Copyright (C) 2015, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#include <ctype.h>
#include <stdbool.h>

int atoi(const char *nptr)
{
  int ret = 0;
  bool neg;

  while (isblank (*nptr))
    nptr++;

  neg = (*nptr == '-');

  if (*nptr == '-' || *nptr == '+')
    nptr++;

  while (isdigit (*nptr))
    ret = ret * 10 + (*(nptr++) - '0');

  return (neg ? -ret : ret); // Since -INT_MIN is INT_MIN in sdcc, the result value always turns out ok.
}

/*-------------------------------------------------------------------------
   _modslong.c - routine for modulus of 32 bit signed long

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

#if _SDCC_MANGLES_SUPPORT_FUNS
unsigned long _modulong (unsigned long a, unsigned long b);
#endif

/*   Assembler-functions are provided for:
     mcs51 small
     mcs51 small stack-auto
*/

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO) && !defined(__SDCC_PARMS_IN_BANK1)
#        define _MODSLONG_ASM_SMALL_AUTO
#      else
#        define _MODSLONG_ASM_SMALL
#      endif
#    endif
#  endif
#endif

#if defined _MODSLONG_ASM_SMALL

static void
_modslong_dummy (void) __naked
{
	__asm

	#define a0	dpl
	#define a1	dph
	#define a2	b
	#define a3	r1

	.globl __modslong
#if defined(__SDCC_PARMS_IN_BANK1)
	#define b0      (b1_0)
	#define b1      (b1_1)
	#define b2      (b1_2)
	#define b3      (b1_3)
#else
	// _modslong_PARM_2 shares the same memory with _modulong_PARM_2
	// and is defined in _modulong.c
	#define b0      (__modslong_PARM_2)
	#define b1      (__modslong_PARM_2 + 1)
	#define b2      (__modslong_PARM_2 + 2)
	#define b3      (__modslong_PARM_2 + 3)
#endif
__modslong:
				; a3 in acc
				; b3 in (__modslong_PARM_2 + 3)
	mov	a3,a		; save a3

	clr	F0 		; Flag 0 in PSW
				; available to user for general purpose
	jnb	acc.7,a_not_negative

	setb	F0

	clr	a		; a = -a;
	clr	c
	subb	a,a0
	mov	a0,a
	clr	a
	subb	a,a1
	mov	a1,a
	clr	a
	subb	a,a2
	mov	a2,a
	clr	a
	subb	a,a3
	mov	a3,a

a_not_negative:

	mov	a,b3
	jnb	acc.7,b_not_negative

	clr	a		; b = -b;
	clr	c
	subb	a,b0
	mov	b0,a
	clr	a
	subb	a,b1
	mov	b1,a
	clr	a
	subb	a,b2
	mov	b2,a
	clr	a
	subb	a,b3
	mov	b3,a

b_not_negative:

	mov	a,a3		; restore a3 in acc

	lcall	__modulong

	jnb	F0,not_negative

				; result in (a == r1), b, dph, dpl
	clr	a
	clr	c
	subb	a,a0
	mov	a0,a
	clr	a
	subb	a,a1
	mov	a1,a
	clr	a
	subb	a,a2
	mov	a2,a
	clr	a
	subb	a,a3
				; result in a, b, dph, dpl
not_negative:
	ret

	__endasm;
}

#elif defined _MODSLONG_ASM_SMALL_AUTO

static void
_modslong_dummy (void) __naked
{
	__asm

	#define a0	dpl
	#define a1	dph
	#define a2	b
	#define a3	r1

	#define b0	r2
	#define b1	r3
	#define b2	r4
	#define b3	r5

	ar2 = 2			; BUG register set is not considered
	ar3 = 3
	ar4 = 4
	ar5 = 5

	.globl __modslong

__modslong:

				; a3 in acc
	mov	a3,a		; save a3

	clr	F0		; F0 (Flag 0)
				; available to user for general purpose
	jnb	acc.7,a_not_negative

	setb	F0

	clr	a		; a = -a;
	clr	c
	subb	a,a0
	mov	a0,a
	clr	a
	subb	a,a1
	mov	a1,a
	clr	a
	subb	a,a2
	mov	a2,a
	clr	a
	subb	a,a3
	mov	a3,a

a_not_negative:

	mov	a,sp
	add	a,#-2-3		; 2 bytes return address, 3 bytes param b
	mov	r0,a		; r1 points to b0

	mov	ar2,@r0		; load b0
	inc	r0		; r0 points to b1
	mov	ar3,@r0		; b1
	inc	r0
	mov	ar4,@r0		; b2
	inc	r0
	mov	a,@r0		; b3
	mov	b3,a

	jnb	acc.7,b_not_negative

	clr	a		; b = -b;
	clr	c
	subb	a,b0
	mov	b0,a
	clr	a
	subb	a,b1
	mov	b1,a
	clr	a
	subb	a,b2
	mov	b2,a
	clr	a
	subb	a,b3
	mov	b3,a

b_not_negative:

	lcall	__modlong

	jnb	F0,not_negative

				; result in (a == r1), b, dph, dpl
	clr	a
	clr	c
	subb	a,a0
	mov	a0,a
	clr	a
	subb	a,a1
	mov	a1,a
	clr	a
	subb	a,a2
	mov	a2,a
	clr	a
	subb	a,a3		; result in a, b, dph, dpl

not_negative:
	ret

	__endasm;
}

#else // _MODSLONG_ASM

long
_modslong (long a, long b)
{
  long r;

  r = (unsigned long)(a < 0 ? -a : a) % (unsigned long)(b < 0 ? -b : b);

  if (a < 0)
    return -r;
  else
    return r;
}

#endif // _MODSLONG_ASM
/*-------------------------------------------------------------------------
   _strrchr.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

#ifdef __SDCC_BROKEN_STRING_FUNCTIONS
char * strrchr ( const char * string, char ch )
#else
char * strrchr ( const char * string, int ch )
#endif
{
        const char * start = string;

        while (*string++)                       /* find end of string */
                ;
                                                /* search towards front */
        while (--string != start && *string != ch)
                ;

        if (*string == ch)                      /* char found ? */
                return( (char *)string );

        return (NULL) ;
}
/*-------------------------------------------------------------------------
   _rlulonglong.c - routine for left shift of 64 bit unsigned long long

   Copyright (C) 2012, Philipp Klaus Krause . philipp@informatik.uni-frankfurt.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#pragma std_c99

#include <stdint.h>

#ifdef __SDCC_LONGLONG

#if defined(__SDCC_hc08) || defined(__SDCC_s08) || defined(__SDCC_stm8) // Big-endian

unsigned long long _rlulonglong(unsigned long long l, char s)
{
	uint32_t *const top = (uint32_t *)((char *)(&l) + 0);
	uint16_t *const middle = (uint16_t *)((char *)(&l) + 4);
	uint32_t *const bottom = (uint32_t *)((char *)(&l) + 4);
	uint16_t *const b = (uint16_t *)(&l);

	for(;s >= 16; s-= 16)
	{
		b[0] = b[1];
		b[1] = b[2];
		b[2] = b[3];
		b[3] = 0;
	}

	(*top) <<= s;
	(*top) |= (((uint32_t)((*middle) & 0xffffu) << s) >> 16);
	(*bottom) <<= s;

	return(l);
}

#else // Little-endian

unsigned long long _rlulonglong(unsigned long long l, char s)
{
	uint32_t *const top = (uint32_t *)((char *)(&l) + 4);
	uint16_t *const middle = (uint16_t *)((char *)(&l) + 2);
	uint32_t *const bottom = (uint32_t *)(&l);
	uint16_t *const b = (uint16_t *)(&l);

	for(;s >= 16; s-= 16)
	{
		b[3] = b[2];
		b[2] = b[1];
		b[1] = b[0];
		b[0] = 0;
	}

	(*top) <<= s;
	(*top) |= (((uint32_t)((*middle) & 0xffffu) << s) >> 16);
	(*bottom) <<= s;

	return(l);
}

#endif

#endif

/*-------------------------------------------------------------------------
   _fscmp.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

static void dummy(void) __naked
{
	__asm

	.globl	fs_compare_uint32
fs_compare_uint32:
	mov	r1, #1
	mov	r2, dpl
	mov	a, @r0
	mov	dpl, r7
	cjne	a, dpl, compare32_done
	dec	r0
	mov	a, @r0
	cjne	a, b, compare32_done
	dec	r0
	mov	a, @r0
	cjne	a, dph, compare32_done
	dec	r0
	mov	a, @r0
	mov	dpl, r2
	cjne	a, dpl, compare32_done
	mov	r1, #0
compare32_done:
	ret


	.globl	fs_check_negative_zeros
fs_check_negative_zeros:
a_check:
	cjne	a, #0x80, a_not_neg_zero
	mov	a, b
	jnz	a_not_neg_zero_cleanup
	mov	a, dph
	jnz	a_not_neg_zero_cleanup
	mov	a, dpl
	jnz	a_not_neg_zero_cleanup
	mov	r7, #0
a_not_neg_zero_cleanup:
	mov	a, r7
a_not_neg_zero:

b_check:
	cjne	@r0, #0x80, b_not_neg_zero
	dec	r0
	cjne	@r0, #0, b_not_neg_zero_cleanup_1
	dec	r0
	cjne	@r0, #0, b_not_neg_zero_cleanup_2
	dec	r0
	cjne	@r0, #0, b_not_neg_zero_cleanup_3
	inc	r0
	inc	r0
	inc	r0
	mov	@r0, #0
	ret
b_not_neg_zero_cleanup_3:
	inc	r0
b_not_neg_zero_cleanup_2:
	inc	r0
b_not_neg_zero_cleanup_1:
	inc	r0
b_not_neg_zero:
	ret

	__endasm;
}

#endif
/*-------------------------------------------------------------------------
   cotf.c - Computes cot(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>
#include <stdbool.h>

float tancotf(float x, bool iscotan);

float cotf(float x) _FLOAT_FUNC_REENTRANT
{
    float y;

    y=fabsf(x);
    if (y<1.0E-30) //This one requires more thinking...
    {
        errno = ERANGE;
        if (x<0.0)
            return -HUGE_VALF;
        else
            return +HUGE_VALF;
    }
    return tancotf(x, 1);
}
/*-------------------------------------------------------------------------
   _fsnormalize.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/



#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

static void dummy(void) __naked
{
	__asm
	.globl	fs_normalize_a
fs_normalize_a:
#ifdef FLOAT_SHIFT_SPEEDUP
	mov	r0, #4
	mov	a, r4
00001$:
	jnz	00003$
	mov	a, exp_a
	add	a, #248
	jnc	00002$	;denormalized
	mov	exp_a, a
	clr	a
	xch	a, r1
	xch	a, r2
	xch	a, r3
	mov	r4, a
	//mov	r4, ar3
	//mov	r3, ar2
	//mov	r2, ar1
	//mov	r1, #0
	djnz	r0, 00001$
	ret
#endif
00002$:
	mov	a, r4
00003$:
	mov	r0, #32
	inc	exp_a
00004$:
	jb	acc.7, 00006$
	djnz	exp_a, 00005$
	ret			;denormalized
00005$:
	clr	c
	mov	a, r1
	rlc	a
	mov	r1, a
	mov	a, r2
	rlc	a
	mov	r2, a
	mov	a, r3
	rlc	a
	mov	r3, a
	mov	a, r4
	rlc	a
	mov	r4, a
	djnz	r0, 00004$
00006$:
	dec	exp_a
	ret
	__endasm;
}

#endif
/*-----------------------------------------------------------------
   vprintf.c - formatted output conversion

   Copyright (C) 1999, Martijn van Balen <aed AT iae.nl>
   Refactored by - Maarten Brock (2004)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

static void
put_char_to_stdout (char c, void* p) _REENTRANT
{
  p;  //make compiler happy
  putchar (c);
}

int
vprintf (const char *format, va_list ap)
{
  return _print_format (put_char_to_stdout, NULL, format, ap);
}

int
printf (const char *format, ...)
{
  va_list arg;
  int i;

  va_start (arg, format);
  i = _print_format (put_char_to_stdout, NULL, format, arg);
  va_end (arg);

  return i;
}
/*-------------------------------------------------------------------------
   _itoa.c - integer to string conversion

   Copyright (c) 1999, Bela Torok, bela.torok@kssg.ch

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

/*-------------------------------------------------------------------------
 usage:

 __uitoa(unsigned int value, char* string, int radix)
 __itoa(int value, char* string, int radix)

 value  ->  Number to be converted
 string ->  Result
 radix  ->  Base of value (e.g.: 2 for binary, 10 for decimal, 16 for hex)
---------------------------------------------------------------------------*/

void __uitoa(unsigned int value, char* string, unsigned char radix)
{
  signed char index = 0, i = 0;

  /* generate the number in reverse order */
  do {
    string[index] = '0' + (value % radix);
    if (string[index] > '9')
        string[index] += 'A' - '9' - 1;
    value /= radix;
    ++index;
  } while (value != 0);

  /* null terminate the string */
  string[index--] = '\0';

  /* reverse the order of digits */
  while (index > i) {
    char tmp = string[i];
    string[i] = string[index];
    string[index] = tmp;
    ++i;
    --index;
  }
}

void __itoa(int value, char* string, unsigned char radix)
{
  if (value < 0 && radix == 10) {
    *string++ = '-';
    value = -value;
  }
  __uitoa(value, string, radix);
}

/*-------------------------------------------------------------------------
   _rrulonglong.c - routine for right shift of 64 bit unsigned long long

   Copyright (C) 2012, Philipp Klaus Krause . philipp@informatik.uni-frankfurt.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#pragma std_c99

#include <stdint.h>

#ifdef __SDCC_LONGLONG
// This function is the same as the one from rrulonglong_rrx_s.c, except for the type of top.

#if defined(__SDCC_hc08) || defined(__SDCC_s08) || defined(__SDCC_stm8) // Big-endian

long long _rrslonglong(long long l, char s)
{
	int32_t *top = (uint32_t *)((char *)(&l) + 0);
	uint32_t *middle = (uint16_t *)((char *)(&l) + 2);
	uint32_t *bottom = (uint32_t *)((char *)(&l) + 4);
	uint16_t *b = (uint16_t *)(&l);

	for(;s >= 16; s-= 16)
	{
		b[3] = b[2];
		b[2] = b[1];
		b[1] = b[0];
		b[0] = (b[0] & 0x8000) ? 0xffff : 0x000000;
	}

	(*bottom) >>= s;
	(*middle) |= (((*middle & 0xffff0000ul) >> s) & 0x0000fffful);
	(*top) >>= s;

	return(l);
}

#else // Little-endian

long long _rrslonglong(long long l, char s)
{
	int32_t *top = (uint32_t *)((char *)(&l) + 4);
	uint16_t *middle = (uint16_t *)((char *)(&l) + 3);
	uint32_t *bottom = (uint32_t *)(&l);
	uint16_t *b = (uint16_t *)(&l);

	for(;s >= 16; s-= 16)
	{
		b[0] = b[1];
		b[1] = b[2];
		b[2] = b[3];
		b[3] = (b[3] & 0x8000) ? 0xffff : 0x000000;
	}

	(*bottom) >>= s;
	(*bottom) |= ((uint32_t)((*middle) >> s) << 16);
	(*top) |= (((*middle) & 0xffff0000) >> s);

	return(l);
}
#endif

#endif

/*-------------------------------------------------------------------------
   _fs2uchar.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// unsigned char __fs2uchar (float x)
static void dummy(void) __naked
{
	__asm
	.globl	___fs2uchar
___fs2uchar:
	mov	r7, #134
	lcall	fs2ulong_begin
	mov	dpl, a
	ret
	__endasm;
}

#else

/* convert float to unsigned char */
unsigned char __fs2uchar (float f)
{
  unsigned long ul=__fs2ulong(f);
  if (ul>=UCHAR_MAX) return UCHAR_MAX;
  return ul;
}

#endif
/*---------------------------------------------------------------------
   strtoul() - convert a string to a unsigned long int and return it

   Copyright (C) 2018, Philipp Klaus Krause . krauseph@informatik.uni-freiburg.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>
#include <errno.h>

static signed char _isdigit(const char c, unsigned char base)
{
  unsigned char v;

  if (c >= '0' && c <= '9')
    v = c - '0';
  else if (c >= 'a' && c <='z')
    v = c - 'a' + 10;
  else if (c >= 'A' && c <='Z')
    v = c - 'A' + 10;
  else
    return (-1);

  if (v >= base)
    return (-1);

  return (v);
}

unsigned long int strtoul(const char *nptr, char **endptr, int base)
{
  const char *ptr = nptr;
  unsigned long int ret;
  bool range_error = false;
  bool neg = false;

  while (isblank (*ptr))
    ptr++;

  // Handle sign.
  switch(*ptr)
    {
    case '-':
      neg = true;
    case '+':
      ptr++;
    }

  // base not specified.
  if (!base)
    {
      if (!strncmp (ptr, "0x", 2) || !strncmp (ptr, "0X", 2))
        {
          base = 16;
          ptr += 2;
        }
      else if (*ptr == '0')
        {
          base = 8;
          ptr++;
        }
      else
        base = 10;
    }
  // Handle optional hex prefix.
  else if (base == 16 && (!strncmp (ptr, "0x", 2) || !strncmp (ptr, "0X", 2)))
    ptr += 2;


  // Empty sequence conversion error
  if (_isdigit (*ptr, base) < 0)
    {
      if (endptr)
        *endptr = (char*)nptr;
      return (0);
    }

  for (ret = 0;; ptr++)
    {
      unsigned long int oldret;
      signed char digit = _isdigit (*ptr, base);

      if (digit < 0)
        break;

      oldret = ret;
      ret *= base;
      if (ret < oldret)
        range_error = true;

      ret += (unsigned char)digit;
    }

  if (endptr)
    *endptr = (char*)ptr;

  if (range_error)
    {
      errno = ERANGE;
      return (ULONG_MAX);
    }

  return (neg ? -ret : ret);
}

/*---------------------------------------------------------------------
   atoll() - convert a string to a long long integer and return it

   Copyright (C) 2015, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#include <ctype.h>
#include <stdbool.h>

#ifdef __SDCC_LONGLONG
long long int atoll(const char *nptr)
{
  long long int ret = 0;
  bool neg;

  while (isblank (*nptr))
    nptr++;

  neg = (*nptr == '-');

  if (*nptr == '-' || *nptr == '+')
    nptr++;

  while (isdigit (*nptr))
    ret = ret * 10 + (*(nptr++) - '0');

  return (neg ? -ret : ret); // Since -LLONG_MIN is LLONG_MIN in sdcc, the result value always turns out ok.
}
#endif

/*-------------------------------------------------------------------------
   _fsrshift.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/



#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

static void dummy(void) __naked
{
	__asm
	.globl	fs_rshift_a
fs_rshift_a:
	jz	00020$
	mov	r0, a
	add	a, exp_a	// adjust exponent
	jnc	00001$
	mov	a, #255		// don't roll over
00001$:
	mov	exp_a, a
#ifdef FLOAT_SHIFT_SPEEDUP
	mov	a, r0
	add	a, #248
	jnc	00003$
	xch	a, r4
	xch	a, r3
	xch	a, r2
	mov	r1, a
	clr	a
	xch	a, r4
	//mov	r1, ar2		// avoid dependence on register bank
	//mov	r2, ar3
	//mov	r3, ar4
	//mov	r4, #0
	add	a, #248
	jnc	00003$
	xch	a, r3
	xch	a, r2
	mov	r1, a
	clr	a
	xch	a, r3
	//mov	r1, ar2
	//mov	r2, ar3
	//mov	r3, #0
	add	a, #248
	jnc	00003$
	xch	a, r2
	mov	r1, a
	clr	a
	xch	a, r2
	//mov	r1, ar2
	//mov	r2, #0
	add	a, #248
	jnc	00003$
	mov	r1, #0
	ret
00003$:
	add	a, #8
	jz	00020$
	mov	r0, a
#endif
00005$:
	clr	c
	mov	a, r4
	rrc	a
	mov	r4, a
	mov	a, r3
	rrc	a
	mov	r3, a
	mov	a, r2
	rrc	a
	mov	r2, a
	mov	a, r1
	rrc	a
	mov	r1, a
	djnz	r0, 00005$
00020$:
	ret
	__endasm;
}

#endif
/*-------------------------------------------------------------------------
   _ltoa.c - integer to string conversion

   Copyright (c) 1999, Bela Torok, bela.torok@kssg.ch

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
 usage:

 __ultoa(unsigned long value, char* string, int radix)
 __ltoa(long value, char* string, int radix)

 value  ->  Number to be converted
 string ->  Result
 radix  ->  Base of value (e.g.: 2 for binary, 10 for decimal, 16 for hex)
---------------------------------------------------------------------------*/

#include <stdlib.h>

/* "11110000111100001111000011110000" base 2 */
/* "37777777777" base 8 */
/* "4294967295" base 10 */
#define NUMBER_OF_DIGITS 32	/* eventually adapt if base 2 not needed */

#if NUMBER_OF_DIGITS < 32
# warning _ltoa() and _ultoa() are not save for radix 2
#endif

#if defined (__SDCC_mcs51) && defined (__SDCC_MODEL_SMALL) && !defined (__SDCC_STACK_AUTO)
# define MEMSPACE_BUFFER __idata	/* eventually __pdata or __xdata */
# pragma nogcse
#else
# define MEMSPACE_BUFFER
#endif

void __ultoa(unsigned long value, char* string, unsigned char radix)
{
  char MEMSPACE_BUFFER buffer[NUMBER_OF_DIGITS];  /* no space for '\0' */
  unsigned char index = NUMBER_OF_DIGITS;

  do {
    unsigned char c = '0' + (value % radix);
    if (c > (unsigned char)'9')
       c += 'A' - '9' - 1;
    buffer[--index] = c;
    value /= radix;
  } while (value);

  do {
    *string++ = buffer[index];
  } while ( ++index != NUMBER_OF_DIGITS );

  *string = 0;  /* string terminator */
}

void __ltoa(long value, char* string, unsigned char radix)
{
  if (value < 0 && radix == 10) {
    *string++ = '-';
    value = -value;
  }
  __ultoa(value, string, radix);
}

/*-------------------------------------------------------------------------
   powf.c - Computes x**y where x and y are 32-bit floats.
            WARNING: less that 6 digits accuracy.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>

float powf(float x, float y)
{
    if(y == 0.0) return 1.0;
    if(y == 1.0) return x;
    if(x <= 0.0) return 0.0;
    return expf(logf(x) * y);
}
/*-------------------------------------------------------------------------
   _modulong.c - routine for modulus of 32 bit unsigned long

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Bug fixes by Martijn van Balen, aed@iae.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*   Assembler-functions are provided for:
     mcs51 small
     mcs51 small stack-auto
*/

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO) && !defined (__SDCC_PARMS_IN_BANK1)
#        define _MODULONG_ASM_SMALL_AUTO
#      else
#        define _MODULONG_ASM_SMALL
#      endif
#    endif
#  endif
#endif

#if defined _MODULONG_ASM_SMALL

static void
_modlong_dummy (void) __naked
{
	__asm

	.globl __modulong

	#define a0	dpl
	#define a1	dph
	#define a2	b
	#define a3	r1
	#define count   r0

__modulong:
#if defined(__SDCC_PARMS_IN_BANK1)
	#define b0      (b1_0)
	#define b1      (b1_1)
	#define b2      (b1_2)
	#define b3      (b1_3)
#else
#if defined(__SDCC_NOOVERLAY)
	.area DSEG    (DATA)
#else
	.area OSEG    (OVR,DATA)
#endif

	.globl __modulong_PARM_2
	.globl __modslong_PARM_2

__modulong_PARM_2:
__modslong_PARM_2:
	.ds	4

	.area CSEG    (CODE)

	#define b0      (__modulong_PARM_2)
	#define b1      (__modulong_PARM_2 + 1)
	#define b2      (__modulong_PARM_2 + 2)
	#define b3      (__modulong_PARM_2 + 3)
#endif
				; parameter a comes in a, b, dph, dpl
	mov	a3,a		; save parameter a3

	mov	a,b0		; b == 0? avoid endless loop
	orl	a,b1
	orl	a,b2
	orl	a,b3
	jz	div_by_0

	mov	count,#0
	clr	c		; when loop1 jumps immediately to loop2

loop1:	inc	count

	mov	a,b3		; if (!MSB_SET(b))
	jb	acc.7,loop2

	mov	a,b0		; b <<= 1
	add	a,acc
	mov	b0,a
	mov	a,b1
	rlc	a
	mov	b1,a
	mov	a,b2
	rlc	a
	mov	b2,a
	mov	a,b3
	rlc	a
	mov	b3,a

	mov	a,a0		; a - b
	subb	a,b0		; here carry is always clear
	mov	a,a1
	subb	a,b1
	mov	a,a2
	subb	a,b2
	mov	a,a3
	subb	a,b3

	jnc	loop1


	clr	c
	mov	a,b3		; b >>= 1;
	rrc	a
	mov	b3,a
	mov	a,b2
	rrc	a
	mov	b2,a
	mov	a,b1
	rrc	a
	mov	b1,a
	mov	a,b0
	rrc	a
	mov	b0,a

loop2:	; clr	c		  never set
	mov	a,a0		; a - b
	subb	a,b0
	mov	r4,a
	mov	a,a1
	subb	a,b1
	mov	r5,a
	mov	a,a2
	subb	a,b2
	mov	r6,a
	mov	a,a3
	subb	a,b3

	jc	smaller		; a >= b?

	mov	a3,a		; -> yes;  a = a - b;
	mov	a2,r6
	mov	a1,r5
	mov	a0,r4
smaller:			; -> no
	clr	c
	mov	a,b3		; b >>= 1;
	rrc	a
	mov	b3,a
	mov	a,b2
	rrc	a
	mov	b2,a
	mov	a,b1
	rrc	a
	mov	b1,a
	mov	a,b0
	rrc	a
	mov	b0,a

	djnz	count,loop2

	mov	a,a3		; prepare the return value
div_by_0:
	ret

	__endasm;
}

#elif defined _MODULONG_ASM_SMALL_AUTO

static void
_modlong_dummy (void) __naked
{
	__asm

	.globl __modulong

__modulong:

	#define count   r0

	#define a0	dpl
	#define a1	dph
	#define a2	b
	#define a3	r1

	#define b0	r2
	#define b1	r3
	#define b2	r4
	#define b3	r5

	ar2 = 2			; BUG register set is not considered
	ar3 = 3
	ar4 = 4
	ar5 = 5

	.globl __modlong	; entry point for __modslong

				; parameter a comes in a, b, dph, dpl
	mov	a3,a		; save parameter a3

	mov	a,sp
	add	a,#-2-3		; 2 bytes return address, 3 bytes param b
	mov	r0,a		; r1 points to b0

	mov	ar2,@r0		; load b0
	inc	r0		; r0 points to b1
	mov	ar3,@r0		; b1
	inc	r0
	mov	ar4,@r0		; b2
	inc	r0
	mov	ar5,@r0		; b3

__modlong:			; entry point for __modslong
				; a in r1, b, dph, dpl
				; b in r5, r4, r3, r2 

	mov	count,#0

	mov	a,b0		; b == 0? avoid endless loop
	orl	a,b1
	orl	a,b2
	orl	a,b3
	jz	div_by_0

	mov	count,#0
	clr	c		; when loop1 jumps immediately to loop2

loop1:	inc	count

	mov	a,b3		; if (!MSB_SET(b))
	jb	acc.7,loop2

	mov	a,b0		; b <<= 1
	add	a,acc
	mov	b0,a
	mov	a,b1
	rlc	a
	mov	b1,a
	mov	a,b2
	rlc	a
	mov	b2,a
	mov	a,b3
	rlc	a
	mov	b3,a

	mov	a,a0		; a - b
	subb	a,b0		; here carry is always clear
	mov	a,a1
	subb	a,b1
	mov	a,a2
	subb	a,b2
	mov	a,a3
	subb	a,b3

	jnc	loop1

	clr	c
	mov	a,b3		; b >>= 1;
	rrc	a
	mov	b3,a
	mov	a,b2
	rrc	a
	mov	b2,a
	mov	a,b1
	rrc	a
	mov	b1,a
	mov	a,b0
	rrc	a
	mov	b0,a

loop2:	; clr	c		  never set
	mov	a,a0		; a - b
	subb	a,b0
	mov	a,a1
	subb	a,b1
	mov	r6,a		; d1
	mov	a,a2
	subb	a,b2
	mov	r7,a		; d2
	mov	a,a3
	subb	a,b3

	jc	smaller		; a >= b?

	mov	a3,a		; -> yes;  a = a - b;
	mov	a2,r7
	mov	a1,r6
	mov	a,a0
	subb	a,b0
	mov	a0,a
smaller:			; -> no
	clr	c
	mov	a,b3		; b >>= 1;
	rrc	a
	mov	b3,a
	mov	a,b2
	rrc	a
	mov	b2,a
	mov	a,b1
	rrc	a
	mov	b1,a
	mov	a,b0
	rrc	a
	mov	b0,a

	djnz	count,loop2

	mov	a,a3		; prepare the return value
div_by_0:
	ret

	__endasm;
}

#else // _MODULONG_ASM

#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1)

unsigned long
_modulong (unsigned long a, unsigned long b)
{
  unsigned char count = 0;

  while (!MSB_SET(b))
  {
     b <<= 1;
     if (b > a)
     {
        b >>=1;
        break;
     }
     count++;
  }
  do
  {
    if (a >= b)
      a -= b;
    b >>= 1;
  }
  while (count--);

  return a;
}

#endif // _MODULONG_ASM
/*-------------------------------------------------------------------------
   _memmove.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adapted By -  Erik Petrich  . epetrich@users.sourceforge.net
   from _memcpy.c which was originally

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
#include <string.h>
#include <stdint.h>
#include <sdcc-lib.h>

void *memmove (void *dst, const void *src, size_t size)
{
	size_t c = size;
	if (c == 0)
		return dst;

	char *d = dst;
	const char *s = src;
	if (s < d) {
		d += c;
		s += c;
		do {
			*--d = *--s;
		} while (--c);
	} else {
		do {
			*d++ = *s++;
		} while (--c);
	}

	return dst;
}
/*-------------------------------------------------------------------------
   _heap.c - memory heap for malloc and friends

   Copyright (C) 2006, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
   This is the default heap. If you need a different size (make a copy and)
   recompile it with -D HEAP_SIZE=<size> where <size> is whatever you need.
   Link the resulting object explicitly with your project.
*/

#ifndef HEAP_SIZE
#define HEAP_SIZE 1024
#endif

__xdata char __sdcc_heap[HEAP_SIZE];
const unsigned int __sdcc_heap_size = HEAP_SIZE;

/*-------------------------------------------------------------------------
   _memcmp.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

int memcmp (const void * buf1, const void * buf2, size_t count)
{
	if (!count)
		return(0);

	while ( --count && *((char *)buf1) == *((char *)buf2) ) {
		buf1 = (char *)buf1 + 1;
		buf2 = (char *)buf2 + 1;
	}

	return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}
/*-------------------------------------------------------------------------
   c32rtomb.c - convert a wide character to a multibyte sequence

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <uchar.h>

#include <stdlib.h>

size_t c32rtomb(char *restrict s, char32_t c32, mbstate_t *restrict ps)
{
	ps;
	return(wctomb(s, c32));
}

/*-------------------------------------------------------------------------
   _gptrget.c - get value for a generic pointer

   Copyright (c) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* not all devices use P2 to page pdata memory, therefore __XPAGE was
   introduced. On some targets __XPAGE itself is a paged SFR so it is
   not safe for all platforms to set this. Furthermore some targets
   can be configured to behave differently for movx @dptr vs. movx @Ri
   (don't drive high byte of address bus for movx @Ri only) */
#define USE_PDATA_PAGING_REGISTER 0

__sbit __at (0xF7) B_7;
__sbit __at (0xF6) B_6;
__sbit __at (0xF5) B_5;

/* the  return value is expected to be in acc, and not in the standard
 * location dpl. Therefore we choose return type void here: */
#if defined DSDCC_MODEL_HUGE
void
_gptrget (char *gptr) __naked
{
/* This is the banked version with pointers up to 23 bits.
   B cannot be trashed */

    gptr; /* hush the compiler */

    __asm
    ;
    ;   depending on the pointer type acc. to SDCCsymt.h
    ;
        jb      _B_7,codeptr$        ; >0x80 code       ; 3
        jnb     _B_6,xdataptr$       ; <0x40 far        ; 3

        mov     dph,r0 ; save r0 independant of regbank ; 2
        mov     r0,dpl ; use only low order address     ; 2

        jb      _B_5,pdataptr$       ; >0x60 pdata      ; 3
    ;
    ;   Pointer to data space
    ;
        mov     a,@r0                                   ; 1
 dataptrrestore$:
        mov     r0,dph ; restore r0                     ; 2
        mov     dph,#0 ; restore dph                    ; 2
        ret                                             ; 1
    ;
    ;   pointer to external stack or pdata
    ;
 pdataptr$:
        movx    a,@r0                                   ; 1
        sjmp    dataptrrestore$                         ; 2
    ;
    ;   pointer to code area
    ;
 codeptr$:
    ; implementation for SiLabs C8051F12x
        mov     a,b                                     ; 2
        anl     a,#0x03                                 ; 2
        swap    a                                       ; 1
        push    _PSBANK                                 ; 2
        anl     _PSBANK,#0x0F                           ; 3
        orl     _PSBANK,a                               ; 2

        clr     a                                       ; 1
        movc    a,@a+dptr                               ; 1
        pop     _PSBANK                                 ; 2
        ret                                             ; 1
    ;
    ;   pointer to xternal data
    ;
 xdataptr$:
    ; implementation for xram a16-a21 tied to P3
        mov     _P3,b                                   ; 3

        movx    a,@dptr                                 ; 1
        ret                                             ; 1
                                                        ;===
                                                        ;44 bytes
     __endasm;
}

#elif defined DSDCC_MODEL_MEDIUM

void
_gptrget (char *gptr) __naked
{
/* This is the non-banked version with pointers up to 15 bits.
   Assumes B is free to be used */

    gptr; /* hush the compiler */

    __asm
    ;
    ;   depending on the pointer type acc. to SDCCsymt.h
    ;
        mov     b,dph                                   ; 3
        jb      _B_7,codeptr$        ; >0x80 code       ; 3
        jnb     _B_6,xdataptr$       ; <0x40 far        ; 3

        mov     b,r0   ; save r0 independant of regbank ; 2
        mov     r0,dpl ; use only low order address     ; 2

        jb      _B_5,pdataptr$       ; >0x60 pdata      ; 3
    ;
    ;   Pointer to data space
    ;
        mov     a,@r0                                   ; 1
        mov     r0,b   ; restore r0                     ; 2
        ret                                             ; 1
    ;
    ;   pointer to xternal stack or pdata
    ;
 pdataptr$:
        movx    a,@r0                                   ; 1
        mov     r0,b   ; restore r0                     ; 2
        ret                                             ; 1
    ;
    ;   pointer to code area, max 15 bits
    ;
 codeptr$:
    ; 0x8000 <= dptr <= 0xFFFF
    ; no need to AND dph and restore from B if hardware wraps code memory
        anl     dph,#0x7F                               ; 3
        clr     a                                       ; 1
        movc    a,@a+dptr                               ; 1
        mov     dph,b                                   ; 3
        ret                                             ; 1
    ;
    ;   pointer to xternal data, max 14 bits
    ;
 xdataptr$:
    ; 0 <= dptr <= 0x3FFF
        movx    a,@dptr                                 ; 1
        ret                                             ; 1
                                                        ;===
                                                        ;35 bytes
     __endasm;
}

#else

void
_gptrget (char *gptr) __naked
{
/* This is the new version with pointers up to 16 bits.
   B cannot be trashed */

    gptr; /* hush the compiler */

    __asm
    ;
    ;   depending on the pointer type acc. to SDCCsymt.h
    ;
        jb      _B_7,codeptr$        ; >0x80 code       ; 3
        jnb     _B_6,xdataptr$       ; <0x40 far        ; 3

        mov     dph,r0 ; save r0 independant of regbank ; 2
        mov     r0,dpl ; use only low order address     ; 2

        jb      _B_5,pdataptr$       ; >0x60 pdata      ; 3
    ;
    ;   Pointer to data space
    ;
        mov     a,@r0                                   ; 1
 dataptrrestore$:
        mov     r0,dph ; restore r0                     ; 2
        mov     dph,#0 ; restore dph                    ; 2
        ret                                             ; 1
    ;
    ;   pointer to xternal stack or pdata
    ;
 pdataptr$:
        movx    a,@r0                                   ; 1
        sjmp    dataptrrestore$                         ; 2
    ;
    ;   pointer to code area, max 16 bits
    ;
 codeptr$:
        clr     a                                       ; 1
        movc    a,@a+dptr                               ; 1
        ret                                             ; 1
    ;
    ;   pointer to xternal data, max 16 bits
    ;
 xdataptr$:
        movx    a,@dptr                                 ; 1
        ret                                             ; 1
                                                        ;===
                                                        ;27 bytes
     __endasm;
}

#endif

#ifdef __SDCC_ds390
/* the  return value is expected to be in acc/acc1, and not in the standard
 * location dpl/dph. Therefore we choose return type void here: */

void
_gptrgetWord (unsigned *gptr)
{
    gptr; /* hush the compiler */

    __asm
    ;
    ;   depending on the pointer type acc. to SDCCsymt.h
    ;
        jb      _B_7,00003$           ; >0x80 code
        jnb     _B_6,00002$           ; <0x40 far

        mov     dph,r0 ; save r0 independant of regbank
        mov     r0,dpl ; use only low order address

        jb      _B_5,00004$           ; >0x60 pdata
    ;
    ;   Pointer to data space
    ;
        mov     acc1,@r0
        inc     r0
        mov     a,@r0
        inc     dpl
        sjmp    00005$
    ;
    ;   pointer to xternal data
    ;
 00002$:
        movx    a,@dptr
        mov     acc1,a
        inc     dptr
        movx    a,@dptr
        sjmp    00006$
;
;   pointer to code area
;
 00003$:
        clr     a
        movc    a,@a+dptr
        mov     acc1,a
        clr     a
        inc     dptr
        movc    a,@a+dptr
        sjmp    00006$
;
;   pointer to xternal stack
;
 00004$:
        movx    a,@r0
        mov     acc1,a
        inc     r0
        movx    a,@r0
        inc     dpl
;
;   restore and return
;
 00005$:
        mov     r0,dph ; restore r0
        mov     dph,#0 ; restore dph
 00006$:
        xch     a,acc1
    __endasm;

}

#endif
/*-------------------------------------------------------------------------
   _fs2ulong.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// unsigned long __fs2ulong (float x)
static void dummy(void) __naked
{
	__asm
	.globl	___fs2ulong
___fs2ulong:
	mov	r7, #158
	.globl	fs2ulong_begin
fs2ulong_begin:
	lcall	fsgetarg
	jnb	sign_a, fs2ulong_int
	ljmp	fs_return_zero

fs2ulong_int:
	clr	c
	mov	a, r7
	subb	a, exp_a
	jnc	fs2ulong_int_ok
	// if we get here, x >= 2^32
	mov	a, #0xFF
	mov	b, a
	mov	dph, a
	mov	dpl, a
	ret

fs2ulong_int_ok:
	mov	r1, #0
	lcall	fs_rshift_a

fs2ulong_done:
	mov	dpl, r1
	mov	dph, r2
	mov	b, r3
	mov	a, r4
	ret
	__endasm;
}

#else

/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */


union float_long
{
  float f;
  long l;
};

/* convert float to unsigned long */
unsigned long 
__fs2ulong (float a1)
{
  volatile union float_long fl1;
  volatile int exp;
  volatile long l;
  
  fl1.f = a1;
  
  if (!fl1.l || SIGN(fl1.l))
    return (0);

  exp = EXP (fl1.l) - EXCESS - 24;
  l = MANT (fl1.l);
  
  l >>= -exp;

  return l;
}

#endif
/*-------------------------------------------------------------------------
   _strcpy.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>
#include <sdcc-lib.h>

#undef strcpy /* Avoid conflict with wrapper macro of the same name */

#if !_SDCC_PORT_PROVIDES_STRCPY

char * strcpy ( char * d, const char * s )
{
#if _SDCC_Z80_STYLE_LIB_OPT
    register char * to = d;
    register const char * from = s;

    while (*to++ = *from++) ;

    return d;
#else
    register char * d1 = d;

    while (*d1++ = *s++) ;

    return d;
#endif
}

#endif
/*-------------------------------------------------------------------------
   strndup.c - part of string library functions

   Copyright (C) 2019, Philipp Klaus Krause . krauseph@informatik.uni-freiburg.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

#include <stdlib.h>

char *strndup (const char *s, size_t n)
{
	size_t l = strlen (s);
	if (l > n)
		l = n;
	char *r = malloc (l + 1);
	if (r)
	{
		memcpy (r, s, l);
		r[l] = 0;
	}
	return (r);
}

/*-------------------------------------------------------------------------
   malloc.c - allocate memory.

   Copyright (C) 2015, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stddef.h>

#if defined(__SDCC_mcs51) || defined(__SDCC_ds390) || defined(__SDCC_ds400)
#define HEAPSPACE __xdata
#elif defined(__SDCC_pdk13) || defined(__SDCC_pdk14) || defined(__SDCC_pdk15)
#define HEAPSPACE __near
#else
#define HEAPSPACE
#endif

typedef struct header HEAPSPACE header_t;

struct header
{
	header_t *next; // Next block. Linked list of all blocks, terminated by pointer to end of heap (or to the byte beyond the end of the heap).
	header_t *next_free; // Next free block. Used in free blocks only. Overlaps with user data in non-free blocks. Linked list of free blocks, 0-terminated.
};

header_t *HEAPSPACE __sdcc_heap_free; // First free block, 0 if no free blocks.

extern header_t __sdcc_heap;
#define HEAP_START &__sdcc_heap

#if defined(__SDCC_mcs51) || defined(__SDCC_ds390) || defined(__SDCC_ds400) || defined(__SDCC_hc08) || defined(__SDCC_s08)

extern const unsigned int __sdcc_heap_size;
#define HEAP_END (struct header HEAPSPACE *)((char HEAPSPACE *)&__sdcc_heap + (__sdcc_heap_size - 1)) // -1 To be sure that HEAP_END is bigger than HEAP_START.

#else

extern header_t __sdcc_heap_end; // Just beyond the end of the heap. Must be higher in memory than _sdcc_heap_start.
#define HEAP_END &__sdcc_heap_end

#endif

void __sdcc_heap_init(void)
{
	__sdcc_heap_free = HEAP_START;
	__sdcc_heap_free->next = HEAP_END;
	__sdcc_heap_free->next_free = 0;
}

#if defined(__SDCC_mcs51) || defined(__SDCC_ds390) || defined(__SDCC_ds400)
void HEAPSPACE *malloc(size_t size)
#else
void *malloc(size_t size)
#endif
{
	header_t *h;
	header_t *HEAPSPACE *f;

#if defined(__SDCC_mcs51) || defined(__SDCC_ds390) || defined(__SDCC_ds400) || defined(__SDCC_hc08) || defined(__SDCC_s08)
	if(!__sdcc_heap_free)
		__sdcc_heap_init();
#endif

	if(!size || size + offsetof(struct header, next_free) < size)
		return(0);
	size += offsetof(struct header, next_free);
	if(size < sizeof(struct header)) // Requiring a minimum size makes it easier to implement free(), and avoid memory leaks.
		size = sizeof(struct header);

	for(h = __sdcc_heap_free, f = &__sdcc_heap_free; h; f = &(h->next_free), h = h->next_free)
	{
		size_t blocksize = (char HEAPSPACE *)(h->next) - (char HEAPSPACE *)h;
		if(blocksize >= size) // Found free block of sufficient size.
		{
			if(blocksize >= size + sizeof(struct header)) // It is worth creating a new free block
			{
				header_t *const newheader = (header_t *const)((char HEAPSPACE *)h + size);
				newheader->next = h->next;
				newheader->next_free = h->next_free;
				*f = newheader;
				h->next = newheader;
			}
			else
				*f = h->next_free;

			return(&(h->next_free));
		}
	}

	return(0);
}

/*-------------------------------------------------------------------------
   logf.c - Computes the natural log of a 32 bit float as outlined in [1].

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

/* Version 1.0 - Initial release */

#define __SDCC_MATH_LIB
#include <math.h>
#include <errno.h>


#ifdef MATH_ASM_MCS51

#define __SDCC_FLOAT_LIB
#include <float.h>

// TODO: share with other temps
static __data unsigned char logf_tmp[4];

float logf(float x)
{
	x;
	__asm

	// extract the two input, placing it into:
	//      sign     exponent   mantiassa
	//      ----     --------   ---------
	//  x:  sign_a   exp_a     r4/r3/r2

	lcall	fsgetarg
logf_neg_check:
	jnb	sign_a, logf_zero_check
	// TODO: set errno to EDOM (negative numbers not allowed)
	lcall	fs_return_nan
	ljmp	logf_exit

logf_zero_check:
	cjne	r4, #0, logf_ok
	// TODO: set errno to ERANGE (zero not allowed)
	setb	sign_a
	lcall	fs_return_inf
	ljmp	logf_exit

logf_ok:
	push	exp_a
	mov	a, #3
	mov	r1, #0
	lcall	fs_rshift_a

	clr	a
	mov	(_logf_tmp + 0), a	// y = 0
	mov	(_logf_tmp + 1), a
	mov	(_logf_tmp + 2), a
	mov	(_logf_tmp + 3), a
	mov	dptr, #__fs_natural_log_table
	mov	r0, a
logf_cordic_loop:
	mov	ar7, r4		// r7/r6/r5 = x >> i
	mov	ar6, r3
	mov	ar5, r2
	mov	b, r1
	mov	a, r0
	lcall	__fs_cordic_rshift_r765_unsigned
	mov	a, r1		// check if x + (x >> i) > 1.0
	add	a, b
	mov	a, r2
	addc	a, r5
	mov	a, r3
	addc	a, r6
	mov	a, r4
	addc	a, r7
	anl	a, #0xE0
	jnz	logf_cordic_skip
	mov	a, r1		// x = x + (x >> i)
	add	a, b
	mov	r1, a
	mov	a, r2
	addc	a, r5
	mov	r2, a
	mov	a, r3
	addc	a, r6
	mov	r3, a
	mov	a, r4
	addc	a, r7
	mov	r4, a
	clr	a		// y = y + log_table[i]
	movc	a, @a+dptr
	add	a, (_logf_tmp + 0)
	mov	(_logf_tmp + 0), a
	mov	a, #1
	movc	a, @a+dptr
	addc	a, (_logf_tmp + 1)
	mov	(_logf_tmp + 1), a
	mov	a, #2
	movc	a, @a+dptr
	addc	a, (_logf_tmp + 2)
	mov	(_logf_tmp + 2), a
	mov	a, #3
	movc	a, @a+dptr
	addc	a, (_logf_tmp + 3)
	mov	(_logf_tmp + 3), a
logf_cordic_skip:
	inc	dptr
	inc	dptr
	inc	dptr
	inc	dptr
	inc	r0
	cjne	r0, #30, logf_cordic_loop
	// at this point, _logf_tmp has the natural log of the positive
	// normalized fractional part (0.5 to 1.0 -> 0.693 to 0.0)
	mov	r4, (_logf_tmp + 3)
	mov	r3, (_logf_tmp + 2)
	mov	r2, (_logf_tmp + 1)
	mov	r1, (_logf_tmp + 0)
	mov	exp_a, #129
	setb	sign_a
	lcall	fs_normalize_a
	pop	acc
	cjne	a, #126, logf_exponent
	// if the input exponent was 126, then we don't need to add
	// anything and we can just return the with we have already

	// TODO: which of these gives best accuracy???
	lcall	fs_zerocheck_return
	//lcall	fs_round_and_return
	sjmp	logf_exit
logf_exponent:
	jc	logf_exp_neg
	// the input exponent was greater than 126
logf_exp_pos:
	add	a, #130
	clr	sign_b
	sjmp	logf_exp_scale
logf_exp_neg:
	// the input exponent was less than 126
	cpl	a
	add	a, #127
	setb	sign_b
logf_exp_scale:
	// r0 has abs(exp - 126)
	mov	r0, a
	// put the log of faction into b, so we can use a to compute
	// the offset to be added to it or subtracted from it
	lcall	fs_swap_a_b
	// multiply r0 by log(2), or r0 * 0xB17218
	mov	a, #0x18
	mov	b, r0
	mul	ab
	mov	r1, a
	mov	r2, b
	mov	a, #0xB1
	mov	b, r0
	mul	ab
	mov	r3, a
	mov	r4, b
	mov	a, #0x72
	mov	b, r0
	mul	ab
	add	a, r2
	mov	r2, a
	mov	a, b
	addc	a, r3
	mov	r3, a
	clr	a
	addc	a, r4
	mov	r4, a
	// turn r0 * log(2) into a proper float
	mov	exp_a, #134
	lcall	fs_normalize_a
	// now just add log(fractional) +/- log(2) * abs(exp - 126)
	lcall	fsadd_direct_entry
logf_exit:
	__endasm;
#pragma less_pedantic
}

#else // not MATH_ASM_MCS51

/*Constants for 24 bits or less (8 decimal digits)*/
#define A0 -0.5527074855E+0
#define B0 -0.6632718214E+1
#define A(w) (A0)
#define B(w) (w+B0)

#define C0  0.70710678118654752440
#define C1  0.693359375 /*355.0/512.0*/
#define C2 -2.121944400546905827679E-4

float logf(float x) _FLOAT_FUNC_REENTRANT
{
#if     defined(__SDCC_mcs51) && defined(__SDCC_MODEL_SMALL) \
    && !defined(__SDCC_NOOVERLAY)
    volatile
#endif
    float Rz;
    float f, z, w, znum, zden, xn;
    int n;

    if (x<=0.0)
    {
        errno=EDOM;
        return 0.0;
    }
    f=frexpf(x, &n);
    znum=f-0.5;
    if (f>C0)
    {
        znum-=0.5;
        zden=(f*0.5)+0.5;
    }
    else
    {
        n--;
        zden=znum*0.5+0.5;
    }
    z=znum/zden;
    w=z*z;

    Rz=z+z*(w*A(w)/B(w));
    xn=n;
    return ((xn*C2+Rz)+xn*C1);
}

#endif
/*-------------------------------------------------------------------------
   cosf.c - Computes cos(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <stdbool.h>

float sincosf(float x, bool iscos);

float cosf(float x) _FLOAT_FUNC_REENTRANT
{
    if (x==0.0) return 1.0;
    return sincosf(x, 1);
}
/*-------------------------------------------------------------------------
   _fssub.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

//float __fssub (float a, float b) __reentrant
static void dummy(void) __naked
{
	__asm
	.globl	___fssub
___fssub:
	mov	r0, sp
	dec	r0
	dec	r0
	xch	a, @r0
	cpl	acc.7
	xch	a, @r0
	ljmp	___fsadd
	__endasm;
}

#else

/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

/* subtract two floats */
float __fssub (float a1, float a2)
{
  float neg = -a1;
  return -(neg + a2);
}

#endif
/*-------------------------------------------------------------------------
   abs.c - computes absolute value of an integer.

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#if defined (__SDCC_mcs51)

#if defined(__SDCC)
 #include <sdcc-lib.h>
#endif

static void dummy(void) __naked
{
	__asm
	.globl	_abs
_abs:
	mov	a, dph
	jnb	acc.7, 00001$
	xrl	dpl,#0xFF
	xrl	dph,#0xFF
	inc	dptr
00001$:
	_RETURN
	__endasm;
}

#else

int abs(int j)
{
	return (j < 0) ? -j : j;
}

#endif

//END OF MODULE
/*-------------------------------------------------------------------------
   sinf.c - Computes sin(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <stdbool.h>

float sincosf(float x, bool iscos);

float sinf(float x) _FLOAT_FUNC_REENTRANT
{
    if (x==0.0) return 0.0;
    return sincosf(x, 0);
}
/*-------------------------------------------------------------------------
   ispunct.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

int ispunct (int c)
{
  return (isprint (c) && !isspace (c) && !isalnum (c));
}

/*-------------------------------------------------------------------------
   _sint2fs.c - Floating point library in optimized assembly for 8051
 
   Copyright (C) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// float long __sint2fs (float x)
static void dummy(void) __naked
{
	__asm
	.globl	___sint2fs
___sint2fs:
	mov	r4, dph
	mov	r3, dpl
	mov	r2, #0
	mov	r1, #0
	mov	a, #142
	ljmp	slong2fs_doit
	__endasm;
}

#else

/* convert signed int to float */
float __sint2fs (signed int si) {
  return __slong2fs(si);
}

#endif
/*-------------------------------------------------------------------------
   _decdptr.c - decrement dptr by 1

   Copyright (C) 1999, Jean-Louis Vern <jlvern AT gmail.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

static void
dummy (void) __naked
{
// void _decdptr (char *gptr)
/* the return value is already in dph/dpl */
        __asm
        .globl  __decdptr
__decdptr:

#ifdef __SDCC_ds390
        orl     dps, #0xc0
        inc     dptr
        anl     dps, #0x3f
#else
        xch     a,dpl
        jnz     00001$
        dec     dph
00001$:
        dec     a
        xch     a,dpl
#endif
        ret
        __endasm;
}
/*-----------------------------------------------------------------
   sprintf.c - formatted output conversion

   Copyright (C) 1999, Martijn van Balen <aed AT iae.nl>
   Refactored by - Maarten Brock (2004)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

static void
put_char_to_string (char c, void* p) _REENTRANT
{
  char **buf = (char **)p;
  *(*buf)++ = c;
}

int
vsprintf (char *buf, const char *format, va_list ap)
{
  int i;
  i = _print_format (put_char_to_string, &buf, format, ap);
  *buf = 0;
  return i;
}

int
sprintf (char *buf, const char *format, ...)
{
  va_list arg;
  int i;

  va_start (arg, format);
  i = _print_format (put_char_to_string, &buf, format, arg);
  *buf = 0;
  va_end (arg);

  return i;
}
/*-------------------------------------------------------------------------
   setjmp.c - source file for ANSI routines setjmp & longjmp

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>
#define __SDCC_HIDE_LONGJMP
#include <setjmp.h>

#if defined(__SDCC_ds390)

#include <ds80c390.h>

int __setjmp (jmp_buf buf)
{
    unsigned char sp, esp;
    unsigned long lsp;

    /* registers would have been saved on the
       stack anyway so we need to save SP
       and the return address */
    __critical {
        sp = SP;
        esp = ESP;
    }
    lsp = sp;
    lsp |= (unsigned int)(esp << 8);
    lsp |= 0x400000;
    *buf++ = lsp;
    *buf++ = lsp >> 8;
    *buf++ = *((unsigned char __xdata *) lsp - 0);
    *buf++ = *((unsigned char __xdata *) lsp - 1);
    *buf++ = *((unsigned char __xdata *) lsp - 2);
    return 0;
}

int longjmp (jmp_buf buf, int rv)
{
    unsigned long lsp;

    lsp = *buf++;
    lsp |= (unsigned int)(*buf++ << 8);
    lsp |= 0x400000;
    *((unsigned char __xdata *) lsp - 0) = *buf++;
    *((unsigned char __xdata *) lsp - 1) = *buf++;
    *((unsigned char __xdata *) lsp - 2) = *buf++;
    __critical {
        SP = lsp;
        ESP = lsp >> 8;
    }
    return rv ? rv : 1;
}

#elif defined(__SDCC_STACK_AUTO) && defined(__SDCC_USE_XSTACK)

static void dummy (void) __naked
{
	__asm

;------------------------------------------------------------
;Allocation info for local variables in function 'setjmp'
;------------------------------------------------------------
;buf                       Allocated to registers dptr b
;------------------------------------------------------------
;../../device/lib/_setjmp.c:180:int setjmp (jmp_buf buf)
;	-----------------------------------------
;	 function setjmp
;	-----------------------------------------
	.globl ___setjmp
___setjmp:
	ar2 = 0x02
	ar3 = 0x03
	ar4 = 0x04
	ar5 = 0x05
	ar6 = 0x06
	ar7 = 0x07
	ar0 = 0x00
	ar1 = 0x01
;../../device/lib/_setjmp.c:183:*buf++ = bpx;
;     genPointerSet
;     genGenPointerSet
	mov	a,_bpx
	lcall	__gptrput
	inc	dptr
;../../device/lib/_setjmp.c:184:*buf++ = spx;
;     genPointerSet
;     genGenPointerSet
	mov	a,_spx
	lcall	__gptrput
	inc	dptr
;../../device/lib/_setjmp.c:185:*buf++ = bp;
;     genPointerSet
;     genGenPointerSet
	mov	a,_bp
	lcall	__gptrput
	inc	dptr
;../../device/lib/_setjmp.c:186:*buf++ = SP;
;     genPointerSet
;     genGenPointerSet
	mov	a,sp
	lcall	__gptrput
	inc	dptr
;../../device/lib/_setjmp.c:187:*buf++ = *((unsigned char __data *) SP  );
;     genCast
;     genPointerGet
;     genNearPointerGet
;     genPointerSet
;     genGenPointerSet
	mov	r0,sp
	mov	a,@r0
	lcall	__gptrput
	inc	dptr
;../../device/lib/_setjmp.c:188:*buf   = *((unsigned char __data *)SP - 1);
;     genCast
;     genMinus
;     genMinusDec
;	peephole 177.g	optimized mov sequence
	dec	r0
;     genPointerGet
;     genNearPointerGet
	mov	a,@r0
;     genPointerSet
;     genGenPointerSet
	lcall	__gptrput
#ifdef __SDCC_MODEL_HUGE
	inc	dptr
;../../device/lib/_setjmp.c:189:*buf   = *((unsigned char __data *)SP - 2);
;     genCast
;     genMinus
;     genMinusDec
;	peephole 177.g	optimized mov sequence
	dec	r0
;     genPointerGet
;     genNearPointerGet
	mov	a,@r0
;     genPointerSet
;     genGenPointerSet
	lcall	__gptrput
#endif
;../../device/lib/_setjmp.c:190:return 0;
;     genRet
	mov	dptr,#0x0000
	_RETURN

;------------------------------------------------------------
;Allocation info for local variables in function 'longjmp'
;------------------------------------------------------------
;rv                        Allocated to stack - offset -2
;buf                       Allocated to registers dptr b
;lsp                       Allocated to registers r5
;------------------------------------------------------------
;../../device/lib/_setjmp.c:192:int longjmp (jmp_buf buf, int rv)
;	-----------------------------------------
;	 function longjmp
;	-----------------------------------------
	.globl _longjmp
_longjmp:
;     genReceive
	mov	r0,_spx
	dec	r0
	movx	a,@r0
	mov	r2,a
	dec	r0
	movx	a,@r0
	mov	r3,a
;../../device/lib/_setjmp.c:193:bpx = *buf++;
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
	mov	_bpx,a
	inc	dptr
;../../device/lib/_setjmp.c:194:spx = *buf++;
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
	mov	_spx,a
	inc	dptr
;../../device/lib/_setjmp.c:195:bp = *buf++;
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
	mov	_bp,a
	inc	dptr
;../../device/lib/_setjmp.c:196:lsp = *buf++;
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
	inc	dptr
;     genAssign
	mov	r5,a
;../../device/lib/_setjmp.c:197:*((unsigned char __data *) lsp) = *buf++;
;     genCast
	mov	r0,a
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
	inc	dptr
;     genPointerSet
;     genNearPointerSet
	mov	@r0,a
;../../device/lib/_setjmp.c:198:*((unsigned char __data *) lsp - 1) = *buf;
;     genMinus
;     genMinusDec
	dec	r0
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
;     genPointerSet
;     genNearPointerSet
	mov	@r0,a
#ifdef __SDCC_MODEL_HUGE
	inc	dptr
;../../device/lib/_setjmp.c:199:*((unsigned char __data *) lsp - 2) = *buf;
;     genMinus
;     genMinusDec
	dec	r0
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
;     genPointerSet
;     genNearPointerSet
	mov	@r0,a
#endif
;../../device/lib/_setjmp.c:200:SP = lsp;
;     genAssign
	mov	sp,r5
;../../device/lib/_setjmp.c:201:return rv ? rv : 1;
;     genAssign
	mov	dph,r2
	mov	dpl,r3
	mov	a,r2
	orl	a,r3
	jnz	00001$
	inc	dptr
;     genRet
00001$:
	_RETURN

	__endasm;
}

#elif defined(__SDCC_STACK_AUTO)

static void dummy (void) __naked
{
	__asm

;------------------------------------------------------------
;Allocation info for local variables in function 'setjmp'
;------------------------------------------------------------
;buf                       Allocated to registers dptr b
;------------------------------------------------------------
;../../device/lib/_setjmp.c:122:int setjmp (unsigned char *buf)
;	-----------------------------------------
;	 function setjmp
;	-----------------------------------------
	.globl ___setjmp
___setjmp:
	ar2 = 0x02
	ar3 = 0x03
	ar4 = 0x04
	ar5 = 0x05
	ar6 = 0x06
	ar7 = 0x07
	ar0 = 0x00
	ar1 = 0x01
;     genReceive
;../../device/lib/_setjmp.c:125:*buf   = BP;
;     genPointerSet
;     genGenPointerSet
	mov	a,_bp
	lcall	__gptrput
	inc	dptr
;../../device/lib/_setjmp.c:126:*buf   = SP;
;     genPointerSet
;     genGenPointerSet
	mov	a,sp
	lcall	__gptrput
	inc	dptr
;../../device/lib/_setjmp.c:127:*buf++ = *((unsigned char __data *) SP  );
;     genCast
	mov	r0,sp
;     genPointerGet
;     genNearPointerGet
	mov	a,@r0
;     genPointerSet
;     genGenPointerSet
	lcall	__gptrput
	inc	dptr
;../../device/lib/_setjmp.c:128:*buf++ = *((unsigned char __data *)SP - 1);
;     genCast
;     genMinus
;     genMinusDec
	dec	r0
;     genPointerGet
;     genNearPointerGet
	mov	a,@r0
;     genPointerSet
;     genGenPointerSet
	lcall	__gptrput
#ifdef __SDCC_MODEL_HUGE
	inc	dptr
;../../device/lib/_setjmp.c:129:*buf++ = *((unsigned char __data *)SP - 2);
;     genCast
;     genMinus
;     genMinusDec
	dec	r0
;     genPointerGet
;     genNearPointerGet
	mov	a,@r0
;     genPointerSet
;     genGenPointerSet
	lcall	__gptrput
#endif
;../../device/lib/_setjmp.c:130:return 0;
;     genRet
	mov	dptr,#0x0000
	_RETURN

;------------------------------------------------------------
;Allocation info for local variables in function 'longjmp'
;------------------------------------------------------------
;rv                        Allocated to stack - offset -3
;buf                       Allocated to registers dptr b
;lsp                       Allocated to registers r5
;------------------------------------------------------------
;../../device/lib/_setjmp.c:28:int longjmp (jmp_buf buf, int rv)
;	-----------------------------------------
;	 function longjmp
;	-----------------------------------------
	.globl _longjmp
_longjmp:
	ar2 = 0x02
	ar3 = 0x03
	ar4 = 0x04
	ar5 = 0x05
	ar6 = 0x06
	ar7 = 0x07
	ar0 = 0x00
	ar1 = 0x01
;     genReceive
	mov	r0,sp
	dec	r0
	dec	r0
#ifdef __SDCC_MODEL_HUGE
	dec	r0
#endif
	mov	ar2,@r0
	dec	r0
	mov	ar3,@r0
;../../device/lib/_setjmp.c:30:bp = *buf++;
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
	inc	dptr
;     genAssign
	mov	_bp,a
;../../device/lib/_setjmp.c:31:lsp = *buf++;
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
	inc	dptr
;     genAssign
	mov	r5,a
;../../device/lib/_setjmp.c:32:*((unsigned char __data *) lsp) = *buf++;
;     genCast
	mov	r0,a
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
	inc	dptr
;     genPointerSet
;     genNearPointerSet
	mov	@r0,a
;../../device/lib/_setjmp.c:33:*((unsigned char __data *) lsp - 1) = *buf;
;     genCast
;     genMinus
;     genMinusDec
	dec	r0
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
;     genPointerSet
;     genNearPointerSet
	mov	@r0,a
#ifdef __SDCC_MODEL_HUGE
	inc	dptr
;../../device/lib/_setjmp.c:34:*((unsigned char __data *) lsp - 2) = *buf;
;     genCast
;     genMinus
;     genMinusDec
	dec	r0
;     genPointerGet
;     genGenPointerGet
	lcall	__gptrget
;     genPointerSet
;     genNearPointerSet
	mov	@r0,a
#endif
;../../device/lib/_setjmp.c:35:SP = lsp;
;     genAssign
	mov	sp,r5
;../../device/lib/_setjmp.c:36:return rv ? rv : 1;
;     genAssign
	mov	dph,r2
	mov	dpl,r3
	mov	a,r2
	orl	a,r3
	jnz	00001$
	inc	dptr
;     genRet
00001$:
	_RETURN

	__endasm;
}

#else

#include <8051.h>

extern unsigned char __data spx;
extern unsigned char __data bpx;

int __setjmp (jmp_buf buf)
{
    /* registers would have been saved on the
       stack anyway so we need to save SP
       and the return address */
#ifdef __SDCC_USE_XSTACK
    *buf++ = spx;
    *buf++ = bpx;
#endif
    *buf++ = SP;
    *buf++ = *((unsigned char __data *) SP - 0);
    *buf++ = *((unsigned char __data *) SP - 1);
#ifdef __SDCC_MODEL_HUGE
    *buf++ = *((unsigned char __data *) SP - 2);
#endif
    return 0;
}

int longjmp (jmp_buf buf, int rv)
{
    unsigned char lsp;

#ifdef __SDCC_USE_XSTACK
    spx = *buf++;
    bpx = *buf++;
#endif
    lsp = *buf++;
    *((unsigned char __data *) lsp - 0) = *buf++;
    *((unsigned char __data *) lsp - 1) = *buf++;
#ifdef __SDCC_MODEL_HUGE
    *((unsigned char __data *) lsp - 2) = *buf++;
#endif
    SP = lsp;
    return rv ? rv : 1;
}

#endif
/*-------------------------------------------------------------------------
   _fsswapargs.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/



#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

static void dummy(void) __naked
{
	__asm
	.globl	fs_swap_a_b
fs_swap_a_b:
	mov	a, exp_a
	xch	a, exp_b
	mov	exp_a, a
	// is there a faster way to swap these 2 bits???
	// this trick with psw can play havoc with the resiter bank setting
	// mov	a, psw
	// swap	a		// depends on sign bits in psw.1 & psw.5
	// mov	psw, a
	mov	c, sign_a
	rlc	a
	mov	c, sign_b
	mov	sign_a, c
	rrc	a
	mov	sign_b, c
	mov	a, r4
	xch	a, r7
	mov	r4, a
	mov	a, r3
	xch	a, r6
	mov	r3, a
	mov	a, r2
	xch	a, r5
	mov	r2, a
	ret
	__endasm;
}

#endif
/*-------------------------------------------------------------------------
   rand.c - random number generator

   Copyright (C) 2017, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.

   This is an xorshift PRNG. See George Marsaglia, "Xorshift RNGs" for details.
   The width of 32 bits was chosen to not regress in period length vs. the
   PRNG from the C standard, while at the same time minimizing RAM usage.
   The parameters a, b, c were chosen to allow the generation of efficient code.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#include <stdint.h>

static uint32_t s = 0x80000001;

int rand(void)
{
	register unsigned long t = s;

	t ^= t >> 10;
	t ^= t << 9;
	t ^= t >> 25;

	s = t;

	return(t & RAND_MAX);
}

void srand(unsigned int seed)
{
    s = seed | 0x80000000; /* s shall not become 0 */
}

/*-------------------------------------------------------------------------
   serial.c - this module implements serial interrupt handler and IO
              routinwes using two 256 byte cyclic buffers. Bit variables
              can be used as flags for real-time kernel tasks

   Copyright (C) 1996, Dmitry S. Obukhov <dmitry.obukhov AT gmail.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* This module contains definition of I8051 registers */
#include "8052.h"


static unsigned char __xdata stx_index_in, srx_index_in, stx_index_out, srx_index_out;
static unsigned char __xdata stx_buffer[0x100];
static unsigned char __xdata srx_buffer[0x100];

static __bit work_flag_byte_arrived;
static __bit work_flag_buffer_transfered;
static __bit tx_serial_buffer_empty;
static __bit rx_serial_buffer_empty;


void serial_init(void)
{
    SCON = 0x50;
    T2CON = 0x34;
    PS = 1;
    T2CON = 0x34;
    RCAP2H = 0xFF;
    RCAP2L = 0xDA;
    
    RI = 0;
    TI = 0;
    
    stx_index_in = srx_index_in = stx_index_out = srx_index_out = 0;
    rx_serial_buffer_empty = tx_serial_buffer_empty = 1;
    work_flag_buffer_transfered = 0;
    work_flag_byte_arrived = 0;
    ES=1;
}

void serial_interrupt_handler(void) __interrupt 4 __using 1
{
    ES=0;
    if ( RI )
	{
	    RI = 0;
	    srx_buffer[srx_index_in++]=SBUF;
	    work_flag_byte_arrived = 1;
	    rx_serial_buffer_empty = 0;
	}
    if ( TI )
	{
	    TI = 0;
	    if (stx_index_out == stx_index_in )
		{
		    tx_serial_buffer_empty = 1;
		    work_flag_buffer_transfered = 1;
		}
	    else SBUF = stx_buffer[stx_index_out++];
	}
    ES=1;
}

/* Next two functions are interface */

void serial_putc(unsigned char c)
{
    stx_buffer[stx_index_in++]=c;
    ES=0;
    if ( tx_serial_buffer_empty )
	{
	    tx_serial_buffer_empty = 0;
	    TI=1;
	}
    ES=1;
}

unsigned char serial_getc(void)
{
    unsigned char tmp = srx_buffer[srx_index_out++];
    ES=0;
    if ( srx_index_out == srx_index_in) rx_serial_buffer_empty = 1;
    ES=1;
    return tmp;
}
/*-------------------------------------------------------------------------
   _strcmp.c - part of string library functions

   Copyright (C) 2011, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include "string.h"

size_t strxfrm(char *dest, const char *src, size_t n)
{
	strncpy(dest, src, n);
	return(strlen(src) + 1);
}

/*-------------------------------------------------------------------------
   sincosf.c - Computes sin or cos of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>
#include <stdbool.h>

#define r1      -0.1666665668E+0
#define r2       0.8333025139E-2
#define r3      -0.1980741872E-3
#define r4       0.2601903036E-5

/* PI=C1+C2 */
#define C1       3.140625
#define C2       9.676535897E-4

/*A reasonable value for YMAX is the int part of PI*B**(t/2)=3.1416*2**(12)*/
#define YMAX     12867.0

float sincosf(float x, bool iscos)
{
    float y, f, r, g, XN;
    int N;
    bool sign;

    if(iscos)
    {
        y=fabsf(x)+HALF_PI;
        sign=0;
    }
    else
    {
        if(x<0.0)
            { y=-x; sign=1; }
        else
            { y=x; sign=0; }
    }

    if(y>YMAX)
    {
        errno=ERANGE;
        return 0.0;
    }

    /*Round y/PI to the nearest integer*/
    N=((y*iPI)+0.5); /*y is positive*/

    /*If N is odd change sign*/
    if(N&1) sign=!sign;

    XN=N;
    /*Cosine required? (is done here to keep accuracy)*/
    if(iscos) XN-=0.5;

    y=fabsf(x);
    r=(int)y;
    g=y-r;
    f=((r-XN*C1)+g)-XN*C2;

    g=f*f;
    if(g>EPS2) //Used to be if(fabsf(f)>EPS)
    {
        r=(((r4*g+r3)*g+r2)*g+r1)*g;
        f+=f*r;
    }
    return (sign?-f:f);
}
/*-------------------------------------------------------------------------
   _uchar2fs.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// float long __uchar2fs (float x)
static void dummy(void) __naked
{
	__asm
	.globl	___uchar2fs
___uchar2fs:
	clr	a
	mov	r4, dpl
	mov	r3, a
	mov	r2, a
	mov	r1, a
	mov	a, #134
	ljmp	ulong2fs_doit
	__endasm;
}

#else

/* convert unsigned char to float */
float __uchar2fs (unsigned char uc) {
  return __ulong2fs(uc);
}

#endif
/*-------------------------------------------------------------------------
   mbsinit.c - determine conversion state

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <wchar.h>

int mbsinit(const mbstate_t *ps)
{
	return(!ps || !ps->c[0] && !ps->c[1] && !ps->c[2]);
}

/*-------------------------------------------------------------------------
   c32rtomb.c - convert UTF-16 to UTF-8

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <uchar.h>

#include <stdlib.h>
#include <limits.h>
#include <errno.h>

size_t c16rtomb(char *restrict s, char16_t c16, mbstate_t *restrict ps)
{
	wchar_t codepoint;
	char buf[MB_LEN_MAX];
	static mbstate_t sps;

	if(!s)
		s = buf;

	if(!ps)
		ps = &sps;

	if (!c16) // 0 always resets conversion state.
	{
		ps->c[1] = ps->c[2] = 0;
		codepoint = 0;
	}
	else if(ps->c[1] || ps->c[2]) // We already have the high surrogate. Now get the low surrogate
	{
		char16_t high_surrogate;

		if(c16 < 0xdc00 || c16 > 0xdfff)
			goto eilseq;

		high_surrogate = ps->c[1] + (ps->c[2] << 8);
		ps->c[1] = ps->c[2] = 0;
		codepoint = (high_surrogate << 10) - (0xd800 << 10) + c16 - 0xdc00 + 0x10000;
	}
	else if(c16 < 0xd7ff || c16 >= 0xe000) // Basic multilingual plane.
		codepoint = c16;
	else // Get the high surrogate
	{
		if(c16 > 0xdbff)
			goto eilseq;

		ps->c[1] = c16 & 0xff;
		ps->c[2] = c16 >> 8;
		return(0);
	}

	return(wctomb(s, codepoint));

eilseq:
	errno = EILSEQ;
	return(-1);
}

/*-----------------------------------------------------------------
   puts.c - source file for C function puts()

   Copyright (C) 2016, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

int puts (const char *s)
{
    while (*s)
        if (putchar(*s++) == EOF)
            return EOF;
    return putchar('\n');
}

/*-------------------------------------------------------------------------
   isspace.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

#ifdef isspace
#undef isspace
#endif

int isspace (int c)
{
  return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
}

/*-------------------------------------------------------------------------
   _fsneq.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// char __fsneq (float a, float b)
static void dummy(void) __naked
{
	__asm
	.globl	___fsneq
___fsneq:
	mov	r7, a
	mov	r0, sp
	dec	r0
	dec	r0
	lcall	fs_check_negative_zeros
	lcall	fs_compare_uint32
	mov	dpl, r1
	ret
	__endasm;
}

#else

/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

union float_long
  {
    float f;
    long l;
  };

/* compare two floats */
char __fsneq (float a1, float a2)
{
  volatile union float_long fl1, fl2;

  fl1.f = a1;
  fl2.f = a2;

  if (fl1.l == fl2.l)
    return (0);
  if (((fl1.l | fl2.l) & 0x7FFFFFFF) == 0)
    return (0);
  return (1);
}

#endif
/*-------------------------------------------------------------------------
   _strcspn.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

size_t strcspn ( const char * string, const char * control )
{
	register size_t count = 0;
	register char ch;

	while (ch = *string) {
		if (strchr(control,ch))
			break;
		else
			count++;
			string++;
	}

	return count;
}  
/*-------------------------------------------------------------------------
   mbstoc16s.c - convert a multibyte string to a wide character string

   Copyright (C) 2018, Philipp Klaus Krause, krauseph@informatik.uni-freiburg.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <uchar.h>

#include <stdlib.h>
#include <limits.h>
#include <wchar.h>

#ifndef __STDC_UTF_16__
#error Encoding for char16_t strings must be UTF-16
#endif
#ifndef __STDC_ISO_10646__
#error Encoding for wchar_t strings must be UCS-4
#endif

// This implementation assumes that mbtowc() does not keep internal state
// and that mbtowc() does not read beyond a terminating 0.
size_t __mbstoc16s(char16_t *restrict c16s, const char *restrict s, size_t n)
{
	size_t m = 0;

	for(;;)
	{
		int l;
		wchar_t codepoint;

		l = mbtowc(&codepoint, s, MB_LEN_MAX);

		if(l < 0)
			return(-1);
		else if(!l)
		{
			if(m < n)
				*c16s = 0;
			break;
		}

		if (codepoint <= 0xffff) // Basic multilingual plane
		{
			if (m >= n)
				break;

			*c16s++ = codepoint;
			m++;
		}
		else
		{
			if (m + 1 >= n)
				break;

			codepoint -= 0x100000;
			*c16s++ = ((codepoint >> 10) & 0x3ff) + 0xd800;
			*c16s++ = (codepoint & 0x3ff) + 0xdc00;
			m += 2;
		}
		s += l;
	}
	
	return(m);
}

/*-------------------------------------------------------------------------
   atanf.c - Computes arctan of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>

#define P0 -0.4708325141E+0
#define P1 -0.5090958253E-1
#define Q0  0.1412500740E+1
#define Q1  0.1000000000E+1

#define P(g,f) ((P1*g+P0)*g*f)
#define Q(g) (Q1*g+Q0)

#define K1  0.2679491924 /* 2-sqrt(3) */
#define K2  0.7320508076 /* sqrt(3)-1 */
#define K3  1.7320508076 /* sqrt(3)   */

#ifdef __SDCC_mcs51
   #define myconst __code
#else
   #define myconst const
#endif

float atanf(float x) _FLOAT_FUNC_REENTRANT
{
    float f, r, g;
    int n=0;
	static myconst float a[]={  0.0, 0.5235987756, 1.5707963268, 1.0471975512 };

    f=fabsf(x);
    if(f>1.0)
    {
        f=1.0/f;
        n=2;
    }
    if(f>K1)
    {
        f=((K2*f-1.0)+f)/(K3+f);
        // What it is actually wanted is this more accurate formula,
        // but SDCC optimizes it and then it does not work:
        // f=(((K2*f-0.5)-0.5)+f)/(K3+f);
        n++;
    }
    if(fabsf(f)<EPS) r=f;
    else
    {
        g=f*f;
        r=f+P(g,f)/Q(g);
    }
    if(n>1) r=-r;
    r+=a[n];
    if(x<0.0) r=-r;
    return r;
}
/*-------------------------------------------------------------------------
   _mullong.c - routine for multiplication of 32 bit (unsigned) long

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Copyright (C) 1999, Jean Louis VERN jlvern@writeme.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Signed and unsigned multiplication are the same - as long as the output
   has the same precision as the input.

   Assembler-functions are provided for:
     mcs51 small
     mcs51 small stack-auto
*/

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO) && !defined(__SDCC_PARMS_IN_BANK1)
#        define _MULLONG_ASM_SMALL_AUTO
#      else
#        define _MULLONG_ASM_SMALL
#      endif
#    elif defined(__SDCC_MODEL_LARGE)
#      if !defined(__SDCC_STACK_AUTO)
#        define _MULLONG_ASM_LARGE
#      endif
#    endif
#  endif
#endif

#if defined(_MULLONG_ASM_SMALL) || defined(_MULLONG_ASM_SMALL_AUTO)

void
_mullong_dummy (void) __naked
{
	__asm

__mullong:

	.globl __mullong

				; the result c will be stored in r4...r7
	#define c0 r4
	#define c1 r5
	#define c2 r6
	#define c3 r7

	#define a0 dpl
	#define a1 dph
	#define a2 r2
	#define a3 r3

	; c0  a0 * b0
	; c1  a1 * b0 + a0 * b1
	; c2  a2 * b0 + a1 * b1 + a0 * b2
	; c3  a3 * b0 + a2 * b1 + a1 * b2 + a0 * b3

#if !defined(__SDCC_STACK_AUTO) || defined(__SDCC_PARMS_IN_BANK1)
#if defined(__SDCC_PARMS_IN_BANK1)
	#define b0  (b1_0)
	#define b1  (b1_1)
	#define b2  (b1_2)
	#define b3  (b1_3)
#else
#if defined(__SDCC_NOOVERLAY)
	.area DSEG    (DATA)
#else
	.area OSEG    (OVR,DATA)
#endif

__mullong_PARM_2:

	.globl __mullong_PARM_2

	.ds	4

	b0 =  __mullong_PARM_2
	b1 = (__mullong_PARM_2+1)
	b2 = (__mullong_PARM_2+2)
	b3 = (__mullong_PARM_2+3)

#endif
	.area CSEG    (CODE)

				; parameter a comes in a, b, dph, dpl
	mov	r2,b		; save parameter a
	mov	r3,a

				;	Byte 0
	mov	a,a0
	mov	b,b0
	mul	ab		; a0 * b0
	mov	c0,a
	mov	c1,b

				;	Byte 1
	mov	a,a1
	mov	b,b0
	mul	ab		; a1 * b0
	add	a,c1
	mov	c1,a
	clr	a
	addc	a,b
	mov	c2,a

	mov	a,a0
	mov	b,b1
	mul	ab		; a0 * b1
	add	a,c1
	mov	c1,a
	mov	a,b
	addc	a,c2
	mov	c2,a
	clr	a
	rlc	a
	mov	c3,a

				;	Byte 2
	mov	a,a2
	mov	b,b0
	mul	ab		; a2 * b0
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	a,a1
	mov	b,b1
	mul	ab		; a1 * b1
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	a,a0
	mov	b,b2
	mul	ab		; a0 * b2
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

				;	Byte 3
	mov	a,a3
	mov	b,b0
	mul	ab		; a3 * b0
	add	a,c3
	mov	c3,a

	mov	a,a2
	mov	b,b1
	mul	ab		; a2 * b1
	add	a,c3
	mov	c3,a

	mov	a,a1
	mov	b,b2
	mul	ab		; a1 * b2
	add	a,c3
	mov	c3,a

	mov	a,a0
	mov	b,b3
	mul	ab		; a0 * b3
	add	a,c3

	mov	b,c2
	mov	dph,c1
	mov	dpl,c0
	ret

#else // __SDCC_STACK_AUTO

				; parameter a comes in a, b, dph, dpl
	mov	r2,b		; save parameter a
	mov	r3,a

	#define a0 dpl
	#define a1 dph
	#define a2 r2
	#define a3 r3

	#define b0 r1

	mov	a,#-2-3		;  1  return address 2 bytes, b 4 bytes
	add	a,sp		;  1
	mov	r0,a		;  1  r0 points to b0

				;	Byte 0
	mov	a,a0
	mov	b,@r0		; b0
	mov	b0,b		; we need b0 several times
	inc	r0		; r0 points to b1
	mul	ab		; a0 * b0
	mov	c0,a
	mov	c1,b

				;	Byte 1
	mov	a,a1
	mov	b,b0
	mul	ab		; a1 * b0
	add	a,c1
	mov	c1,a
	clr	a
	addc	a,b
	mov	c2,a

	mov	a,a0
	mov	b,@r0		; b1
	mul	ab		; a0 * b1
	add	a,c1
	mov	c1,a
	mov	a,b
	addc	a,c2
	mov	c2,a
	clr	a
	rlc	a
	mov	c3,a

				;	Byte 2
	mov	a,a2
	mov	b,b0
	mul	ab		; a2 * b0
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	a,a1
	mov	b,@r0		; b1
	mul	ab		; a1 * b1
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	a,a0
	inc	r0
	mov	b,@r0		; b2
	mul	ab		; a0 * b2
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

				;	Byte 3
	mov	a,a3
	mov	b,b0
	mul	ab		; a3 * b0
	add	a,c3
	mov	c3,a

	mov	a,a1
	mov	b,@r0		; b2
	mul	ab		; a1 * b2
	add	a,c3
	mov	c3,a

	mov	a,a2
	dec	r0
	mov	b,@r0		; b1
	mul	ab		; a2 * b1
	add	a,c3
	mov	c3,a

	mov	a,a0
	inc	r0
	inc	r0
	mov	b,@r0		; b3
	mul	ab		; a0 * b3
	add	a,c3

	mov	b,c2
	mov	dph,c1
	mov	dpl,c0

	ret

#endif // __SDCC_STACK_AUTO

	__endasm;
}

#elif defined(_MULLONG_ASM_LARGE)

void
_mullong_dummy (void) __naked
{
	__asm

__mullong:

	.globl __mullong

				; the result c will be stored in r4...r7
	#define c0 r4
	#define c1 r5
	#define c2 r6
	#define c3 r7

	; c0  a0 * b0
	; c1  a1 * b0 + a0 * b1
	; c2  a2 * b0 + a1 * b1 + a0 * b2
	; c3  a3 * b0 + a2 * b1 + a1 * b2 + a0 * b3

#if !defined(__SDCC_PARMS_IN_BANK1)
	.area XSEG    (XDATA)

__mullong_PARM_2:

	.globl __mullong_PARM_2

	.ds	4
#endif
	.area CSEG    (CODE)

				; parameter a comes in a, b, dph, dpl
	mov	r0,dpl		; save parameter a
	mov	r1,dph
	mov	r2,b
	mov	r3,a

	#define a0 r0
	#define a1 r1
	#define a2 r2
	#define a3 r3

				;	Byte 0
	mov	b,a0
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_0		; b0
#else
	mov	dptr,#__mullong_PARM_2
	movx	a,@dptr		; b0
#endif
	mul	ab		; a0 * b0
	mov	c0,a
	mov	c1,b

				;	Byte 1
	mov	b,a1
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_0		; b0
#else
	movx	a,@dptr		; b0
#endif
	mul	ab		; a1 * b0
	add	a,c1
	mov	c1,a
	clr	a
	addc	a,b
	mov	c2,a

	mov	b,a0
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_1		; b1
#else
	inc	dptr		; b1
	movx	a,@dptr
#endif
	mul	ab		; a0 * b1
	add	a,c1
	mov	c1,a
	mov	a,b
	addc	a,c2
	mov	c2,a
	clr	a
	rlc	a
	mov	c3,a

				;	Byte 2
	mov	b,a1
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_1		; b1
#else
	movx	a,@dptr		; b1
#endif
	mul	ab		; a1 * b1
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	b,a0
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_2		; b2
#else
	inc	dptr		; b2
	movx	a,@dptr
#endif
	mul	ab		; a0 * b2
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	b,a2
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_0		; b0
#else
	mov	dptr,#__mullong_PARM_2
	movx	a,@dptr		; b0
#endif
	mul	ab		; a2 * b0
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

				;	Byte 3
	mov	b,a3
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_0		; b0
#else
	movx	a,@dptr		; b0
#endif
	mul	ab		; a3 * b0
	add	a,c3
	mov	c3,a

	mov	b,a2
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_1		; b1
#else
	inc	dptr		; b1
	movx	a,@dptr
#endif
	mul	ab		; a2 * b1
	add	a,c3
	mov	c3,a

	mov	b,a1
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_2		; b2
#else
	inc	dptr		; b2
	movx	a,@dptr
#endif
	mul	ab		; a1 * b2
	add	a,c3
	mov	c3,a

	mov	b,a0
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_3		; b3
#else
	inc	dptr		; b3
	movx	a,@dptr
#endif
	mul	ab		; a0 * b3
	add	a,c3

	mov	b,c2
	mov	dph,c1
	mov	dpl,c0
	ret

	__endasm;
}

#elif defined(__SDCC_USE_XSTACK) && defined(__SDCC_STACK_AUTO)

void
_mullong_dummy (void) __naked
{
	__asm

__mullong:

	.globl __mullong

				; the result c will be stored in r4...r7
	#define c0 r4
	#define c1 r5
	#define c2 r6
	#define c3 r7

	#define a0 dpl
	#define a1 dph
	#define a2 r2
	#define a3 r3

	#define b0 r1

	; c0  a0 * b0
	; c1  a1 * b0 + a0 * b1
	; c2  a2 * b0 + a1 * b1 + a0 * b2
	; c3  a3 * b0 + a2 * b1 + a1 * b2 + a0 * b3

				; parameter a comes in a, b, dph, dpl
	mov	r2,b		; save parameter a
	mov	r3,a

	mov	a,#-4		;  1  b 4 bytes
	add	a,_spx		;  1
	mov	r0,a		;  1  r0 points to b0

				;	Byte 0
	movx	a,@r0		; b0
	mov	b0,a		; we need b0 several times
	inc	r0		; r0 points to b1
	mov	b,a0
	mul	ab		; a0 * b0
	mov	c0,a
	mov	c1,b

				;	Byte 1
	mov	a,a1
	mov	b,b0
	mul	ab		; a1 * b0
	add	a,c1
	mov	c1,a
	clr	a
	addc	a,b
	mov	c2,a

	mov	b,a0
	movx	a,@r0		; b1
	mul	ab		; a0 * b1
	add	a,c1
	mov	c1,a
	mov	a,b
	addc	a,c2
	mov	c2,a
	clr	a
	rlc	a
	mov	c3,a

				;	Byte 2
	mov	a,a2
	mov	b,b0
	mul	ab		; a2 * b0
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	b,a1
	movx	a,@r0		; b1
	mul	ab		; a1 * b1
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	b,a0
	inc	r0
	movx	a,@r0		; b2
	mul	ab		; a0 * b2
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

				;	Byte 3
	mov	a,a3
	mov	b,b0
	mul	ab		; a3 * b0
	add	a,c3
	mov	c3,a

	mov	b,a1
	movx	a,@r0		; b2
	mul	ab		; a1 * b2
	add	a,c3
	mov	c3,a

	mov	b,a2
	dec	r0
	movx	a,@r0		; b1
	mul	ab		; a2 * b1
	add	a,c3
	mov	c3,a

	mov	b,a0
	inc	r0
	inc	r0
	movx	a,@r0		; b3
	mul	ab		; a0 * b3
	add	a,c3

	mov	b,c2
	mov	dph,c1
	mov	dpl,c0

	ret

	__endasm;
}

#else // _MULLONG_ASM

struct some_struct {
	short a ;
	char b;
	long c ;};
#if defined(__SDCC_hc08) || defined(__SDCC_s08) || defined(__SDCC_stm8)
/* big endian order */
union bil {
        struct {unsigned char b3,b2,b1,b0 ;} b;
        struct {unsigned short hi,lo ;} i;
        unsigned long l;
        struct { unsigned char b3; unsigned short i12; unsigned char b0;} bi;
} ;
#else
/* little endian order */
union bil {
        struct {unsigned char b0,b1,b2,b3 ;} b;
        struct {unsigned short lo,hi ;} i;
        unsigned long l;
        struct { unsigned char b0; unsigned short i12; unsigned char b3;} bi;
} ;
#endif

#if defined(__SDCC)
 #include <sdcc-lib.h>
#endif

#define bcast(x) ((union bil _AUTOMEM *)&(x))

/*
                     3   2   1   0
       X             3   2   1   0
       ----------------------------
                   0.3 0.2 0.1 0.0
               1.3 1.2 1.1 1.0
           2.3 2.2 2.1 2.0
       3.3 3.2 3.1 3.0
       ----------------------------
                  |3.3|1.3|0.2|0.0|   A
                    |2.3|0.3|0.1|     B
                    |3.2|1.2|1.0|     C
                      |2.2|1.1|       D
                      |3.1|2.0|       E
                        |2.1|         F
                        |3.0|         G
                          |-------> only this side 32 x 32 -> 32
*/
#if defined(__SDCC_USE_XSTACK)
// currently the original code without u fails with --xstack
// it runs out of pointer registers
long
_mullong (long a, long b)
{
        union bil t, u;

        t.i.hi   = bcast(a)->b.b0 * bcast(b)->b.b2;          // A
        t.i.lo   = bcast(a)->b.b0 * bcast(b)->b.b0;          // A
        u.bi.b3  = bcast(a)->b.b0 * bcast(b)->b.b3;          // B
        u.bi.i12 = bcast(a)->b.b0 * bcast(b)->b.b1;          // B
        u.bi.b0  = 0;                                        // B
        t.l += u.l;

        t.b.b3  += bcast(a)->b.b3 * bcast(b)->b.b0;          // G
        t.b.b3  += bcast(a)->b.b2 * bcast(b)->b.b1;          // F
        t.i.hi  += bcast(a)->b.b2 * bcast(b)->b.b0;          // E
        t.i.hi  += bcast(a)->b.b1 * bcast(b)->b.b1;          // D

        u.bi.b3  = bcast(a)->b.b1 * bcast(b)->b.b2;          // C
        u.bi.i12 = bcast(a)->b.b1 * bcast(b)->b.b0;          // C
        u.bi.b0  = 0;                                        // C
        t.l += u.l;

        return t.l;
}
#elif defined(__SDCC_z80) || defined(__SDCC_gbz80) || defined(__SDCC_r2k) || defined(__SDCC_r3k)
/* 32x32->32 multiplication to be used
   if 16x16->16 is faster than three 8x8->16.
   2009, by M.Bodrato ( http://bodrato.it/ )

   z80 and gbz80 don't have any hardware multiplication.
   r2k and r3k have 16x16 hardware multiplication.
 */
long
_mullong (long a, long b)
{
  unsigned short i12;

  bcast(a)->i.hi *= bcast(b)->i.lo;
  bcast(a)->i.hi += bcast(b)->i.hi * bcast(a)->i.lo;

  /* only (a->i.lo * b->i.lo) 16x16->32 to do. asm? */
  bcast(a)->i.hi += bcast(a)->b.b1 * bcast(b)->b.b1;

  i12 = bcast(b)->b.b0 * bcast(a)->b.b1;
  bcast(b)->bi.i12 = bcast(a)->b.b0 * bcast(b)->b.b1;

  /* add up the two partial result, store carry in b3 */
  bcast(b)->b.b3 = ((bcast(b)->bi.i12 += i12) < i12);

  bcast(a)->i.lo  = bcast(a)->b.b0 * bcast(b)->b.b0;

  bcast(b)->bi.b0 = 0;

  return a + b;
}
#else
long
_mullong (long a, long b)
{
        union bil t;

        t.i.hi = bcast(a)->b.b0 * bcast(b)->b.b2;           // A
        t.i.lo = bcast(a)->b.b0 * bcast(b)->b.b0;           // A
        t.b.b3 += bcast(a)->b.b3 * bcast(b)->b.b0;          // G
        t.b.b3 += bcast(a)->b.b2 * bcast(b)->b.b1;          // F
        t.i.hi += bcast(a)->b.b2 * bcast(b)->b.b0;          // E <- b lost in .lst
        // bcast(a)->i.hi is free !
        t.i.hi += bcast(a)->b.b1 * bcast(b)->b.b1;          // D <- b lost in .lst

        bcast(a)->bi.b3 = bcast(a)->b.b1 * bcast(b)->b.b2;  // C
        bcast(a)->bi.i12 = bcast(a)->b.b1 * bcast(b)->b.b0; // C

        bcast(b)->bi.b3 = bcast(a)->b.b0 * bcast(b)->b.b3;  // B
        bcast(b)->bi.i12 = bcast(a)->b.b0 * bcast(b)->b.b1; // B

        bcast(b)->bi.b0 = 0;                                // B
        bcast(a)->bi.b0 = 0;                                // C
        t.l += a;

        return t.l + b;
}
#endif

#endif // _MULLONG_ASM
/*-------------------------------------------------------------------------
   coshf.c - Computes cosh(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <stdbool.h>

float sincoshf(float x, bool iscosh);

float coshf(float x) _FLOAT_FUNC_REENTRANT
{
    return sincoshf(x, 1);
}
/*-------------------------------------------------------------------------
   mbrtoc32.c - convert a multibyte sequence to a wide character

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <uchar.h>

#include <limits.h>
#include <wchar.h>

size_t mbrtoc32(char32_t *restrict pc32, const char *restrict s, size_t n, mbstate_t *restrict ps)
{
	char32_t wc;
	size_t ret;
	static mbstate_t sps;

	if(!ps)
		ps = &sps;

	if(!pc32)
		return(mbrtowc(0, s, n, ps));

	ret = mbrtowc(&wc, s, n, ps);

	if(ret <= MB_LEN_MAX)
		*pc32 = wc;

	return(ret);
}

/*-------------------------------------------------------------------------
   asincosf.c - Computes asin or acos of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>
#include <stdbool.h>

#define P1  0.933935835E+0
#define P2 -0.504400557E+0
#define Q0  0.560363004E+1
#define Q1 -0.554846723E+1
#define Q2  0.100000000E+1

#define P(g) (P2 * g + P1)
#define Q(g) ((Q2 * g + Q1) * g + Q0)

float asincosf(float x, bool isacos)
{
    float y, g, r;
    unsigned char i;
    bool quartPI = isacos;

    static const float a[2] = { 0.0, QUART_PI };
    static const float b[2] = { HALF_PI, QUART_PI };

    y = fabsf(x);
    if (y < EPS)
    {
        r = y;
    }
    else
    {
        if (y > 0.5)
        {
            quartPI = !isacos;
            if (y > 1.0)
            {
                errno = EDOM;
                return 0.0;
            }
            g = (0.5 - y) + 0.5;
            g = ldexpf(g, -1);
            y = sqrtf(g);
            y = -(y + y);
        }
        else
        {
            g = y * y;
        }
        r = y + y * ((P(g) * g) / Q(g));
    }
    i = quartPI;
    if (isacos)
    {
        if (x < 0.0)
            r = (b[i] + r) + b[i];
        else
            r = (a[i] - r) + a[i];
    }
    else
    {
        r = (a[i] + r) + a[i];
        if (x < 0.0)
            r = -r;
    }
    return r;
}
/*-------------------------------------------------------------------------
   _moduchar.c :- routine for signed char (8 bit) division.

   Copyright (C) 2013, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

unsigned int
_moduchar (unsigned char x, unsigned char y)
{
  return ((unsigned int)x % (unsigned int)y);
}

/*---------------------------------------------------------------------
   qsort() - sort an array

   Copyright (C) 2018, Philipp Klaus Krause . krauseph@informatik.uni-freiburg.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

// Despite the name, this is an insertion sort, since it tends to be smaller in code size.

static void swap(void *restrict dst, void *restrict src, size_t n)
{
	unsigned char *restrict d = dst;
	unsigned char *restrict s = src;

	while(n--)
	{
		unsigned char tmp = *d;
		*d = *s;
		*s = tmp;
		d++;
		s++;
	}
}

void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *) __reentrant)
{
	unsigned char *b = base;

	if(nmemb <= 1)
		return;

	for(unsigned char *i = base; i < b + nmemb * size; i += size)
	{
		for(unsigned char *j = i; (j > b) && (*compar)(j, j - size) < 0; j -= size)
			swap(j, j - size, size);
	}
}

/*-------------------------------------------------------------------------
   _fslt.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// char __fslt (float a, float b)
static void dummy(void) __naked
{
	__asm
	.globl	___fslt
___fslt:
	mov	r7, a
	mov	r0, sp
	dec	r0
	dec	r0
	lcall	fs_check_negative_zeros
	setb	sign_a
	rlc	a
	mov	a, @r0
	jc	a_negative
a_positive:
	jnb	acc.7, ab_positive
	// a is positive and b is negative, so a > b
	mov	dpl, #0
	ret
a_negative:
	jb	acc.7, ab_negative
	// a is negative and b is positive, so a < b
	mov	dpl, #1
	ret
ab_positive:
	clr	sign_a
ab_negative:
	lcall	fs_compare_uint32
	mov	a, r1
	jnz	ab_different
	// a and b are equal
	mov	dpl, a
	ret
ab_different:
	jb	sign_a, skip_invert
	cpl	c
skip_invert:
	clr	a
	rlc	a
	mov	dpl, a
	ret
	__endasm;
}

#else

/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

union float_long
  {
    float f;
    long l;
  };

/* compare two floats */
char __fslt (float a1, float a2)
{
  volatile union float_long fl1, fl2;

  fl1.f = a1;
  fl2.f = a2;

  if (((fl1.l | fl2.l) & 0x7FFFFFFF) == 0)
    return (0);

  if (fl1.l<0 && fl2.l<0) {
    if (fl2.l < fl1.l)
      return (1);
    return (0);
  }

  if (fl1.l < fl2.l)
    return (1);
  return (0);
}

#endif
/*-------------------------------------------------------------------------
   _divsint.c :- routine for signed int (16 bit) division. just calls
                 routine for unsigned division after sign adjustment

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#include <sdcc-lib.h>

#if _SDCC_MANGLES_SUPPORT_FUNS
unsigned unsigned _divuint (unsigned x, unsigned y);
#endif

/*   Assembler-functions are provided for:
     mcs51 small
     mcs51 small stack-auto
*/

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO) && !defined(__SDCC_PARMS_IN_BANK1)
#        define _DIVSINT_ASM_SMALL_AUTO
#      else
#        define _DIVSINT_ASM_SMALL
#      endif
#    endif
#  endif
#endif

#if defined _DIVSINT_ASM_SMALL

static void
_divsint_dummy (void) __naked
{
	__asm

	#define xl	dpl
	#define xh	dph

	.globl __divsint

	// _divsint_PARM_2 shares the same memory with _divuint_PARM_2
	// and is defined in _divuint.c
#if defined(__SDCC_PARMS_IN_BANK1)
	#define yl      (b1_0)
	#define yh      (b1_1)
#else
	#define yl      (__divsint_PARM_2)
	#define yh      (__divsint_PARM_2 + 1)
#endif
__divsint:
				; xh in dph
				; yh in (__divsint_PARM_2 + 1)

	clr	F0 		; Flag 0 in PSW
				; available to user for general purpose
	mov	a,xh
	jnb	acc.7,a_not_negative

	setb	F0

	clr	a
	clr	c
	subb	a,xl
	mov	xl,a
	clr	a
	subb	a,xh
	mov	xh,a

a_not_negative:

	mov	a,yh
	jnb	acc.7,b_not_negative

	cpl	F0

	clr	a
	clr	c
	subb	a,yl
	mov	yl,a
	clr	a
	subb	a,yh
	mov	yh,a

b_not_negative:

	lcall	__divuint

	jnb	F0,not_negative

	clr	a
	clr	c
	subb	a,xl
	mov	xl,a
	clr	a
	subb	a,xh
	mov	xh,a

not_negative:
	ret

	__endasm;
}

#elif defined _DIVSINT_ASM_SMALL_AUTO

static void
_divsint_dummy (void) __naked
{
	__asm

	#define xl	dpl
	#define xh	dph

	.globl __divsint

__divsint:

	clr	F0 		; Flag 0 in PSW
				; available to user for general purpose
	mov	a,xh
	jnb	acc.7,a_not_negative

	setb	F0

	clr	a
	clr	c
	subb	a,xl
	mov	xl,a
	clr	a
	subb	a,xh
	mov	xh,a

a_not_negative:

	mov	a,sp
	add	a,#-2		; 2 bytes return address
	mov	r0,a		; r0 points to yh
	mov	a,@r0		; a = yh

	jnb	acc.7,b_not_negative

	cpl	F0

	dec	r0

	clr	a
	clr	c
	subb	a,@r0		; yl
	mov	@r0,a
	clr	a
	inc	r0
	subb	a,@r0		; a = yh

b_not_negative:

	mov	r1,a		; yh
	dec	r0
	mov	a,@r0		; yl
	mov	r0,a

	lcall	__divint

	jnb	F0,not_negative

	clr	a
	clr	c
	subb	a,xl
	mov	xl,a
	clr	a
	subb	a,xh
	mov	xh,a

not_negative:
	ret

	__endasm;
}

#else  // _DIVSINT_ASM_

int
_divsint (int x, int y)
{
  register int r;

  r = (unsigned int)(x < 0 ? -x : x) / (unsigned int)(y < 0 ? -y : y);
  if ((x < 0) ^ (y < 0))
    return -r;
  else
    return r;
}

#endif  // _DIVSINT_ASM_
/*-------------------------------------------------------------------------
   _gptrput.c - put value for a generic pointer

   Copyright (c) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* not all devices use P2 to page pdata memory, therefore __XPAGE was
   introduced. On some targets __XPAGE itself is a paged SFR so it is
   not safe for all platforms to set this. Furthermore some targets
   can be configured to behave differently for movx @dptr vs. movx @Ri
   (don't drive high byte of address bus for movx @Ri only) */
#define USE_PDATA_PAGING_REGISTER 0

__sbit __at (0xF7) B_7;
__sbit __at (0xF6) B_6;
__sbit __at (0xF5) B_5;

#if defined DSDCC_MODEL_HUGE
void
_gptrput (char *gptr, char c) __naked
{
/* This is the banked version with pointers up to 22 bits.
   B cannot be trashed */

    gptr; c; /* hush the compiler */

    __asm
    ;
    ;   depending on the pointer type according to SDCCsymt.h
    ;
        jb      _B_7,codeptr$        ; >0x80 code       ; 3
        jnb     _B_6,xdataptr$       ; <0x40 far        ; 3

        mov     dph,r0 ; save r0 independant of regbank ; 2
        mov     r0,dpl ; use only low order address     ; 2

        jb      _B_5,pdataptr$       ; >0x60 pdata      ; 3
    ;
    ;   store into near/idata space
    ;
        mov     @r0,a                                   ; 1
 dataptrrestore$:
        mov     r0,dph ; restore r0                     ; 2
        mov     dph,#0 ; restore dph                    ; 2
        ret                                             ; 1
    ;
    ;   cannot store into code space, lock up
    ;
 codeptr$:
        sjmp    .                                       ; 2
    ;
    ;   store into external stack/pdata space
    ;
 pdataptr$:
        movx    @r0,a                                   ; 1
        sjmp    dataptrrestore$                         ; 2
    ;
    ;   store into far space
    ;
 xdataptr$:
        mov     _P3,b                                   ; 3

        movx    @dptr,a                                 ; 1
        ret                                             ; 1

                                                        ;===
                                                        ;29 bytes
    __endasm;
}

#elif defined DSDCC_MODEL_MEDIUM

void
_gptrput (char *gptr, char c) __naked
{
/* This is the non-banked version with pointers up to 14 bits.
   Assumes B is free to be used */

    gptr; c; /* hush the compiler */

    __asm
    ;
    ;   depending on the pointer type according to SDCCsymt.h
    ;
        mov     b,dph                                   ; 3
        jb      _B_7,codeptr$        ; >0x80 code       ; 3
        jnb     _B_6,xdataptr$       ; <0x40 far        ; 3

        mov     b,r0   ; save r0 independant of regbank ; 2
        mov     r0,dpl ; use only low order address     ; 2

        jb      _B_5,pdataptr$       ; >0x60 pdata      ; 3
    ;
    ;   store into near/idata space
    ;
        mov     @r0,a                                   ; 1
 dataptrrestore$:
        mov     r0,b   ; restore r0                     ; 2
        ret                                             ; 1
    ;
    ;   cannot store into code space, lock up
    ;
 codeptr$:
        sjmp    .                                       ; 2
    ;
    ;   store into external stack/pdata space
    ;
 pdataptr$:
        movx    @r0,a                                   ; 1
        sjmp    dataptrrestore$                         ; 2
    ;
    ;   store into far space, max 14 bits
    ;
 xdataptr$:
    ; 0 <= dptr <= 0x3FFF
        movx    @dptr,a                                 ; 1
        ret                                             ; 1
                                                        ;===
                                                        ;27 bytes
    __endasm;
}

#else

void
_gptrput (char *gptr, char c) __naked
{
/* This is the new version with pointers up to 16 bits.
   B cannot be trashed */

    gptr; c; /* hush the compiler */

    __asm
    ;
    ;   depending on the pointer type according to SDCCsymt.h
    ;
        jb      _B_7,codeptr$        ; >0x80 code       ; 3
        jnb     _B_6,xdataptr$       ; <0x40 far        ; 3

        mov     dph,r0 ; save r0 independant of regbank ; 2
        mov     r0,dpl ; use only low order address     ; 2

        jb      _B_5,pdataptr$       ; >0x60 pdata      ; 3
    ;
    ;   store into near/idata space
    ;
        mov     @r0,a                                   ; 1
 dataptrrestore$:
        mov     r0,dph ; restore r0                     ; 2
        mov     dph,#0 ; restore dph                    ; 2
        ret                                             ; 1
    ;
    ;   cannot store into code space, lock up
    ;
 codeptr$:
        sjmp    .                                       ; 2
    ;
    ;   store into external stack/pdata space
    ;
 pdataptr$:
        movx    @r0,a                                   ; 1
        sjmp    dataptrrestore$                         ; 2
    ;
    ;   store into far space
    ;
 xdataptr$:
        movx    @dptr,a                                 ; 1
        ret                                             ; 1

                                                        ;===
                                                        ;26 bytes
    __endasm;
}

#endif

#ifdef __SDCC_ds390

void
_gptrputWord (int *gptr, int w) __naked
{
/* The ds390 can write two bytes in one go.
   B cannot be trashed */

    gptr; w; /* hush the compiler */

    __asm
    ;
    ;   depending on the pointer type acc. to SDCCsymt.h
    ;
        jb      _B_7,codeptr_w$       ; >0x80 code
        jnb     _B_6,xdataptr_w$      ; <0x40 far

        mov     dph,r0 ; save r0 independant of regbank
        mov     r0,dpl ; use only low order address

        jb      _B_5,pdataptr_w$      ; >0x60 pdata
;
;       store into near space
;
        mov     @r0,acc1
        inc     r0
        mov     @r0,a
 dataptrrestore_w$:
        mov     dpl,r0
        mov     r0,dph ; restore r0
        mov     dph,#0 ; restore dph
        ret
    ;
    ;   cannot store into code space, lock up
    ;
 codeptr_w$:
        sjmp    .
;
;       store into xstack space
;
 pdataptr_w$:
        xch     a,acc1
        movx    @r0,a
        inc     r0
        xch     a,acc1
        movx    @r0, a
        sjmp    dataptrrestore_w$
;
;       store into far space
;
 xdataptr_w$:
        xch     a,acc1
        movx    @dptr,a
        inc     dptr
        xch     a,acc1
        movx    @dptr,a
        ret
    __endasm;
}

#endif
/*-------------------------------------------------------------------------
   isupper.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* it is important to declare this function extern before including
   the inline definition to give it external linkage */
extern int isupper (int c);

/* also include stdio.h before ctype.h here so ctype can perform a
   _Static_assert on EOF */
#include <stdio.h>

#include <ctype.h>
/*-----------------------------------------------------------------
   printf_large.c - formatted output conversion

   Copyright (C) 1999, Martijn van Balen <aed AT iae.nl>
   Added %f By - <johan.knol AT iduna.nl> (2000)
   Refactored by - Maarten Brock (2004)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#if defined (__SDCC_ds390) || defined (__SDCC_USE_XSTACK) || defined (__SDCC_MODEL_HUGE)
#define USE_FLOATS 1
#endif

#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <stdbool.h>
#include <sdcc-lib.h>

#define PTR value.ptr

#ifdef __SDCC_ds390
#define NULL_STRING "<NULL>"
#define NULL_STRING_LENGTH 6
#endif

#if defined (__SDCC_mcs51) && defined (__SDCC_MODEL_SMALL) && !defined (__SDCC_STACK_AUTO)
# define MEM_SPACE_BUF __idata
# define MEM_SPACE_BUF_PP __idata
#else
# define MEM_SPACE_BUF
# define MEM_SPACE_BUF_PP _AUTOMEM
#endif

/****************************************************************************/

//typedef const char * ptr_t;
#define ptr_t const char *

#ifdef toupper
#undef toupper
#endif
#ifdef tolower
#undef tolower
#endif
#ifdef islower
#undef islower
#endif
#ifdef isdigit
#undef isdigit
#endif

//#define toupper(c) ((c)&=~0x20)
#define toupper(c) ((c)&=0xDF)
#define tolower(c) ((c)|=0x20)
#define islower(c) ((unsigned char)c >= (unsigned char)'a' && (unsigned char)c <= (unsigned char)'z')
#define isdigit(c) ((unsigned char)c >= (unsigned char)'0' && (unsigned char)c <= (unsigned char)'9')

typedef union
{
  unsigned char  byte[5];
  long           l;
  unsigned long  ul;
  float          f;
  const char     *ptr;
} value_t;

#ifndef __SDCC_STACK_AUTO
  static bool lower_case;
  static pfn_outputchar output_char;
  static void* p;
  static value_t value;
  static int charsOutputted;
#endif

/****************************************************************************/

#ifdef __SDCC_STACK_AUTO
  #define OUTPUT_CHAR(c, p) { output_char (c, p); charsOutputted++; }
#else
  #define OUTPUT_CHAR(c, p) _output_char (c)
  static void
  _output_char (unsigned char c)
  {
    output_char( c, p );
    charsOutputted++;
  }
#endif

/*--------------------------------------------------------------------------*/

#ifdef __SDCC_STACK_AUTO
  static void
  output_digit (unsigned char n, bool lower_case, pfn_outputchar output_char, void* p)
  {
    register unsigned char c = n + (unsigned char)'0';

    if (c > (unsigned char)'9')
    {
      c += (unsigned char)('A' - '0' - 10);
      if (lower_case)
         c += (unsigned char)('a' - 'A');
    }
    output_char( c, p );
  }
#else
  static void
  output_digit (unsigned char n)
  {
    register unsigned char c = n + (unsigned char)'0';

    if (c > (unsigned char)'9')
    {
      c += (unsigned char)('A' - '0' - 10);
      if (lower_case)
         c = tolower(c);
    }
    _output_char( c );
  }
#endif

/*--------------------------------------------------------------------------*/

#ifdef __SDCC_STACK_AUTO
  #define OUTPUT_2DIGITS( B )   { output_2digits( B, lower_case, output_char, p ); charsOutputted += 2; }
  static void
  output_2digits (unsigned char b, bool lower_case, pfn_outputchar output_char, void* p)
  {
    output_digit( b>>4,   lower_case, output_char, p );
    output_digit( b&0x0F, lower_case, output_char, p );
  }
#else
  #define OUTPUT_2DIGITS( B )   output_2digits( B )
  static void
  output_2digits (unsigned char b)
  {
    output_digit( b>>4   );
    output_digit( b&0x0F );
  }
#endif

/*--------------------------------------------------------------------------*/

#if defined __SDCC_STACK_AUTO
static void
calculate_digit (value_t _AUTOMEM * value, unsigned char radix)
{
  unsigned long ul = value->ul;
  unsigned char _AUTOMEM * pb4 = &value->byte[4];
  unsigned char i = 32;

  do
  {
    *pb4 = (*pb4 << 1) | ((ul >> 31) & 0x01);
    ul <<= 1;

    if (radix <= *pb4 )
    {
      *pb4 -= radix;
      ul |= 1;
    }
  } while (--i);
  value->ul = ul;
}
#else
static void
calculate_digit (unsigned char radix)
{
  register unsigned long ul = value.ul;
  register unsigned char b4 = value.byte[4];
  register unsigned char i = 32;

  do
  {
    b4 = (b4 << 1);
    b4 |= (ul >> 31) & 0x01;
    ul <<= 1;

    if (radix <= b4 )
    {
      b4 -= radix;
      ul |= 1;
    }
  } while (--i);
  value.ul = ul;
  value.byte[4] = b4;
}
#endif

#if USE_FLOATS

/* This is a very inefficient but direct approach, since we have no math
   library yet (e.g. log()).
   It does most of the modifiers, but has some restrictions. E.g. the
   abs(float) shouldn't be bigger than an unsigned long (that's
   about 4294967295), but still makes it usefull for most real-life
   applications.
*/

#define DEFAULT_FLOAT_PRECISION 6

#ifdef __SDCC_STACK_AUTO
#define OUTPUT_FLOAT(F, W, D, L, Z, S, P)       output_float(F, W, D, L, Z, S, P, output_char, p)
static unsigned char
output_float (float f, unsigned char reqWidth,
              signed char reqDecimals,
              bool left, bool zero, bool sign, bool space,
              pfn_outputchar output_char, void* p)
{
  unsigned char charsOutputted = 0;
 #if defined (__SDCC_mcs51)
  char fpBuffer[16];      //mcs51 has only a small stack
 #else
  char fpBuffer[128];
 #endif
#else
#define OUTPUT_FLOAT(F, W, D, L, Z, S, P)       output_float(F, W, D, L, Z, S, P)
static void
output_float (float f, unsigned char reqWidth,
              signed char reqDecimals,
              bool left, bool zero, bool sign, bool space)
{
  __xdata char fpBuffer[128];
#endif //__SDCC_STACK_AUTO
  bool negative = 0;
  unsigned long integerPart;
  float rounding;
  float decimalPart;
  char fpBI=0, fpBD;
  unsigned char minWidth, i;
  signed char exp = -128;

  // save the sign
  if (f<0)
  {
    negative=1;
    f=-f;
  }

  if (f>0x00ffffff)
  {
    // this part is from Frank van der Hulst

    for (exp = 0; f >= 10.0; exp++) f /=10.0;
    for (       ; f < 1.0;   exp--) f *=10.0;

    if (negative)
    {
      OUTPUT_CHAR ('-', p);
    }
    else
    {
      if (sign)
      {
        OUTPUT_CHAR ('+', p);
      }
    }
    reqWidth = 0;
    left = 0;
    zero = 0;
    sign = 0;
    space = 0;
  }

  // display some decimals as default
  if (reqDecimals==-1)
    reqDecimals=DEFAULT_FLOAT_PRECISION;

  // round the float
  rounding = 0.5;
  for (i=reqDecimals; i>0; i--)
  {
      rounding /= 10.0;
  }
  f += rounding;

  // split the float
  integerPart = f;
  decimalPart = f - integerPart;

  // fill the buffer with the integerPart (in reversed order!)
  while (integerPart)
  {
    fpBuffer[fpBI++]='0' + integerPart%10;
    integerPart /= 10;
  }
  if (!fpBI)
  {
    // we need at least a 0
    fpBuffer[fpBI++]='0';
  }

  // fill buffer with the decimalPart (in normal order)
  fpBD=fpBI;

  for (i=reqDecimals; i>0; i--)
  {
      decimalPart *= 10.0;
      // truncate the float
      integerPart = decimalPart;
      fpBuffer[fpBD++] = '0' + integerPart;
      decimalPart -= integerPart;
  }

  minWidth=fpBI; // we need at least these
  minWidth+=reqDecimals?reqDecimals+1:0; // maybe these
  if (negative || sign || space)
    minWidth++; // and maybe even this :)

  if (!left && reqWidth>i)
  {
    if (zero)
    {
      if (negative)
      {
        OUTPUT_CHAR('-', p);
      }
      else if (sign)
      {
        OUTPUT_CHAR('+', p);
      }
      else if (space)
      {
        OUTPUT_CHAR(' ', p);
      }
      while (reqWidth-->minWidth)
      {
        OUTPUT_CHAR('0', p);
      }
    }
    else
    {
      while (reqWidth-->minWidth)
      {
        OUTPUT_CHAR(' ', p);
      }
      if (negative)
      {
        OUTPUT_CHAR('-', p);
      }
      else if (sign)
      {
        OUTPUT_CHAR('+', p);
      }
      else if (space)
      {
        OUTPUT_CHAR(' ', p);
      }
    }
  }
  else
  {
    if (negative)
    {
      OUTPUT_CHAR('-', p);
    }
    else if (sign)
    {
      OUTPUT_CHAR('+', p);
    }
    else if (space)
    {
      OUTPUT_CHAR(' ', p);
    }
  }

  // output the integer part
  i=fpBI-1;
  do {
    OUTPUT_CHAR (fpBuffer[i], p);
  } while (i--);

  // ouput the decimal part
  if (reqDecimals)
  {
    OUTPUT_CHAR ('.', p);
    i=fpBI;
    while (reqDecimals--)
    {
      OUTPUT_CHAR (fpBuffer[i++], p);
    }
  }

  if (left && reqWidth>minWidth)
  {
    while (reqWidth-->minWidth)
    {
      OUTPUT_CHAR(' ', p);
    }
  }

  if (exp != -128)
  {
    OUTPUT_CHAR ('e', p);
    if (exp<0)
    {
      OUTPUT_CHAR ('-', p);
      exp = -exp;
    }
    OUTPUT_CHAR ('0'+exp/10, p);
    OUTPUT_CHAR ('0'+exp%10, p);
  }
#ifdef __SDCC_STACK_AUTO
  return charsOutputted;
#else
  return;
#endif //__SDCC_STACK_AUTO
}
#endif //USE_FLOATS

int
_print_format (pfn_outputchar pfn, void* pvoid, const char *format, va_list ap)
{
  bool   left_justify;
  bool   zero_padding;
  bool   prefix_sign;
  bool   prefix_space;
  bool   signed_argument;
  bool   char_argument;
  bool   long_argument;
  bool   float_argument;
#ifdef __SDCC_STACK_AUTO
  bool   lower_case;
  value_t value;
  int charsOutputted;
#endif
  bool   lsd;

  unsigned char radix;
  size_t  width;
  int decimals;
  size_t  length;
  char           c;

#ifdef __SDCC_STACK_AUTO
  #define output_char   pfn
  #define p             pvoid
#else
  output_char = pfn;
  p = pvoid;
#endif

  // reset output chars
  charsOutputted = 0;

#ifdef __SDCC_ds390
  if (format==0)
  {
    format=NULL_STRING;
  }
#endif

  while( c=*format++ )
  {
    if ( c=='%' )
    {
      left_justify    = 0;
      zero_padding    = 0;
      prefix_sign     = 0;
      prefix_space    = 0;
      signed_argument = 0;
      char_argument   = 0;
      long_argument   = 0;
      float_argument  = 0;
      radix           = 0;
      width           = 0;
      decimals        = -1;

get_conversion_spec:

      c = *format++;

      if (c=='%')
      {
        OUTPUT_CHAR(c, p);
        continue;
      }

      if (isdigit(c))
      {
        if (decimals==-1)
        {
          width = 10*width + c - '0';
          if (width == 0)
          {
            /* first character of width is a zero */
            zero_padding = 1;
          }
        }
        else
        {
          decimals = 10*decimals + c - '0';
        }
        goto get_conversion_spec;
      }

      if (c=='.')
      {
        if (decimals==-1)
          decimals=0;
        else
          ; // duplicate, ignore
        goto get_conversion_spec;
      }

      if (islower(c))
      {
        c = toupper(c);
        lower_case = 1;
      }
      else
        lower_case = 0;

      switch( c )
      {
      case '-':
        left_justify = 1;
        goto get_conversion_spec;
      case '+':
        prefix_sign = 1;
        goto get_conversion_spec;
      case ' ':
        prefix_space = 1;
        goto get_conversion_spec;
      case 'B': /* byte */
        char_argument = 1;
        goto get_conversion_spec;
//      case '#': /* not supported */
      case 'H': /* short */
      case 'J': /* intmax_t */
      case 'T': /* ptrdiff_t */
      case 'Z': /* size_t */
        goto get_conversion_spec;
      case 'L': /* long */
        long_argument = 1;
        goto get_conversion_spec;

      case 'C':
        if( char_argument )
          c = va_arg(ap,char);
        else
          c = va_arg(ap,int);
        OUTPUT_CHAR( c, p );
        break;

      case 'S':
        PTR = va_arg(ap,ptr_t);

#ifdef __SDCC_ds390
        if (PTR==0)
        {
          PTR=NULL_STRING;
          length=NULL_STRING_LENGTH;
        }
        else
        {
          length = strlen(PTR);
        }
#else
        length = strlen(PTR);
#endif
        if ( decimals == -1 )
        {
          decimals = length;
        }
        if ( ( !left_justify ) && (length < width) )
        {
          width -= length;
          while( width-- != 0 )
          {
            OUTPUT_CHAR( ' ', p );
          }
        }

        while ( (c = *PTR)  && (decimals-- > 0))
        {
          OUTPUT_CHAR( c, p );
          PTR++;
        }

        if ( left_justify && (length < width))
        {
          width -= length;
          while( width-- != 0 )
          {
            OUTPUT_CHAR( ' ', p );
          }
        }
        break;

      case 'P':
        PTR = va_arg(ap,ptr_t);

#if defined (__SDCC_ds390)
        {
          unsigned char memtype = value.byte[3];
          if (memtype >= 0x80)
            c = 'C';
          else if (memtype >= 0x60)
            c = 'P';
          else if (memtype >= 0x40)
            c = 'I';
          else
            c = 'X';
        }
        OUTPUT_CHAR(c, p);
        OUTPUT_CHAR(':', p);
        OUTPUT_CHAR('0', p);
        OUTPUT_CHAR('x', p);
        OUTPUT_2DIGITS( value.byte[2] );
        OUTPUT_2DIGITS( value.byte[1] );
        OUTPUT_2DIGITS( value.byte[0] );
#elif defined (__SDCC_mcs51)
        {
          unsigned char memtype = value.byte[2];
          if (memtype >= 0x80)
            c = 'C';
          else if (memtype >= 0x60)
            c = 'P';
          else if (memtype >= 0x40)
            c = 'I';
          else
            c = 'X';
        }
        OUTPUT_CHAR(c, p);
        OUTPUT_CHAR(':', p);
        OUTPUT_CHAR('0', p);
        OUTPUT_CHAR('x', p);
        if ((c != 'I' /* idata */) &&
            (c != 'P' /* pdata */))
        {
          OUTPUT_2DIGITS( value.byte[1] );
        }
        OUTPUT_2DIGITS( value.byte[0] );
#else
        OUTPUT_CHAR('0', p);
        OUTPUT_CHAR('x', p);
        OUTPUT_2DIGITS( value.byte[1] );
        OUTPUT_2DIGITS( value.byte[0] );
#endif
        break;

      case 'D':
      case 'I':
        signed_argument = 1;
        radix = 10;
        break;

      case 'O':
        radix = 8;
        break;

      case 'U':
        radix = 10;
        break;

      case 'X':
        radix = 16;
        break;

      case 'F':
        float_argument=1;
        break;

      default:
        // nothing special, just output the character
        OUTPUT_CHAR( c, p );
        break;
      }

      if (float_argument)
      {
        value.f = va_arg(ap, float);
#if !USE_FLOATS
        PTR="<NO FLOAT>";
        while (c=*PTR++)
        {
          OUTPUT_CHAR (c, p);
        }
        // treat as long hex
        //radix=16;
        //long_argument=1;
        //zero_padding=1;
        //width=8;
#else
        // ignore b and l conversion spec for now
#ifdef __SDCC_STACK_AUTO
        charsOutputted += OUTPUT_FLOAT(value.f, width, decimals, left_justify,
                                     zero_padding, prefix_sign, prefix_space);
#else
        OUTPUT_FLOAT(value.f, width, decimals, left_justify,
                     zero_padding, prefix_sign, prefix_space);
#endif //__SDCC_STACK_AUTO
#endif //USE_FLOATS
      }
      else if (radix != 0)
      {
        // Apparently we have to output an integral type
        // with radix "radix"
        unsigned char MEM_SPACE_BUF store[6];
        unsigned char MEM_SPACE_BUF_PP *pstore = &store[5];

        // store value in byte[0] (LSB) ... byte[3] (MSB)
        if (char_argument)
        {
          value.l = va_arg(ap, char);
          if (!signed_argument)
          {
            value.l &= 0xFF;
          }
        }
        else if (long_argument)
        {
          value.l = va_arg(ap, long);
        }
        else // must be int
        {
          value.l = va_arg(ap, int);
          if (!signed_argument)
          {
            value.l &= 0xFFFF;
          }
        }

        if ( signed_argument )
        {
          if (value.l < 0)
            value.l = -value.l;
          else
            signed_argument = 0;
        }

        length=0;
        lsd = 1;

        do {
          value.byte[4] = 0;
#if defined __SDCC_STACK_AUTO
          calculate_digit(&value, radix);
#else
          calculate_digit(radix);
#endif
          if (!lsd)
          {
            *pstore = (value.byte[4] << 4) | (value.byte[4] >> 4) | *pstore;
            pstore--;
          }
          else
          {
            *pstore = value.byte[4];
          }
          length++;
          lsd = !lsd;
        } while( value.ul );

        if (width == 0)
        {
          // default width. We set it to 1 to output
          // at least one character in case the value itself
          // is zero (i.e. length==0)
          width = 1;
        }

        /* prepend spaces if needed */
        if (!zero_padding && !left_justify)
        {
          while ( width > (unsigned char) (length+1) )
          {
            OUTPUT_CHAR( ' ', p );
            width--;
          }
        }

        if (signed_argument) // this now means the original value was negative
        {
          OUTPUT_CHAR( '-', p );
          // adjust width to compensate for this character
          width--;
        }
        else if (length != 0)
        {
          // value > 0
          if (prefix_sign)
          {
            OUTPUT_CHAR( '+', p );
            // adjust width to compensate for this character
            width--;
          }
          else if (prefix_space)
          {
            OUTPUT_CHAR( ' ', p );
            // adjust width to compensate for this character
            width--;
          }
        }

        /* prepend zeroes/spaces if needed */
        if (!left_justify)
        {
          while ( width-- > length )
          {
            OUTPUT_CHAR( zero_padding ? '0' : ' ', p );
          }
        }
        else
        {
          /* spaces are appended after the digits */
          if (width > length)
            width -= length;
          else
            width = 0;
        }

        /* output the digits */
        while( length-- )
        {
          lsd = !lsd;
          if (!lsd)
          {
            pstore++;
            value.byte[4] = *pstore >> 4;
          }
          else
          {
            value.byte[4] = *pstore & 0x0F;
          }
#ifdef __SDCC_STACK_AUTO
          output_digit( value.byte[4], lower_case, output_char, p );
          charsOutputted++;
#else
          output_digit( value.byte[4] );
#endif
        }
        if (left_justify)
        {
          while (width-- > 0)
          {
            OUTPUT_CHAR(' ', p);
          }
        }
      }
    }
    else
    {
      // nothing special, just output the character
      OUTPUT_CHAR( c, p );
    }
  }

  return charsOutputted;
}

/****************************************************************************/
/*-------------------------------------------------------------------------
   _bp.c - just declares bp as a variable                

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

__data unsigned char bp ;
/*-------------------------------------------------------------------------
   _strncmp.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

int strncmp ( const char * first, const char * last, size_t count )
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last) {
		first++;
		last++;
	}

	return( *first - *last );
}
/*-------------------------------------------------------------------------

   _autobaud.c - automatic baud rate detection routine. Adapted for
   sdcc compiler from Paul Stoffregen's  <paul@ece.orst.edu> autobaud.asm
   the original assembly code can be found at 
   http://www.ece.orst.edu/~paul/8051-goodies/autobaud.html  
  
   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <8051.h>
/*
; To set the baud rate, use this formula or use autobaud()
; baud_const = 256 - (crystal / (12 * 16 * baud)) */

/*
;to do automatic baud rate detection, we assume the user will
;press the carriage return, which will cause this bit pattern
;to appear on port 3 pin 0 (CR = ascii code 13, assume 8N1 format)
;
;              0 1 0 1 1 0 0 0 0 1
;              | |             | |
; start bit----+ +--lsb   msb--+ +----stop bit
;
;we'll start timer #1 in 16 bit mode at the transition between the
;start bit and the LSB and stop it between the MBS and stop bit.
;That will give approx the number of cpu cycles for 8 bits.  Divide
;by 8 for one bit and by 16 since the built-in UART takes 16 timer
;overflows for each bit.  We need to be careful about roundoff during
;division and the result has to be inverted since timer #1 counts up.  Of
;course, timer #1 gets used in 8-bit auto reload mode for generating the
;built-in UART's baud rate once we know what the reload value should be.
*/

void autobaud ()
{

        /* get timer #1 ready for action (16 bit mode) */
        TMOD=0x11;
        TCON = 0;
        TH1 = TL1 = 0;
        
        /* wait for start bit */
autobaud2:
        while(RXD) ; 

        /*  check it a few more times to make
             sure we don't trigger on some noise*/
        if (RXD) goto autobaud2;
        if (RXD) goto autobaud2;
        if (RXD) goto autobaud2;
        if (RXD) goto autobaud2;

        /* wait for bit #0 to begin      */
        while (!RXD);
        TR1 = 1; /* start the timer */
        while (RXD);             // wait for bit #1 to begin
        while(!RXD);             // wait for bit #2 to begin
        while(RXD);              // wait for bit #4 to begin
        while (!RXD);            // wait for stop bit to begin
        TR1 = 0;                 // stop timing

        /* ;grab bit 7... it's the lsb we want */
        TH1 = (TH1 << 1) | (TL1 >> 7);

        /* round off if necessary */
        TH1 = (TH1 << 1) | ((TL1 >> 6) & 0x01);

        /* invert since timer #1 will count up */
        TH1 = ~TH1;

        /* now TH1 has the correct reload value (I hope) */
        TH1++ ;

        TL1 = TH1;
        TMOD =  0x21     ;      // set timer #1 for 8 bit auto-reload
        PCON =  0x80     ;      // configure built-in uart
        SCON =  0x52     ;
}
/*-------------------------------------------------------------------------
   strdup.c - part of string library functions

   Copyright (C) 2019, Philipp Klaus Krause . krauseph@informatik.uni-freiburg.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

#include <stdlib.h>

char *strdup (const char *s)
{
	char *r = malloc(strlen(s) + 1);
	if (r)
		strcpy(r, s);
	return (r);
}

/*-------------------------------------------------------------------------
   memcpy.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

#undef memcpy /* Avoid conflict with wrapper macro of the same name */

void * __memcpy (void *dst, const void *src, size_t n);

void *memcpy (void *dst, const void *src, size_t n)
{
	return __memcpy (dst, src, n);
}

/*-------------------------------------------------------------------------
   isalnum.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

#ifdef isalnum
#undef isalnum
#endif

int isalnum (int c)
{
  return (isalpha (c) || isdigit (c));
}

/*-------------------------------------------------------------------------
   _muluchar.c :- routine for unsigned char (8 bit) multiplication.

   Copyright (C) 2017, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

unsigned int
_muluchar (unsigned char x, unsigned char y)
{
  unsigned int result = 0;

  for (unsigned char i = 0; i < 8; i++)
    {
      result <<= 1;
      if (x & 0x80)
        result += y;
      x <<= 1;
    }

  return result;
}

/*-------------------------------------------------------------------------
   _strtok.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

#if defined(__SDCC_MODEL_LARGE) || defined (__SDCC_MODEL_FLAT24)
#pragma noinduction
#pragma noinvariant
#endif

char * strtok ( char * str, const char * control )
{
	static char * s;
	register char * s1;

	if ( str )
		s = str;
	if ( !s )
		return NULL;

	while (*s) {
		if (strchr(control,*s))
			s++;
		else
			break;
	}

	s1 = s;

	while (*s) {
		if (strchr(control,*s)) {
			*s++ = '\0';
			return s1;
		}
		s++ ;
	}

	s = NULL;

	if (*s1)
		return s1;
	else
		return NULL;
}
/*-------------------------------------------------------------------------
   assert.c

   Copyright (C) 2000, Michael Hope

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void __assert(const char *expression, const char *functionname, const char *filename, unsigned int linenumber)
{
	printf("Assert(%s) failed in function %s at line %u in file %s.\n",
		expression, functionname, linenumber, filename);
	for(;;);
}

/*---------------------------------------------------------------------
   bsearch() - search a sorted array

   Copyright (C) 2018, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *) __reentrant)
{
	for(const char *left = base; nmemb;)
	{
		const char *middle = left + nmemb / 2 * size;
		int c = (*compar)(key, middle);

		if(c < 0)
			nmemb = nmemb / 2;	
		else if(c > 0)
		{
			left = middle + size;
			nmemb = (nmemb - 1) / 2;
		}
		else
			return(middle);
	}

	return(0);
}

/*-------------------------------------------------------------------------
   wcrtomb.c - convert a wide character to a multibyte sequence

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <wchar.h>

#include <stdlib.h>
#include <errno.h>

size_t wcrtomb(char *restrict s, wchar_t wc, mbstate_t *restrict ps)
{
	size_t ret;

	ps;

	ret = wctomb(s, wc);

	if(ret == (size_t)(-1))
		errno = EILSEQ;

	return(ret);
}

/*-------------------------------------------------------------------------
   _fs2schar.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>



#ifdef FLOAT_ASM_MCS51

// char __fs2schar (float x)
static void dummy(void) __naked
{
        __asm
        .globl  ___fs2schar
___fs2schar:
        lcall   ___fs2slong
        jnz     fs2schar_not_zero
        mov     a, dpl
        orl     a, dph
        orl     a, b
        jnz     fs2schar_clr_a
        ret
fs2schar_clr_a:
        clr a
fs2schar_not_zero:
        jnb     sign_a, fs2schar_pos
fs2schar_neg:
        cpl     a
        jnz     fs2schar_maxval_neg
        mov     a, b
        cpl     a
        jnz     fs2schar_maxval_neg
        mov     a, dph
        cpl     a
        jnz     fs2schar_maxval_neg
        mov     a, dpl
        jnb     acc.7, fs2schar_maxval_neg
        ret
fs2schar_maxval_neg:
        mov     dpl, #0x80
        ret
fs2schar_pos:
        jnz     fs2schar_maxval_pos
        mov     a, b
        jnz     fs2schar_maxval_pos
        mov     a, dph
        jnz     fs2schar_maxval_pos
        mov     a, dpl
        jb      acc.7, fs2schar_maxval_pos
        ret
fs2schar_maxval_pos:
        mov     dpl, #0x7F
        ret
        __endasm;
}

#else

/* convert float to signed char */
signed char __fs2schar (float f)
{
  signed long sl=__fs2slong(f);
  if (sl>=SCHAR_MAX)
    return SCHAR_MAX;
  if (sl<=SCHAR_MIN)
    return -SCHAR_MIN;
  return sl;
}

#endif
/*-------------------------------------------------------------------------
   _memcpy.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

void *__memcpy (void *dst, const void *src, size_t n)
{
	void *ret = dst;
	char *d = dst;
	const char *s = src;

	while (n--)
		*d++ = *s++;

	return(ret);
}

/*-------------------------------------------------------------------------
   _strncpy.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

#undef strncpy /* Avoid conflict with builtin strncpy() in Z80 and some related ports */

char *strncpy ( char * d, const char * s, size_t n )
{
	register char * d1 =  d;

	while ( n && *s )
	{
		n-- ;
		*d++ = *s++ ;
	}
	while ( n-- )
	{
		*d++ = '\0' ;
	}
	return d1;
}
/*-------------------------------------------------------------------------
   _strcmp.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>
#include <sdcc-lib.h>

#if !_SDCC_PORT_PROVIDES_STRCMP

int strcmp ( const char * asrc, const char * adst )
{
#if _SDCC_Z80_STYLE_LIB_OPT
#pragma noinduction

	char ret = 0;
	const char * src = asrc;
	const char * dst = adst;

	while( ! (*src - *dst) && *dst)
		++src, ++dst;

	return *src - *dst;
#else
	register int ret = 0;

	while( ! (ret = *(unsigned char *)asrc - *(unsigned char *)adst) && *adst)
		++asrc, ++adst;

	return( ret );
#endif
}

#endif
/*-------------------------------------------------------------------------
   mblen.c - determine number of bytes in next multibyte character

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

int mblen(const char *s, size_t n)
{
	unsigned char m = 0;
	unsigned char c;

	if(!s)
		return(0);

	if(!n)
		return(-1);

	c = *s;

	if(!c)
		return(0);

	if(c <= 0x7f)
		return(1);

	while(c & 0x80)
	{
		c <<= 1;
		m++;
	}

	if(m > n)
		return(-1);

	n = m;
	while(--m)
		if((*++s & 0xc0) != 0x80)
			return(-1);

	return(n);
}

/*-------------------------------------------------------------------------
   time.c - stdlib time conversion routines

   Copyright (C) 2001, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>
#include <time.h>

// please note that the tm structure has the years since 1900,
// but time returns the seconds since 1970

/* You need some kind of real time clock for the time() function.
   Either a rtc-chip or some kind of DCF device will do. For TINI, the 
   HAVE_RTC is defined in tinibios.h
   If not, the conversion routines still work.
*/

#ifndef HAVE_RTC
unsigned char RtcRead(struct tm *timeptr) {
  // no real time hardware 
  timeptr; // hush the compiler
  return 0;
}
#endif

// return the calendar time, seconds since the Epoch (Jan 1 1970 00:00:00)
time_t time(time_t *timeptr) {
  struct tm now;
  time_t t=(time_t) -1;

  if (RtcRead(&now)) {
    t=mktime(&now);
  }
  if (timeptr) {
    *timeptr=t;
  }
  return t;
}

static const char monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31};

const const char *const __month[]={"Jan","Feb","Mar","Apr","May","Jun",
                                    "Jul","Aug","Sep","Oct","Nov","Dec"};

const const char *const __day[]={"Sun","Mon","Tue","Wed","Thu","Fri","Sat"};

static char ascTimeBuffer[32];

// validate the tm structure
static void CheckTime(struct tm *timeptr) {
    // we could do some normalization here, e.g.
    // change 40 october to 9 november
    #if !__TIME_UNSIGNED
    if (timeptr->tm_sec<0) timeptr->tm_sec=0;
    if (timeptr->tm_min<0) timeptr->tm_min=0;
    if (timeptr->tm_hour<0) timeptr->tm_hour=0;
    if (timeptr->tm_wday<0) timeptr->tm_wday=0;
    if (timeptr->tm_mon<0) timeptr->tm_mon=0;
    #endif
    
    if (timeptr->tm_sec>59) timeptr->tm_sec=59;
    if (timeptr->tm_min>59) timeptr->tm_min=59;
    if (timeptr->tm_hour>23) timeptr->tm_hour=23;
    if (timeptr->tm_wday>6) timeptr->tm_wday=6;
    if (timeptr->tm_mday<1) timeptr->tm_mday=1;
    else if (timeptr->tm_mday>31) timeptr->tm_mday=31;
    if (timeptr->tm_mon>11) timeptr->tm_mon=11;
    if (timeptr->tm_year<0) timeptr->tm_year=0;
}

// format the time into "Sat Feb 17 17:45:23 2001\n"
char *asctime(struct tm *timeptr) {
  CheckTime(timeptr);
  sprintf (ascTimeBuffer, "%s %s %2d %02d:%02d:%02d %04d\n",
	   __day[timeptr->tm_wday], __month[timeptr->tm_mon], timeptr->tm_mday,
	   timeptr->tm_hour, timeptr->tm_min, timeptr->tm_sec, 
	   timeptr->tm_year+1900);
  return ascTimeBuffer;
}

char *ctime(time_t *timep) {
  return asctime(localtime(timep));
}

static struct tm lastTime;

/* convert calendar time (seconds since 1970) to broken-time
   This only works for dates between 01-01-1970 00:00:00 and 
   19-01-2038 03:14:07

   A leap year is ((((year%4)==0) && ((year%100)!=0)) || ((year%400)==0)) 
   but since we have no fancy years between 1970 and 2038 we can do:
*/

#define LEAP_YEAR(year) ((year%4)==0)

// forget about timezones for now
struct tm *localtime(time_t *timep) {
    return gmtime(timep);
}

struct tm *gmtime(time_t *timep) {
  unsigned long epoch=*timep;
  unsigned int year;
  unsigned char month, monthLength;
  unsigned long days;
  
  lastTime.tm_sec=epoch%60;
  epoch/=60; // now it is minutes
  lastTime.tm_min=epoch%60;
  epoch/=60; // now it is hours
  lastTime.tm_hour=epoch%24;
  epoch/=24; // now it is days
  lastTime.tm_wday=(epoch+4)%7;
  
  year=1970;
  days=0;
  while((days += (LEAP_YEAR(year) ? 366 : 365)) <= epoch) {
    year++;
  }
  lastTime.tm_year=year-1900;
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  epoch -= days; // now it is days in this year, starting at 0
  lastTime.tm_yday=epoch;
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // februari
      if (LEAP_YEAR(year)) {
	monthLength=29;
      } else {
	monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (epoch>=monthLength) {
      epoch-=monthLength;
    } else {
	break;
    }
  }
  lastTime.tm_mon=month;
  lastTime.tm_mday=epoch+1;
  
  lastTime.tm_isdst=0;
  
  return &lastTime;
}

// convert broken time to calendar time (seconds since 1970)
time_t mktime(struct tm *timeptr) {
    int year=timeptr->tm_year+1900, month=timeptr->tm_mon, i;
    long seconds;
    
    CheckTime(timeptr);

    // seconds from 1970 till 1 jan 00:00:00 this year
    seconds= (year-1970)*(60*60*24L*365);

    // add extra days for leap years
    for (i=1970; i<year; i++) {
	if (LEAP_YEAR(i)) {
	    seconds+= 60*60*24L;
	}
    }

    // add days for this year
    for (i=0; i<month; i++) {
      if (i==1 && LEAP_YEAR(year)) { 
	seconds+= 60*60*24L*29;
      } else {
	seconds+= 60*60*24L*monthDays[i];
      }
    }

    seconds+= (timeptr->tm_mday-1)*60*60*24L;
    seconds+= timeptr->tm_hour*60*60L;
    seconds+= timeptr->tm_min*60;
    seconds+= timeptr->tm_sec;
    return seconds;
}
/*-------------------------------------------------------------------------
   _strstr.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char *strstr ( const char *str1, const char *str2 )
{
	const char *cp = str1;
	const char *s1;
	const char *s2;

	if (!*str2)
	    return ((char*)str1);

	while (*cp)
	{
		s1 = cp;
		s2 = str2;

		while (*s1 && *s2 && !(*s1-*s2))
			s1++, s2++;

		if (!*s2)
			return ((char*)cp);

		cp++;
	}

	return (NULL) ;
}
/*-------------------------------------------------------------------------
   _moduint.c - routine for unsigned int (16 bit) modulus

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Bug fixes by Martijn van Balen, aed@iae.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*   Assembler-functions are provided for:
     mcs51 small
     mcs51 small stack-auto
*/

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO)
#        define _MODUINT_ASM_SMALL_AUTO
#      else
#        define _MODUINT_ASM_SMALL
#      endif
#    endif
#  endif
#endif

#if defined _MODUINT_ASM_SMALL || defined _MODUINT_ASM_SMALL_AUTO

static void
_moduint_dummy (void) __naked
{
	__asm

	.globl __moduint

__moduint:

	#define count   r2
	#define al      dpl
	#define ah      dph

#if defined(__SDCC_STACK_AUTO) && !defined(__SDCC_PARMS_IN_BANK1)

	ar0 = 0			; BUG register set is not considered
	ar1 = 1

	.globl __modint

	mov	a,sp
	add	a,#-2		; 2 bytes return address
	mov	r0,a		; r0 points to bh
	mov	ar1,@r0		; load bh
	dec	r0
	mov	ar0,@r0		; load bl

	#define bl      r0
	#define bh      r1

__modint:			; entry point for __modsint


#else // __SDCC_STACK_AUTO

#if !defined(__SDCC_PARMS_IN_BANK1)
#if defined(__SDCC_NOOVERLAY)
	.area DSEG    (DATA)
#else
	.area OSEG    (OVR,DATA)
#endif

	.globl __moduint_PARM_2
	.globl __modsint_PARM_2

__moduint_PARM_2:
__modsint_PARM_2:
	.ds	2

	.area CSEG    (CODE)

	#define bl      (__moduint_PARM_2)
	#define bh      (__moduint_PARM_2 + 1)
#else
	#define bl      (b1_0)
	#define bh      (b1_1)
#endif
#endif // __SDCC_STACK_AUTO

	mov	a,bl		; avoid endless loop
	orl	a,bh
	jz	div_by_0

	mov	count,#1

loop1:	mov	a,bl		; b <<= 1
	add	a,acc
	mov	bl,a
	mov	a,bh
	rlc	a
	jc	msbset
	mov	bh,a

	mov	a,al		; a - b
	subb	a,bl		; here carry is always clear
	mov	a,ah
	subb	a,bh

	jc	start

	inc	count
	sjmp	loop1

start:	clr	c
	mov	a,bh		; b >>= 1;
msbset:	rrc	a
	mov	bh,a
	mov	a,bl
	rrc	a
	mov	bl,a

loop2:	clr	c
	mov	a,al		; a - b
	subb	a,bl

	mov	b,a
	mov	a,ah
	subb	a,bh

	jc	smaller		; a >= b?

	mov	ah,a		; -> yes;  a = a - b;
	mov	al,b
smaller:			; -> no
	clr	c
	mov	a,bh		; b >>= 1;
	rrc	a
	mov	bh,a
	mov	a,bl
	rrc	a
	mov	bl,a

	djnz	count,loop2
div_by_0:
	ret

	__endasm;
}

#else  // defined _MODUINT_ASM_SMALL || defined _MODUINT_ASM_SMALL_AUTO

#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1)

unsigned int
_moduint (unsigned int a, unsigned int b)
{
  unsigned char count = 0;

  while (!MSB_SET(b))
  {
    b <<= 1;
    if (b > a)
    {
      b >>=1;
      break;
    }
    count++;
  }
  do
  {
    if (a >= b)
      a -= b;
    b >>= 1;
  }
  while (count--);
  return a;
}

#endif  // defined _MODUINT_ASM_SMALL || defined _MODUINT_ASM_SMALL_AUTO
/*-------------------------------------------------------------------------
   btowc.c - convert a single-byte character to a wide character

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <wchar.h>

#include <stdio.h>

_Static_assert(EOF & 0x80, "Invalid EOF");

wint_t btowc(int c)
{
	if(c & 0x80)
		return WEOF;
	return c;
}

/*-------------------------------------------------------------------------
   atof.c - converts an ASCII string to float

   Copyright (C) 2003, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>
#include <stdlib.h>
#include <stdbool.h>

float atof(const char * s)
{
    float value, fraction;
    signed char iexp;
    bool sign;

    //Skip leading blanks
    while (isspace(*s)) s++;

    //Get the sign
    if (*s == '-')
    {
        sign=1;
        s++;
    }
    else
    {
        sign=0;
        if (*s == '+') s++;
    }

    //Get the integer part
    for (value=0.0; isdigit(*s); s++)
    {
        value=10.0*value+(*s-'0');
    }

    //Get the fraction
    if (*s == '.')
    {
        s++;
        for (fraction=0.1; isdigit(*s); s++)
        {
            value+=(*s-'0')*fraction;
            fraction*=0.1;
        }
    }

    //Finally, the exponent (not very efficient, but enough for now*/
    if (toupper(*s)=='E')
    {
        s++;
        iexp=(signed char)atoi(s);
        {
            while(iexp!=0)
            {
                if(iexp<0)
                {
                    value*=0.1;
                    iexp++;
                }
                else
                {
                    value*=10.0;
                    iexp--;
                }
            }
        }
    }

    if(sign) value*=-1.0;
    return (value);
}

/*-------------------------------------------------------------------------
   ser_ir_cts_rts.c - source file for serial routines

   Copyright (C) 1999, Josef Wolf <jw AT raven.inka.de>

   Revisions:
   1.0  Bela Torok <bela.torok.kssg.ch> Jul. 2000
   RTS / CTS protocol added

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* This file implements a serial interrupt handler and its supporting
* routines. Compared with the existing serial.c and _ser.c it has
* following advantages:
* - You can specify arbitrary buffer sizes (umm, up to 255 bytes),
*   so it can run on devices with _little_ memory like at89cx051.
* - It won't overwrite characters which already are stored in the
*   receive-/transmit-buffer.
*/

/* BUG: those definitions (and the #include) should be set dynamically
* (while linking or at runtime) to make this file a _real_ library.
*/

/* RTS/CTS protocol howto:


   Shematic of cable for RTS/CTS protocol (B. Torok - Jun. 2000)

<- DB9 female connector -><- RS232 driver/receiver -><- 8051 system ->
   connect to PC             e.g. MAX232

                             RS232         TTL
                             level         level

   DCD    DTR                
   Pin1---Pin4               
                            Transmitters/Receivers
   RXD
   Pin2-----------------------------<<<-------------------TXD

   TXD
   Pin3----------------------------->>>-------------------RXD

   GND
   Pin5---------------------------------------------------GND

   DSR    CTS
   Pin6---Pin8----------------------<<<-------------------CTS (see #define CTS)

   RTS
   Pin7----------------------------->>>-------------------RTS (see #define RTS)
*/


#include <8051.h>
#include "ser_ir.h"

#define TXBUFLEN 3
#define RXBUFLEN 18      // The minimum rx buffer size for safe communications
                         // is 17. (The UART in the PC has a 16-byte FIFO.)
// TXBUFLEN & RXBUFLEN can be highher if rxbuf[] and txbuf[] is in xdata, max size is limited to 256!

#define THRESHOLD 16
#define ENABLE    0
#define DISABLE   1

#define CTS P3_6          // CTS & RTS can be assigned to any free pins
#define RTS P3_7

// You might want to specify idata, pdata or xdata for the buffers
static unsigned char rxbuf[RXBUFLEN], txbuf[TXBUFLEN];
static unsigned char rxcnt, txcnt, rxpos, txpos;
static bit busy;

void
ser_init ()
{
  ES = 0;
  rxcnt = txcnt = rxpos = txpos = 0;  // init buffers
  busy = 0;
  SCON = 0x50;               // mode 1 - 8-bit UART
  PCON |= 0x80;              // SMOD = 1;
  TMOD &= 0x0f;              // use timer 1
  TMOD |= 0x20;
//  TL1 = TH1 = 256 - 104;      // 600bps with 12 MHz crystal
//  TL1 = TH1 = 256 - 52;      // 1200bps with 12 MHz crystal
//  TL1 = TH1 = 256 - 26;      // 2400bps with 12 MHz crystal
  TL1 = TH1 = 256 - 13;      // 4800bps with 12 MHz crystal

  TR1 = 1;                   // Enable timer 1
  ES = 1;

  CTS = ENABLE;
}

void
ser_handler (void) interrupt 4
{
  if (RI) {
    RI = 0;
    /* don't overwrite chars already in buffer */
    if(rxcnt < RXBUFLEN) rxbuf [(unsigned char)(rxpos + rxcnt++) % RXBUFLEN] = SBUF;
    if(rxcnt >= (RXBUFLEN - THRESHOLD)) CTS = DISABLE;
  }

  if (TI) {
    TI = 0;
    if (busy = txcnt) {   /* Assignment, _not_ comparison! */
      txcnt--;
      SBUF = txbuf[txpos++];
      if(txpos >= TXBUFLEN) txpos = 0;
    }
  }
}

void
ser_putc (unsigned char c)
{
  while(txcnt >= TXBUFLEN);   // wait for room in buffer

  while(RTS == DISABLE);

  ES = 0;
  if (busy) {
    txbuf[(unsigned char)(txpos + txcnt++) % TXBUFLEN] = c;
  } else {
    SBUF = c;
    busy = 1;
  }
  ES = 1;
}

unsigned char
ser_getc (void)
{
  unsigned char c;

  while (!rxcnt) {        // wait for a character
    CTS = ENABLE;
  }

  ES = 0;
  rxcnt--;
  c = rxbuf[rxpos++];
  if (rxpos >= RXBUFLEN) rxpos = 0;
  ES = 1;
  return (c);
}

#pragma save
#pragma noinduction
void
ser_puts (unsigned char *s)
{
  unsigned char c;
  while (c= *s++) {
    if (c == '\n') ser_putc('\r');
    ser_putc (c);
  }
}
#pragma restore

void
ser_gets (unsigned char *s, unsigned char len)
{
  unsigned char pos, c;

  pos = 0;
  while (pos <= len) {
    c = ser_getc();
    if (c == '\r') continue;        // discard CR's
    s[pos++] = c;
    if (c == '\n') break;           // NL terminates
  }
  s[pos] = '\0';                  // terminate string
}

unsigned char
ser_can_xmt (void)
{
  return TXBUFLEN - txcnt;
}

unsigned char
ser_can_rcv (void)
{
  return rxcnt;
}
/*-------------------------------------------------------------------------
   frexpf.c - Returns the exponent and mantisa of a 32 bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>

float frexpf(float x, int *pw2)
{
    union float_long fl;
    long int i;

    fl.f=x;
    /* Find the exponent (power of 2) */
    i  = ( fl.l >> 23) & 0x000000ff;
    i -= 0x7e;
    *pw2 = i;
    fl.l &= 0x807fffff; /* strip all exponent bits */
    fl.l |= 0x3f000000; /* mantissa between 0.5 and 1 */
    return(fl.f);
}
/*-------------------------------------------------------------------------
   _fsreturnval.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/



#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

static void dummy(void) __naked
{
	__asm

	.globl	fs_round_and_return
fs_round_and_return:
#ifdef FLOAT_FULL_ACCURACY
	// discard the extra 8 bits of precision we kept around in r1
	cjne	r1, #128, 00001$
	mov	a, r2
	rrc	a
	cpl	c
00001$:
	jc	fs_zerocheck_return
	mov	a, r2
	add	a, #1
	mov	r2, a
	clr	a
	addc	a, r3
	mov	r3, a
	clr	a
	addc	a, r4
	mov	r4, a
	jnc	fs_zerocheck_return
	mov	r4, #0x80
	inc	exp_a
#endif

	.globl	fs_zerocheck_return
fs_zerocheck_return:
	// zero output is a special case
	cjne	r4, #0, fs_direct_return
	cjne	r3, #0, fs_direct_return
	cjne	r2, #0, fs_direct_return

	.globl	fs_return_zero
fs_return_zero:
	clr	a
	mov	b, a
	mov	dph, a
	mov	dpl, a
	ret

	.globl	fs_direct_return
fs_direct_return:
	// collect all pieces and return
	mov	c, sign_a
	mov	a, exp_a
	rrc	a
	mov	b, r4
	mov	b.7, c
	mov	dph, r3
	mov	dpl, r2
	ret

	.globl	fs_return_inf
fs_return_inf:
	clr	a
	mov	dph, a
	mov	dpl, a
	mov	b, #0x80
	cpl	a
	mov	c, sign_a
	rrc	a
	ret

	.globl	fs_return_nan
fs_return_nan:
	clr	a
	mov	dph, a
	mov	dpl, a
	mov	b, #0xC0
	mov	a, #0x7F
	ret

	__endasm;
}

#endif
/*-------------------------------------------------------------------------
   _rlslonglong.c - routine for left shift of 64 bit long long

   Copyright (C) 2012, Philipp Klaus Krause . philipp@informatik.uni-frankfurt.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#pragma std_c99

#include <stdint.h>

#ifdef __SDCC_LONGLONG

long long _rlslonglong(long long l, char s)
{
	return((unsigned long long)(l) << s);
}

#endif

/*-------------------------------------------------------------------------
   gets.c

   Copyright (C) 2000, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

char *
gets (char *s)
{
  char c;
  unsigned int count = 0;

  while (1)
    {
      c = getchar ();
      switch(c)
        {
        case '\b': /* backspace */
          if (count)
            {
              putchar ('\b');
              putchar (' ');
	      putchar ('\b');
	      --s;
	      --count;
            }
          break;

        case '\n':
        case '\r': /* CR or LF */
          putchar ('\r');
          putchar ('\n');
          *s = 0;
          return s;

        default:
          *s++ = c;
          ++count;
          putchar (c);
          break;
        }
    }
}
/*-------------------------------------------------------------------------
   _modsint.c - routine for signed int (16 bit) modulus

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#include <sdcc-lib.h>

#if _SDCC_MANGLES_SUPPORT_FUNS
unsigned unsigned _moduint (unsigned a, unsigned b);
#endif

/*   Assembler-functions are provided for:
     mcs51 small
     mcs51 small stack-auto
*/

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO) && !defined(__SDCC_PARMS_IN_BANK1)
#        define _MODSINT_ASM_SMALL_AUTO
#      else
#        define _MODSINT_ASM_SMALL
#      endif
#    endif
#  endif
#endif

#if defined _MODSINT_ASM_SMALL

static void
_modsint_dummy (void) __naked
{
	__asm

	#define a0	dpl
	#define a1	dph

	.globl __modsint
#if defined(__SDCC_PARMS_IN_BANK1)
	#define b0      (b1_0)
	#define b1      (b1_1)
#else
	// _modsint_PARM_2 shares the same memory with _moduint_PARM_2
	// and is defined in _moduint.c
	#define b0      (__modsint_PARM_2)
	#define b1      (__modsint_PARM_2 + 1)
#endif
__modsint:
				; a1 in dph
				; b1 in (__modsint_PARM_2 + 1)

	clr	F0 		; Flag 0 in PSW
				; available to user for general purpose
	mov	a,a1
	jnb	acc.7,a_not_negative

	setb	F0

	clr	a
	clr	c
	subb	a,a0
	mov	a0,a
	clr	a
	subb	a,a1
	mov	a1,a

a_not_negative:

	mov	a,b1
	jnb	acc.7,b_not_negative

	clr	a
	clr	c
	subb	a,b0
	mov	b0,a
	clr	a
	subb	a,b1
	mov	b1,a

b_not_negative:

	lcall	__moduint

	jnb	F0,not_negative

	clr	a
	clr	c
	subb	a,a0
	mov	a0,a
	clr	a
	subb	a,a1
	mov	a1,a

not_negative:
	ret

	__endasm;
}

#elif defined _MODSINT_ASM_SMALL_AUTO

static void
_modsint_dummy (void) __naked
{
	__asm

	#define a0	dpl
	#define a1	dph

	ar0 = 0			; BUG register set is not considered
	ar1 = 1

	.globl __modsint

__modsint:

	clr	F0 		; Flag 0 in PSW
				; available to user for general purpose
	mov	a,a1
	jnb	acc.7,a_not_negative

	setb	F0

	clr	a
	clr	c
	subb	a,a0
	mov	a0,a
	clr	a
	subb	a,a1
	mov	a1,a

a_not_negative:

	mov	a,sp
	add	a,#-2		; 2 bytes return address
	mov	r0,a		; r0 points to b1
	mov	a,@r0		; b1

	jnb	acc.7,b_not_negative

	dec	r0

	clr	a
	clr	c
	subb	a,@r0		; b0
	mov	@r0,a
	clr	a
	inc	r0
	subb	a,@r0		; b1
	mov	@r0,a

b_not_negative:

	mov	ar1,@r0		; b1
	dec	r0
	mov	ar0,@r0		; b0

	lcall	__modint

	jnb	F0,not_negative

	clr	a
	clr	c
	subb	a,a0
	mov	a0,a
	clr	a
	subb	a,a1
	mov	a1,a

not_negative:
	ret

	__endasm;
}

#else  // _MODSINT_ASM_

int _modsint (int a, int b)
{
  register int r;

  r = (unsigned)(a < 0 ? -a : a) % (unsigned)(b < 0 ? -b : b);

  if (a < 0)
    return -r;
  else
    return r;
}

#endif  // _MODSINT_ASM_
/*-------------------------------------------------------------------------
   atan2f.c - Computes atan2(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>

float atan2f(float x, float y)
{
    float r;

    if ((x==0.0) && (y==0.0))
    {
        errno=EDOM;
        return 0.0;
    }

    if(fabsf(y)>=fabsf(x))
    {
        r=atanf(x/y);
        if(y<0.0) r+=(x>=0?PI:-PI);
    }
    else
    {
        r=-atanf(y/x);
        r+=(x<0.0?-HALF_PI:HALF_PI);
    }
    return r;
}
/*-------------------------------------------------------------------------
   _fseq.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// char __fseq (float a, float b)
static void dummy(void) __naked
{
	__asm
	.globl	___fseq
___fseq:
	mov	r7, a
	mov	r0, sp
	dec	r0
	dec	r0
	lcall	fs_check_negative_zeros
	lcall	fs_compare_uint32
	mov	a, r1
	xrl	a, #1
	mov	dpl, a
	ret
	__endasm;
}

#else

/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

union float_long
  {
    float f;
    long l;
  };

/* compare two floats */
char
__fseq (float a1, float a2)
{
  volatile union float_long fl1, fl2;

  fl1.f = a1;
  fl2.f = a2;

  if (fl1.l == fl2.l)
    return (1);
  //if (((fl1.l | fl2.l) & 0x7FFFFFFF) == 0) // Slightly faster, but needs an additional temporary (4B of RAM)
  if ((fl1.l & 0x7fffffff) == 0 && (fl2.l & 0x7fffffff) == 0)
    return (1);
  return (0);
}

#endif
/*-------------------------------------------------------------------------
   _fsadd.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>
#include <stdbool.h>
#include <sdcc-lib.h>

#ifdef FLOAT_ASM_MCS51

// float __fsadd (float a, float b) __reentrant
static void dummy(void) __naked
{
	__asm

	// extract the two inputs, placing them into:
	//      sign     exponent   mantissa
	//      ----     --------   --------
	//  a:  sign_a   exp_a      r4/r3/r2
	//  b:  sign_b   exp_b      r7/r6/r5
	//
	// r1: used to extend precision of a's mantissa
	// r0: general purpose loop counter

	.globl	___fsadd
___fsadd:
	lcall	fsgetargs

	.globl	fsadd_direct_entry
fsadd_direct_entry:
	// we're going to extend mantissa to 32 bits temporarily
	mov	r1, #0

	// which exponent is greater?
	mov	a, exp_b
	cjne	a, exp_a, 00005$
	sjmp	00011$
00005$:	jnc	00010$

	// a's exponent was greater, so shift b's mantissa
	lcall	fs_swap_a_b

00010$:
	// b's exponent was greater, so shift a's mantissa
	mov	a, exp_b
	clr	c
	subb	a, exp_a
	lcall	fs_rshift_a	// acc has # of shifts to do

00011$:
	// decide if we need to add or subtract
	// sign_a and sign_b are stored in the flag bits of psw,
	// so this little trick checks if the arguements have the
	// same sign.
	mov	a, psw
	swap	a
	xrl	a, psw
	jb	acc.1, 00022$

00020$:
	// add the mantissas (both positive or both negative)
	mov	a, r2
	add	a, r5
	mov	r2, a
	mov	a, r3
	addc	a, r6
	mov	r3, a
	mov	a, r4
	addc	a, r7
	mov	r4, a
	// check for overflow past 24 bits
	jnc	00021$
	mov	a, #1
	lcall	fs_rshift_a
	mov	a, r4
	orl	a, #0x80
	mov	r4, a
00021$:
	ljmp	fs_round_and_return



00022$:
	// subtract the mantissas (one of them is negative)
	clr	c
	mov	a, r2
	subb	a, r5
	mov	r2, a
	mov	a, r3
	subb	a, r6
	mov	r3, a
	mov	a, r4
	subb	a, r7
	mov	r4, a
	jnc	00025$
	// if we get a negative result, turn it positive and
	// flip the sign bit
	clr	c
	clr	a
	subb	a, r1
	mov	r1, a
	clr	a
	subb	a, r2
	mov	r2, a
	clr	a
	subb	a, r3
	mov	r3, a
	clr	a
	subb	a, r4
	mov	r4, a
	cpl	sign_a
00025$:
	lcall	fs_normalize_a
	ljmp	fs_round_and_return

	__endasm;
}

#else

/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

union float_long
  {
    float f;
    unsigned long l;
  };

/* add two floats */
float __fsadd (float a1, float a2)
{
  long mant1, mant2;
  long _AUTOMEM *pfl1;
  long _AUTOMEM *pfl2;
  int exp1, exp2, expd;
  bool sign = false;

  pfl2 = (long _AUTOMEM *)&a2;
  exp2 = EXP (*pfl2);
  mant2 = MANT (*pfl2) << 4;
  if (SIGN (*pfl2))
    mant2 = -mant2;
  /* check for zero args */
  if (!*pfl2)
    return (a1);

  pfl1 = (long _AUTOMEM *)&a1;
  exp1 = EXP (*pfl1);
  mant1 = MANT (*pfl1) << 4;
  if (SIGN(*pfl1))
  if (*pfl1 & 0x80000000)
    mant1 = -mant1;
  /* check for zero args */
  if (!*pfl1)
    return (a2);

  expd = exp1 - exp2;
  if (expd > 25)
    return (a1);
  if (expd < -25)
    return (a2);

  if (expd < 0)
    {
      expd = -expd;
      exp1 += expd;
      mant1 >>= expd;
    }
  else
    {
      mant2 >>= expd;
    }
  mant1 += mant2;

  sign = false;

  if (mant1 < 0)
    {
      mant1 = -mant1;
      sign = true;
    }
  else if (!mant1)
    return (0);

  /* normalize */
  while (mant1 < (HIDDEN<<4)) {
    mant1 <<= 1;
    exp1--;
  }

  /* round off */
  while (mant1 & 0xf0000000) {
    if (mant1&1)
      mant1 += 2;
    mant1 >>= 1;
    exp1++;
  }

  /* turn off hidden bit */
  mant1 &= ~(HIDDEN<<4);

  /* pack up and go home */
  if (exp1 >= 0x100)
    *pfl1 = (sign ? (SIGNBIT | __INFINITY) : __INFINITY);
  else if (exp1 < 0)
    *pfl1 = 0;
  else
    *pfl1 = PACK (sign ? SIGNBIT : 0 , exp1, mant1>>4);
  return (a1);
}

#endif
/*-------------------------------------------------------------------------
   _strlen.c - part of string library functions
 
   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   mcs51 assembler by Frieder Ferlemann (2007)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

#if (!defined (__SDCC_mcs51))

  /* Generic routine first */
  size_t strlen ( const char * str )
  {
    register int i = 0 ;

    while (*str++)
      i++ ;

    return i;
  }

#else

#if defined(__SDCC)
 #include <sdcc-lib.h>
#endif

  /* Assembler version for mcs51 */
  size_t strlen ( const char * str ) __naked
  {
    str;     /* hush the compiler */

    __asm
      ; dptr holds pointer
      ; b holds pointer memspace
      ;

      ; char *ptr = str:
      mov     r2,dpl
      mov     r3,dph
      ;

      ; while ( *ptr ) ptr++;
    L00101$:
      lcall   __gptrget
      jz      L00102$
      inc     dptr
      sjmp    L00101$
      ;

    L00102$:
      ; return ptr - str;
      clr     c
      mov     a,dpl
      subb    a,r2
      mov     dpl,a
      ;
      mov     a,dph
      subb    a,r3
      mov     dph,a
      ;
      _RETURN
    __endasm;
  }

#endif
/*-------------------------------------------------------------------------
   _logexpf.c

   Copyright (C) 2005, Paul Stoffregen

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#define __SDCC_MATH_LIB
#include <math.h>


#ifdef MATH_ASM_MCS51

// This code is shared by both logf() and expf(), so it goes in this
// separate file to allow the linker to include it when either
// function is needed, but only 1 copy when both are used.

void _fs_cordic_rshift_r765_unsigned(void) __naked
{
	__asm
	ar2 = 0x02
	ar3 = 0x03
	ar4 = 0x04
	ar5 = 0x05
	ar6 = 0x06
	ar7 = 0x07
	ar0 = 0x00
	ar1 = 0x01

	add	a, #248
	jnc	00003$
	mov	b, r5
	mov	r5, ar6
	mov	r6, ar7
	mov	r7, #0
	add	a, #248
	jnc	00003$
	mov	b, r5
	mov	r5, ar6
	mov	r6, #0
	add	a, #248
	jnc	00003$
	mov	b, r5
	mov	r5, #0
	add	a, #248
	jnc	00003$
	mov	b, #0
	ret
00003$:
	add	a, #8
	jz	00030$
	push	ar0
	mov	r0, a
00010$:
	clr	c
	mov	a, r7
	rrc	a
	mov	r7, a
	mov	a, r6
	rrc	a
	mov	r6, a
	mov	a, r5
	rrc	a
	mov	r5, a
	mov	a, b
	rrc	a
	mov	b, a
	djnz	r0, 00010$
	pop	ar0
00030$:
	ret
	__endasm;
}

__code unsigned char _fs_natural_log_table[] = {
0xFF, 0x42, 0x2E, 0x16,         // 0.693147180560
0xF6, 0x91, 0xF9, 0x0C,         // 0.405465108108
0xF2, 0xFD, 0x23, 0x07,         // 0.223143551314
0xEE, 0xE0, 0xC4, 0x03,         // 0.117783035656
0x0C, 0xA3, 0xF0, 0x01,         // 0.060624621816
0xD8, 0x14, 0xFC, 0x00,         // 0.030771658667
0xA3, 0x02, 0x7F, 0x00,         // 0.015504186536
0x55, 0xC0, 0x3F, 0x00,         // 0.007782140442
0x0B, 0xF0, 0x1F, 0x00,         // 0.003898640416
0x01, 0xFC, 0x0F, 0x00,         // 0.001951220131
0x00, 0xFF, 0x07, 0x00,         // 0.000976085973
0xC0, 0xFF, 0x03, 0x00,         // 0.000488162080
0xF0, 0xFF, 0x01, 0x00,         // 0.000244110828
0xFC, 0xFF, 0x00, 0x00,         // 0.000122062863
0xFF, 0x7F, 0x00, 0x00,         // 0.000061033294
0x00, 0x40, 0x00, 0x00,         // 0.000030517112
0x00, 0x20, 0x00, 0x00,         // 0.000015258673
0x00, 0x10, 0x00, 0x00,         // 0.000007629365
0x00, 0x08, 0x00, 0x00,         // 0.000003814690
0x00, 0x04, 0x00, 0x00,         // 0.000001907347
0x00, 0x02, 0x00, 0x00,         // 0.000000953674
0x00, 0x01, 0x00, 0x00,         // 0.000000476837
0x80, 0x00, 0x00, 0x00,         // 0.000000238419
0x40, 0x00, 0x00, 0x00,         // 0.000000119209
0x20, 0x00, 0x00, 0x00,         // 0.000000059605
0x10, 0x00, 0x00, 0x00,         // 0.000000029802
0x08, 0x00, 0x00, 0x00,         // 0.000000014901
0x04, 0x00, 0x00, 0x00,         // 0.000000007451
0x02, 0x00, 0x00, 0x00,         // 0.000000003725
0x01, 0x00, 0x00, 0x00          // 0.000000001863
};

#endif
/*-------------------------------------------------------------------------
   _fsmul.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// float __fsmul (float a, float b) __reentrant
static void dummy(void) __naked
{
	__asm
	.globl	___fsmul
___fsmul:
	// extract the two inputs, placing them into:
	//      sign     exponent   mantissa
	//      ----     --------   --------
	//  a:  sign_a   exp_a      r4/r3/r2
	//  b:  sign_b   exp_b      r7/r6/r5

	lcall	fsgetargs

	// first check if either input is zero
	cjne	r4, #0, 00002$
00001$:
	ljmp	fs_return_zero

00002$:
	mov	a, r7
	jz	00001$

	// compute final sign bit
	jnb	sign_b, 00003$
	cpl	sign_a
00003$:

	// check if either input is infinity
	mov	a, exp_b
	cjne	a, #0xFF, 00004$
	ljmp	fs_return_inf
00004$:
	mov	a, exp_a
	cjne	a, #0xFF, 00005$
	ljmp	fs_return_inf
00005$:

	// add the exponents
	add	a, exp_b
	// if carry then no underflow
	jc	00006$
	add	a, #130
	jc	00007$
	ljmp	fs_return_zero

00006$:
	add	a, #131
	dec	a
	jnc	00007$
	ljmp	fs_return_inf

00007$:
	mov	exp_a, a

	// now we need to multipy r4/r3/r2 * r7/r6/r5
	// ------------------------------------------
	//	                        r2 * r5		<< 0
	//	            r3 * r5  +  r2 * r6		<< 8
	//	r4 * r5  +  r3 * r6  +  r2 * r7		<< 16
	//	r4 * r6  +  r3 * r7			<< 24
	//	r4 * r7					<< 32
	//
	// This adds quite a bit of code, but it is a LOT faster
	// than three calls to __mululong...

	// output goes into r4/r3/r2/r1/r0/xx

	mov	a, r2
	mov	b, r5
	mul	ab			// r2 * r5
	// discard lowest 8 bits
	mov	r0, b
	// range 0-FE

	mov	a, r2
	mov	b, r6
	mul	ab			// r2 * r6
	add	a, r0
	mov	r0, a
	clr	a
	addc	a, b
	mov	r1, a
	// range 0-FEFF

	mov	a, r3
	mov	b, r5
	mul	ab			// r3 * r5
	add	a, r0
	// discard lowest 8 bits
	mov	a, r1
	addc	a, b
	mov	r1, a
	clr	a
	rlc	a
	xch	a, r2
	// range 0-1FD

	mov	b, r7
	mul	ab			// r2 * r7
	add	a, r1
	mov	r1, a
	mov	a, r2
	addc	a, b
	mov	r2, a
	// range 0-FFFE

	mov	a, r3
	mov	r0, a
	mov	b, r6
	mul	ab			// r3 * r6
	add	a, r1
	mov	r1, a
	mov	a, r2
	addc	a, b
	mov	r2, a
	clr	a
	rlc	a
	mov	r3, a
	// range 0-1FDFF

	mov	a, r4
	mov	b, r5
	mul	ab			// r4 * r5
	add	a, r1
	mov	r1, a
	mov	a, r2
	addc	a, b
	mov	r2, a
	clr	a
	addc	a, r3
	mov	r3, a
	// range 0-2FC00

	mov	a, r0 // r3
	mov	b, r7
	mul	ab			// r3 * r7
	add	a, r2
	mov	r2, a
	mov	a, r3
	addc	a, b
	mov	r3, a
	clr	a
	rlc	a
	xch	a, r4
	// range 0-100FD00

	mov	r5, a
	mov	b, r6
	mul	ab			// r4 * r6
	add	a, r2
	mov	r2, a
	mov	a, r3
	addc	a, b
	mov	r3, a
	clr	a
	addc	a, r4
	mov	r4, a
	// range 0-1FEFE00

	mov	a, r5 // r4
	mov	b, r7
	mul	ab			// r4 * r7
	add	a, r3
	mov	r3, a
	mov	a, r4
	addc	a, b
	mov	r4, a
	// range 40000000-FFFFFE00

	jb	acc.7, 00010$
	lcall	fs_normalize_a

00010$:
	ljmp	fs_round_and_return
	__endasm;
}

#else

/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

union float_long
  {
    float f;
    unsigned long l;
  };

/* multiply two floats */
float __fsmul (float a1, float a2) {
  volatile union float_long fl1, fl2;
  volatile unsigned long result;
  int exp;
  char sign;

  fl1.f = a1;
  fl2.f = a2;

  if (!fl1.l || !fl2.l)
    return (0);

  /* compute sign and exponent */
  sign = SIGN (fl1.l) ^ SIGN (fl2.l);
  exp = EXP (fl1.l) - EXCESS;
  exp += EXP (fl2.l);

  fl1.l = MANT (fl1.l);
  fl2.l = MANT (fl2.l);

  /* the multiply is done as one 16x16 multiply and two 16x8 multiplies */
  result = (unsigned long)((unsigned short)(fl1.l >> 8)) * (unsigned short)(fl2.l >> 8);
  result += ((unsigned long)((unsigned short)(fl1.l & 0xff)) * (unsigned short)(fl2.l >> 8)) >> 8;
  result += ((unsigned long)((unsigned short)(fl2.l & 0xff)) * (unsigned short)(fl1.l >> 8)) >> 8;

  /* round, phase 1 */
  result += 0x40;

  if (result & SIGNBIT)
    {
      /* round, phase 2 */
      result += 0x40;
      result >>= 8;
    }
  else
    {
      result >>= 7;
      exp--;
    }

  result &= ~HIDDEN;

  /* pack up and go home */
  if (exp >= 0x100)
    fl1.l = (sign ? SIGNBIT : 0) | __INFINITY;
  else if (exp < 0)
    fl1.l = 0;
  else
    fl1.l = PACK (sign ? SIGNBIT : 0 , exp, result);
  return (fl1.f);
}

#endif
/*-------------------------------------------------------------------------
   ceilf.c - Returns the integer larger or equal than x

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>

float ceilf(float x) _FLOAT_FUNC_REENTRANT
{
    long r;
    r=x;
    if (r<0)
        return r;
    else
        return (r+((r<x)?1:0));
}
/*-------------------------------------------------------------------------
   _strcat.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char * strcat ( char * dst, const char * src )
{
        char * cp = dst;

        while( *cp )
                cp++;                   /* find end of dst */

        while( *cp++ = *src++ ) ;       /* Copy src to end of dst */

        return( dst );                  /* return dst */
}
/*-------------------------------------------------------------------------
   _fsget2args.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/



#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

static void dummy(void) __naked
{
	// arg1: passed in a,b,dph,dpl
	// arg2: passed on stack
	__asm
	.globl	fsgetargs
fsgetargs:
	// extract the two inputs, placing them into:
	//      sign     exponent   mantissa
	//      ----     --------   --------
	//  a:  sign_a   exp_a      r4/r3/r2
	//  b:  sign_b   exp_b      r7/r6/r5
	//
	mov	r2, dpl
	mov	r3, dph
	mov	c, b.7
	rlc	a
	mov	sign_a, c
	mov	exp_a, a
	jz	00001$
	setb	b.7
00001$:
	mov	r4, b
	// now extract the 2nd parameter from the stack
	mov	a, sp
	add	a, #249
	mov	r0, a
	mov	a, @r0
	mov	r5, a
	inc	r0
	mov	a, @r0
	mov	r6, a
	inc	r0
	mov	b, @r0
	inc	r0
	mov	a, @r0
	mov	c, b.7
	rlc	a
	mov	sign_b, c
	mov	exp_b, a
	jz	00002$
	setb	b.7
00002$:
	mov	r7, b
	ret
	__endasm;
}

#endif
/*-------------------------------------------------------------------------
   _divslong.c - routine for division of 32 bit long

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#include <sdcc-lib.h>

#if _SDCC_MANGLES_SUPPORT_FUNS
unsigned long _divulong (unsigned long x, unsigned long y);
#endif

/*   Assembler-functions are provided for:
     mcs51 small
     mcs51 small stack-auto
*/

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO) && !defined(__SDCC_PARMS_IN_BANK1)
#        define _DIVSLONG_ASM_SMALL_AUTO
#      else
#        define _DIVSLONG_ASM_SMALL
#      endif
#    endif
#  endif
#endif

#if defined _DIVSLONG_ASM_SMALL

static void
_divslong_dummy (void) __naked
{
	__asm

	#define x0	dpl
	#define x1	dph
	#define x2	b
	#define x3	r3

	.globl __divslong

	// _divslong_PARM_2 shares the same memory with _divulong_PARM_2
	// and is defined in _divulong.c
#if defined(__SDCC_PARMS_IN_BANK1)
	#define y0      (b1_0)
	#define y1      (b1_1)
	#define y2      (b1_2)
	#define y3      (b1_3)
#else
	#define y0      (__divslong_PARM_2)
	#define y1      (__divslong_PARM_2 + 1)
	#define y2      (__divslong_PARM_2 + 2)
	#define y3      (__divslong_PARM_2 + 3)
#endif
__divslong:
				; x3 in acc
				; y3 in (__divslong_PARM_2 + 3)
	mov	x3,a		; save x3

	clr	F0 		; Flag 0 in PSW
				; available to user for general purpose
	jnb	acc.7,a_not_negative

	setb	F0

	clr	a
	clr	c
	subb	a,x0
	mov	x0,a
	clr	a
	subb	a,x1
	mov	x1,a
	clr	a
	subb	a,x2
	mov	x2,a
	clr	a
	subb	a,x3
	mov	x3,a

a_not_negative:

	mov	a,y3
	jnb	acc.7,b_not_negative

	cpl	F0

	clr	a
	clr	c
	subb	a,y0
	mov	y0,a
	clr	a
	subb	a,y1
	mov	y1,a
	clr	a
	subb	a,y2
	mov	y2,a
	clr	a
	subb	a,y3
	mov	y3,a

b_not_negative:

	mov	a,x3		; restore x3 in acc

	lcall	__divulong

	jnb	F0,not_negative

	mov	x3,a		; save x3

	clr	a
	clr	c
	subb	a,x0
	mov	x0,a
	clr	a
	subb	a,x1
	mov	x1,a
	clr	a
	subb	a,x2
	mov	x2,a
	clr	a
	subb	a,x3	; x3 ends in acc

not_negative:
	ret

	__endasm;
}

#elif defined _DIVSLONG_ASM_SMALL_AUTO

static void
_divslong_dummy (void) __naked
{
	__asm

	#define x0	dpl
	#define x1	dph
	#define x2	b
	#define x3	r3

	.globl __divslong

__divslong:

				; x3 in acc
	mov	x3,a		; save x3

	clr	F0 		; Flag 0 in PSW
				; available to user for general purpose
	jnb	acc.7,a_not_negative

	setb	F0

	clr	a
	clr	c
	subb	a,x0
	mov	x0,a
	clr	a
	subb	a,x1
	mov	x1,a
	clr	a
	subb	a,x2
	mov	x2,a
	clr	a
	subb	a,x3
	mov	x3,a

a_not_negative:

	mov	a,sp
	add	a,#-2		; 2 bytes return address
	mov	r0,a		; r0 points to y3
	mov	a,@r0		; y3

	jnb	acc.7,b_not_negative

	cpl	F0

	dec	r0
	dec	r0
	dec	r0

	clr	a
	clr	c
	subb	a,@r0		; y0
	mov	@r0,a
	clr	a
	inc	r0
	subb	a,@r0		; y1
	mov	@r0,a
	clr	a
	inc	r0
	subb	a,@r0		; y2
	mov	@r0,a
	clr	a
	inc	r0
	subb	a,@r0		; y3
	mov	@r0,a

b_not_negative:
	dec	r0
	dec	r0
	dec	r0		; r0 points to y0

	lcall	__divlong

	jnb	F0,not_negative

	mov	x3,a		; save x3

	clr	a
	clr	c
	subb	a,x0
	mov	x0,a
	clr	a
	subb	a,x1
	mov	x1,a
	clr	a
	subb	a,x2
	mov	x2,a
	clr	a
	subb	a,x3		; x3 ends in acc

not_negative:
	ret

	__endasm;
}

#else // _DIVSLONG_ASM

long
_divslong (long x, long y)
{
  long r;

  r = (unsigned long)(x < 0 ? -x : x) / (unsigned long)(y < 0 ? -y : y);
  if ((x < 0) ^ (y < 0))
    return -r;
  else
    return r;
}

#endif // _DIVSLONG_ASM
/*-------------------------------------------------------------------------
   modff.c - Returns both the integer and fraction of a float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>

float modff(float x, float * y)
{
    *y=(long)x;
    return (x-*y);
}
/*-------------------------------------------------------------------------
   tancotf.c - Computes tan or cot of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>
#include <stdbool.h>

#define P0  0.100000000E+1
#define P1 -0.958017723E-1
#define Q0  0.100000000E+1
#define Q1 -0.429135777E+0
#define Q2  0.971685835E-2

#define C1  1.5703125
#define C2  4.83826794897E-4

#define P(f,g) (P1*g*f+f)
#define Q(g) ((Q2*g+Q1)*g+Q0)

//A reasonable choice for YMAX is the integer part of B**(t/2)*PI/2:
#define YMAX 6433.0

float tancotf(float x, bool iscotan)
{
    float f, g, xn, xnum, xden;
    int n;

    if (fabsf(x) > YMAX)
    {
        errno = ERANGE;
        return 0.0;
    }

    /*Round x*2*PI to the nearest integer*/
    n=(x*TWO_O_PI+(x>0.0?0.5:-0.5)); /*works for +-x*/
    xn=n;

    xnum=(int)x;
    xden=x-xnum;
    f=((xnum-xn*C1)+xden)-xn*C2;

    if (fabsf(f) < EPS)
    {
        xnum = f;
        xden = 1.0;
    }
    else
    {
        g = f*f;
        xnum = P(f,g);
        xden = Q(g);
    }

    if(n&1)
    //xn is odd
    {
        if(iscotan) return (-xnum/xden);
               else return (-xden/xnum);
    }
    else
    {
        if(iscotan) return (xden/xnum);
               else return (xnum/xden);
    }
}
/*-------------------------------------------------------------------------
   _modulonglong.c - routine for modulus of 64 bit unsigned long long

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Bug fixes by Martijn van Balen, aed@iae.nl
   Copyright (C) 2014, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdint.h>

#ifdef __SDCC_LONGLONG

#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1)

unsigned long long
_modulonglong (unsigned long long a, unsigned long long b)
{
  unsigned char count = 0;

  while (!MSB_SET(b))
  {
     b <<= 1;
     if (b > a)
     {
        b >>=1;
        break;
     }
     count++;
  }
  do
  {
    if (a >= b)
      a -= b;
    b >>= 1;
  }
  while (count--);

  return a;
}
#endif

/*-------------------------------------------------------------------------
   _uint2fs.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// float long __uint2fs (float x)
static void dummy(void) __naked
{
	__asm
	.globl	___uint2fs
___uint2fs:
	clr	a
	mov	r4, dph
	mov	r3, dpl
	mov	r2, a
	mov	r1, a
	mov	a, #142
	ljmp	ulong2fs_doit
	__endasm;
}

#else

/* convert unsigned int to float */
float __uint2fs (unsigned int ui) {
  return __ulong2fs(ui);
}

#endif
/*-------------------------------------------------------------------------
   _divslonglong.c - routine for divsion of 64 bit unsigned long long

   Copyright (C) 1999, Jean-Louis Vern <jlvern AT gmail.com>
   Copyright (C) 2012, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#pragma std_c99

#include <stdint.h>
#include <stdbool.h>

#ifdef __SDCC_LONGLONG
#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1)

unsigned long long
_divulonglong (unsigned long long x, unsigned long long y)
{
  unsigned long long reste = 0L;
  unsigned char count = 64;
  bool c;

  do
  {
    // reste: x <- 0;
    c = MSB_SET(x);
    x <<= 1;
    reste <<= 1;
    if (c)
      reste |= 1L;

    if (reste >= y)
    {
      reste -= y;
      // x <- (result = 1)
      x |= 1L;
    }
  }
  while (--count);
  return x;
}
#endif

/*-------------------------------------------------------------------------
   wcslen.c - compute the length of a string

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <wchar.h>

size_t wcslen(const wchar_t *s)
{
	register size_t n = 0;
	while (*s)
	{
		n++;
		s++;
	}

	return n;
}

/*-------------------------------------------------------------------------
   isblank.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* it is important to declare this function extern before including
   the inline definition to give it external linkage */
extern int isblank (int c);

/* also include stdio.h before ctype.h here so ctype can perform a
   _Static_assert on EOF */
#include <stdio.h>

#include <ctype.h>

/*-------------------------------------------------------------------------
   acosf.c - Computes arc cosine of a 32-bit float

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <stdbool.h>

float asincosf(float x, bool isacos);

float acosf(float x) _FLOAT_FUNC_REENTRANT
{
         if (x == 1.0) return 0.0;
    else if (x ==-1.0) return PI;
    else if (x == 0.0) return HALF_PI;
    else               return asincosf(x, true);
}
/*-------------------------------------------------------------------------
   _fs2slong.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// long __fs2slong (float x)
static void dummy(void) __naked
{
	__asm
	.globl	___fs2slong
___fs2slong:
	lcall	fsgetarg
	clr	c
	mov	a, #158
	subb	a, exp_a
	jc	fs2slong_maxval		//  |x| >= 2^32
fs2slong_int_ok:
	mov	r1, #0
	lcall	fs_rshift_a
	jnb	sign_a, fs2slong_pos
fs2slong_neg:
	mov	a, r1
	cpl	a
	add	a, #1
	mov	dpl, a
	mov	a, r2
	cpl	a
	addc	a, #0
	mov	dph, a
	mov	a, r3
	cpl	a
	addc	a, #0
	mov	b, a
	mov	a, r4
	cpl	a
	addc	a, #0
	//Check for zero
	jnz fs2slong_not_zero
	mov a, dpl
	orl a, dph
	orl a, b
	jnz fs2slong_clr_a
	ret
fs2slong_clr_a:
	clr a
fs2slong_not_zero:
	jnb acc.7, fs2slong_maxval_neg  // x < -0x80000000
	ret
fs2slong_pos:
	mov	a, r4
	jb	acc.7, fs2slong_maxval_pos  //  x > 0x7FFFFFFF
	mov	dpl, r1
	mov	dph, r2
	mov	b, r3
	ret
fs2slong_maxval:
	jnb	sign_a, fs2slong_maxval_pos
fs2slong_maxval_neg:
	clr	a
	mov	dpl, a
	mov	dph, a
	mov	b, a
	mov	a, #0x80
	ret
fs2slong_maxval_pos:
	mov	a, #0xFF
	mov	dpl, a
	mov	dph, a
	mov	b, a
	mov	a, #0x7F
	ret
	__endasm;
}

#else

/* convert float to signed long */
signed long __fs2slong (float f)
{

  if (!f)
    return 0;

  if (f<0) {
    return -__fs2ulong(-f);
  } else {
    return __fs2ulong(f);
  }
}

#endif
/*-----------------------------------------------------------------
    printfl.c - source file for reduced version of printf

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   2001060401: Improved by was@icb.snz.chel.su

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* following formats are supported :-
   format     output type       argument-type
     %d        decimal             int
     %ld       decimal             long
     %hd       decimal             char
     %x        hexadecimal         int
     %lx       hexadecimal         long
     %hx       hexadecimal         char
     %o        octal               int
     %lo       octal               long
     %ho       octal               char
     %c        character           char
     %s        character           generic pointer
*/

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

static __data char radix ;
static __bit  long_flag = 0;
static __bit  string_flag =0;
static __bit  char_flag = 0;
static char * __data str ;
static __data long val;

/* This great loop fails with the ds390 port (2003-01-13).

   At the beginning resp. end of the loop the compiler inserts a "push ar2"
   resp. "pop ar2", which badly interferes with the push/pop in the source.

   Library functions should be rock solid and portable. There's an __ltoa in
   the library, so let's use it and don't reinvent the wheel.

   Bernhard
*/

#if NICE_LIFO_IMPLEMENTATION_BUT_NOT_PORTABLE
/* just for the SP */
#include <8051.h>

static __data volatile char ch;
static __bit sign;

static void pval(void)
{
        volatile char sp;
        unsigned long lval;
        sp = SP;

        if (val < 0 && radix != 16)
        {
           lval = -val;
           sign = 1;
        }
        else { sign = 0; lval = val;}

        if (!long_flag) {
          lval &= 0x0000ffff;
        }
        if (char_flag) {
          lval &= 0x000000ff;
        }

        do
        {

#  if 1
                if(radix != 16)  ch = (lval % radix) + '0';
                else ch = "0123456789ABCDEF"[(unsigned char)lval & 0x0f];
                __asm push _ch __endasm;
                lval /= radix;
#  else
                // This only looks more efficient, but isn't. see the .map
                ch = (lval % radix) + '0';
                if (ch>'9') ch+=7;
                __asm push _ch __endasm;
                lval /= radix;
#  endif
        }
        while (lval);

        if (sign) {
                ch = '-';
                __asm push _ch __endasm;
        }

        while (sp != SP) {
                __asm pop _ch __endasm;
                putchar(ch);
        }
}
#endif

void printf_small (char * fmt, ... ) __reentrant
{
    va_list ap ;

    va_start(ap,fmt);

    for (; *fmt ; fmt++ ) {
        if (*fmt == '%') {
            long_flag = string_flag = char_flag = 0;
            fmt++ ;
            switch (*fmt) {
            case 'l':
                long_flag = 1;
                fmt++;
                break;
            case 'h':
                char_flag = 1;
                fmt++;
            }

            switch (*fmt) {
            case 's':
                string_flag = 1;
                break;
            case 'd':
                radix = 10;
                break;
            case 'x':
                radix = 16;
                break;
            case 'c':
                radix = 0;
                break;
            case 'o':
                radix = 8;
                break;
            }

            if (string_flag) {
                str = va_arg(ap, char *);
                while (*str) putchar(*str++);
                continue ;
            }

            if (long_flag)
                val = va_arg(ap,long);
            else
                if (char_flag)
                    val = va_arg(ap,char);
                else
                    val = va_arg(ap,int);

#if NICE_LIFO_IMPLEMENTATION_BUT_NOT_PORTABLE
            if (radix) pval();
#else
            if (radix)
            {
              static char __idata buffer[12]; /* 37777777777(oct) */
              char __idata * stri;

              __ltoa (val, buffer, radix);
              stri = buffer;
              while (*stri)
                {
                  putchar (*stri);
                  stri++;
                }
            }
#endif
            else
              putchar((char)val);

        } else
            putchar(*fmt);
    }
}
/*-------------------------------------------------------------------------
   floorf.c - Returns the integer smaller or equal than x

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>

float floorf (float x) _FLOAT_FUNC_REENTRANT
{
    long r;
    r=x;
    if (r<=0)
        return (r+((r>x)?-1:0));
    else
        return r;
}
/*-------------------------------------------------------------------------
   c16stombs.c - convert a wide character string to a multibyte string

   Copyright (C) 2018, Philipp Klaus Krause, krauseph@informatik.uni-freiburg.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <uchar.h>

#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <wchar.h>

#ifndef __STDC_UTF_16__
#error Encoding for char16_t strings must be UTF-16
#endif
#ifndef __STDC_ISO_10646__
#error Encoding for wchar_t strings must be UCS-4
#endif

// This implementation assumes that wctomb() does not keep internal state.
size_t __c16stombs(char *restrict s, const char16_t *restrict c16s, size_t n)
{
	size_t m = 0;
	char b[MB_LEN_MAX];

	for(;;)
	{
		int l;
		wchar_t codepoint;

		if(c16s[0] < 0xd800 || c16s[0] >= 0xe000) // Basic multilingual plane
		{
			codepoint = c16s[0];
			c16s++;
		}
                else if(c16s[0] > 0xdbff || c16s[1] < 0xdc00 || c16s[1] > 0xdfff) // Unpaired surrogate
			return(-1);
		else
		{
			codepoint = ((unsigned long)(c16s[0]) << 10) -(0xd800ul << 10) + (unsigned long)(c16s[1]) - 0xdc00ul + 0x10000ul;
			c16s += 2;
		}

		if(!codepoint)
		{
			if(m < n)
				*s = 0;
			break;
		}

		l = wctomb(b, codepoint);

		if(l < 0)
			return(-1);

		if(m + l > n)
			break;

		memcpy(s, b, l);
		s += l;
		m += l;
	}

	return(m);
}

/*-------------------------------------------------------------------------
   _mullonglong.c - routine for multiplication of 64 bit long long

   Copyright (C) 2012, Philipp Klaus Krause . philipp@informatik.uni-frankfurt.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#pragma std_c99

#include <stdint.h>

#ifdef __SDCC_LONGLONG

long long _mullonglong(long long ll, long long lr)
{
  unsigned long long ret = 0ull;
  unsigned char i, j;

  for (i = 0; i < sizeof (long long); i++)
    {
      unsigned char l = ll >> (i * 8);
      for(j = 0; (i + j) < sizeof (long long); j++)
        {
          unsigned char r = lr >> (j * 8);
          ret += (unsigned long long)((unsigned short)(l * r)) << ((i + j) * 8);
        }
    }

  return(ret);
}

#endif

/*-------------------------------------------------------------------------
   _strncat.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char * strncat ( char * front, const char * back, size_t count )
{
	char *start = front;

	while (*front++);

	front--;

	while (count--)
		if (!(*front++ = *back++))
			return(start);

	*front = '\0';
	return(start);
}
/*-------------------------------------------------------------------------
   _divulong.c - routine for division of 32 bit unsigned long

   Copyright (C) 1999, Jean-Louis Vern <jlvern AT gmail.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*   Assembler-functions are provided for:
     mcs51 small
     mcs51 small stack-auto
*/

#include <stdbool.h>

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO) && !defined(__SDCC_PARMS_IN_BANK1)
#        define _DIVULONG_ASM_SMALL_AUTO
#      else
#        define _DIVULONG_ASM_SMALL
#      endif
#    endif
#  endif
#endif

#if defined _DIVULONG_ASM_SMALL

static void
_divlong_dummy (void) __naked
{
	__asm

	.globl __divulong

__divulong:

	#define count   r2

	#define x0	dpl
	#define x1	dph
	#define x2	b
	#define x3	r3

	#define reste0	r4
	#define reste1	r5
	#define reste2	r6
	#define reste3	r7
#if !defined(__SDCC_PARMS_IN_BANK1)

#if defined(__SDCC_NOOVERLAY)
	.area DSEG    (DATA)
#else
	.area OSEG    (OVR,DATA)
#endif

	.globl __divulong_PARM_2
	.globl __divslong_PARM_2

__divulong_PARM_2:
__divslong_PARM_2:
	.ds	4

	.area CSEG    (CODE)

	#define y0      (__divulong_PARM_2)
	#define y1      (__divulong_PARM_2 + 1)
	#define y2      (__divulong_PARM_2 + 2)
	#define y3      (__divulong_PARM_2 + 3)
#else
	#define y0      (b1_0)
	#define y1      (b1_1)
	#define y2      (b1_2)
	#define y3      (b1_3)
#endif // !__SDCC_PARMS_IN_BANK1
				; parameter x comes in a, b, dph, dpl
	mov	x3,a		; save parameter x3

	mov	count,#32
	clr	a
	mov	reste0,a
	mov	reste1,a
	mov	reste2,a
	mov	reste3,a

	; optimization  loop in lp0 until the first bit is shifted into rest

lp0:	mov	a,x0		; x <<= 1
	add	a,x0
	mov	x0,a
	mov	a,x1
	rlc	a
	mov	x1,a
	mov	a,x2
	rlc	a
	mov	x2,a
	mov	a,x3
	rlc	a
	mov	x3,a

	jc	in_lp
	djnz	count,lp0

	sjmp	exit

loop:	mov	a,x0		; x <<= 1
	add	a,x0
	mov	x0,a
	mov	a,x1
	rlc	a
	mov	x1,a
	mov	a,x2
	rlc	a
	mov	x2,a
	mov	a,x3
	rlc	a
	mov	x3,a

in_lp:	mov	a,reste0	; reste <<= 1
	rlc	a		; feed in carry
	mov	reste0,a
	mov	a,reste1
	rlc	a
	mov	reste1,a
	mov	a,reste2
	rlc	a
	mov	reste2,a
	mov	a,reste3
	rlc	a
	mov	reste3,a

	mov	a,reste0	; reste - y
	subb	a,y0		; carry is always clear here, because
					; reste <<= 1 never overflows
	mov	a,reste1
	subb	a,y1
	mov	a,reste2
	subb	a,y2
	mov	a,reste3
	subb	a,y3

	jc	minus		; reste >= y?

				; -> yes;  reste -= y;
	mov	a,reste0
	subb	a,y0		; carry is always clear here (jc)
	mov	reste0,a
	mov	a,reste1
	subb	a,y1
	mov	reste1,a
	mov	a,reste2
	subb	a,y2
	mov	reste2,a
	mov	a,reste3
	subb	a,y3
	mov	reste3,a

	orl	x0,#1

minus:	djnz	count,loop	; -> no

exit:	mov	a,x3		; prepare the return value
	ret

	__endasm;
}

#elif defined _DIVULONG_ASM_SMALL_AUTO

static void
_divlong_dummy (void) __naked
{
	__asm

	.globl __divulong

__divulong:

	#define count   r2

	#define x0	dpl
	#define x1	dph
	#define x2	b
	#define x3	r3

	#define reste0	r4
	#define reste1	r5
	#define reste2	r6
	#define reste3	r7

	.globl __divlong	; entry point for __divslong

	#define y0	r1

				; parameter x comes in a, b, dph, dpl
	mov	x3,a		; save parameter x3

	mov	a,sp
	add	a,#-2-3		; 2 bytes return address, 3 bytes param y
	mov	r0,a		; r0 points to y0

__divlong:			; entry point for __divslong

	mov	a,@r0		; load y0
	mov	y0,a
	inc	r0		; r0 points to y1

	mov	count,#32
	clr	a
	mov	reste0,a
	mov	reste1,a
	mov	reste2,a
	mov	reste3,a

	; optimization  loop in lp0 until the first bit is shifted into rest

lp0:	mov	a,x0		; x <<= 1
	add	a,x0
	mov	x0,a
	mov	a,x1
	rlc	a
	mov	x1,a
	mov	a,x2
	rlc	a
	mov	x2,a
	mov	a,x3
	rlc	a
	mov	x3,a

	jc	in_lp
	djnz	count,lp0

	sjmp	exit

loop:	mov	a,x0		; x <<= 1
	add	a,x0
	mov	x0,a
	mov	a,x1
	rlc	a
	mov	x1,a
	mov	a,x2
	rlc	a
	mov	x2,a
	mov	a,x3
	rlc	a
	mov	x3,a

in_lp:	mov	a,reste0	; reste <<= 1
	rlc	a		; feed in carry
	mov	reste0,a
	mov	a,reste1
	rlc	a
	mov	reste1,a
	mov	a,reste2
	rlc	a
	mov	reste2,a
	mov	a,reste3
	rlc	a
	mov	reste3,a

	mov	a,reste0	; reste - y
	subb	a,y0		; carry is always clear here, because
				; reste <<= 1 never overflows
	mov	a,reste1
	subb	a,@r0		; y1
	mov	a,reste2
	inc	r0
	subb	a,@r0		; y2
	mov	a,reste3
	inc	r0
	subb	a,@r0		; y3
	dec	r0
	dec	r0

	jc	minus		; reste >= y?

				; -> yes;  reste -= y;
	mov	a,reste0
	subb	a,y0		; carry is always clear here (jc)
	mov	reste0,a
	mov	a,reste1
	subb	a,@r0		; y1
	mov	reste1,a
	mov	a,reste2
	inc	r0
	subb	a,@r0		; y2
	mov	reste2,a
	mov	a,reste3
	inc	r0
	subb	a,@r0		; y3
	mov	reste3,a
	dec	r0
	dec	r0

	orl	x0,#1

minus:	djnz	count,loop	; -> no

exit:	mov	a,x3		; prepare the return value
	ret

	__endasm;
}

#else // _DIVULONG_ASM

#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1)

unsigned long
_divulong (unsigned long x, unsigned long y)
{
  unsigned long reste = 0L;
  unsigned char count = 32;
  bool c;

  do
  {
    // reste: x <- 0;
    c = MSB_SET(x);
    x <<= 1;
    reste <<= 1;
    if (c)
      reste |= 1L;

    if (reste >= y)
    {
      reste -= y;
      // x <- (result = 1)
      x |= 1L;
    }
  }
  while (--count);
  return x;
}

#endif // _DIVULONG_ASM
/*-------------------------------------------------------------------------
   _rrulonglong.c - routine for right shift of 64 bit unsigned long long

   Copyright (C) 2012, Philipp Klaus Krause . philipp@informatik.uni-frankfurt.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#pragma std_c99

#include <stdint.h>

#ifdef __SDCC_LONGLONG
// This function is the same as the one from rrslonglong_rrx_s.c, except for the type of top, and b[0/3].

#if defined(__SDCC_hc08) || defined(__SDCC_s08) || defined(__SDCC_stm8) // Big-endian

unsigned long long _rrulonglong(unsigned long long l, char s)
{
	uint32_t *const top = (uint32_t *)((char *)(&l) + 0);
	uint32_t *const middle = (uint16_t *)((char *)(&l) + 2);
	uint32_t *const bottom = (uint32_t *)((char *)(&l) + 4);
	uint16_t *const b = (uint16_t *)(&l);

	for(;s >= 16; s -= 16)
	{
		b[3] = b[2];
		b[2] = b[1];
		b[1] = b[0];
		b[0] = 0x000000;
	}

	(*bottom) >>= s;
	(*middle) |= (((*middle & 0xffff0000ul) >> s) & 0x0000fffful);
	(*top) >>= s;

	return(l);
}

#else // Little-endian

unsigned long long _rrulonglong(unsigned long long l, char s)
{
	uint32_t *const top = (uint32_t *)((char *)(&l) + 4);
	uint16_t *const middle = (uint16_t *)((char *)(&l) + 4);
	uint32_t *const bottom = (uint32_t *)(&l);
	uint16_t *const b = (uint16_t *)(&l);

	for(;s >= 16; s -= 16)
	{
		b[0] = b[1];
		b[1] = b[2];
		b[2] = b[3];
		b[3] = 0x000000;
	}

	(*bottom) >>= s;
	(*middle) |= (uint16_t)(((uint32_t)(*middle) << 16) >> s);
	(*top) |= (((*middle) & 0xffff0000ul) >> s);

	return(l);
}

#endif

#endif

/*---------------------------------------------------------------------
   strtol() - convert a string to a long int and return it

   Copyright (C) 2018, Philipp Klaus Krause . krauseph@informatik.uni-freiburg.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#include <stdbool.h>
#include <ctype.h>
#include <limits.h>
#include <errno.h>

#pragma disable_warning 196

long int strtol(const char *nptr, char **endptr, int base)
{
  const char *ptr = nptr;
  const char *rptr;
  unsigned long int u;
  bool neg;

  while (isblank (*ptr))
    ptr++;

  neg = (*ptr == '-');

  if (*ptr == '-')
    {
      neg = true;
      ptr++;
    }
  else
    neg = false;

  // strtoul() would accept leading blanks or signs (that might come after '-' handled above)
  if (neg && (isblank (*ptr) || *ptr == '-' || *ptr == '+'))
    {
      if (endptr)
        *endptr = nptr;
      return (0);
    }

  u = strtoul(ptr, &rptr, base);

  // Check for conversion error
  if (rptr == ptr)
    {
      if (endptr)
        *endptr = nptr;
      return (0);
    }

  if (endptr)
    *endptr = rptr;

  // Check for range error
  if (!neg && u > LONG_MAX)
    {
      errno = ERANGE;
      return (LONG_MAX);
    }
  else if (neg && u > -LONG_MIN)
    {
      errno = ERANGE;
      return (LONG_MIN);
    }

  return (neg ? -u : u);
}

/*-------------------------------------------------------------------------
   _fs2sint.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// int __fs2sint (float x)
static void dummy(void) __naked
{
	__asm
	.globl	___fs2sint
___fs2sint:
	lcall	___fs2slong
	jnz fs2sint_not_zero
	mov a, dpl
	orl a, dph
	orl a, b
	jnz fs2sint_clr_a
	ret
fs2sint_clr_a:
	clr a
fs2sint_not_zero:
	jnb	sign_a, fs2sint_pos
fs2sint_neg:
	cpl	a
	jnz	fs2sint_maxval_neg
	mov	a, b
	cpl	a
	jnz	fs2sint_maxval_neg
	mov	a, dph
	jnb	acc.7, fs2sint_maxval_neg
	ret
fs2sint_maxval_neg:
	mov	dptr, #0x8000
	ret
fs2sint_pos:
	jnz	fs2sint_maxval_pos
	mov	a, b
	jnz	fs2sint_maxval_pos
	mov	a, dph
	jb	acc.7, fs2sint_maxval_pos
	ret
fs2sint_maxval_pos:
	mov	dptr, #0x7FFF
	ret
	__endasm;
}

#else

/* convert float to signed int */
signed int __fs2sint (float f)
{
  signed long sl=__fs2slong(f);
  if (sl>=INT_MAX)
    return INT_MAX;
  if (sl<=INT_MIN)
    return -INT_MIN;
  return sl;
}

#endif
/*-------------------------------------------------------------------------
   toupper.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

int toupper (int c)
{
  return (islower (c) ? c + ('A' - 'a') : c);
}

/*-------------------------------------------------------------------------
   _divslonglong.c - routine for divsion of 64 bit unsigned long long

   Copyright (C) 2012, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#pragma std_c99

#include <stdint.h>
#include <stdbool.h>

#ifdef __SDCC_LONGLONG
long long 
_divslonglong (long long numerator, long long denominator)
{
  bool numeratorneg = (numerator < 0);
  bool denominatorneg = (denominator < 0);
  long long d;

  if (numeratorneg)
    numerator = -numerator;
  if (denominatorneg)
    denominator = -denominator;

  d = (unsigned long long)numerator / (unsigned long long)denominator;

  return ((numeratorneg ^ denominatorneg) ? -d : d);
}
#endif

/*-------------------------------------------------------------------------
   sincoshf.c - Computes sinh or cosh of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>
#include <stdbool.h>

#define P0 -0.713793159E+1
#define P1 -0.190333999E+0
#define Q0 -0.428277109E+2
#define Q1  0.100000000E+1

#define P(z) (P1*z+P0)
#define Q(z) (Q1*z+Q0)

#define K1 0.69316101074218750000E+0 /* ln(v)   */
#define K2 0.24999308500451499336E+0 /* v**(-2) */
#define K3 0.13830277879601902638E-4 /* v/2-1   */

//WMAX is defined as ln(HUGE_VALF)-ln(v)+0.69
#define WMAX 44.93535952E+0
//WBAR 0.35*(b+1)
#define WBAR 1.05
#define YBAR 9.0 /*Works for me*/

float sincoshf(float x, bool iscosh)
{
    float y, w, z;
    bool sign;

    if (x<0.0) { y=-x; sign=1; }
          else { y=x;  sign=0; }

    if ((y>1.0) || iscosh)
    {
        if(y>YBAR)
        {
            w=y-K1;
            if (w>WMAX)
            {
                errno=ERANGE;
                z=HUGE_VALF;
            }
            else
            {
                z=expf(w);
                z+=K3*z;
            }
        }
        else
        {
            z=expf(y);
            w=1.0/z;
            if(!iscosh) w=-w;
            z=(z+w)*0.5;
        }
        if(sign) z=-z;
    }
    else
    {
        if (y<EPS)
            z=x;
        else
        {
            z=x*x;
            z=x+x*z*P(z)/Q(z);
        }
    }
    return z;
}
/*-------------------------------------------------------------------------
   aligned_alloc.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2015 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#pragma std_c11

#include <stddef.h>

/* it is important to declare this function extern before including
   the inline definition to give it external linkage */

extern void *aligned_alloc(size_t alignment, size_t size);

#include <stdlib.h>

/*-------------------------------------------------------------------------
   _fs2uint.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// unsigned int __fs2uint (float x)
static void dummy(void) __naked
{
	__asm
	.globl	___fs2uint
___fs2uint:
	mov	r7, #142
	lcall	fs2ulong_begin
	mov	dph, a
	mov	dpl, b
	ret
	__endasm;
}

#else

unsigned long __fs2ulong (float a1);

/* convert float to unsigned int */
unsigned int __fs2uint (float f)
{
  unsigned long ul=__fs2ulong(f);
  if (ul>=UINT_MAX) return UINT_MAX;
  return ul;
}

#endif
/*-------------------------------------------------------------------------
   tanhf.c - Computes tanh(x) where x is a 32-bit float as outlined in [1].

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>

#define P0 -0.8237728127E+0
#define P1 -0.3831010665E-2
#define Q0  0.2471319654E+1
#define Q1  0.1000000000E+1

/* ln(3)/2 */
#define K1  0.5493061443E+0
/* SBIG=[ln(2)+(t+1)*ln(B)]/2 */
#define SBIG 9.01091

#define P(g) ((P1*g+P0)*g)
#define Q(g) (Q1*g+Q0)

float tanhf(float x) _FLOAT_FUNC_REENTRANT
{
    float f, g, r;

    f=fabsf(x);
    if(f>SBIG) r=1.0;
    else if(f>K1)
    {
        r=0.5-1.0/(expf(f+f)+1.0);
        r+=r;
    }
    else if(f<EPS) r=f;
    else
    {
        g=f*f;
        r=f+f*(P(g)/Q(g));
    }
    if(x<0.0) r=-r;
    return r;
}
/*-------------------------------------------------------------------------
   isprint.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

int isprint (int c)
{
  return (c >= ' ' && c <= '~');
}

/*-------------------------------------------------------------------------
   isxdigit.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

int isxdigit (int c)
{
  return (c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
}

/*-------------------------------------------------------------------------
   wctob.c - convert a wide character to a single-byte character

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <wchar.h>

#include <stdio.h>

_Static_assert(WEOF & 0xffffff80, "Invalid WEOF");

int wctob(wint_t c)
{
	if(c & 0xffffff80)
		return WEOF;
	return c;
}

/*-------------------------------------------------------------------------
   _memset.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Copyright (C) 2020, Sergey Belyashov sergey.belyashov@gmail.com
   mcs51 assembler by Frieder Ferlemann (2007)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

#undef memset /* Avoid conflict with builtin memset() in Z80 and some related ports */

#if defined (_SDCC_NO_ASM_LIB_FUNCS) || !defined (__SDCC_mcs51) || \
    (!defined (__SDCC_MODEL_SMALL) && !defined (__SDCC_MODEL_LARGE)) || \
     (defined (__SDCC_STACK_AUTO) || defined (__SDCC_PARMS_IN_BANK1) )

#ifdef __SDCC_BROKEN_STRING_FUNCTIONS
void *memset (void *s, unsigned char c, size_t n)
#else
void *memset (void *s, int c, size_t n)
#endif

#if !defined (_SDCC_NO_ASM_LIB_FUNCS) && (\
              defined (__SDCC_z80) ||\
              defined (__SDCC_ez80_z80) ||\
              defined (__SDCC_z180) ||\
              defined (__SDCC_z80n) ||\
              defined (__SDCC_r2k) ||\
              defined (__SDCC_z3ka))

__naked
{
  (void)s;
  (void)c;
  (void)n;
  __asm
    pop   af
    pop   hl
#ifdef __SDCC_BROKEN_STRING_FUNCTIONS
    dec   sp
#endif
    pop   de
    pop   bc
    push  bc
    push  de
#ifdef __SDCC_BROKEN_STRING_FUNCTIONS
    inc   sp
#endif
    push  hl
    push  af
    ld    a, c
    or    a, b
    ret   Z
#ifdef __SDCC_BROKEN_STRING_FUNCTIONS
    ld    (hl), d
#else
    ld    (hl), e
#endif
    dec   bc
    ld    a, c
    or    a, b
    ret   Z
    push  hl
    ld    e, l
    ld    d, h
    inc   de
    ldir
    pop   hl
    ret
  __endasm;
}
#elif !defined (_SDCC_NO_ASM_LIB_FUNCS) && defined(__SDCC_gbz80)
__naked
{
  (void)s;
  (void)c;
  (void)n;
  __asm
    ldhl  sp,#2
    ld    e, (hl)
    inc   hl
    ld    d, (hl)
    inc   hl
    ld    a, (hl)
    inc   hl
#ifndef __SDCC_BROKEN_STRING_FUNCTIONS
    inc   hl
#endif
    ld    c, (hl)
    inc   hl
    ld    b, (hl)
    ld    l, e
    ld    h, d
    inc   b
    inc   c
    jr    20$
10$:
    ld    (hl+),a
20$:
    dec   c
    jr    NZ, 10$
    dec   b
    jr    NZ, 10$
    ret
  __endasm;
}
#else
{
  register size_t sz = n;
  if (sz != 0)
    {
      register char *dst = s;
      register char data = (char)c;
      do {
        *dst++ = data;
      } while (--sz);
    }
  return s;
}
#endif
#else

  /* assembler implementation for mcs51 */
  static void dummy(void) __naked
  {
    __asm

  /* assigning function parameters to registers.
     __SDCC_PARMS_IN_BANK1 or __SDCC_STACK_AUTO not yet implemented. */
  #if defined (__SDCC_MODEL_SMALL)

    #if defined(__SDCC_NOOVERLAY)
        .area DSEG    (DATA)
    #else
        .area OSEG    (OVR,DATA)
    #endif
        _memset_PARM_2::
              .ds 1
        _memset_PARM_3::
              .ds 2

        .area CSEG    (CODE)

        _memset::

        ;   Assign buf (b holds memspace, no need to touch)
                mov     r4,dpl
                mov     r5,dph
                ;
        ;   Assign count
                mov     r6,_memset_PARM_3
                mov     r7,(_memset_PARM_3 + 1)
                ;
        ;   if (!count) return buf;
        ;   check for count != 0 intermangled with gymnastic
        ;   preparing djnz instructions
                cjne    r6,#0x00,COUNT_LSB_NOT_ZERO
                mov     a,r7
                jz      MEMSET_END
                dec     r7
        COUNT_LSB_NOT_ZERO:
                inc     r7
                ;
                ; This was 8 byte overhead for preparing
                ; the count argument for an integer loop with two
                ; djnz instructions - it might make sense to
                ; let SDCC automatically generate this when
                ; it encounters a loop like:
                ; for(i=0;i<j;i++){...}
                ; (at least for option --opt-code-speed)
                ;

        ;   Assign ch
                mov     a,_memset_PARM_2

  #else

        .area XSEG    (XDATA)

        _memset_PARM_2::
                .ds 1
        _memset_PARM_3::
                .ds 2

        .area CSEG    (CODE)

        _memset::

        ;   Assign buf (b holds memspace, no need to touch)
                mov     r4,dpl
                mov     r5,dph
                ;
        ;   Assign count
                mov     dptr,#_memset_PARM_3
                movx    a,@dptr
                mov     r6,a
                inc     dptr
                movx    a,@dptr
                mov     r7,a
                ;
        ;   if (!count) return buf;
        ;   check for count != 0 intermangled with gymnastic
        ;   preparing djnz instructions
                cjne    r6,#0x00,COUNT_LSB_NOT_ZERO
        ;   acc holds r7
                jz      MEMSET_END
                dec     r7
        COUNT_LSB_NOT_ZERO:
                inc     r7
                ;
        ;   Assign ch
                mov     dptr,#_memset_PARM_2
                movx    a,@dptr
        ;   acc is precious now
                ;
        ;   Restore dptr
                mov     dpl,r4
                mov     dph,r5

  #endif

        /* now independent of the parameter passing everything
           should be in registers by now and the loop may start */
        ;   _memset.c do {

        MEMSET_LOOP:
        ;   _memset.c *p = ch;
                lcall   __gptrput

        ;   _memset.c p++;
                inc     dptr

        ;   _memset.c } while(--count) ;
                djnz    r6,MEMSET_LOOP
                djnz    r7,MEMSET_LOOP
                ;

        MEMSET_END:
        ;   _memset.c return buf ;
                ; b was unchanged
                mov     dpl,r4
                mov     dph,r5
                ;
                ret

    __endasm;
  }

#endif
/*-------------------------------------------------------------------------
   mbtowc.c - convert a multibyte sequence to a wide character

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

int mbtowc(wchar_t *pwc, const char *restrict s, size_t n)
{
	wchar_t codepoint;
	unsigned char seqlen, i;
	unsigned char first_byte;

	if(!s)
		return(0);

	seqlen = 1;
	first_byte = *s;

	if(first_byte & 0x80)
	{
		while (first_byte & (0x80 >> seqlen))
			seqlen++;
		first_byte &= (0xff >> (seqlen + 1));
	}

	if(seqlen > 4 || n < seqlen)
		return(-1);

	for(i = 1; i < seqlen; i++)
		if((s[i] & 0xc0) != 0x80)
			return(-1);

	codepoint = first_byte;

	for(s++, i = seqlen - 1; i; i--)
	{
		codepoint <<= 6;
		codepoint |= (*s & 0x3f);
		s++;
	}

	if(codepoint >= 0xd800 && codepoint <= 0xdfff) // UTF-16 surrogate.
		return(-1);

	if(pwc)
		*pwc = codepoint;
	return(codepoint ? seqlen : 0);
}

/*-------------------------------------------------------------------------
   sinhf.c - Computes sinh(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <stdbool.h>

float sincoshf(float x, bool iscosh);

float sinhf(float x) _FLOAT_FUNC_REENTRANT
{
    return sincoshf(x, 0);
}
/*-------------------------------------------------------------------------
   _ulong2fs.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// float long __ulong2fs (float x)
static void dummy(void) __naked
{
	__asm
	.globl	___ulong2fs
___ulong2fs:
	mov	r4, a
	mov	r3, b
	mov	r2, dph
	mov	r1, dpl
	mov	a, #158
	.globl	ulong2fs_doit
ulong2fs_doit:
	clr	sign_a
long2fs_doit:
	mov	exp_a, a
	lcall	fs_normalize_a
	ljmp	fs_round_and_return
	__endasm;
}

#else

/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

union float_long
  {
    float f;
    long l;
  };

float __ulong2fs (unsigned long a )
{
  unsigned char exp = 24 + EXCESS;
  volatile union float_long fl;

  if (!a)
    {
      return 0.0;
    }

  while (a < HIDDEN)
    {
      a <<= 1;
      exp--;
    }

  while (a & NORM) 
    {
      // we lose accuracy here
      if (a & 1)
        a += 2;
      a >>= 1;
      exp++;
    }
  
  a &= ~HIDDEN ;
  /* pack up and go home */
  fl.l = PACK(0,(unsigned long)exp, a);

  return (fl.f);
}

#endif
/*-------------------------------------------------------------------------
   printf_fast_f.c - Same as printf_fast, but with floating point enabled

   Copyright (C) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#define __SDCC_FLOAT_LIB
#include <float.h>

#ifdef FLOAT_ASM_MCS51

#define FLOAT
#define PRINTF_FAST printf_fast_f

#include "printf_fast.c"

#endif
/*-------------------------------------------------------------------------
   mbrtoc32.c - convert UTF-8 to UTF-16

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <uchar.h>

#include <limits.h>
#include <wchar.h>

size_t mbrtoc16(char16_t *restrict pc16, const char *restrict s, size_t n, mbstate_t *restrict ps)
{
	char32_t codepoint;
	size_t ret;
	static mbstate_t sps;
	char16_t low_surrogate;

	if(!s)
		return(mbrtoc16(0, "", 1, ps));

	if(!ps)
		ps = &sps;

	if(!ps->c[0] && (ps->c[1] || ps->c[2]))
	{
		if(pc16)
			*pc16 = ps->c[1] + (ps->c[2] << 8);
		ps->c[1] = ps->c[2] = 0;
		return(-3);
	}

	ret = mbrtowc(&codepoint, s, n, ps);

	if(ret > MB_LEN_MAX)
		return(ret);

	if (codepoint <= 0xffff) // Basic multilingual plane
	{
		if(pc16)
			*pc16 = codepoint;
		return(ret);
	}

	codepoint -= 0x100000;
	if(pc16)
		*pc16 = ((codepoint >> 10) & 0x3ff) + 0xd800;
	low_surrogate = (codepoint & 0x3ff) + 0xdc00;
	ps->c[0] = 0;
	ps->c[1] = low_surrogate & 0xff;
	ps->c[2] = low_surrogate >> 8;

	return(ret);
}

/*-------------------------------------------------------------------------
   _slong2fs.c - Floating point library in optimized assembly for 8051
 
   Copyright (C) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

//float __slong2fs (long x)
static void dummy(void) __naked
{
	__asm
	.globl	___slong2fs
___slong2fs:
	mov	r4, a
	mov	r3, b
	mov	r2, dph
	mov	r1, dpl
	mov	a, #158
	.globl	slong2fs_doit
slong2fs_doit:
	mov	exp_a, a
	clr	sign_a
	mov	a, r4
	jnb	acc.7, slong2fs_positive
	setb	sign_a
	mov	a, r1
	cpl	a
	add	a, #1
	mov	r1, a
	mov	a, r2
	cpl	a
	addc	a, #0
	mov	r2, a
	mov	a, r3
	cpl	a
	addc	a, #0
	mov	r3, a
	mov	a, r4
	cpl	a
	addc	a, #0
	mov	r4, a
slong2fs_positive:
	lcall	fs_normalize_a
	ljmp	fs_round_and_return
	__endasm;
}

#else

/* convert signed long to float */
float __slong2fs (signed long sl) {
  if (sl<0) 
    return -__ulong2fs(-sl);
  else 
    return __ulong2fs(sl);
}

#endif
/*-------------------------------------------------------------------------
   memccpy.c - part of string library functions

   Copyright (C) 2019, Philipp Klaus Krause . krauseph@informatik.uni-freiburg.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

void *memccpy (void *restrict dst, const void *restrict src, int c, size_t n)
{
	char *d = dst;
	const char *s = src;

	while (n--)
		if ((*d++ = *s++) == (unsigned char)c)
			return (d);

	return (0);
}

/*-------------------------------------------------------------------------
   iscntrl.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

int iscntrl (int c)
{
  return (c < ' ' || c == 0x7f);
}

/*-------------------------------------------------------------------------
   fabsf.c - Returns the absolute value of a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>

float fabsf(float x) _FLOAT_FUNC_REENTRANT
{
    union float_long fl;

    fl.f = x;
    fl.l &= 0x7fffffff;
    return fl.f;
}
/*-------------------------------------------------------------------------
   _strspn.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

size_t strspn ( const char * string, const char * control )
{
	register size_t count = 0;
	register char ch ;

	while (ch = *string) {
		if ( strchr(control,ch) )
			count++ ;
		else
			break ;
		string++ ;
	}

	return count ;
}
/*-------------------------------------------------------------------------
   printf_fast.c - Fast printf routine for use with sdcc/mcs51

   Copyright (C) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/******************************************************************/
/**                                                              **/
/**    Major features.  These determine what capabilities your   **/
/**    compiled printf_fast will have.                           **/
/**                                                              **/
/******************************************************************/

// Include support for 32 bit base 10 integers (%ld and %lu).  Without
// this, you won't be able to print 32 bit integers as base 10.  They
// will appear in hexadecimal.
#define LONG

// Include support for floating point numbers (%f).  Don't forget to
// enable LONG above, if you want to print floats greater than
// 65535.997.  You can have 6 good digits after the decimal point,
// or an 8th if a small error is ok.  +/- 2^32 to 1/10^8 isn't the
// full dynamic range of 32 bit floats, but it covers the most
// commonly used range.  Adds about 500-600 bytes of code.
//#define FLOAT

// Include support for minimum field widths (%8d, %20s, %12.5f)
#define FIELD_WIDTH

// Include fast integer conversion.  Without this, a compact but slower
// algorithm is used to convert integers (%d, %u, int part of %f).
// Even the slow algorithm is much faster than a typical C implementation
// based on repetitive division by 10.  If you enable this, you get an
// extremely fast version (only 8 table lookups and 8 adds to convert a
// 32 bit integer), but it costs extra code space for larger lookup
// tables and optimized non-looping code.
#define FAST_INTEGER


/******************************************************************/
/**                                                              **/
/**    Minor tweaks.  These provide small code savings, with     **/
/**    a partial loss of functionality.                          **/
/**                                                              **/
/******************************************************************/


// If you enabled FLOAT, enabling this replaces the normal %f float
// output with a very compact version that always prints 4 fractional
// digits and does not have round off.  Zero will print as "0.0000",
// and 1.999997 will print as "1.9999" (not rounded up to 2).  The
// 4th digit is not accurate (+/- 2).  This simpler version also
// avoids using 5 bytes of internal data memory.  Code size is about
// 240 bytes less.
//#define FLOAT_FIXED4

// If you used FLOAT (not FLOAT_FIXED4), this will remove the smart
// default number of digits code.  When you use "%f" without a field
// width, normally the smart default width code chooses a good number
// of digits based on size of the number.  If you enabled FIELD_WIDTH
// and use a number, like "%.5f", this smart default code is never
// used anyway.  Saves about 40 bytes of code.
//#define FLOAT_DEFAULT_FRAC_DIGITS 6

// If you used FLOAT (not FLOAT_FIXED4) and you do not specify a
// field width, normally trailing zeros are trimmed.  Using this
// removes that feature (saves only a few bytes).
//#define DO_NOT_TRIM_TRAILING_ZEROS

// Omit saving and restoring registers when calling putchar().  If you
// are desparate for a little more code space, this will give you a
// small savings.  You MUST define putchar() with #pragma callee_saves,
// or implement it in assembly and avoid changing the registers.
//#define PUTCHAR_CALLEE_SAVES


/* extern void putchar(char ); */

// Warning: using static/global variables makes these functions NON-reentrant!
// reentrant keyword is only used for parameter passing method

static __bit long_flag, short_flag, print_zero_flag, negative_flag;

#ifdef FIELD_WIDTH
static __bit field_width_flag;
static __bit leading_zero_flag;
static __data unsigned char field_width;
#endif

#ifdef FLOAT
#define __SDCC_FLOAT_LIB
#include <float.h>
static __bit continue_float;
#ifndef FLOAT_FIXED4
static __data unsigned char frac_field_width;
static __data unsigned char float_frac_bcd[4];
// TODO: can float_frac_bcd be overlaid with temps used by trig functions
#endif
#endif

#ifndef FAST_INTEGER
#ifdef LONG
static __data unsigned int i2bcd_tmp;  // slow 32 int conversion needs temp space
#endif
#endif


#ifndef PRINTF_FAST
#define PRINTF_FAST printf_fast
#endif


#if !defined(__SDCC_mcs51) || defined(__SDCC_USE_XSTACK) || defined(_SDCC_NO_ASM_LIB_FUNCS)
// Does printf_fast really work on ds390 and ds400?
// If it does, enable them in the line above
#if defined(__SDCC_USE_XSTACK)
#warning "printf_fast not built, does not support --xstack"
#elif defined(_SDCC_NO_ASM_LIB_FUNCS)
#warning "printf_fast not built, _SDCC_NO_ASM_LIB_FUNCS defined"
#endif
#else // defines are compatible with printf_fast


void PRINTF_FAST(__code const char *fmt, ...) __reentrant
{
	fmt;	/* suppress unreferenced variable warning */

	__asm

printf_begin:
	mov	a, _bp		// r0 will point to va_args (stack)
	add	a, #253
	mov	r0, a		// r0 points to MSB of fmt
	mov	dph, @r0
	dec	r0
	mov	dpl, @r0	// dptr has address of fmt
	dec	r0

printf_main_loop:
	clr	a
	movc	a, @a+dptr	// get next byte of fmt string
	inc	dptr
	//cjne	a, #'%', printf_normal
	cjne	a, #37, printf_normal

printf_format:
	clr	_long_flag
	clr	_short_flag
	clr	_print_zero_flag
	clr	_negative_flag
#ifdef FIELD_WIDTH
	clr	_field_width_flag
	clr	_leading_zero_flag
	mov	r1, #_field_width
	mov	@r1, #0
#endif
#ifdef FLOAT
	clr	_continue_float
#endif

printf_format_loop:
	clr	a
	movc	a, @a+dptr	// get next byte of data format
	inc	dptr

	/* parse and consume the field width digits, even if */
	/* we don't build the code to make use of them */
	add	a, #198
	jc	printf_nondigit1
	add	a, #10
	jnc	printf_nondigit2
#ifdef FIELD_WIDTH
printf_digit:
	jnz	printf_digit_2
	cjne	a, _field_width, printf_digit_2
	setb	_leading_zero_flag
printf_digit_2:
	setb	_field_width_flag
	mov	r2, a
	mov	a, @r1
	mov	b, #10
	mul	ab
	add	a, r2
	mov	@r1, a
#endif
	sjmp	printf_format_loop
printf_nondigit1:
	add	a, #10
printf_nondigit2:
	add	a, #48

printf_format_l:
	//cjne	a, #'l', printf_format_h
	cjne	a, #108, printf_format_h
	setb	_long_flag
	sjmp	printf_format_loop

printf_format_h:
	//cjne	a, #'h', printf_format_s
	cjne	a, #104, printf_format_s
	setb	_short_flag
	sjmp	printf_format_loop

printf_format_s:
	//cjne	a, #'s', printf_format_d
	cjne	a, #115, printf_format_d
	ljmp	printf_string

printf_format_d:
	//cjne	a, #'d', printf_format_u
	cjne	a, #100, printf_format_u
	lcall	printf_get_int
	ljmp	printf_int

printf_format_u:
	//cjne	a, #'u', printf_format_c
	cjne	a, #117, printf_format_c
	lcall	printf_get_int
	ljmp	printf_uint

printf_format_c:
	//cjne	a, #'c', printf_format_x
	cjne	a, #99, printf_format_x
	dec	r0
	mov	a, @r0		// Acc has the character to print
	dec	r0
	sjmp	printf_char

printf_format_x:
	//cjne	a, #'x', printf_format_f
	cjne	a, #120, printf_format_f
	ljmp	printf_hex

printf_format_f:
#ifdef FLOAT
	//cjne	a, #'f', printf_format_dot
	cjne	a, #102, printf_format_dot
	ljmp	print_float
#endif

printf_format_dot:
	//cjne	a, #'.', printf_normal
	cjne	a, #46, printf_normal
#ifdef FLOAT
#ifdef FLOAT_FIXED4
	mov	r1, #ar3	// parse frac field, but discard if FIXED4
#else
	mov	r1, #_frac_field_width
	mov	@r1, #0
#endif
#endif
	sjmp	printf_format_loop

printf_normal:
	jz	printf_eot
printf_char:
	lcall	printf_putchar
	ljmp	printf_main_loop

printf_eot:
	ljmp	printf_end


	/* print a string... just grab each byte with __gptrget */
	/* the user much pass a 24 bit generic pointer */

printf_string:
	push	dph		// save addr in fmt onto stack
	push	dpl
	mov	b, @r0		// b has type of address (generic *)
	dec	r0
	mov	dph, @r0
	dec	r0
	mov	dpl, @r0	// dptr has address of user's string
	dec	r0

#ifdef FIELD_WIDTH
	jnb	_field_width_flag, printf_str_loop
	clr	_leading_zero_flag	// never leading zeros for strings
	push	dpl
	push	dph
printf_str_fw_loop:
	lcall	__gptrget
	jz	printf_str_space
	inc	dptr
	dec	_field_width
	mov	a, _field_width
	jnz	printf_str_fw_loop
printf_str_space:
	lcall	printf_space
	pop	dph
	pop	dpl
#endif // FIELD_WIDTH

printf_str_loop:
	lcall	__gptrget
	jz	printf_str_done
	inc	dptr
	lcall	printf_putchar
	sjmp	printf_str_loop
printf_str_done:
	pop	dpl		// restore addr withing fmt
	pop	dph
	ljmp	printf_main_loop


	/* printing in hex is easy because sdcc pushes the LSB first */

printf_hex:
	lcall	printf_hex8
	jb	_short_flag, printf_hex_end
	lcall	printf_hex8
	jnb	_long_flag, printf_hex_end
	lcall	printf_hex8
	lcall	printf_hex8
printf_hex_end:
	lcall	printf_zero
	ljmp	printf_main_loop
printf_hex8:
	mov	a, @r0
	lcall	printf_phex_msn
	mov	a, @r0
	dec	r0
	ljmp	printf_phex_lsn


#ifndef LONG
printf_ld_in_hex:
	//mov	a, #'0'
	mov	a, #48
	lcall	printf_putchar
	//mov	a, #'x'
	mov	a, #120
	lcall	printf_putchar
	mov	a, r0
	add	a, #4
	mov	r0, a
	sjmp	printf_hex
#endif


	/* printing an integer is not so easy.  For a signed int */
	/* check if it is negative and print the minus sign and */
	/* invert it to a positive integer */

printf_int:
	mov	a, r5
	jnb	acc.7, printf_uint	/* check if negative */
	setb	_negative_flag
	mov	a, r1			/* invert integer */
	cpl	a
	add	a, #1
	mov	r1, a
	jb	_short_flag, printf_uint
	mov	a, r2
	cpl	a
	addc	a, #0
	mov	r2, a
	jnb	_long_flag, printf_uint
	mov	a, r3
	cpl	a
	addc	a, #0
	mov	r3, a
	mov	a, r4
	cpl	a
	addc	a, #0
	mov	r4, a


	/* printing integers is a lot of work... because it takes so */
	/* long, the first thing to do is make sure we're doing as */
	/* little work as possible, then convert the binary int to */
	/* packed BCD, and finally print each digit of the BCD number */

printf_uint:

	jb	_short_flag, printf_uint_ck8
	jnb	_long_flag, printf_uint_ck16
printf_uint_ck32:
	/* it's a 32 bit int... but if the upper 16 bits are zero */
	/* we can treat it like a 16 bit integer and convert much faster */
#ifdef LONG
	mov	a, r3
	jnz	printf_uint_begin
	mov	a, r4
	jnz	printf_uint_begin
#else
	mov	a, r3
	jnz	printf_ld_in_hex	// print long integer as hex
	mov	a, r4			// rather than just the low 16 bits
	jnz	printf_ld_in_hex
#endif
	clr	_long_flag
printf_uint_ck16:
	/* it's a 16 bit int... but if the upper 8 bits are zero */
	/* we can treat it like a 8 bit integer and convert much faster */
	mov	a, r2
	jnz	printf_uint_begin
	setb	_short_flag
printf_uint_ck8:
	/* it's an 8 bit int... if it's zero, it's a lot faster to just */
	/* print the digit zero and skip all the hard work! */
	mov	a, r1
	jnz	printf_uint_begin
#ifdef FLOAT
	/* never use the "just print zero" shortcut if we're printing */
	/* the integer part of a float  (fixes bug 1255403)  */
	jb	_continue_float, printf_uint_begin
#endif
#ifdef FIELD_WIDTH
	jnb	_field_width_flag, printf_uint_zero
	mov	a, _field_width
	jz	printf_uint_zero
	dec	_field_width
	lcall	printf_space
#endif
printf_uint_zero:
	//mov	a, #'0'
	mov	a, #48
	lcall	printf_putchar
	ljmp	printf_main_loop

printf_uint_begin:
	push	dpl
	push	dph
	lcall	printf_int2bcd		// bcd number in r3/r2/r7/r6/r5
printf_uint_2:

#ifdef FIELD_WIDTH
	jnb	_field_width_flag, printf_uifw_end
#ifdef LONG
printf_uifw_32:
	mov	r1, #10
	jnb	_long_flag, printf_uifw_16
	mov	a, r3
	anl	a, #0xF0
	jnz	printf_uifw_sub
	dec	r1
	mov	a, r3
	anl	a, #0x0F
	jnz	printf_uifw_sub
	dec	r1
	mov	a, r2
	anl	a, #0xF0
	jnz	printf_uifw_sub
	dec	r1
	mov	a, r2
	anl	a, #0x0F
	jnz	printf_uifw_sub
	dec	r1
	mov	a, r7
	anl	a, #0xF0
	jnz	printf_uifw_sub
#endif // LONG
printf_uifw_16:
	mov	r1, #5
	jb	_short_flag, printf_uifw_8
	mov	a, r7
	anl	a, #0x0F
	jnz	printf_uifw_sub
	dec	r1
	mov	a, r6
	anl	a, #0xF0
	jnz	printf_uifw_sub
printf_uifw_8:
	mov	r1, #3
	mov	a, r6
	anl	a, #0x0F
	jnz	printf_uifw_sub
	dec	r1
	mov	a, r5
	anl	a, #0xF0
	jnz	printf_uifw_sub
	dec	r1
printf_uifw_sub:
	//r1 has the number of digits for the number
	mov	a, _field_width
	mov	c, _negative_flag
	subb	a, r1
	jc	printf_uifw_end
	mov	_field_width, a

#ifndef PUTCHAR_CALLEE_SAVES
#ifdef LONG
	push	ar3
	push	ar2
#endif
	push	ar7
	push	ar6
	push	ar5
#endif
	lcall	printf_space
#ifndef PUTCHAR_CALLEE_SAVES
	pop	ar5
	pop	ar6
	pop	ar7
#ifdef LONG
	pop	ar2
	pop	ar3
#endif
#endif


printf_uifw_end:
#endif // FIELD_WIDTH


printf_uint_doit:
	jnb	_negative_flag, printf_uint_pos
#ifdef PUTCHAR_CALLEE_SAVES
	//mov	a, #'-'
	mov	a, #45
	lcall	printf_putchar
#else
#ifdef LONG
	push	ar3
	push	ar2
#endif
	push	ar7
	push	ar6
	push	ar5
	//mov	a, #'-'
	mov	a, #45
	lcall	printf_putchar
	pop	ar5
	pop	ar6
	pop	ar7
#ifdef LONG
	pop	ar2
	pop	ar3
#endif
#endif // PUTCHAR_CALLEE_SAVES

printf_uint_pos:
	jb	_short_flag, printf_uint8
#ifdef LONG
	jnb	_long_flag, printf_uint16
printf_uint32:
	push	ar5
	push	ar6
	push	ar7
	mov	dpl, r2
	mov	a, r3
	mov	dph, a
	lcall	printf_phex_msn
	mov	a, dph
	lcall	printf_phex_lsn
	mov	a, dpl
	lcall	printf_phex_msn
	mov	a, dpl
	lcall	printf_phex_lsn
	pop	acc
	mov	dpl, a
	lcall	printf_phex_msn
	mov	a, dpl
	pop	dph
	pop	dpl
	sjmp	printf_uint16a
#endif // LONG

printf_uint16:
	mov	dpl, r5
	mov	dph, r6
	mov	a, r7
printf_uint16a:
	lcall	printf_phex_lsn
	mov	a, dph
	lcall	printf_phex_msn
	mov	a, dph
	sjmp	printf_uint8a

printf_uint8:
	mov	dpl, r5
	mov	a, r6
printf_uint8a:
	lcall	printf_phex_lsn
	mov	a, dpl
	lcall	printf_phex_msn
	mov	a, dpl
	lcall	printf_phex_lsn
	lcall	printf_zero
	pop	dph
	pop	dpl
#ifdef FLOAT
	jnb	_continue_float, 0002$
	ret
0002$:
#endif
	ljmp	printf_main_loop


#ifdef FLOAT
#ifdef FLOAT_FIXED4
	// Print a float the easy way.  First, extract the integer part and
	// use the integer printing code.  Then extract the fractional part,
	// convert each bit to 4 digit BCD, and print the BCD sum.  Absolutely
	// no field width control, always 4 digits printed past the decimal
	// point.  No round off.  1.9999987 prints as 1.9999, not 2.0000.
print_float:
#ifdef FIELD_WIDTH
	jnb	_field_width_flag, print_float_begin
	mov	a, _field_width
	add	a, #251
	mov	_field_width, a
	jc	print_float_begin
	mov	_field_width, #0
#endif
print_float_begin:
	push	ar0		// keep r0 safe, will need it again
	lcall	printf_get_float
	clr	c
	mov	a, #158			// check for large float we can't print
	subb	a, r7
	jnc	print_float_size_ok
printf_float_too_big:
	// TODO: should print some sort of overflow error??
	pop	ar0
	ljmp	printf_format_loop
print_float_size_ok:
	push	dpl
	lcall	fs_rshift_a
	pop	dpl
	setb	_continue_float
#ifndef LONG
	mov	a, r3
	orl	a, r4
	jnz	printf_float_too_big
#endif
	lcall	printf_uint		// print the integer portion
	//mov	a, #'.'
	mov	a, #0x2E
	lcall	printf_putchar
	// now that the integer part is printed, we need to refetch the
	// float from the va_args and extract the fractional part
	pop	ar0
	lcall	printf_get_float
	push	ar0
	push	dpl
	push	dph
	mov	a, r7
	cjne	a, #126, print_float_frac_lshift
	sjmp	print_float_frac // input between 0.5 to 0.9999
print_float_frac_lshift:
	jc	print_float_frac_rshift
	//Acc (exponent) is greater than 126 (input >= 1.0)
	add	a, #130
	mov	r5, a
print_float_lshift_loop:
	clr	c
	mov	a, r2
	rlc	a
	mov	r2, a
	mov	a, r3
	rlc	a
	mov	r3, a
	mov	a, r4
	rlc	a
	mov	r4, a
	djnz	r5, print_float_lshift_loop
	sjmp	print_float_frac
print_float_frac_rshift:
	//Acc (exponent) is less than 126 (input < 0.5)
	cpl	a
	add	a, #127
	lcall	fs_rshift_a
print_float_frac:
	// now we've got the fractional part, so now is the time to
	// convert to BCD... just convert each bit to BCD using a
	// lookup table and BCD sum them together
	mov	r7, #14
	clr	a
	mov	r6, a
	mov	r5, a
	mov	dptr, #_frac2bcd	// FLOAT_FIXED4 version (14 entries)
print_float_frac_loop:
	mov	a, r3
	rlc	a
	mov	r3, a
	mov	a, r4
	rlc	a
	mov	r4, a
	jnc	print_float_frac_skip
	clr	a
	movc	a, @a+dptr
	add	a, r5
	da	a
	mov	r5, a
	mov	a, #1
	movc	a, @a+dptr
	addc	a, r6
	da	a
	mov	r6, a
print_float_frac_skip:
	inc	dptr
	inc	dptr
	djnz	r7, print_float_frac_loop
	// the BCD sum is in dptr, so all we've got to do is output
	// all 4 digits.  No trailing zero suppression, no nice round
	// off (impossible to change the integer part since we already
	// printed it).
	mov	dph, r6
	mov	dpl, r5
	setb	_print_zero_flag
	mov	a, dph
	lcall	printf_phex_msn
	mov	a, dph
	lcall	printf_phex_lsn
	mov	a, dpl
	lcall	printf_phex_msn
	mov	a, dpl
	lcall	printf_phex_lsn
	pop	dph
	pop	dpl
	pop	ar0
	ljmp	printf_main_loop

#else // not FLOAT_FIXED4


print_float:
	// Print a float the not-as-easy way, with a configurable number of
	// fractional digits (up to 8) and proper round-off (up to 7 digits).
	// First, extract the fractional part, convert to BCD, and then add
	// the scaled round-off.  Store the rounded fractional digits and
	// their carry.  Then extract the integer portion, increment it if
	// the rounding caused a carry.  Use the integer printing to output
	// the integer, and then output the stored fractional digits.  This
	// approach requires 5 bytes of internal RAM to store the 8 fractional
	// digits and the number of them we'll actually print.  This code is
	// a couple hundred bytes larger and a bit slower than the FIXED4
	// version, but it gives very nice results.
print_float_1:
#ifdef FIELD_WIDTH
	jnb	_field_width_flag, print_float_default_width
	// The caller specified exact field width, so use it.  Need to
	// convert the whole float digits into the integer portion only.
	mov	a, _field_width
	setb	c
	subb	a, _frac_field_width
	mov	_field_width, a
	jnc	print_float_begin
	mov	_field_width, #0
	sjmp	print_float_begin
#endif
print_float_default_width:
	// The caller didn't specify field width (or FIELD_WIDTH is
	// not defined so it's ignored).  We've still got to know
	// how many fractional digits are going to print, so we can
	// round off properly.
#ifdef FLOAT_DEFAULT_FRAC_DIGITS
	mov	_frac_field_width, #FLOAT_DEFAULT_FRAC_DIGITS
#else
	// default fractional field width (between 0 to 7)
	// attempt to scale the default number of fractional digits
	// based on the magnitude of the float
	mov	a, @r0
	anl	a, #0x7F	// ignore sign bit
	mov	r2, a		// r2 is first byte of float
	dec	r0
	mov	ar3, @r0	// r3 is second byte of float
	inc	r0
	mov	r6, dpl
	mov	r7, dph
	mov	dptr, #_float_range_table
	mov	r5, #7
print_float_default_loop:
	clr	a
	movc	a, @a+dptr
	add	a, r3
	inc	dptr
	clr	a
	movc	a, @a+dptr
	addc	a, r2
	jnc	print_float_default_done
	inc	dptr
	djnz	r5, print_float_default_loop
print_float_default_done:
	mov	_frac_field_width, r5
	mov	dpl, r6
	mov	dph, r7
#endif // not FLOAT_DEFAULT_FRAC_DIGITS

print_float_begin:
	push	ar0			// keep r0 safe, will need it again
	lcall	printf_get_float
	push	dpl
	push	dph
	mov	a, r7
	cjne	a, #126, print_float_frac_lshift
	sjmp	print_float_frac	// input between 0.5 to 0.9999

print_float_frac_lshift:
	jc	print_float_frac_rshift
	//Acc (exponent) is greater than 126 (input >= 1.0)
	add	a, #130
	mov	r5, a
print_float_lshift_loop:
	clr	c
	mov	a, r2
	rlc	a
	mov	r2, a
	mov	a, r3
	rlc	a
	mov	r3, a
	mov	a, r4
	rlc	a
	mov	r4, a
	djnz	r5, print_float_lshift_loop
	sjmp	print_float_frac
print_float_frac_rshift:
	//Acc (exponent) is less than 126 (input < 0.5)
	cpl	a
	add	a, #127
	lcall	fs_rshift_a
print_float_frac:
	// Convert the fraction in r4/r3/r2/r1 into 8 BCD digits in r0/r7/r6/r5
	mov	b, #27
	clr	a
	mov	r0, a
	mov	r7, a
	mov	r6, a
	mov	r5, a
	mov	dptr, #_frac2bcd	// FLOAT version (27 entries)
print_float_frac_loop:
	mov	a, r1
	rlc	a
	mov	r1, a
	mov	a, r2
	rlc	a
	mov	r2, a
	mov	a, r3
	rlc	a
	mov	r3, a
	mov	a, r4
	rlc	a
	mov	r4, a
	jnc	print_float_frac_skip
	clr	a
	movc	a, @a+dptr
	add	a, r5
	da	a
	mov	r5, a
	mov	a, #1
	movc	a, @a+dptr
	addc	a, r6
	da	a
	mov	r6, a
	mov	a, #2
	movc	a, @a+dptr
	addc	a, r7
	da	a
	mov	r7, a
	mov	a, #3
	movc	a, @a+dptr
	addc	a, r0
	da	a
	mov	r0, a
print_float_frac_skip:
	inc	dptr
	inc	dptr
	inc	dptr
	inc	dptr
	djnz	b, print_float_frac_loop
print_float_frac_roundoff:
	// Now it's time to round-off the BCD digits to the desired precision.
	clr	a
	mov	r4, #0x50		// r4/r3/r2/r1 = 0.5 (bcd rounding)
	mov	r3, a
	mov	r2, a
	mov	r1, a
	mov	a, _frac_field_width
	rl	a
	rl	a
	anl	a, #0xFC
	mov	dph, r0			// fs_rshift_a will overwrite r0 & dpl
	lcall	fs_rshift_a		// divide r4/r3/r2/r1 by 10^frac_field_width
	mov	a, r5
	add	a, r1			// add rounding to fractional part
	da	a
	mov	_float_frac_bcd+3, a	// and store it for later use
	mov	a, r6
	addc	a, r2
	da	a
	mov	_float_frac_bcd+2, a
	mov	a, r7
	addc	a, r3
	da	a
	mov	_float_frac_bcd+1, a
	mov	a, dph
	addc	a, r4
	da	a
	mov	_float_frac_bcd+0, a
	mov	sign_b, c		// keep fractional carry in sign_b
	pop	dph
	pop	dpl
print_float_int:
	// Time to work on the integer portion... fetch the float again, check
	// size (exponent), scale to integer, add the fraction's carry, and
	// let the integer printing code do all the work.
	pop	ar0
	lcall	printf_get_float
	push	ar0
	clr	c
	mov	a, #158			// check for large float we can't print
	subb	a, r7
	jnc	print_float_size_ok
printf_float_too_big:
	// TODO: should print some sort of overflow error??
	pop	ar0
	ljmp	printf_format_loop
print_float_size_ok:
	push	dpl
	lcall	fs_rshift_a
	pop	dpl
	jnb	sign_b, print_float_do_int
	// if we get here, the fractional round off caused the
	// integer part to increment.  Add 1 for a proper result
	mov	a, r1
	add	a, #1
	mov	r1, a
	clr	a
	addc	a, r2
	mov	r2, a
#ifdef LONG
	clr	a
	addc	a, r3
	mov	r3, a
	clr	a
	addc	a, r4
	mov	r4, a
#endif
	jc	printf_float_too_big
print_float_do_int:
#ifndef LONG
	mov	a, r3
	orl	a, r4
	jnz	printf_float_too_big
#endif
	setb	_continue_float
	lcall	printf_uint		// print the integer portion


print_float_frac_width:
	// Now all we have to do is output the fractional digits that
	// were previous computed and stored in memory.
#ifdef FIELD_WIDTH
	jb	_field_width_flag, print_float_do_frac
#endif
#ifndef DO_NOT_TRIM_TRAILING_ZEROS 
	// if the user did not explicitly set a
	// field width, trim off trailing zeros
print_float_frac_trim:
	mov	a, _frac_field_width
	jz	print_float_do_frac
	lcall	get_float_frac_digit
	jnz	print_float_do_frac
	djnz	_frac_field_width, print_float_frac_trim
#endif

print_float_do_frac:
	mov	a, _frac_field_width
	jz	print_float_done
	//mov	a, #'.'
	mov	a, #0x2E
	lcall	printf_putchar
	mov	r0, #0
	setb	_print_zero_flag
print_float_do_frac_loop:
	inc	r0
	mov	a, r0
	lcall	get_float_frac_digit
	lcall	printf_phex_lsn
	mov	a, r0
	cjne	a, _frac_field_width, print_float_do_frac_loop

print_float_done:
	pop	ar0
	ljmp	printf_main_loop


	// acc=1 for tenths, acc=2 for hundredths, etc
get_float_frac_digit:
	dec	a
	clr	c
	rrc	a
	mov	psw.5, c
	add	a, #_float_frac_bcd
	mov	r1, a
	mov	a, @r1
	jb	psw.5, get_float_frac_digit_done
	swap	a
get_float_frac_digit_done:
	anl	a, #15
	ret

#endif // end of normal FLOAT code (not FLOAT_FIXED4)


// These helper functions are used, regardless of which type of
// FLOAT code is used.

#if 0
pm2_print_float:
	 mov	a, r7
	 lcall	pm2_entry_phex
	 mov	a, #0x20
	 lcall	pm2_entry_cout
	 lcall	_print_r4321
	 mov	a, #0x20
	 lcall	pm2_entry_cout
	 ret
#endif

	// Fetch a float from the va_args and put it into
	// r7(exp) r4/r3/r2(mant) and also clear r1 and preset
	// the flags
printf_get_float:
	mov	a, @r0
	dec	r0
	mov	r1, a
	mov	a, @r0
	dec	r0
	mov	r4, a
	rlc	a
	mov	a, r1
	rlc	a
	mov	_negative_flag, c
	mov	r7, a
	jz	printf_get_float_2
	orl	ar4, #0x80
printf_get_float_2:
	mov	a, @r0
	dec	r0
	mov	r3, a
	mov	a, @r0
	dec	r0
	mov	r2, a
	mov	r1, #0
	clr	_short_flag
	setb	_long_flag
	ret
#endif // FLOAT


	/* read an integer into r1/r2/r3/r4, and msb into r5 */
printf_get_int:
	mov	a, @r0
	mov	r1, a
	mov	r5, a
	dec	r0
	jb	_short_flag, printf_get_done
	mov	r2, ar1
	mov	a, @r0
	mov	r1, a
	dec	r0
	jnb	_long_flag, printf_get_done
	mov	r4, ar2
	mov	r3, ar1
	mov	a, @r0
	mov	r2, a
	dec	r0
	mov	a, @r0
	mov	r1, a
	dec	r0
printf_get_done:
	ret


#ifdef FAST_INTEGER

	/* convert binary number in r4/r3/r2/r1 into bcd packed number
	 * in r3/r2/r7/r6/r5.  The input number is destroyed in the
	 * process, to avoid needing extra memory for the result (and
	 * r1 gets used for temporary storage).  dptr is overwritten,
	 * but r0 is not changed.
	 */

printf_int2bcd:
	mov	a, r1
	mov	b, #100
	div	ab
	mov	r6, a
	mov	a, #10
	xch	a, b
	div	ab
	swap	a
	orl	a, b
	mov	r5, a

	jnb	_short_flag, printf_i2bcd_16	// if 8 bit int, we're done
	ret

printf_i2bcd_16:
	mov	a, r2
	anl	a, #0x0F
	mov	r1, a
	mov	dptr, #_int2bcd_2
	movc	a, @a+dptr
	add	a, r5
	da	a
	mov	r5, a
	mov	a, r1
	orl	a, #16
	movc	a, @a+dptr
	addc	a, r6
	da	a
	mov	r6, a

	mov	a, r2
	swap	a
	anl	a, #0x0F
	mov	r1, a
	mov	dptr, #_int2bcd_3
	movc	a, @a+dptr
	add	a, r5
	da	a
	mov	r5, a
	mov	a, r1
	orl	a, #16
	movc	a, @a+dptr
	addc	a, r6
	da	a
	mov	r6, a
	mov	a, r1
	orl	a, #32
	movc	a, @a+dptr
	addc	a, #0
	da	a
	mov	r7, a

	jb	_long_flag, printf_i2bcd_32	// if 16 bit int, we're done
	ret

printf_i2bcd_32:

#ifdef LONG
	mov	a, r3
	anl	a, #0x0F
	mov	r1, a
	mov	dptr, #_int2bcd_4
	movc	a, @a+dptr
	add	a, r5
	da	a
	mov	r5, a
	mov	a, r1
	orl	a, #16
	movc	a, @a+dptr
	addc	a, r6
	da	a
	mov	r6, a
	mov	a, r1
	orl	a, #32
	movc	a, @a+dptr
	addc	a, r7
	da	a
	mov	r7, a
	clr	a
	addc	a, #0
	mov	r2, a

	mov	a, r3
	swap	a
	anl	a, #0x0F
	mov	r1, a
	mov	dptr, #_int2bcd_5
	movc	a, @a+dptr
	add	a, r5
	da	a
	mov	r5, a
	mov	a, r1
	orl	a, #16
	movc	a, @a+dptr
	addc	a, r6
	da	a
	mov	r6, a
	mov	a, r1
	orl	a, #32
	movc	a, @a+dptr
	addc	a, r7
	da	a
	mov	r7, a
	mov	a, r1
	orl	a, #48
	movc	a, @a+dptr
	addc	a, r2
	da	a
	mov	r2, a

	mov	a, r4
	anl	a, #0x0F
	mov	r1, a
	mov	dptr, #_int2bcd_6
	mov	r3, #0
	lcall	printf_bcd_add10	// saves 27 bytes, costs 5 cycles

	mov	a, r4
	swap	a
	anl	a, #0x0F
	mov	r1, a
	mov	dptr, #_int2bcd_7
printf_bcd_add10:
	movc	a, @a+dptr
	add	a, r5
	da	a
	mov	r5, a
	mov	a, r1
	orl	a, #16
	movc	a, @a+dptr
	addc	a, r6
	da	a
	mov	r6, a
	mov	a, r1
	orl	a, #32
	movc	a, @a+dptr
	addc	a, r7
	da	a
	mov	r7, a
	mov	a, r1
	orl	a, #48
	movc	a, @a+dptr
	addc	a, r2
	da	a
	mov	r2, a
	mov	a, r1
	orl	a, #64
	movc	a, @a+dptr
	addc	a, r3
	da	a
	mov	r3, a
#endif // LONG
	ret


#else // not FAST_INTEGER

	/* convert binary number in r4/r3/r2/r1 into bcd packed number
	 * in r3/r2/r7/r6/r5.  The input number is destroyed in the
	 * process, to avoid needing extra memory for the result (and
	 * r1 gets used for temporary storage).  dptr is overwritten,
	 * but r0 is not changed.
	 */

#ifdef LONG

printf_int2bcd:
	mov	a, #8
	jb	_short_flag, printf_int2bcd_begin
	mov	a, #16
	jnb	_long_flag, printf_int2bcd_begin
	mov	a, #32
printf_int2bcd_begin:
	mov	b, a
	clr	a
	mov	r5, a
	mov	r6, a
	mov	r7, a
	mov	(_i2bcd_tmp + 0), a
	mov	(_i2bcd_tmp + 1), a
	mov	dptr, #_int2bcd
printf_i2bcd_loop:
	mov	a, r4
	rrc	a
	mov	r4, a
	mov	a, r3
	rrc	a
	mov	r3, a
	mov	a, r2
	rrc	a
	mov	r2, a
	mov	a, r1
	rrc	a
	mov	r1, a
	jnc	print_i2bcd_skip
	clr	a
	movc	a, @a+dptr
	add	a, r5
	da	a
	mov	r5, a
	mov	a, #1
	movc	a, @a+dptr
	addc	a, r6
	da	a
	mov	r6, a
	mov	a, #2
	movc	a, @a+dptr
	addc	a, r7
	da	a
	mov	r7, a
	mov	a, #3
	movc	a, @a+dptr
	addc	a, (_i2bcd_tmp + 0)
	da	a
	mov	(_i2bcd_tmp + 0), a
	mov	a, #4
	movc	a, @a+dptr
	addc	a, (_i2bcd_tmp + 1)
	da	a
	mov	(_i2bcd_tmp + 1), a
print_i2bcd_skip:
	inc	dptr
	inc	dptr
	inc	dptr
	inc	dptr
	inc	dptr
	djnz	b, printf_i2bcd_loop
	mov	r2, (_i2bcd_tmp + 0)
	mov	r3, (_i2bcd_tmp + 1)
	ret

#else //  not LONG

printf_int2bcd:
	mov	a, #8
	jb	_short_flag, printf_int2bcd_begin
	mov	a, #16
printf_int2bcd_begin:
	mov	b, a
	clr	a
	mov	r5, a
	mov	r6, a
	mov	r7, a
	mov	dptr, #_int2bcd
printf_i2bcd_loop:
	mov	a, r2
	rrc	a
	mov	r2, a
	mov	a, r1
	rrc	a
	mov	r1, a
	jnc	printf_i2bcd_add_skip
	clr	a
	movc	a, @a+dptr
	add	a, r5
	da	a
	mov	r5, a
	mov	a, #1
	movc	a, @a+dptr
	addc	a, r6
	da	a
	mov	r6, a
	mov	a, #2
	movc	a, @a+dptr
	addc	a, r7
	da	a
	mov	r7, a
printf_i2bcd_add_skip:
	inc	dptr
	inc	dptr
	inc	dptr
	djnz	b, printf_i2bcd_loop
	ret

#endif // not LONG


#endif // not FAST_INTEGER


#ifdef FIELD_WIDTH
printf_space_loop:
	//mov	a, #' '
	mov	a, #32
	jnb	_leading_zero_flag, printf_space_output
	//mov	a, #'0'
	mov	a, #48
printf_space_output:
	lcall	printf_putchar
	dec	_field_width
printf_space:
	mov	a, _field_width
	jnz	printf_space_loop
	ret
#endif

	/* print a hex digit, either upper 4 bit (msn) or lower 4 bits (lsn) */

printf_phex_msn:
	swap	a
printf_phex_lsn:
	anl	a, #15
	jnz	printf_phex_ok
	jnb	_print_zero_flag, printf_ret
printf_phex_ok:
	setb	_print_zero_flag
	add	a, #0x90
	da	a
	addc    a, #0x40
	da	a
printf_putchar:
#ifdef PUTCHAR_CALLEE_SAVES
	push	dph
	push	dpl
	mov	dpl, a
	lcall	_putchar
	pop	dpl
	pop	dph
#else
	push	dph
	push	dpl
	push	ar0
	mov	dpl, a
	lcall	_putchar
	pop	ar0
	pop	dpl
	pop	dph
#endif
printf_ret:
	ret

	/* print a zero if all the calls to print the digits ended up */
	/* being leading zeros */

printf_zero:
        jb	_print_zero_flag, printf_ret
        //mov	a, #'0'
        mov	a, #48
        ljmp	printf_putchar
  
printf_end:
	__endasm;
}


#ifdef FAST_INTEGER
/*
 * #! /usr/bin/perl
 * for ($d=0; $d < 8; $d++) {
 * 	$n = 16 ** $d;
 * 	for ($p=0; $p < 5; $p++) {
 * 		last unless (((16 ** $d) * 15) / (10 ** ($p * 2))) % 100;
 * 		printf "code unsigned char int2bcd_%d_%d[15] = {", $d, $p;
 * 		for ($i=0; $i < 16; $i++) {
 * 			printf "0x%02d",
 * 			   (((16 ** $d) * $i) / (10 ** ($p * 2))) % 100;
 * 			print ", " if $i < 15;
 * 		}
 * 		print "};\n";
 * 	}
 * }
 */

#if 0
static __code unsigned char int2bcd_0[] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15};

static __code unsigned char int2bcd_1[] = {
0x00, 0x16, 0x32, 0x48, 0x64, 0x80, 0x96, 0x12,
0x28, 0x44, 0x60, 0x76, 0x92, 0x08, 0x24, 0x40,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02};
#endif

static __code unsigned char int2bcd_2[] = {
0x00, 0x56, 0x12, 0x68, 0x24, 0x80, 0x36, 0x92,
0x48, 0x04, 0x60, 0x16, 0x72, 0x28, 0x84, 0x40,
0x00, 0x02, 0x05, 0x07, 0x10, 0x12, 0x15, 0x17,
0x20, 0x23, 0x25, 0x28, 0x30, 0x33, 0x35, 0x38};

static __code unsigned char int2bcd_3[] = {
0x00, 0x96, 0x92, 0x88, 0x84, 0x80, 0x76, 0x72,
0x68, 0x64, 0x60, 0x56, 0x52, 0x48, 0x44, 0x40,
0x00, 0x40, 0x81, 0x22, 0x63, 0x04, 0x45, 0x86,
0x27, 0x68, 0x09, 0x50, 0x91, 0x32, 0x73, 0x14,
0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x02,
0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06};

#ifdef LONG
static __code unsigned char int2bcd_4[] = {
0x00, 0x36, 0x72, 0x08, 0x44, 0x80, 0x16, 0x52,
0x88, 0x24, 0x60, 0x96, 0x32, 0x68, 0x04, 0x40,
0x00, 0x55, 0x10, 0x66, 0x21, 0x76, 0x32, 0x87,
0x42, 0x98, 0x53, 0x08, 0x64, 0x19, 0x75, 0x30,
0x00, 0x06, 0x13, 0x19, 0x26, 0x32, 0x39, 0x45,
0x52, 0x58, 0x65, 0x72, 0x78, 0x85, 0x91, 0x98};

static __code unsigned char int2bcd_5[] = {
0x00, 0x76, 0x52, 0x28, 0x04, 0x80, 0x56, 0x32,
0x08, 0x84, 0x60, 0x36, 0x12, 0x88, 0x64, 0x40,
0x00, 0x85, 0x71, 0x57, 0x43, 0x28, 0x14, 0x00,
0x86, 0x71, 0x57, 0x43, 0x29, 0x14, 0x00, 0x86,
0x00, 0x04, 0x09, 0x14, 0x19, 0x24, 0x29, 0x34,
0x38, 0x43, 0x48, 0x53, 0x58, 0x63, 0x68, 0x72,
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15};

static __code unsigned char int2bcd_6[] = {
0x00, 0x16, 0x32, 0x48, 0x64, 0x80, 0x96, 0x12,
0x28, 0x44, 0x60, 0x76, 0x92, 0x08, 0x24, 0x40,
0x00, 0x72, 0x44, 0x16, 0x88, 0x60, 0x32, 0x05,
0x77, 0x49, 0x21, 0x93, 0x65, 0x38, 0x10, 0x82,
0x00, 0x77, 0x55, 0x33, 0x10, 0x88, 0x66, 0x44,
0x21, 0x99, 0x77, 0x54, 0x32, 0x10, 0x88, 0x65,
0x00, 0x16, 0x33, 0x50, 0x67, 0x83, 0x00, 0x17,
0x34, 0x50, 0x67, 0x84, 0x01, 0x18, 0x34, 0x51,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02};

static __code unsigned char int2bcd_7[] = {
0x00, 0x56, 0x12, 0x68, 0x24, 0x80, 0x36, 0x92,
0x48, 0x04, 0x60, 0x16, 0x72, 0x28, 0x84, 0x40,
0x00, 0x54, 0x09, 0x63, 0x18, 0x72, 0x27, 0x81,
0x36, 0x91, 0x45, 0x00, 0x54, 0x09, 0x63, 0x18,
0x00, 0x43, 0x87, 0x30, 0x74, 0x17, 0x61, 0x04,
0x48, 0x91, 0x35, 0x79, 0x22, 0x66, 0x09, 0x53,
0x00, 0x68, 0x36, 0x05, 0x73, 0x42, 0x10, 0x79,
0x47, 0x15, 0x84, 0x52, 0x21, 0x89, 0x58, 0x26,
0x00, 0x02, 0x05, 0x08, 0x10, 0x13, 0x16, 0x18,
0x21, 0x24, 0x26, 0x29, 0x32, 0x34, 0x37, 0x40};
#endif // LONG

#else // not FAST_INTEGER

/*
 * #! /usr/bin/perl
 * print "__code unsigned char int2bcd[] = {\n";
 * for ($i=0, $n=1; $i<32; $i++, $n*=2) {
 * 	$r = sprintf "%010u", $n;
 * 	$r =~ /([0-9][0-9])([0-9][0-9])([0-9][0-9])([0-9][0-9])([0-9][0-9])/;
 * 	printf "0x%02d, 0x%02d, 0x%02d, 0x%02d, 0x%02d", $5, $4, $3, $2, $1;
 * 	print ',' if $i < 31;
 * 	printf "\t\t// %10u\n", $n;
 * }
 * print "}\n__code unsigned char int2bcd[] = {\n";
 * for ($i=0, $n=1; $i<16; $i++, $n*=2) {
 * 	$r = sprintf "%06u", $n;
 * 	$r =~ /([0-9][0-9])([0-9][0-9])([0-9][0-9])/;
 * 	printf "0x%02d, 0x%02d, 0x%02d", $3, $2, $1;
 * 	print ',' if $i < 15;
 * 	printf "\t\t// %10u\n", $n;
 * }
 * print "};\n";
*/

#ifdef LONG
static __code unsigned char int2bcd[] = {
0x01, 0x00, 0x00, 0x00, 0x00,		//          1
0x02, 0x00, 0x00, 0x00, 0x00,		//          2
0x04, 0x00, 0x00, 0x00, 0x00,		//          4
0x08, 0x00, 0x00, 0x00, 0x00,		//          8
0x16, 0x00, 0x00, 0x00, 0x00,		//         16
0x32, 0x00, 0x00, 0x00, 0x00,		//         32
0x64, 0x00, 0x00, 0x00, 0x00,		//         64
0x28, 0x01, 0x00, 0x00, 0x00,		//        128
0x56, 0x02, 0x00, 0x00, 0x00,		//        256
0x12, 0x05, 0x00, 0x00, 0x00,		//        512
0x24, 0x10, 0x00, 0x00, 0x00,		//       1024
0x48, 0x20, 0x00, 0x00, 0x00,		//       2048
0x96, 0x40, 0x00, 0x00, 0x00,		//       4096
0x92, 0x81, 0x00, 0x00, 0x00,		//       8192
0x84, 0x63, 0x01, 0x00, 0x00,		//      16384
0x68, 0x27, 0x03, 0x00, 0x00,		//      32768
0x36, 0x55, 0x06, 0x00, 0x00,		//      65536
0x72, 0x10, 0x13, 0x00, 0x00,		//     131072
0x44, 0x21, 0x26, 0x00, 0x00,		//     262144
0x88, 0x42, 0x52, 0x00, 0x00,		//     524288
0x76, 0x85, 0x04, 0x01, 0x00,		//    1048576
0x52, 0x71, 0x09, 0x02, 0x00,		//    2097152
0x04, 0x43, 0x19, 0x04, 0x00,		//    4194304
0x08, 0x86, 0x38, 0x08, 0x00,		//    8388608
0x16, 0x72, 0x77, 0x16, 0x00,		//   16777216
0x32, 0x44, 0x55, 0x33, 0x00,		//   33554432
0x64, 0x88, 0x10, 0x67, 0x00,		//   67108864
0x28, 0x77, 0x21, 0x34, 0x01,		//  134217728
0x56, 0x54, 0x43, 0x68, 0x02,		//  268435456
0x12, 0x09, 0x87, 0x36, 0x05,		//  536870912
0x24, 0x18, 0x74, 0x73, 0x10,		// 1073741824
0x48, 0x36, 0x48, 0x47, 0x21		// 2147483648
};
#else // not LONG
static __code unsigned char int2bcd[] = {
0x01, 0x00, 0x00,		//          1
0x02, 0x00, 0x00,		//          2
0x04, 0x00, 0x00,		//          4
0x08, 0x00, 0x00,		//          8
0x16, 0x00, 0x00,		//         16
0x32, 0x00, 0x00,		//         32
0x64, 0x00, 0x00,		//         64
0x28, 0x01, 0x00,		//        128
0x56, 0x02, 0x00,		//        256
0x12, 0x05, 0x00,		//        512
0x24, 0x10, 0x00,		//       1024
0x48, 0x20, 0x00,		//       2048
0x96, 0x40, 0x00,		//       4096
0x92, 0x81, 0x00,		//       8192
0x84, 0x63, 0x01,		//      16384
0x68, 0x27, 0x03		//      32768
};
#endif // not LONG

#endif // not FAST_INTEGER


#ifdef FLOAT
#ifndef FLOAT_FIXED4

/*
 * #! /usr/bin/perl
 * for ($i=0, $f=0.5; $i<24; $i++) {
 * 	$r = sprintf "%.8f", $f;
 * 	$r =~ /0\.([0-9][0-9])([0-9][0-9])([0-9][0-9])([0-9][0-9])/;
 * 	printf "0x%02d, 0x%02d, 0x%02d, 0x%02d", $4, $3, $2, $1;
 * 	print ',' if $i < 23;
 * 	$sum += $r;
 * 	printf "\t\t// %.15f  %.8f\n", $f, $sum;
 * 	$f /= 2;
 * }
 */

static __code unsigned char frac2bcd[] = {
0x00, 0x00, 0x00, 0x50,		// 0.500000000000000  0.50000000
0x00, 0x00, 0x00, 0x25,		// 0.250000000000000  0.75000000
0x00, 0x00, 0x50, 0x12,		// 0.125000000000000  0.87500000
0x00, 0x00, 0x25, 0x06,		// 0.062500000000000  0.93750000
0x00, 0x50, 0x12, 0x03,		// 0.031250000000000  0.96875000
0x00, 0x25, 0x56, 0x01,		// 0.015625000000000  0.98437500
0x50, 0x12, 0x78, 0x00,		// 0.007812500000000  0.99218750
0x25, 0x06, 0x39, 0x00,		// 0.003906250000000  0.99609375
0x12, 0x53, 0x19, 0x00,		// 0.001953125000000  0.99804687
0x56, 0x76, 0x09, 0x00,		// 0.000976562500000  0.99902343
0x28, 0x88, 0x04, 0x00,		// 0.000488281250000  0.99951171
0x14, 0x44, 0x02, 0x00,		// 0.000244140625000  0.99975585
0x07, 0x22, 0x01, 0x00,		// 0.000122070312500  0.99987792
0x04, 0x61, 0x00, 0x00,		// 0.000061035156250  0.99993896
0x52, 0x30, 0x00, 0x00,		// 0.000030517578125  0.99996948
0x26, 0x15, 0x00, 0x00,		// 0.000015258789062  0.99998474
0x63, 0x07, 0x00, 0x00,		// 0.000007629394531  0.99999237
0x81, 0x03, 0x00, 0x00,		// 0.000003814697266  0.99999618
0x91, 0x01, 0x00, 0x00,		// 0.000001907348633  0.99999809
0x95, 0x00, 0x00, 0x00,		// 0.000000953674316  0.99999904
0x48, 0x00, 0x00, 0x00,		// 0.000000476837158  0.99999952
0x24, 0x00, 0x00, 0x00,		// 0.000000238418579  0.99999976
0x12, 0x00, 0x00, 0x00,		// 0.000000119209290  0.99999988
0x06, 0x00, 0x00, 0x00,		// 0.000000059604645  0.99999994
0x03, 0x00, 0x00, 0x00,		// 0.000000029802322  0.99999997
0x01, 0x00, 0x00, 0x00,		// 0.000000014901161  0.99999998
0x01, 0x00, 0x00, 0x00		// 0.000000007450581  0.99999999
};

#ifndef FLOAT_DEFAULT_FRAC_DIGITS
// TODO: Perhaps these should be tweaked a bit to take round up
// effects into account... or maybe give more default digits??
// Range		#digits
// 0.0001 - 0.0009999	7
// 0.001 - 0.009999	6	0.001 = 0x3A83126F  3A83
// 0.01 - 0.09999	5	0.01  = 0x3C23D70A  3C23
// 0.1 - 9.9999		4	0.1   = 0x3DCCCCCD, 3DCC
// 10.0 - 99.99		3	10.0  = 0x41200000  4120
// 100.0 - 999.99	2	100.0 = 0x42C80000  42C8
// 1000 - 9999.9	1	1000  = 0x447A0000  447A
// 10000+		0	10000 = 0x461C4000  461C
static __code unsigned int float_range_table[] = {
65536 - 0x3A83,
65536 - 0x3C23,
65536 - 0x3DCC,
65536 - 0x4120,
65536 - 0x42C8,
65536 - 0x447A,
65536 - 0x461C
};
#endif

#else // using FLOAT_FIXED4

/*
* #! /usr/bin/perl
*     for ($i=0, $f=0.5; $i<14; $i++) {
*     $r = sprintf "%.4f", $f;
*     $r =~ /0\.([0-9][0-9])([0-9][0-9])/;
*     printf "0x%02d, 0x%02d", $2, $1;
*     print ',' if $i < 13;
*     $sum += $r;
*     printf "\t\t// %.15f  %.4f\n", $f, $sum;
*     $f /= 2;
* }
*/

static __code unsigned char frac2bcd[] = {
0x00, 0x50,             // 0.500000000000000  0.5000
0x00, 0x25,             // 0.250000000000000  0.7500
0x50, 0x12,             // 0.125000000000000  0.8750
0x25, 0x06,             // 0.062500000000000  0.9375
0x12, 0x03,             // 0.031250000000000  0.9687
0x56, 0x01,             // 0.015625000000000  0.9843
0x78, 0x00,             // 0.007812500000000  0.9921
0x39, 0x00,             // 0.003906250000000  0.9960
0x20, 0x00,             // 0.001953125000000  0.9980
0x10, 0x00,             // 0.000976562500000  0.9990
0x05, 0x00,             // 0.000488281250000  0.9995
0x02, 0x00,             // 0.000244140625000  0.9997
0x01, 0x00,             // 0.000122070312500  0.9998
0x01, 0x00              // 0.000061035156250  0.9999
};

#endif // FLOAT_FIXED4
#endif // FLOAT


#endif // defines compatible with printf_fast
/*-------------------------------------------------------------------------
   _divuchar.c :- routine for unsigned char (8 bit) division. just calls
                  routine for unsigned int division

   Copyright (C) 2017, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

unsigned int
_divuchar (unsigned char x, unsigned char y)
{
  return ((unsigned int)x / (unsigned int)y);
}

/*-------------------------------------------------------------------------
   _startup.c - startup routine for sdcc

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* External startup code can be written in C
   here .. Special usage if this routine
   returns a non-zero value then global &
   static variable initialisation will be skipped.
   Beware not to use initialized variables as they
   are not initialized yet nor to use pdata/xdata
   variables if external data memory needs to be
   enabled first. */

#if defined(__SDCC_ds390) || defined(__SDCC_ds400)

/* Disable "ISO C forbids an empty source file" warning message */
#pragma disable_warning 190

#elif defined(__SDCC_mcs51) || defined(__SDCC_z80)

unsigned char _sdcc_external_startup (void) __nonbanked
{
    return 0;
}

#else

unsigned char _sdcc_external_startup ()
{
    return 0;
}

#endif
/*-------------------------------------------------------------------------
   _fsdiv.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>


#ifdef FLOAT_ASM_MCS51

// float __fsdiv (float a, float b) __reentrant
static void dummy(void) __naked
{
	__asm
	.globl	___fsdiv
___fsdiv:
	// extract the two inputs, placing them into:
	//      sign     exponent   mantiassa
	//      ----     --------   ---------
	//  a:  sign_a   exp_a      r4/r3/r2
	//  b:  sign_b   exp_b      r7/r6/r5

	lcall	fsgetargs

	// compute final sign bit
	jnb	sign_b, 00001$
	cpl	sign_a
00001$:

	// if divisor is zero, ...
	cjne	r7, #0, 00003$
	// if dividend is also zero, return NaN
	cjne	r4, #0, 00002$
	ljmp	fs_return_nan
00002$:
	// but dividend is non-zero, return infinity
	ljmp	fs_return_inf
00003$:
	// if dividend is zero, return zero
	cjne	r4, #0, 00004$
	ljmp	fs_return_zero
00004$:
	// if divisor is infinity, ...
	mov	a, exp_b
	cjne	a, #0xFF, 00006$
	// and dividend is also infinity, return NaN
	mov	a, exp_a
	cjne	a, #0xFF, 00005$
	ljmp	fs_return_nan
00005$:
	// but dividend is not infinity, return zero
	ljmp	fs_return_zero
00006$:
	// if dividend is infinity, return infinity
	mov	a, exp_a
	cjne	a, #0xFF, 00007$
	ljmp	fs_return_inf
00007$:

	// subtract exponents
	clr	c
	subb	a, exp_b
	// if no carry then no underflow
	jnc	00008$
	add	a, #127
	jc	00009$
	ljmp	fs_return_zero

00008$:
	add	a, #128
	dec	a
	jnc	00009$
	ljmp	fs_return_inf

00009$:
	mov	exp_a, a

	// need extra bits on a's mantissa
#ifdef FLOAT_FULL_ACCURACY
	clr	c
	mov	a, r5
	subb	a, r2
	mov	a, r6
	subb	a, r3
	mov	a, r7
	subb	a, r4
	jc	00010$
	dec	exp_a
	clr	c
	mov	a, r2
	rlc	a
	mov	r1, a
	mov	a, r3
	rlc	a
	mov	r2, a
	mov	a, r4
	rlc	a
	mov	r3, a
	clr	a
	rlc	a
	mov	r4, a
	sjmp	00011$
00010$:
#endif
	clr	a
	xch	a, r4
	xch	a, r3
	xch	a, r2
	mov	r1, a
00011$:

	// begin long division
	push	exp_a
#ifdef FLOAT_FULL_ACCURACY
	mov	b, #25
#else
	mov	b, #24
#endif
00012$:
	// compare
	clr	c
	mov	a, r1
	subb	a, r5
	mov	a, r2
	subb	a, r6
	mov	a, r3
	subb	a, r7
	mov	a, r4
	subb	a, #0		// carry==0 if mant1 >= mant2

#ifdef FLOAT_FULL_ACCURACY
	djnz	b, 00013$
	sjmp	00015$
00013$:
#endif
	jc	00014$
	// subtract
	mov	a, r1
	subb	a, r5
	mov	r1, a
	mov	a, r2
	subb	a, r6
	mov	r2, a
	mov	a, r3
	subb	a, r7
	mov	r3, a
	mov	a, r4
	subb	a, #0
	mov	r4, a
	clr	c

00014$:
	// shift result
	cpl	c
	mov	a, r0
	rlc	a
	mov	r0, a
	mov	a, dpl
	rlc	a
	mov	dpl, a
	mov	a, dph
	rlc	a
	mov	dph, a

	// shift partial remainder
	clr	c
	mov	a, r1
	rlc	a
	mov	r1, a
	mov	a, r2
	rlc	a
	mov	r2, a
	mov	a, r3
	rlc	a
	mov	r3, a
	mov	a, r4
	rlc	a
	mov	r4, a

#ifdef FLOAT_FULL_ACCURACY
	sjmp	00012$
00015$:
#else
	djnz	b, 00012$
#endif

	// now we've got a division result, so all we need to do
	// is round off properly, normalize and output a float

#ifdef FLOAT_FULL_ACCURACY
	cpl	c
	clr	a
	mov	r1, a
	addc	a, r0
	mov	r2, a
	clr	a
	addc	a, dpl
	mov	r3, a
	clr	a
	addc	a, dph
	mov	r4, a
	pop	exp_a
	jnc	00016$
	inc	exp_a
	// incrementing exp_a without checking carry is dangerous
	mov	r4, #0x80
00016$:
#else
	mov	r1, #0
	mov	a, r0
	mov	r2, a
	mov	r3, dpl
	mov	r4, dph
	pop	exp_a
#endif

	lcall	fs_normalize_a
	ljmp	fs_zerocheck_return
	__endasm;
}

#else

/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

union float_long
  {
    float f;
    long l;
  };

/* divide two floats */
static float __fsdiv_org (float a1, float a2)
{
  volatile union float_long fl1, fl2;
  volatile long result;
  volatile unsigned long mask;
  volatile long mant1, mant2;
  volatile int exp;
  char sign;
 
  fl1.f = a1;
  fl2.f = a2;

  /* subtract exponents */
  exp = EXP (fl1.l) ;
  exp -= EXP (fl2.l);
  exp += EXCESS;

  /* compute sign */
  sign = SIGN (fl1.l) ^ SIGN (fl2.l);

  /* divide by zero??? */
  if (!fl2.l)
    {/* return NaN or -NaN */
      fl2.l = 0x7FC00000;
      return (fl2.f);
    }

  /* numerator zero??? */
  if (!fl1.l)
    return (0);

  /* now get mantissas */
  mant1 = MANT (fl1.l);
  mant2 = MANT (fl2.l);

  /* this assures we have 25 bits of precision in the end */
  if (mant1 < mant2)
    {
      mant1 <<= 1;
      exp--;
    }

  /* now we perform repeated subtraction of fl2.l from fl1.l */
  mask = 0x1000000;
  result = 0;
  while (mask)
    {
      if (mant1 >= mant2)
	{
	  result |= mask;
	  mant1 -= mant2;
	}
      mant1 <<= 1;
      mask >>= 1;
    }

  /* round */
  result += 1;

  /* normalize down */
  exp++;
  result >>= 1;

  result &= ~HIDDEN;

  /* pack up and go home */
  if (exp >= 0x100)
    fl1.l = (sign ? SIGNBIT : 0) | __INFINITY;
  else if (exp < 0)
    fl1.l = 0;
  else
    fl1.l = PACK (sign ? SIGNBIT : 0 , exp, result);
  return (fl1.f);
}

float __fsdiv (float a1, float a2)
{
  float f;
  unsigned long *p = (unsigned long *) &f;

  if (a2 == 0.0f && a1 > 0.0f)
    *p = 0x7f800000; // inf
  else if (a2 == 0.0f && a1 < 0.0f)
    *p = 0xff800000; // -inf
  else if (a2 == 0.0f && a1 == 0.0f)
    *p = 0xffc00000; // nan
  else
    f = __fsdiv_org (a1, a2);

  return f; 
}

#endif
/*-------------------------------------------------------------------------
   _modschar.c :- routine for signed char (8 bit) division. just calls
                 routine for signed int division after sign extension

   Copyright (C) 2013, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

signed int
_modschar (signed char x, signed char y)
{
  return ((int)x % (int)y);
}

signed int
_moduschar (unsigned char x, unsigned char y)
{
  return ((int)((signed char)x) % (int)y);
}

unsigned int
_modsuchar (signed char x, signed char y)
{
  return ((int)((unsigned char)x) % (int)y);
}

/*-------------------------------------------------------------------------
   isinf.c - Check if a float value is an infinite (positive or negative)

   Copyright (C) 2016, Ben Shi, powerstudio1st@163.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#define __SDCC_FLOAT_LIB
#include <float.h>
#include <math.h>

int isinf (float f)
{
  unsigned long *pl = (unsigned long *) &f;
  return *pl == 0x7f800000 || *pl == 0xff800000;
}
/*-------------------------------------------------------------------------
   _spx.c - just declares bp as a variable                

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

__data unsigned char spx ;
__data unsigned char _page_no__;
/*-------------------------------------------------------------------------
   calloc.c - allocate memory.

   Copyright (C) 2015, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#if defined(__SDCC_mcs51) || defined(__SDCC_ds390) || defined(__SDCC_ds400)
#define HEAPSPACE __xdata
#elif defined(__SDCC_pdk13) || defined(__SDCC_pdk14) || defined(__SDCC_pdk15)
#define HEAPSPACE __near
#else
#define HEAPSPACE
#endif

#if defined(__SDCC_mcs51) || defined(__SDCC_ds390) || defined(__SDCC_ds400)
void HEAPSPACE *calloc (size_t nmemb, size_t size)
#else
void *calloc (size_t nmemb, size_t size)
#endif
{
	void HEAPSPACE *ptr;

	unsigned long msize = (unsigned long)nmemb * (unsigned long)size;

	_Static_assert(sizeof(unsigned long) >= sizeof(size_t) * 2,
		"size_t too large wrt. unsigned long for overflow check");

	if (msize > SIZE_MAX)
		return(0);

	if (ptr = malloc(msize))
		memset(ptr, 0, msize);

	return(ptr);
}

/*-------------------------------------------------------------------------
   labs.c - computes absolute value of an integer.

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#if defined (__SDCC_mcs51)

#if defined(__SDCC)
 #include <sdcc-lib.h>
#endif

static void dummy(void) __naked
{
	__asm
	.globl	_labs
_labs:
	jnb	acc.7, 00001$
	mov	r2,a
	clr	c
	clr	a
	subb	a,dpl
	mov	dpl,a
	clr	a
	subb	a,dph
	mov	dph,a
	clr	a
	subb	a,b
	mov	b,a
	clr	a
	subb	a,r2
00001$:
	_RETURN
	__endasm;
}

#else

long int labs(long int j)
{
	return (j < 0) ? -j : j;
}

#endif

//END OF MODULE
/*-------------------------------------------------------------------------
   bpx.c - just declares bpx as a variable                

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#if defined(__SDCC_mcs51)
  __data unsigned char bpx ;
#else
  __data unsigned int bpx ;
#endif
/*-------------------------------------------------------------------------
   _ser.c - this file contains a simple interrupt driven serial driver with
            buffer (no check for overflow!!!).

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*KA******************************************************************
* PROJECT: PL-One/8052 
**********************************************************************
* FILE: ser.c
**********************************************************************
* CHANGES:
* date      author            description
* --------------------------------------------------------------------
* 04/26/99  we                final
* 04/27/99  we                comments
**********************************************************************
* DESCRIPTION:
* This file contains a simple interrupt driven serial driver with
* buffer (no check for overflow!!!).
**********************************************************************
* FUNCTIONS DECLARED:
* ser_init       Initialization; must be called first
* ser_putc       output one char on the serial line
* ser_getc       return a char if one has been received, else 0
* ser_printString print a 0-terminated string
* ser_charAvail  return 1 if a char arrived on serial line
**********************************************************************
* NOTE:
* Remember to enable all interrupts (EA=1) outside of this module!!
**********************************************************************
* COMPILE TIME OPTIONS: -
* DEBUG OPTIONS: -
******************************************************************KE*/

#include <8052.h>

#include "ser.h"

#define NON_BLOCKING

unsigned char __xdata ser_txIndexIn;
unsigned char __xdata ser_txIndexOut;
unsigned char __xdata ser_rxIndexIn;
unsigned char __xdata ser_rxIndexOut;

unsigned char __xdata ser_txBuffer[0x100];
unsigned char __xdata ser_rxBuffer[0x100];

static __bit ser_txBusy;

void
ser_init(void)
{
  ES = 0;

  ser_txBusy     = 0;

  ser_txIndexIn  = 0;
  ser_txIndexOut = 0;
  ser_rxIndexIn  = 0;
  ser_rxIndexOut = 0;
  
  T2CON = 0x30;

  /* Baudrate = 19200, oscillator frq. of my processor is 21.4772 MHz */
  RCAP2H = 0xFF;
  RCAP2L = 0xDD;

  /* enable counter */
  T2CON = 0x34;
  
  SCON = 0x50;

  if (TI) {
    TI = 0;
  }
  if (RI) {
    RI = 0;
  }
  
  ES=1;  
}

void
ser_interrupt_handler(void) __interrupt 4 __using 1
{
  ES=0;

  if (RI) {
    RI = 0;
    ser_rxBuffer[ser_rxIndexIn++] = SBUF;
  }

  if (TI) {
    TI = 0;
    if (ser_txIndexIn == ser_txIndexOut) {
      ser_txBusy = 0;
    }
    else {
      SBUF = ser_txBuffer[ser_txIndexOut++];
    }
  }

  ES=1;
}

void 
ser_putc(unsigned char c)
{
  ES=0;

  if (ser_txBusy) {
    ser_txBuffer[ser_txIndexIn++] = c;
  }
  else {
    ser_txBusy = 1;
    SBUF = c;
  }

  ES=1;
}

unsigned char
ser_getc(void)
{
  char tmp;

#ifdef NON_BLOCKING
  if (ser_rxIndexIn != ser_rxIndexOut) {
    tmp = ser_rxBuffer[ser_rxIndexOut++];
  }
  else {
    tmp = 0;
  }
#endif

  return(tmp);
}

void
ser_printString(char *String)
{
  while (*String) {
    ser_putc(*String++);
  }
}

char
ser_charAvail(void)
{
  char ret = 0;

  if (ser_rxIndexIn != ser_rxIndexOut) {
    ret = 1;
  }

  return(ret);
}

/*********************End of File************************************/
/*-------------------------------------------------------------------------
   tolower.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

int tolower (int c)
{
  return (isupper (c) ? c + ('a' - 'A') : c);
}

/*-------------------------------------------------------------------------
   mbstowcs.c - convert a multibyte string to a wide character string

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#include <limits.h>

size_t mbstowcs(wchar_t *restrict pwcs, const char *restrict s, size_t n)
{
	size_t m = 0;
	while(n--)
	{
		int b = mbtowc(pwcs++, s, MB_LEN_MAX);
		if(!b)
			break;
		if(b < 0)
			return(-1);
		s += b;
		m++;
	}

	return(m);
}

/*-------------------------------------------------------------------------
   _strpbrk.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char * strpbrk ( const char * string, const char * control )
{
	char *ret = NULL;
	register char ch;

	while (ch = *control) {
		char * p = strchr(string, ch);
		if (p != NULL && (ret == NULL || p < ret)) {
			ret = p;
		}
		control++;
	}

	return (ret);
}
/*-------------------------------------------------------------------------
   isalpha.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

#ifdef isalpha
#undef isalpha
#endif

int isalpha (int c)
{
  return (isupper (c) || islower (c));
}

/*-------------------------------------------------------------------------
   sqrtf.c - Computes square root of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>

float sqrtf(float x) _FLOAT_FUNC_REENTRANT
{
    float f, y;
    int n;

    if (x==0.0) return x;
    else if (x==1.0) return 1.0;
    else if (x<0.0)
    {
        errno=EDOM;
        return 0.0;
    }
    f=frexpf(x, &n);
    y=0.41731+0.59016*f; /*Educated guess*/
    /*For a 24 bit mantisa (float), two iterations are sufficient*/
    y+=f/y;
    y=ldexpf(y, -2) + f/y; /*Faster version of 0.25 * y + f/y*/

    if (n&1)
    {
        y*=0.7071067812;
        ++n;
    }
    return ldexpf(y, n/2);
}
/*-------------------------------------------------------------------------
   isdigit.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* it is important to declare this function extern before including
   the inline definition to give it external linkage */
extern int isdigit (int c);

/* also include stdio.h before ctype.h here so ctype can perform a
   _Static_assert on EOF */
#include <stdio.h>

#include <ctype.h>
/*-------------------------------------------------------------------------
   _modslonglong.c - routine for modulo of 64 bit unsigned long long

   Copyright (C) 2014, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#pragma std_c99

#include <stdint.h>
#include <stdbool.h>

#ifdef __SDCC_LONGLONG
long long 
_modslonglong (long long numerator, long long denominator)
{
  bool numeratorneg = (numerator < 0);
  bool denominatorneg = (denominator < 0);
  long long r;

  if (numeratorneg)
    numerator = -numerator;
  if (denominatorneg)
    denominator = -denominator;

  r = (unsigned long long)numerator % (unsigned long long)denominator;

  return (numeratorneg ? -r : r);
}
#endif

/*-------------------------------------------------------------------------
   _divschar.c :- routine for signed char (8 bit) division. just calls
                  routine for signed int division after sign extension

   Copyright (C) 2013, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

signed int
_divschar (signed char x, signed char y)
{
  return ((int)x / (int)y);
}

signed int
_divuschar (unsigned char x, unsigned char y)
{
  return ((int)((signed char)x) / (int)y);
}

unsigned int
_divsuchar (signed char x, signed char y)
{
  return ((int)((unsigned char)x) / (int)y);
}

/*-------------------------------------------------------------------------
   _gptrgetc.c - get value for a generic pointer (used with --xram-movc)

   Copyright (c) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


/* the  return value is expected to be in acc, and not in the standard
 * location dpl. Therefore we choose return type void here: */

#if 1

void
_gptrgetc (char *gptr) __naked
{
/* This is the new version with pointers up to 16 bits.
   B cannot be trashed */

    gptr; /* hush the compiler */

    __asm
    ;   save values passed
    ;
    ;   depending on the pointer type acc. to SDCCsymt.h
    ;
    	jb		_B_7,codeptr$        ; >0x80 code		; 3
    	jnb		_B_6,xdataptr$       ; <0x40 far		; 3

        mov     dph,r0 ; save r0 independant of regbank	; 2
        mov     r0,dpl ; use only low order address		; 2

    	jb		_B_5,pdataptr$       ; >0x60 pdata		; 3
    ;
    ;   Pointer to data space
    ;
        mov     a,@r0									; 1
        mov     r0,dph ; restore r0						; 2
        mov     dph,#0 ; restore dph					; 2
        ret												; 1
    ;
    ;   pointer to external stack or pdata
    ;
 pdataptr$:
        movx    a,@r0									; 1
        mov     r0,dph ; restore r0						; 2
        mov     dph,#0 ; restore dph					; 2
        ret												; 1
;
;   pointer to xternal data
;   pointer to code area
;
 codeptr$:
 xdataptr$:
        clr     a										; 1
        movc    a,@a+dptr								; 1
        ret												; 1
        												;===
        												;28 bytes
     __endasm;
}

#else

void
_gptrgetc (char *gptr) __naked
{
    gptr; /* hush the compiler */

    __asm
    ;   save values passed
	xch    a,r0
	push   acc
    ;
    ;   depending on the pointer type acc. to SDCCsymt.h
    ;
        mov     a,b
        jz      00001$	; 0 near
	dec     a
	jz      00003$	; 1 far
        dec     a
        jz      00003$	; 2 code
	dec     a
	jz      00004$  ; 3 pdata
	dec     a	; 4 skip generic pointer
	dec     a
	jz      00001$	; 5 idata
    ;
    ;   any other value for type
    ;   return xFF
	mov     a,#0xff
	ret
    ;
    ;   Pointer to data space
    ;
 00001$:
	mov     r0,dpl     ; use only low order address
	mov     a,@r0
        ret
;
;   pointer to xternal data
;   pointer to code area
;
 00003$:
	; clr     a  is already 0
        movc    a,@a+dptr
        ret
;
;   pointer to xternal stack
;
 00004$:
	mov     r0,dpl
        movx    a,@r0
;
;   restore and return
;
        mov     r0,a
        pop     acc
        xch     a,r0
        ret
     __endasm;

}
#endif
/*-------------------------------------------------------------------------
   log10f.c - Computes the base 10 log of a 32 bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <errno.h>

float log10f(float x) _FLOAT_FUNC_REENTRANT
{
    return logf(x)*0.4342944819;
}
/*-------------------------------------------------------------------------
   asinf.c - Computes asin(x)

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#include <math.h>
#include <stdbool.h>

float asincosf(float x, bool isacos);

float asinf(float x) _FLOAT_FUNC_REENTRANT
{
         if (x == 1.0) return  HALF_PI;
    else if (x ==-1.0) return -HALF_PI;
    else if (x == 0.0) return 0.0;
    else               return asincosf(x, false);
}
/*-------------------------------------------------------------------------
   ser_ir.h - source file for serial routines

   Copyright (C) 1999, Josef Wolf <jw AT raven.inka.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include "ser_ir.h"

/* This file implements a serial interrupt handler and its supporting
* routines. Compared with the existing serial.c and _ser.c it has
* following advantages:
* - You can specify arbitrary buffer sizes (umm, up to 255 bytes),
*   so it can run on devices with _little_ memory like at89cx051.
* - It won't overwrite characters which already are stored in the
*   receive-/transmit-buffer.
*/

/* BUG: those definitions (and the #include) should be set dynamically
* (while linking or at runtime) to make this file a _real_ library.
*/
#include <8051.h>
#define XBUFLEN 4
#define RBUFLEN 8

/* You might want to specify idata, pdata or xdata for the buffers */
static unsigned char __pdata rbuf[RBUFLEN], xbuf[XBUFLEN];
static unsigned char rcnt, xcnt, rpos, xpos;
static __bit busy;

void
ser_init (void)
{
   ES = 0;
   rcnt = xcnt = rpos = xpos = 0;  /* init buffers */
   busy = 0;
   SCON = 0x50;
   PCON |= 0x80;                   /* SMOD = 1; */
   TMOD &= 0x0f;                   /* use timer 1 */
   TMOD |= 0x20;
   TL1 = -3; TH1 = -3; TR1 = 1;    /* 19200bps with 11.059MHz crystal */
   ES = 1;
}

void
ser_handler (void) __interrupt 4
{
   if (RI) {
	   RI = 0;
	   /* don't overwrite chars already in buffer */
	   if (rcnt < RBUFLEN)
		   rbuf [(unsigned char)(rpos+rcnt++) % RBUFLEN] = SBUF;
   }
   if (TI) {
	   TI = 0;
	   if (busy = xcnt) {   /* Assignment, _not_ comparison! */
		   xcnt--;
		   SBUF = xbuf [xpos++];
		   if (xpos >= XBUFLEN)
			   xpos = 0;
	   }
   }
}

void
ser_putc (unsigned char c)
{
   while (xcnt >= XBUFLEN) /* wait for room in buffer */
	   ;
   ES = 0;
   if (busy) {
	   xbuf[(unsigned char)(xpos+xcnt++) % XBUFLEN] = c;
   } else {
	   SBUF = c;
	   busy = 1;
   }
   ES = 1;
}

unsigned char
ser_getc (void)
{
   unsigned char c;
   while (!rcnt)   /* wait for character */
	   ;
   ES = 0;
   rcnt--;
   c = rbuf [rpos++];
   if (rpos >= RBUFLEN)
	   rpos = 0;
   ES = 1;
   return (c);
}

#pragma save
#pragma noinduction
void
ser_puts (unsigned char *s)
{
   unsigned char c;
   while (c=*s++) {
	   if (c == '\n') ser_putc ('\r');
	   ser_putc (c);
   }
}
#pragma restore

void
ser_gets (unsigned char *s, unsigned char len)
{
   unsigned char pos, c;

   pos = 0;
   while (pos <= len) {
	   c = ser_getc ();
	   if (c == '\r') continue;        /* discard CR's */
	   s[pos++] = c;
	   if (c == '\n') break;           /* NL terminates */
   }
   s[pos] = '\0';
}

unsigned char
ser_can_xmt (void)
{
   return XBUFLEN - xcnt;
}

unsigned char
ser_can_rcv (void)
{
   return rcnt;
}
/*-------------------------------------------------------------------------
   isgraph.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

int isgraph (int c)
{
  return (c > ' ' && c <= '~');
}

/*-------------------------------------------------------------------------
   wcscmp.c - compare strings

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <wchar.h>

int wcscmp(const wchar_t *s1, const wchar_t *s2)
{
	while(*s1 == *s2 && *s1)
		s1++, s2++;

	if(*s1 < *s2)
		return(-1);
	if(*s1 > *s2)
		return(1);
	return(0);
}

/*-------------------------------------------------------------------------
   _divuint.c - routine for unsigned int (16 bit) division

   Copyright (C) 1999, Jean-Louis Vern <jlvern AT gmail.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*   Assembler-functions are provided for:
     mcs51 small
     mcs51 small stack-auto
*/

#include <stdbool.h>

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO)
#        define _DIVUINT_ASM_SMALL_AUTO
#      else
#        define _DIVUINT_ASM_SMALL
#      endif
#    endif
#  endif
#endif

#if defined _DIVUINT_ASM_SMALL || defined _DIVUINT_ASM_SMALL_AUTO

static void
_divuint_dummy (void) __naked
{
	__asm

	.globl __divuint

__divuint:

	#define count   r2
	#define reste_l r3
	#define reste_h r4
	#define xl      dpl
	#define xh      dph

#if defined(__SDCC_PARMS_IN_BANK1)
	#define yl      (b1_0)
	#define yh      (b1_1)
#else // __SDCC_PARMS_IN_BANK1
  #if defined(__SDCC_STACK_AUTO)

	.globl __divint

	mov	a,sp
	add	a,#-2		; 2 bytes return address
	mov	r0,a		; r0 points to yh
	mov	a,@r0		; load yh
	mov	r1,a
	dec	r0
	mov	a,@r0		; load yl
	mov	r0,a

	#define yl      r0
	#define yh      r1

__divint:			; entry point for __divsint


  #else // __SDCC_STACK_AUTO

    #if defined(__SDCC_NOOVERLAY)
	.area DSEG    (DATA)
    #else
	.area OSEG    (OVR,DATA)
    #endif

	.globl __divuint_PARM_2
	.globl __divsint_PARM_2

__divuint_PARM_2:
__divsint_PARM_2:
	.ds	2

	.area CSEG    (CODE)

	#define yl      (__divuint_PARM_2)
	#define yh      (__divuint_PARM_2 + 1)

  #endif // __SDCC_STACK_AUTO
#endif // __SDCC_PARMS_IN_BANK1

	mov	count,#16
	clr	a
	mov	reste_l,a
	mov	reste_h,a

loop:
	mov	a,xl		; x <<= 1
	add	a,acc
	mov	xl,a
	mov	a,xh
	rlc	a
	mov	xh,a

	mov	a,reste_l	; reste <<= 1
	rlc	a		;   feed in carry
	mov	reste_l,a
	mov	a,reste_h
	rlc	a
	mov	reste_h,a

	mov	a,reste_l	; reste - y
	subb	a,yl		; here carry is always clear, because
					; reste <<= 1 never overflows
	mov	b,a
	mov	a,reste_h
	subb	a,yh

	jc	smaller		; reste >= y?

	mov	reste_h,a	; -> yes;  reste = reste - y;
	mov	reste_l,b
	orl	xl,#1
smaller:			; -> no
	djnz	count,loop
	ret

	__endasm;
}

#else  // defined _DIVUINT_ASM_SMALL || defined _DIVUINT_ASM_SMALL_AUTO

#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1)

unsigned int
_divuint (unsigned int x, unsigned int y)
{
  unsigned int reste = 0;
  unsigned char count = 16;
  bool c;

  do
  {
    // reste: x <- 0;
    c = MSB_SET(x);
    x <<= 1;
    reste <<= 1;
    if (c)
      reste |= 1;

    if (reste >= y)
    {
      reste -= y;
      // x <- (result = 1)
      x |= 1;
    }
  }
  while (--count);
  return x;
}

#endif  // defined _DIVUINT_ASM_SMALL || defined _DIVUINT_ASM_SMALL_AUTO
/*-------------------------------------------------------------------------
   wctomb.c - convert a wide character string to a multibyte string

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#include <limits.h>

size_t wcstombs(char *restrict s, const wchar_t *restrict pwcs, size_t n)
{
	size_t m = 0;
	char buffer[MB_LEN_MAX];

	while(n > MB_LEN_MAX || n >= wctomb(buffer, *pwcs))
	{
		int b = wctomb(s, *pwcs);

		if(b == 1 && !*s)
			break;
		if(b < 0)
			return(-1);

		n -= b;
		m += b;
		s += b;
		pwcs++;
	}

	return(m);
}

/*-------------------------------------------------------------------------
   _mulint.c - routine for (unsigned) int (16 bit) multiplication

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Signed and unsigned multiplication are the same - as long as the output
   has the same precision as the input.

   Assembler-functions are provided for:
     hc08
     hc08 stack-auto
*/


#if !defined(_SDCC_NO_ASM_LIB_FUNCS)

#pragma save
#pragma less_pedantic
int
_mulint (int a, int b)
{
  a,b;	/* reference to make compiler happy */

#if !defined(__SDCC_STACK_AUTO)
    __asm
   	ais #-2
	psha
	pshx

	ldx __mulint_PARM_2+1
	mul
	sta 4,s
	stx 3,s

	lda 1,s
	ldx __mulint_PARM_2+1
	mul
	add 3,s
	sta 3,s

	lda 2,s
	ldx __mulint_PARM_2
	mul
	add 3,s
	sta 3,s

	ais #2
	pulx
	pula
    __endasm;
#else
    __asm
   	ais #-2
	psha
	pshx

	ldx 8,s
	mul
	sta 4,s
	stx 3,s

	lda 1,s
	ldx 8,s
	mul
	add 3,s
	sta 3,s

	lda 2,s
	ldx 7,s
	mul
	add 3,s
	sta 3,s

	ais #2
	pulx
	pula
    __endasm;
#endif
}
#pragma restore

#else

union uu {
	struct { unsigned char hi,lo ;} s;
        unsigned int t;
} ;

int
_mulint (int a, int b)
{
#if !defined(__SDCC_STACK_AUTO) && (defined(__SDCC_MODEL_LARGE) || defined(__SDCC_ds390))	// still needed for large
	union uu __xdata *x;
	union uu __xdata *y;
	union uu t;
        x = (union uu __xdata *)&a;
        y = (union uu __xdata *)&b;
#else
	register union uu *x;
	register union uu *y;
	union uu t;
        x = (union uu *)&a;
        y = (union uu *)&b;
#endif

        t.t = x->s.lo * y->s.lo;
        t.s.hi += (x->s.lo * y->s.hi) + (x->s.hi * y->s.lo);

       return t.t;
}
#endif


#undef _MULINT_ASM

/*
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
*/

#include <stdatomic.h>

_Bool atomic_flag_test_and_set(volatile atomic_flag *object) __naked
{
  object; // avoid warning 85 unreferenced function argument
__asm
	pshx
	pulh
	tax
	clra
	lsr	,x
	rola
	eor	#0x01
	rts
__endasm;
}

/*-------------------------------------------------------------------------
   setjmp.c - source file for ANSI routines setjmp & longjmp

   Copyright (C) 2016, Maarten Brock. sourceforge.brock AT dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>
#define __SDCC_HIDE_LONGJMP
#include <setjmp.h>

static void dummy (void) __naked
{
        __asm

;--------------------------------------------------------
; overlayable items in ram
;--------------------------------------------------------
        .area   OSEG    (PAG, OVR)
___setjmp_buf:
        .ds 2
        .area   OSEG    (PAG, OVR)
_longjmp_buf:
        .ds 2
;--------------------------------------------------------
; extended address mode data
;--------------------------------------------------------
        .area XSEG
_longjmp_PARM_2:
        .ds 2
;--------------------------------------------------------
; code
;--------------------------------------------------------
        .area CSEG    (CODE)
;------------------------------------------------------------
;Allocation info for local variables in function '__setjmp'
;------------------------------------------------------------
;buf                       Allocated with name '___setjmp_buf'
;------------------------------------------------------------
;_setjmp.c:205: int __setjmp (jmp_buf buf)
;       -----------------------------------------
;        function __setjmp
;       -----------------------------------------
;       Stack space usage: 1 bytes.
        .globl ___setjmp
___setjmp:
        stx	(___setjmp_buf + 0)		; msb(buf)
        sta	(___setjmp_buf + 1)		; lsb(buf)

        ; save stack pointer
        tsx
        pshh
        txa
        ldhx	(___setjmp_buf)
        sta	1,x
        pula
        sta	0,x

        ; save return address
        lda	1,s
        sta	2,x
        lda	2,s
        sta	3,x

        ; return 0
        clra
        tax
        rts

;------------------------------------------------------------
;Allocation info for local variables in function 'longjmp'
;------------------------------------------------------------
;rv                        Allocated with name '_longjmp_PARM_2'
;buf                       Allocated with name '_longjmp_buf'
;------------------------------------------------------------
;_setjmp.c:216: int longjmp (jmp_buf buf, int rv)
;       -----------------------------------------
;        function longjmp
;       -----------------------------------------
;       Stack space usage: 1 bytes.
        .globl _longjmp
        .globl _longjmp_PARM_2
_longjmp:
        stx	(_longjmp_buf + 0)		; msb(buf)
        sta	(_longjmp_buf + 1)		; lsb(buf)

        ; restore stack pointer
        ldhx	(_longjmp_buf)
        lda	0,x
        psha
        ldx	1,x
        pulh
        txs

        ; set return address
        ldhx	(_longjmp_buf)
        lda	2,x
        sta	1,s
        lda	3,x
        sta	2,s

;_setjmp.c:224: return rv ? rv : 1;
        ldx     (_longjmp_PARM_2 + 0)
        txa
        ora     (_longjmp_PARM_2 + 1)
        beq     0001$
        lda     (_longjmp_PARM_2 + 1)
        rts
0001$:
        lda     #0x01
        rts

        __endasm;
}
/*-------------------------------------------------------------------------
   _ret.c

   Copyright (C) 2003, Erik Petrich
   Copyright (C) 2012, Philipp Klaus Krause
   Considering how short this file is, it is probably not copyrightable, though.

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

__data unsigned char __SDCC_hc08_ret2;
__data unsigned char __SDCC_hc08_ret3;
__data unsigned char __SDCC_hc08_ret4;
__data unsigned char __SDCC_hc08_ret5;
__data unsigned char __SDCC_hc08_ret6;
__data unsigned char __SDCC_hc08_ret7;

;--------------------------------------------------------------------------
;  modunsigned.s
;
;  Copyright (C) 2009-2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__moduchar
.globl	__moduint

__moduchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __divu8

	ex	de,hl

        ret

__moduint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __divu16

        ex      de,hl

        ret

;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2001, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; Just stubs - not copyrightable

        ;; Stubs that hook the heap in
        .globl  ___sdcc_heap_init

        .area   _GSINIT
        call    ___sdcc_heap_init

        .area   _HEAP
___sdcc_heap::
        ;; For now just allocate 1k of heap.
        .ds     1023

        .area   _HEAP_END
___sdcc_heap_end::
        .ds     1
;--------------------------------------------------------------------------
;  __ltoa.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___ltoa
	.globl ___ultoa
;
;void __itoa(long value, char *string, unsigned char radix);
;
___ltoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	8(ix) - string
;	10(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
	bit	7, 7 (ix)
	jr	Z, ___ultoa_de
;positive/negative numbers are supported only for radix=10
	ld	a, 10 (ix)
	cp	a, #10
	jr	NZ, ___ultoa_de
;add minus sign to result and inverse value
	ld	hl, #0
	or	a, a
	sbc	hl, de
	ex	de, hl
	ld	hl, #0
	ld	c, 6 (ix)
	ld	b, 7 (ix)
	sbc	hl, bc
	ld	6 (ix), l
	ld	7 (ix), h
	ld	l, 8 (ix)
	ld	h, 9 (ix)
	ld	(hl), #0x2D	;minus symbol
	inc	hl
	ld	8 (ix), l
	ld	9 (ix), h
	jr	___ultoa_dehl
;
;void __uitoa(unsigned int value, char *string, unsigned char radix);
;
___ultoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	8(ix) - string
;	10(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
;
___ultoa_de:
	ld	l, 8 (ix)
	ld	h, 9 (ix)
;
___ultoa_dehl:
	ld	a, e
	or	a, d
	or	a, 6 (ix)
	or	a, 7 (ix)
	jr	NZ, 100$
;
	ld	(hl), #0x30
	inc	hl
	jp	190$
100$:
	ld	a, 10 (ix)
	cp	a, #10		;most popular radix
	jr	NZ, 110$
;
;-------- decimal convertion
;this algorithm is 20% faster than generic one
;
	ld	c, l
	ld	b, h
	ld	hl, #-5
	add	hl, sp
	ld	sp, hl
	push	bc
	push	hl
	ld	c, 6 (ix)
	ld	b, 7 (ix)
	push	bc
	push	de
	call	___ultobcd
	ld	hl, #6
	add	hl, sp
	ld	sp, hl
	pop	de		;DE - pointer to string
	inc	hl
	inc	hl		;HL - pointer to BCD value
	ld	b, #5		;number of bytes in BCD value
	ld	a, #0x30	;ASCII code of '0'
103$:
	rrd
	ld	(de), a
	inc	de
	rrd
	ld	(de), a
	inc	de
	inc	hl
	djnz	103$
;
;	ld	sp, hl
;skip trailing zeroes
	ld	b, #10		;real decimal number is at most 10 digits
105$:
	dec	de
	ld	a, (de)
	cp	a, #0x30
	jr	NZ, 107$	;break loop if non-zero found
	djnz	105$
107$:
	inc	de		;always point to symbol next to last significant
	ex	de, hl
	jr	190$
;
;---------------------------
;
110$:
	cp	a, #2
	jr	C, 190$		;radix is less than 2
;
	ld	c, a
	dec	c
	and	a, c
	jr	NZ, 150$
;
;-------- radix is power of 2
;
; DE - lower 16 bits of value, HL - pointer to string, C - mask
120$:
	ld	a, e
	ld	b, c
125$:
	srl	7 (ix)
	rr	6 (ix)
	rr	d
	rr	e
	srl	b
	jr	NZ, 125$
;
	and	a, c
	add	a, #0x30
	cp	a, #0x3A ;convert to 0...9A...Z
	jr	C, 130$
	add	a, #7
130$:
	ld	(hl), a
	inc	hl
	ld	a, e
	or	a, d
	or	a, 6 (ix)
	or	a, 7 (ix)
	jr	NZ, 120$
	jr	190$
;
;---------------------------
;
;-------- custom radix (generic algorithm)
;
150$:
	ex	de, hl
	ld	c, e
	ld	b, d
	ld	e, 6 (ix)
	ld	d, 7 (ix)
160$:
	push	bc
	ld	c, 10 (ix)
	call	___divu32_8
	pop	bc
	add	a, #0x30
	cp	a, #0x3A
	jr	C, 165$
	add	a, #7
165$:
	ld	(bc), a
	inc	bc
	ld	a, l
	or	a, h
	or	a, e
	or	a, d
	jr	NZ, 160$
	ld	l, c
	ld	h, b
;	jr	190$
;
;---------------------------
;
;-------- finish string and reverse order
190$:
	ld	(hl), #0
	ld	e, 8 (ix)
	ld	d, 9 (ix)
	call	___strreverse_reg
	ld	sp, ix
	pop	ix
	ret
;
;in: DEHL - divident, C - divisor
;out: DEHL - quotient, A - remainder
___divu32_8:
	xor	a, a
	ld	b, #32
100$:
	add	hl, hl
	rl	e
	rl	d
	rla
	jr	c, 110$
	cp	a, c
	jr	c, 120$
110$:
	sub	a, c
	inc	l
120$:
	djnz	100$
	ret

;--------------------------------------------------------------------------
;  memcpy.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memcpy
	.globl ___memcpy

; The Z80 has the ldir instruction, which is perfect for implementing memcpy().
_memcpy:
___memcpy:
	pop	af
	pop	hl	;return value expected to be in HL, so pop dst to HL
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	ex	de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  modmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__modsuchar
.globl	__moduschar

__modsuchar:
	ld      hl,#2+1
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)
	ld      h,#0

	call    __div_signexte

	jp	__get_remainder

__moduschar:
	ld      hl,#2+1
	ld      d, h
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)

	ld      a,l	; Sign extend
	rlca
	sbc     a, a
	ld      h, a

	call	__div16

	jp	__get_remainder

;--------------------------------------------------------------------------
;  strcpy.s
;
;  Copyright (C) 2012, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strcpy

_strcpy:
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
	push	de
	xor	a, a
loop:
	cp	a, (hl)
	ldi
	jr	NZ, loop
	pop	hl
	ret

;--------------------------------------------------------------------------
;  divsigned.s
;
;  Copyright (C) 2000-2010, Michael Hope, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area	_CODE

.globl	__divsint
.globl	__divschar

__divsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jp      __div16

__divschar:
        ld      hl, #2+1
        add     hl, sp

        ld      e, (hl)
        dec     hl
        ld      l, (hl)

__div8::
        ld      a, l            ; Sign extend
        rlca
        sbc     a,a
        ld      h, a
__div_signexte::
        ld      a, e            ; Sign extend
        rlca
        sbc     a,a
        ld      d, a
        ; Fall through to __div16

        ;; signed 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;
        ;; Register used: AF,B,DE,HL
__div16::
        ;; Determine sign of quotient by xor-ing high bytes of dividend
        ;;  and divisor. Quotient is positive if signs are the same, negative
        ;;  if signs are different
        ;; Remainder has same sign as dividend
        ld      a, h            ; Get high byte of dividend
        xor     a, d            ; Xor with high byte of divisor
        rla                     ; Sign of quotient goes into the carry
        ld      a, h            ; Get high byte of dividend
        push    af              ; Save sign of both quotient and reminder

        ; Take absolute value of dividend
        rla
        jr      NC, .chkde      ; Jump if dividend is positive
        sub     a, a            ; Substract dividend from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a

        ; Take absolute value of divisor
.chkde:
        bit     7, d
        jr      Z, .dodiv       ; Jump if divisor is positive
        sub     a, a            ; Subtract divisor from 0
        sub     a, e
        ld      e, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, d
        ld      d, a

        ; Divide absolute values
.dodiv:
        call    __divu16

.fix_quotient:
        ; Negate quotient if it is negative
        pop     af              ; recover sign of quotient
        ret	NC		; Jump if quotient is positive
        ld      b, a
        sub     a, a            ; Subtract quotient from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ld      a, b
	ret

__get_remainder::
        ; Negate remainder if it is negative and move it into hl
        rla
	ex	de, hl
        ret     NC              ; Return if remainder is positive
        sub     a, a            ; Subtract remainder from 0
        sub     a, l
        ld      l, a
        sbc     a, a             ; Propagate remainder (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ret

;--------------------------------------------------------------------------
;  divunsigned.s
;
;  Copyright (C) 2000-2012, Michael Hope, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        ;; Originally from GBDK by Pascal Felber.

.area   _CODE

.globl	__divuint
.globl	__divuchar

__divuint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jr      __divu16

__divuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ;; Fall through
__divu8::
        ld      h,#0x00
        ld      d,h
        ; Fall through to __divu16

        ;; unsigned 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;   carry = 0
        ;;   If divisor is 0, quotient is set to "infinity", i.e HL = 0xFFFF.
        ;;
        ;; Register used: AF,B,DE,HL
__divu16::
        ;; Two algorithms: one assumes divisor <2^7, the second
        ;; assumes divisor >=2^7; choose the applicable one.
        ld      a,e
        and     a,#0x80
        or      a,d
        jr      NZ,.morethan7bits
        ;; Both algorithms "rotate" 24 bits (H,L,A) but roles change.

        ;; unsigned 16/7-bit division
.atmost7bits:
        ld      b,#16           ; bits in dividend and possible quotient
        ;; Carry cleared by AND/OR, this "0" bit will pass trough HL.[*]
        adc     hl,hl
.dvloop7:
        ;; HL holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry.
        ;; A holds remainder.
        rla

        ;; If remainder is >= divisor, next bit of quotient is 1.  We try
        ;;  to compute the difference.
        sub     a,e
        jr      NC,.nodrop7     ; Jump if remainder is >= dividend
        add     a,e             ; Otherwise, restore remainder
        ;; The add above sets the carry, because sbc a,e did set it.
.nodrop7:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        adc     hl,hl
        djnz    .dvloop7
        ;; Carry now contains the same value it contained before
        ;; entering .dvloop7[*]: "0" = valid result.
        ld      e,a             ; DE = remainder, HL = quotient
        ret

.morethan7bits:
        ld      b,#9            ; at most 9 bits in quotient.
        ld      a,l             ; precompute the first 7 shifts, by
        ld      l,h             ;  doing 8
        ld      h,#0
        rr      l               ;  undoing 1
.dvloop:
        ;; Shift next bit of quotient into bit 0 of dividend
        ;; Shift next MSB of dividend into LSB of remainder
        ;; A holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry
        ;; HL holds remainder
        adc     hl,hl           ; HL < 2^(7+9), no carry, ever.

        ;; If remainder is >= divisor, next bit of quotient is 1. We try
        ;;  to compute the difference.
        sbc     hl,de
        jr      NC,.nodrop      ; Jump if remainder is >= dividend
        add     hl,de           ; Otherwise, restore remainder
	;; The add above sets the carry, because sbc hl,de did set it.
.nodrop:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        rla
        djnz    .dvloop
        ;; Take care of the ninth quotient bit! after the loop B=0.
        rl      b               ; BA = quotient
        ;; Carry now contains "0" = valid result.
        ld      d,b
        ld      e,a             ; DE = quotient, HL = remainder
        ex      de,hl           ; HL = quotient, DE = remainder
        ret

;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _atomic_flag_test_and_set

_atomic_flag_test_and_set:
	pop	de
	pop	hl
	push	hl
	push	de
	xor a, a
	srl	(hl)
	ccf
	rla
	ld	l, a
	ret

;--------------------------------------------------------------------------
;  __strreverse.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___strreverse
	.globl ___strreverse_reg
;
;void __reverse(char *beg, char *end);
;
___strreverse::
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
;
;in: HL - pointer to end of string (null symbol), DE - pointer to start of string
;
___strreverse_reg::
	jr	110$
100$:
	add	hl, de
	ld	a, (de)
	ld	c, (hl)
	ld	(hl), a
	ld	a, c
	ld	(de), a
	inc	de
110$:
	dec	hl
	or	a, a
	sbc	hl, de
	jr	NC, 100$
	ret
;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (c) 2017, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

; unsigned char x unsigned char multiplication is done by code generation.

.globl	__mulsuchar
.globl	__muluschar
.globl	__mulschar

; operands have different sign

__mulsuchar:
        ld      hl,#2+1
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        jr      signexte

__muluschar:
        ld      hl,#2
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      c,(hl)
        jr      signexte

__mulschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)

        ;; Need to sign extend before going in.
        ld      a,c
        rla
        sbc     a,a
        ld      b,a
signexte:
        ld      a,e
        rla
        sbc     a,a
        ld      d,a

        jp      __mul16

;--------------------------------------------------------------------------
;  crtenter.s
;
;  Copyright (C) 2015, Alan Cox, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_enter_ix

; Factor out some start of function code to reduce code size

___sdcc_enter_ix:
	pop	hl	; return address
	push	ix	; save frame pointer
	ld	ix, #0
	add	ix, sp	; set ix to the stack frame
	jp	(hl)	; and return

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_iy

; The Z80 has the jp (iy) instruction, which is perfect for implementing function pointers.

___sdcc_call_iy:
	jp	(iy)

;--------------------------------------------------------------------------
;  memmove.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memmove

; The Z80 has the ldir and lddr instructions, which are perfect for implementing memmove().

_memmove:
	pop	af
	pop	hl
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	sbc	hl, de		; or above cleared carry.
	add	hl, de		; same carry as the line before
	jr	C, memmove_up
memmove_down:
	dec	bc
	add	hl, bc
	ex      de, hl
	add	hl, bc
	inc	bc
	lddr
	pop	hl
	ret
memmove_up:
	ex      de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  setjmp.s
;
;  Copyright (C) 2011-2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___setjmp

___setjmp:
	pop	hl
	pop	iy
	push	af
	push	hl

	; Store return address.
	ld	0(iy), l
	ld	1(iy), h

	; Store stack pointer.
	xor	a, a
	ld	l, a
	ld	h, a
	add	hl, sp
	ld	2(iy), l
	ld	3(iy), h

	; Store frame pointer.
	push	ix
	pop	hl
	ld	4(iy), l
	ld	5(iy), h

	; Return 0.
	ld	l, a
	ld	h, a
	ret

.globl _longjmp

_longjmp:
	pop	af
	pop	iy
	pop	de

	; Ensure that return value is non-zero.
	ld	a, e
	or	a, d
	jr	NZ, jump
	inc	de
jump:

	; Restore frame pointer.
	ld	l, 4(iy)
	ld	h, 5(iy)
	push	hl
	pop	ix

	; Adjust stack pointer.
	ld	l, 2(iy)
	ld	h, 3(iy)
	ld	sp, hl
	pop	hl

	; Move return value into hl.
	ex	de, hl

	; Jump.
	ld	c, 0(iy)
	ld	b, 1(iy)
	push	bc
	ret
;--------------------------------------------------------------------------
;  __uitobcd.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___uitobcd
;
; void __uitobcd (unsigned int v, unsigned char bcd[3])
; __uitobcd converts v to BCD representation to the bcd.
; bcd[] will contain BCD value.
;
___uitobcd:
	push	ix
	ld	ix, #0
	add	ix, sp
;
	ld	bc, #0x1000
	ld	d, c
	ld	e, c
	ld	l, 4 (ix)
	ld	h, 5 (ix)
;
;--- begin speed optimization
;
	ld	a, h
	or	a, a
	jr	NZ, 100$
;
	ld	h, l
	srl	b
;
;--- end speed optimization
;
; HL - binary value
; CDE - future BCD value
; B - bits count (16)
100$:
	add	hl, hl
	ld	a, e
	adc	a, a
	daa
	ld	e, a
	ld	a, d
	adc	a, a
	daa
	ld	d, a
	ld	a, c
	adc	a, a
	daa
	ld	c, a
	djnz	100$
;
	ld	l, 6 (ix)
	ld	h, 7 (ix)
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	ld	(hl), c
;
	pop	ix
	ret
;--------------------------------------------------------------------------
;  abs.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _abs

; 12B; 86T for nonnegative arguments, 78T for negative.
_abs:
	pop	hl
	pop	de
	push	de
	push	hl
	xor	a, a
	ld	l, a
	ld	h, a
	sbc	hl, de
	ret	P
	ex	de, hl
	ret

; 14B; 59T for nonegative arguments, 94T for negative:
;_abs:
;	pop	de
;	pop	hl
;	push	hl
;	push	de
;	bit	7, h
;	ret	Z
;	xor	a, a
;	ld	e, a
;	ld	d, a
;	ex	de, hl
;	sbc	hl, de
;	ret

;--------------------------------------------------------------------------
;  strlen.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strlen

; The Z80 has the cpir instruction, which is perfect for implementing strlen().

_strlen:
	pop	bc
	pop	hl
	push	hl
	push	bc
	xor	a, a
	ld	b, a
	ld	c, a
	cpir
	ld	hl, #-1
	sbc	hl, bc	; C flag still cleared from xor above.
	ret

;--------------------------------------------------------------------------
;  __ultobcd.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___ultobcd
;
; void __ultobcd (unsigned long v, unsigned char bcd[5])
; __ultobcd converts v to BCD representation to the bcd.
; bcd[] will contain BCD value.
;
___ultobcd:
	push	ix
	ld	ix, #0
	add	ix, sp
	ld	bc, #0x2000
;
;--- begin speed optimization
;
	ld	l, 4 (ix)
	ld	h, 5 (ix)
	ld	e, 6 (ix)
	ld	d, 7 (ix)
	ld	a, e
	or	a, d
	jr	NZ, 101$
;high 2 bytes are zero
	ld	b, #0x10
	ex	de, hl
101$:
	ld	a, d
	or	a, a
	jr	NZ, 102$
;high byte is zero
	ld	d, e
	ld	e, h
	ld	h, l
	ld	a, #-8
	add	a, b
	ld	b, a
102$:
	ld	4 (ix), l
	ld	5 (ix), h
	ld	6 (ix), e
	ld	7 (ix), d
;
;--- end speed optimization
;
	ld	hl, #0x0000
	ld	e, l
	ld	d, h
; (ix+0)..(ix+3) - binary value
; CDEHL - future BCD value
; B - bits count (32)
103$:
	sla	4 (ix)
	rl	5 (ix)
	rl	6 (ix)
	rl	7 (ix)
	ld	a, l
	adc	a, a
	daa
	ld	l, a
	ld	a, h
	adc	a, a
	daa
	ld	h, a
	ld	a, e
	adc	a, a
	daa
	ld	e, a
	ld	a, d
	adc	a, a
	daa
	ld	d, a
	ld	a, c
	adc	a, a
	daa
	ld	c, a
	djnz	103$
;
	ld	b, l
	ld	a, h
	ld	l, 8 (ix)
	ld	h, 9 (ix)
	ld	(hl), b
	inc	hl
	ld	(hl), a
	inc	hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	ld	(hl), c
;
	pop	ix
	ret
;--------------------------------------------------------------------------
;  divmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__divsuchar
.globl	__divuschar

__divsuchar:
	ld	hl, #2+1
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)
	ld	h, #0

	jp	__div_signexte

__divuschar:
	ld	hl, #2+1
	ld	d, h
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)

	ld 	a, l	; Sign extend
	rlca
	sbc	a, a
	ld	h, a

	jp	__div16

;--------------------------------------------------------------------------
;  __itoa.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___itoa
	.globl ___uitoa
;
;void __itoa(int value, char *string, unsigned char radix);
;
___itoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	6(ix) - string
;	8(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
	bit	7, d
	jr	Z, ___uitoa_de
;positive/negative numbers are supported only for radix=10
	ld	a, 8 (ix)
	cp	a, #10
	jr	NZ, ___uitoa_de
;add minus sign to result and inverse value
	ld	hl, #0
	or	a, a
	sbc	hl, de
	ex	de, hl
	ld	l, 6 (ix)
	ld	h, 7 (ix)
	ld	(hl), #0x2D	;minus symbol
	inc	hl
	ld	6 (ix), l
	ld	7 (ix), h
	jr	___uitoa_dehl
;
;void __uitoa(unsigned int value, char *string, unsigned char radix);
;
___uitoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	6(ix) - string
;	8(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
;
___uitoa_de:
	ld	l, 6 (ix)
	ld	h, 7 (ix)
;
___uitoa_dehl:
	ld	a, e
	or	a, d
	jr	NZ, 100$
;
	ld	(hl), #0x30
	inc	hl
	jp	190$
100$:
	ld	a, 8 (ix)
	cp	a, #10		;most popular radix
	jr	NZ, 110$
;
;-------- decimal convertion
; this algorithm up to 2 times faster than generic
;
	ld	c, l
	ld	b, h
	ld	hl, #-4
	add	hl, sp
	ld	sp, hl
	push	bc
	push	hl
	push	de
	call	___uitobcd
	ld	hl, #4
	add	hl, sp
	ld	sp, hl
	pop	de		;DE - pointer to string
	inc	hl
	inc	hl		;HL - pointer to BCD value
	ld	b, #3		;number of bytes in BCD value
	ld	a, #0x30	;ASCII code of '0'
103$:
	rrd
	ld	(de), a
	inc	de
	rrd
	ld	(de), a
	inc	de
	inc	hl
	djnz	103$
;
;	pop	af
;	pop	af
;skip trailing zeroes
	ld	b, #5		;real BCD number is at most 5 digits
	dec	de		;so always skip last zero
105$:
	dec	de
	ld	a, (de)
	cp	a, #0x30
	jr	NZ, 107$	;break loop if non-zero found
	djnz	105$
107$:
	inc	de		;always point to symbol next to last significant
	ex	de, hl
	jr	190$
;
;---------------------------
;
110$:
	cp	a, #2
	jr	C, 190$		;radix is less than 2
;
	ld	c, a
	dec	c
	and	a, c
	jr	NZ, 150$
;
;-------- radix is power of 2
;
; DE - value, HL - pointer to string, C - mask
120$:
	ld	a, e
	ld	b, c
125$:
	srl	d
	rr	e
	srl	b
	jr	NZ, 125$
;
	and	a, c
	add	a, #0x30
	cp	a, #0x3A ;convert to 0...9A...Z
	jr	C, 130$
	add	a, #7
130$:
	ld	(hl), a
	inc	hl
	ld	a, e
	or	a, d
	jr	NZ, 120$
	jr	190$
;
;---------------------------
;
;-------- custom radix (generic algorithm)
;
150$:
	ex	de, hl
160$:
	ld	c, 8 (ix)
	call	___divu16_8
	add	a, #0x30
	cp	a, #0x3A
	jr	C, 165$
	add	a, #7
165$:
	ld	(de), a
	inc	de
	ld	a, l
	or	h
	jr	NZ, 160$
	ex	de, hl
;	jr	190$
;
;---------------------------
;
;-------- finish string and reverse order
190$:
	ld	(hl), #0
	ld	e, 6 (ix)
	ld	d, 7 (ix)
	call	___strreverse_reg
	ld	sp, ix
	pop	ix
	ret
;
;
;in: HL - divident, C - divisor
;out: HL - quotient, A - remainder
___divu16_8:
	xor	a, a
	ld	b, #16
100$:
	add	hl, hl
	rla
	jr	c, 110$
	cp	a, c
	jr	c, 120$
110$:
	sub	a, c
	inc	l
120$:
	djnz	100$
	ret

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_hl

; The Z80 has the jp (hl) instruction, which is perfect for implementing function pointers.

___sdcc_call_hl:
	jp	(hl)

;--------------------------------------------------------------------------
;  __sdcc_bcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; This file contains generic trampolines for banked function calls.
; They are not complete. Programmer must provide set_bank and get_bank
; routines. Or rewrite whole code completely.
;
	.area   _CODE

	.globl ___sdcc_bcall
	.globl ___sdcc_bcall_abc
	.globl ___sdcc_bcall_ehl
;
; trampoline to call banked functions
; used when legacy banking is enabled only
; Usage:
;   call ___sdcc_bcall
;   .dw  <function>
;   .dw  <function_bank>
;
___sdcc_bcall::
	ex	(sp), hl
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	ld	a, (hl)
	inc	hl
	inc	hl
	ex	(sp), hl
;
; trampoline to call banked functions with __z88dk_fastcall calling convention
; Usage:
;  ld   a, #<function_bank>
;  ld   bc, #<function>
;  call ___sdcc_bcall_abc
;
___sdcc_bcall_abc::
	push	hl
	ld	l, a
	call	get_bank	;must return A as current bank number, other registers expected to be unchanged
	ld	h, a
	ld	a, l
	ex	(sp), hl
	inc	sp
	call	___sdcc_bjump_abc
	dec	sp
	pop	af
	jp	set_bank
;
___sdcc_bjump_abc:
	call	set_bank	;set current bank to A, other registers expected to be unchanged
	push	bc
	ret
;
; default trampoline to call banked functions
; Usage:
;  ld   e, #<function_bank>
;  ld   hl, #<function>
;  call ___sdcc_bcall_ehl
;
___sdcc_bcall_ehl::
	call	get_bank
	push	af
	inc	sp
	call	___sdcc_bjump_ehl
	dec	sp
	pop	af
	jp	set_bank
;
___sdcc_bjump_ehl:
	ld	a, e
	call	set_bank
	jp	(hl)
;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__mulint

__mulint:
        pop     af
        pop     bc
        pop     de
        push    de
        push    bc
        push    af

	;; 16-bit multiplication
	;;
	;; Entry conditions
	;; bc = multiplicand
	;; de = multiplier
	;;
	;; Exit conditions
	;; hl = less significant word of product
	;;
	;; Register used: AF,BC,DE,HL
__mul16::
	xor	a,a
	ld	l,a
	or	a,b
	ld	b,#16

        ;; Optimise for the case when this side has 8 bits of data or
        ;; less.  This is often the case with support address calls.
        jr      NZ,2$
        ld      b,#8
        ld      a,c
1$:
        ;; Taken from z88dk, which originally borrowed from the
        ;; Spectrum rom.
        add     hl,hl
2$:
        rl      c
        rla                     ;DLE 27/11/98
        jr      NC,3$
        add     hl,de
3$:
        djnz    1$
        ret

;--------------------------------------------------------------------------
;  crt0.s - Generic crt0.s for a Z80
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.module crt0
	.globl	_main

	.area	_HEADER (ABS)
	;; Reset vector
	.org 	0
	jp	init

	.org	0x08
	ei
	reti
	.org	0x10
	ei
	reti
	.org	0x18
	ei
	reti
	.org	0x20
	ei
	reti
	.org	0x28
	ei
	reti
	.org	0x30
	ei
	reti
	.org	0x38
	ei
	reti

	.org	0x100
init:
	;; Set stack pointer directly above top of memory.
	ld	sp,#0x0000

	;; Initialise global variables
	call	gsinit
	call	_main
	jp	_exit

	;; Ordering of segments for the linker.
	.area	_HOME
	.area	_CODE
	.area	_INITIALIZER
	.area   _GSINIT
	.area   _GSFINAL

	.area	_DATA
	.area	_INITIALIZED
	.area	_BSEG
	.area   _BSS
	.area   _HEAP

	.area   _CODE
__clock::
	ld	a,#2
	rst	0x08
	ret

_exit::
	;; Exit - special code to the emulator
	ld	a,#0
	rst	0x08
1$:
	halt
	jr	1$

	.area   _GSINIT
gsinit::
	ld	bc, #l__INITIALIZER
	ld	a, b
	or	a, c
	jr	Z, gsinit_next
	ld	de, #s__INITIALIZED
	ld	hl, #s__INITIALIZER
	ldir
gsinit_next:

	.area   _GSFINAL
	ret

;--------------------------------------------------------------------------
;  modsigned.s
;
;  Copyright (C) 2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__modschar
.globl	__modsint

__modschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __div8

        jp	__get_remainder

__modsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __div16

        jp	__get_remainder

;--------------------------------------------------------------------------
;  __sdcc_critical.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_critical_enter
;
; NMOS Z80 compatible
; this function cannot be placed at 0x0000...0x00ff addresses
;
___sdcc_critical_enter::
	xor	a, a
	push	af
	pop	af
	ld	a, i
	di
	ret	pe	;enabled interrupts
	dec	sp
	dec	sp
	pop	af
	or	a, a	;A = 0 if interrupts disabled
	jr	NZ, 00100$
;inetrrupts disabled
	sub	a, a	;force P/V = 0
	ret
;interrupts enabled
00100$:
	xor	a, a	;force P/V = 1
	ret
sdcc/device/lib/z80
-------------------

Z80 specific routines.

Notes:
* Cost of ld r,(ix+n):	19
* Cost of ld r,(hl); inc hl: 7+6 = 13 and you don't have to pop ix
        /*-------------------------------------------------------------------------
   _mulint.c - routine for (unsigned) int (16 bit) multiplication

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Signed and unsigned multiplication are the same - as long as the output
   has the same precision as the input.

   Assembler-functions are provided for:
     hc08
     hc08 stack-auto
*/


#if !defined(_SDCC_NO_ASM_LIB_FUNCS)

#pragma save
#pragma less_pedantic
int
_mulint (int a, int b)
{
  a,b;	/* reference to make compiler happy */

#if !defined(__SDCC_STACK_AUTO)
    __asm
   	ais #-2
	psha
	pshx

	ldx __mulint_PARM_2+1
	mul
	sta 4,s
	stx 3,s

	lda 1,s
	ldx __mulint_PARM_2+1
	mul
	add 3,s
	sta 3,s

	lda 2,s
	ldx __mulint_PARM_2
	mul
	add 3,s
	sta 3,s

	ais #2
	pulx
	pula
    __endasm;
#else
    __asm
   	ais #-2
	psha
	pshx

	ldx 8,s
	mul
	sta 4,s
	stx 3,s

	lda 1,s
	ldx 8,s
	mul
	add 3,s
	sta 3,s

	lda 2,s
	ldx 7,s
	mul
	add 3,s
	sta 3,s

	ais #2
	pulx
	pula
    __endasm;
#endif
}
#pragma restore

#else

union uu {
	struct { unsigned char hi,lo ;} s;
        unsigned int t;
} ;

int
_mulint (int a, int b)
{
#if !defined(__SDCC_STACK_AUTO) && (defined(__SDCC_MODEL_LARGE) || defined(__SDCC_ds390))	// still needed for large
	union uu __xdata *x;
	union uu __xdata *y;
	union uu t;
        x = (union uu __xdata *)&a;
        y = (union uu __xdata *)&b;
#else
	register union uu *x;
	register union uu *y;
	union uu t;
        x = (union uu *)&a;
        y = (union uu *)&b;
#endif

        t.t = x->s.lo * y->s.lo;
        t.s.hi += (x->s.lo * y->s.hi) + (x->s.hi * y->s.lo);

       return t.t;
}
#endif


#undef _MULINT_ASM

/*
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
*/

#include <stdatomic.h>

_Bool atomic_flag_test_and_set(volatile atomic_flag *object) __naked
{
  object; // avoid warning 85 unreferenced function argument
__asm
	pshx
	pulh
	tax
	clra
	lsr	,x
	rola
	eor	#0x01
	rts
__endasm;
}

/*-------------------------------------------------------------------------
   setjmp.c - source file for ANSI routines setjmp & longjmp

   Copyright (C) 2016, Maarten Brock. sourceforge.brock AT dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>
#define __SDCC_HIDE_LONGJMP
#include <setjmp.h>

static void dummy (void) __naked
{
        __asm

;--------------------------------------------------------
; overlayable items in ram
;--------------------------------------------------------
        .area   OSEG    (PAG, OVR)
___setjmp_buf:
        .ds 2
        .area   OSEG    (PAG, OVR)
_longjmp_buf:
        .ds 2
;--------------------------------------------------------
; extended address mode data
;--------------------------------------------------------
        .area XSEG
_longjmp_PARM_2:
        .ds 2
;--------------------------------------------------------
; code
;--------------------------------------------------------
        .area CSEG    (CODE)
;------------------------------------------------------------
;Allocation info for local variables in function '__setjmp'
;------------------------------------------------------------
;buf                       Allocated with name '___setjmp_buf'
;------------------------------------------------------------
;_setjmp.c:205: int __setjmp (jmp_buf buf)
;       -----------------------------------------
;        function __setjmp
;       -----------------------------------------
;       Stack space usage: 1 bytes.
        .globl ___setjmp
___setjmp:
        stx	(___setjmp_buf + 0)		; msb(buf)
        sta	(___setjmp_buf + 1)		; lsb(buf)

        ; save stack pointer
        tsx
        pshh
        txa
        ldhx	(___setjmp_buf)
        sta	1,x
        pula
        sta	0,x

        ; save return address
        lda	1,s
        sta	2,x
        lda	2,s
        sta	3,x

        ; return 0
        clra
        tax
        rts

;------------------------------------------------------------
;Allocation info for local variables in function 'longjmp'
;------------------------------------------------------------
;rv                        Allocated with name '_longjmp_PARM_2'
;buf                       Allocated with name '_longjmp_buf'
;------------------------------------------------------------
;_setjmp.c:216: int longjmp (jmp_buf buf, int rv)
;       -----------------------------------------
;        function longjmp
;       -----------------------------------------
;       Stack space usage: 1 bytes.
        .globl _longjmp
        .globl _longjmp_PARM_2
_longjmp:
        stx	(_longjmp_buf + 0)		; msb(buf)
        sta	(_longjmp_buf + 1)		; lsb(buf)

        ; restore stack pointer
        ldhx	(_longjmp_buf)
        lda	0,x
        psha
        ldx	1,x
        pulh
        txs

        ; set return address
        ldhx	(_longjmp_buf)
        lda	2,x
        sta	1,s
        lda	3,x
        sta	2,s

;_setjmp.c:224: return rv ? rv : 1;
        ldx     (_longjmp_PARM_2 + 0)
        txa
        ora     (_longjmp_PARM_2 + 1)
        beq     0001$
        lda     (_longjmp_PARM_2 + 1)
        rts
0001$:
        lda     #0x01
        rts

        __endasm;
}
/*-------------------------------------------------------------------------
   _ret.c

   Copyright (C) 2003, Erik Petrich
   Copyright (C) 2012, Philipp Klaus Krause
   Considering how short this file is, it is probably not copyrightable, though.

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

__data unsigned char __SDCC_hc08_ret2;
__data unsigned char __SDCC_hc08_ret3;
__data unsigned char __SDCC_hc08_ret4;
__data unsigned char __SDCC_hc08_ret5;
__data unsigned char __SDCC_hc08_ret6;
__data unsigned char __SDCC_hc08_ret7;

# generated automatically by aclocal 1.16.2 -*- Autoconf -*-

# Copyright (C) 1996-2020 Free Software Foundation, Inc.

# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])
m4_ifndef([AC_AUTOCONF_VERSION],
  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,
[m4_warning([this file was generated for autoconf 2.69.
You have another version of autoconf.  It may work, but is not guaranteed to.
If you have problems, you may need to regenerate the build system entirely.
To do so, use the procedure documented by the package, typically 'autoreconf'.])])

# Copyright (C) 2002-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_AUTOMAKE_VERSION(VERSION)
# ----------------------------
# Automake X.Y traces this macro to ensure aclocal.m4 has been
# generated from the m4 files accompanying Automake X.Y.
# (This private macro should not be called outside this file.)
AC_DEFUN([AM_AUTOMAKE_VERSION],
[am__api_version='1.16'
dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
dnl require some minimum version.  Point them to the right macro.
m4_if([$1], [1.16.2], [],
      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
])

# _AM_AUTOCONF_VERSION(VERSION)
# -----------------------------
# aclocal traces this macro to find the Autoconf version.
# This is a private macro too.  Using m4_define simplifies
# the logic in aclocal, which can simply ignore this definition.
m4_define([_AM_AUTOCONF_VERSION], [])

# AM_SET_CURRENT_AUTOMAKE_VERSION
# -------------------------------
# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
[AM_AUTOMAKE_VERSION([1.16.2])dnl
m4_ifndef([AC_AUTOCONF_VERSION],
  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])

# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to
# '$srcdir', '$srcdir/..', or '$srcdir/../..'.
#
# Of course, Automake must honor this variable whenever it calls a
# tool from the auxiliary directory.  The problem is that $srcdir (and
# therefore $ac_aux_dir as well) can be either absolute or relative,
# depending on how configure is run.  This is pretty annoying, since
# it makes $ac_aux_dir quite unusable in subdirectories: in the top
# source directory, any form will work fine, but in subdirectories a
# relative path needs to be adjusted first.
#
# $ac_aux_dir/missing
#    fails when called from a subdirectory if $ac_aux_dir is relative
# $top_srcdir/$ac_aux_dir/missing
#    fails if $ac_aux_dir is absolute,
#    fails when called from a subdirectory in a VPATH build with
#          a relative $ac_aux_dir
#
# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
# are both prefixed by $srcdir.  In an in-source build this is usually
# harmless because $srcdir is '.', but things will broke when you
# start a VPATH build or use an absolute $srcdir.
#
# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
# and then we would define $MISSING as
#   MISSING="\${SHELL} $am_aux_dir/missing"
# This will work as long as MISSING is not called from configure, because
# unfortunately $(top_srcdir) has no meaning in configure.
# However there are other variables, like CC, which are often used in
# configure, and could therefore not use this "fixed" $ac_aux_dir.
#
# Another solution, used here, is to always expand $ac_aux_dir to an
# absolute PATH.  The drawback is that using absolute paths prevent a
# configured tree to be moved without reconfiguration.

AC_DEFUN([AM_AUX_DIR_EXPAND],
[AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl
# Expand $ac_aux_dir to an absolute path.
am_aux_dir=`cd "$ac_aux_dir" && pwd`
])

# AM_CONDITIONAL                                            -*- Autoconf -*-

# Copyright (C) 1997-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_CONDITIONAL(NAME, SHELL-CONDITION)
# -------------------------------------
# Define a conditional.
AC_DEFUN([AM_CONDITIONAL],
[AC_PREREQ([2.52])dnl
 m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
AC_SUBST([$1_TRUE])dnl
AC_SUBST([$1_FALSE])dnl
_AM_SUBST_NOTMAKE([$1_TRUE])dnl
_AM_SUBST_NOTMAKE([$1_FALSE])dnl
m4_define([_AM_COND_VALUE_$1], [$2])dnl
if $2; then
  $1_TRUE=
  $1_FALSE='#'
else
  $1_TRUE='#'
  $1_FALSE=
fi
AC_CONFIG_COMMANDS_PRE(
[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
  AC_MSG_ERROR([[conditional "$1" was never defined.
Usually this means the macro was only invoked conditionally.]])
fi])])

# Copyright (C) 1999-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.


# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be
# written in clear, in which case automake, when reading aclocal.m4,
# will think it sees a *use*, and therefore will trigger all it's
# C support machinery.  Also note that it means that autoscan, seeing
# CC etc. in the Makefile, will ask for an AC_PROG_CC use...


# _AM_DEPENDENCIES(NAME)
# ----------------------
# See how the compiler implements dependency checking.
# NAME is "CC", "CXX", "OBJC", "OBJCXX", "UPC", or "GJC".
# We try a few techniques and use that to set a single cache variable.
#
# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
# dependency, and given that the user is not expected to run this macro,
# just rely on AC_PROG_CC.
AC_DEFUN([_AM_DEPENDENCIES],
[AC_REQUIRE([AM_SET_DEPDIR])dnl
AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
AC_REQUIRE([AM_MAKE_INCLUDE])dnl
AC_REQUIRE([AM_DEP_TRACK])dnl

m4_if([$1], [CC],   [depcc="$CC"   am_compiler_list=],
      [$1], [CXX],  [depcc="$CXX"  am_compiler_list=],
      [$1], [OBJC], [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
      [$1], [OBJCXX], [depcc="$OBJCXX" am_compiler_list='gcc3 gcc'],
      [$1], [UPC],  [depcc="$UPC"  am_compiler_list=],
      [$1], [GCJ],  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
                    [depcc="$$1"   am_compiler_list=])

AC_CACHE_CHECK([dependency style of $depcc],
               [am_cv_$1_dependencies_compiler_type],
[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
  # We make a subdir and do the tests there.  Otherwise we can end up
  # making bogus files that we don't know about and never remove.  For
  # instance it was reported that on HP-UX the gcc test will end up
  # making a dummy file named 'D' -- because '-MD' means "put the output
  # in D".
  rm -rf conftest.dir
  mkdir conftest.dir
  # Copy depcomp to subdir because otherwise we won't find it if we're
  # using a relative directory.
  cp "$am_depcomp" conftest.dir
  cd conftest.dir
  # We will build objects and dependencies in a subdirectory because
  # it helps to detect inapplicable dependency modes.  For instance
  # both Tru64's cc and ICC support -MD to output dependencies as a
  # side effect of compilation, but ICC will put the dependencies in
  # the current directory while Tru64 will put them in the object
  # directory.
  mkdir sub

  am_cv_$1_dependencies_compiler_type=none
  if test "$am_compiler_list" = ""; then
     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
  fi
  am__universal=false
  m4_case([$1], [CC],
    [case " $depcc " in #(
     *\ -arch\ *\ -arch\ *) am__universal=true ;;
     esac],
    [CXX],
    [case " $depcc " in #(
     *\ -arch\ *\ -arch\ *) am__universal=true ;;
     esac])

  for depmode in $am_compiler_list; do
    # Setup a source with many dependencies, because some compilers
    # like to wrap large dependency lists on column 80 (with \), and
    # we should not choose a depcomp mode which is confused by this.
    #
    # We need to recreate these files for each test, as the compiler may
    # overwrite some of them when testing with obscure command lines.
    # This happens at least with the AIX C compiler.
    : > sub/conftest.c
    for i in 1 2 3 4 5 6; do
      echo '#include "conftst'$i'.h"' >> sub/conftest.c
      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
      # Solaris 10 /bin/sh.
      echo '/* dummy */' > sub/conftst$i.h
    done
    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf

    # We check with '-c' and '-o' for the sake of the "dashmstdout"
    # mode.  It turns out that the SunPro C++ compiler does not properly
    # handle '-M -o', and we need to detect this.  Also, some Intel
    # versions had trouble with output in subdirs.
    am__obj=sub/conftest.${OBJEXT-o}
    am__minus_obj="-o $am__obj"
    case $depmode in
    gcc)
      # This depmode causes a compiler race in universal mode.
      test "$am__universal" = false || continue
      ;;
    nosideeffect)
      # After this tag, mechanisms are not by side-effect, so they'll
      # only be used when explicitly requested.
      if test "x$enable_dependency_tracking" = xyes; then
	continue
      else
	break
      fi
      ;;
    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
      # This compiler won't grok '-c -o', but also, the minuso test has
      # not run yet.  These depmodes are late enough in the game, and
      # so weak that their functioning should not be impacted.
      am__obj=conftest.${OBJEXT-o}
      am__minus_obj=
      ;;
    none) break ;;
    esac
    if depmode=$depmode \
       source=sub/conftest.c object=$am__obj \
       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
         >/dev/null 2>conftest.err &&
       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
      # icc doesn't choke on unknown options, it will just issue warnings
      # or remarks (even with -Werror).  So we grep stderr for any message
      # that says an option was ignored or not supported.
      # When given -MP, icc 7.0 and 7.1 complain thusly:
      #   icc: Command line warning: ignoring option '-M'; no argument required
      # The diagnosis changed in icc 8.0:
      #   icc: Command line remark: option '-MP' not supported
      if (grep 'ignoring option' conftest.err ||
          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
        am_cv_$1_dependencies_compiler_type=$depmode
        break
      fi
    fi
  done

  cd ..
  rm -rf conftest.dir
else
  am_cv_$1_dependencies_compiler_type=none
fi
])
AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
AM_CONDITIONAL([am__fastdep$1], [
  test "x$enable_dependency_tracking" != xno \
  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
])


# AM_SET_DEPDIR
# -------------
# Choose a directory name for dependency files.
# This macro is AC_REQUIREd in _AM_DEPENDENCIES.
AC_DEFUN([AM_SET_DEPDIR],
[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
])


# AM_DEP_TRACK
# ------------
AC_DEFUN([AM_DEP_TRACK],
[AC_ARG_ENABLE([dependency-tracking], [dnl
AS_HELP_STRING(
  [--enable-dependency-tracking],
  [do not reject slow dependency extractors])
AS_HELP_STRING(
  [--disable-dependency-tracking],
  [speeds up one-time build])])
if test "x$enable_dependency_tracking" != xno; then
  am_depcomp="$ac_aux_dir/depcomp"
  AMDEPBACKSLASH='\'
  am__nodep='_no'
fi
AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
AC_SUBST([AMDEPBACKSLASH])dnl
_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
AC_SUBST([am__nodep])dnl
_AM_SUBST_NOTMAKE([am__nodep])dnl
])

# Generate code to set up dependency tracking.              -*- Autoconf -*-

# Copyright (C) 1999-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# _AM_OUTPUT_DEPENDENCY_COMMANDS
# ------------------------------
AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
[{
  # Older Autoconf quotes --file arguments for eval, but not when files
  # are listed without --file.  Let's play safe and only enable the eval
  # if we detect the quoting.
  # TODO: see whether this extra hack can be removed once we start
  # requiring Autoconf 2.70 or later.
  AS_CASE([$CONFIG_FILES],
          [*\'*], [eval set x "$CONFIG_FILES"],
          [*], [set x $CONFIG_FILES])
  shift
  # Used to flag and report bootstrapping failures.
  am_rc=0
  for am_mf
  do
    # Strip MF so we end up with the name of the file.
    am_mf=`AS_ECHO(["$am_mf"]) | sed -e 's/:.*$//'`
    # Check whether this is an Automake generated Makefile which includes
    # dependency-tracking related rules and includes.
    # Grep'ing the whole file directly is not great: AIX grep has a line
    # limit of 2048, but all sed's we know have understand at least 4000.
    sed -n 's,^am--depfiles:.*,X,p' "$am_mf" | grep X >/dev/null 2>&1 \
      || continue
    am_dirpart=`AS_DIRNAME(["$am_mf"])`
    am_filepart=`AS_BASENAME(["$am_mf"])`
    AM_RUN_LOG([cd "$am_dirpart" \
      && sed -e '/# am--include-marker/d' "$am_filepart" \
        | $MAKE -f - am--depfiles]) || am_rc=$?
  done
  if test $am_rc -ne 0; then
    AC_MSG_FAILURE([Something went wrong bootstrapping makefile fragments
    for automatic dependency tracking.  If GNU make was not used, consider
    re-running the configure script with MAKE="gmake" (or whatever is
    necessary).  You can also try re-running configure with the
    '--disable-dependency-tracking' option to at least be able to build
    the package (albeit without support for automatic dependency tracking).])
  fi
  AS_UNSET([am_dirpart])
  AS_UNSET([am_filepart])
  AS_UNSET([am_mf])
  AS_UNSET([am_rc])
  rm -f conftest-deps.mk
}
])# _AM_OUTPUT_DEPENDENCY_COMMANDS


# AM_OUTPUT_DEPENDENCY_COMMANDS
# -----------------------------
# This macro should only be invoked once -- use via AC_REQUIRE.
#
# This code is only required when automatic dependency tracking is enabled.
# This creates each '.Po' and '.Plo' makefile fragment that we'll need in
# order to bootstrap the dependency handling code.
AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
[AC_CONFIG_COMMANDS([depfiles],
     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
     [AMDEP_TRUE="$AMDEP_TRUE" MAKE="${MAKE-make}"])])

# Do all the work for Automake.                             -*- Autoconf -*-

# Copyright (C) 1996-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This macro actually does too much.  Some checks are only needed if
# your package does certain things.  But this isn't really a big deal.

dnl Redefine AC_PROG_CC to automatically invoke _AM_PROG_CC_C_O.
m4_define([AC_PROG_CC],
m4_defn([AC_PROG_CC])
[_AM_PROG_CC_C_O
])

# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
# AM_INIT_AUTOMAKE([OPTIONS])
# -----------------------------------------------
# The call with PACKAGE and VERSION arguments is the old style
# call (pre autoconf-2.50), which is being phased out.  PACKAGE
# and VERSION should now be passed to AC_INIT and removed from
# the call to AM_INIT_AUTOMAKE.
# We support both call styles for the transition.  After
# the next Automake release, Autoconf can make the AC_INIT
# arguments mandatory, and then we can depend on a new Autoconf
# release and drop the old call support.
AC_DEFUN([AM_INIT_AUTOMAKE],
[AC_PREREQ([2.65])dnl
dnl Autoconf wants to disallow AM_ names.  We explicitly allow
dnl the ones we care about.
m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
AC_REQUIRE([AC_PROG_INSTALL])dnl
if test "`cd $srcdir && pwd`" != "`pwd`"; then
  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
  # is not polluted with repeated "-I."
  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl
  # test to see if srcdir already configured
  if test -f $srcdir/config.status; then
    AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
  fi
fi

# test whether we have cygpath
if test -z "$CYGPATH_W"; then
  if (cygpath --version) >/dev/null 2>/dev/null; then
    CYGPATH_W='cygpath -w'
  else
    CYGPATH_W=echo
  fi
fi
AC_SUBST([CYGPATH_W])

# Define the identity of the package.
dnl Distinguish between old-style and new-style calls.
m4_ifval([$2],
[AC_DIAGNOSE([obsolete],
             [$0: two- and three-arguments forms are deprecated.])
m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
 AC_SUBST([PACKAGE], [$1])dnl
 AC_SUBST([VERSION], [$2])],
[_AM_SET_OPTIONS([$1])dnl
dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
m4_if(
  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),
  [ok:ok],,
  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
 AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
 AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl

_AM_IF_OPTION([no-define],,
[AC_DEFINE_UNQUOTED([PACKAGE], ["$PACKAGE"], [Name of package])
 AC_DEFINE_UNQUOTED([VERSION], ["$VERSION"], [Version number of package])])dnl

# Some tools Automake needs.
AC_REQUIRE([AM_SANITY_CHECK])dnl
AC_REQUIRE([AC_ARG_PROGRAM])dnl
AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])
AM_MISSING_PROG([AUTOCONF], [autoconf])
AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])
AM_MISSING_PROG([AUTOHEADER], [autoheader])
AM_MISSING_PROG([MAKEINFO], [makeinfo])
AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
AC_REQUIRE([AC_PROG_MKDIR_P])dnl
# For better backward compatibility.  To be removed once Automake 1.9.x
# dies out for good.  For more background, see:
# <https://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
# <https://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
AC_SUBST([mkdir_p], ['$(MKDIR_P)'])
# We need awk for the "check" target (and possibly the TAP driver).  The
# system "awk" is bad on some platforms.
AC_REQUIRE([AC_PROG_AWK])dnl
AC_REQUIRE([AC_PROG_MAKE_SET])dnl
AC_REQUIRE([AM_SET_LEADING_DOT])dnl
_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
	      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
			     [_AM_PROG_TAR([v7])])])
_AM_IF_OPTION([no-dependencies],,
[AC_PROVIDE_IFELSE([AC_PROG_CC],
		  [_AM_DEPENDENCIES([CC])],
		  [m4_define([AC_PROG_CC],
			     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl
AC_PROVIDE_IFELSE([AC_PROG_CXX],
		  [_AM_DEPENDENCIES([CXX])],
		  [m4_define([AC_PROG_CXX],
			     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl
AC_PROVIDE_IFELSE([AC_PROG_OBJC],
		  [_AM_DEPENDENCIES([OBJC])],
		  [m4_define([AC_PROG_OBJC],
			     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl
AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],
		  [_AM_DEPENDENCIES([OBJCXX])],
		  [m4_define([AC_PROG_OBJCXX],
			     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl
])
AC_REQUIRE([AM_SILENT_RULES])dnl
dnl The testsuite driver may need to know about EXEEXT, so add the
dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This
dnl macro is hooked onto _AC_COMPILER_EXEEXT early, see below.
AC_CONFIG_COMMANDS_PRE(dnl
[m4_provide_if([_AM_COMPILER_EXEEXT],
  [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl

# POSIX will say in a future version that running "rm -f" with no argument
# is OK; and we want to be able to make that assumption in our Makefile
# recipes.  So use an aggressive probe to check that the usage we want is
# actually supported "in the wild" to an acceptable degree.
# See automake bug#10828.
# To make any issue more visible, cause the running configure to be aborted
# by default if the 'rm' program in use doesn't match our expectations; the
# user can still override this though.
if rm -f && rm -fr && rm -rf; then : OK; else
  cat >&2 <<'END'
Oops!

Your 'rm' program seems unable to run without file operands specified
on the command line, even when the '-f' option is present.  This is contrary
to the behaviour of most rm programs out there, and not conforming with
the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>

Please tell bug-automake@gnu.org about your system, including the value
of your $PATH and any error possibly output before this message.  This
can help us improve future automake versions.

END
  if test x"$ACCEPT_INFERIOR_RM_PROGRAM" = x"yes"; then
    echo 'Configuration will proceed anyway, since you have set the' >&2
    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to "yes"' >&2
    echo >&2
  else
    cat >&2 <<'END'
Aborting the configuration process, to ensure you take notice of the issue.

You can download and install GNU coreutils to get an 'rm' implementation
that behaves properly: <https://www.gnu.org/software/coreutils/>.

If you want to complete the configuration process using your problematic
'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
to "yes", and re-run configure.

END
    AC_MSG_ERROR([Your 'rm' program is bad, sorry.])
  fi
fi
dnl The trailing newline in this macro's definition is deliberate, for
dnl backward compatibility and to allow trailing 'dnl'-style comments
dnl after the AM_INIT_AUTOMAKE invocation. See automake bug#16841.
])

dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
dnl mangled by Autoconf and run in a shell conditional statement.
m4_define([_AC_COMPILER_EXEEXT],
m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])

# When config.status generates a header, we must update the stamp-h file.
# This file resides in the same directory as the config header
# that is generated.  The stamp files are numbered to have different names.

# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
# loop where config.status creates the headers, so we can generate
# our stamp files there.
AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
[# Compute $1's index in $config_headers.
_am_arg=$1
_am_stamp_count=1
for _am_header in $config_headers :; do
  case $_am_header in
    $_am_arg | $_am_arg:* )
      break ;;
    * )
      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
  esac
done
echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_PROG_INSTALL_SH
# ------------------
# Define $install_sh.
AC_DEFUN([AM_PROG_INSTALL_SH],
[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
if test x"${install_sh+set}" != xset; then
  case $am_aux_dir in
  *\ * | *\	*)
    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
  *)
    install_sh="\${SHELL} $am_aux_dir/install-sh"
  esac
fi
AC_SUBST([install_sh])])

# Copyright (C) 2003-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# Check whether the underlying file-system supports filenames
# with a leading dot.  For instance MS-DOS doesn't.
AC_DEFUN([AM_SET_LEADING_DOT],
[rm -rf .tst 2>/dev/null
mkdir .tst 2>/dev/null
if test -d .tst; then
  am__leading_dot=.
else
  am__leading_dot=_
fi
rmdir .tst 2>/dev/null
AC_SUBST([am__leading_dot])])

# Check to see how 'make' treats includes.	            -*- Autoconf -*-

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_MAKE_INCLUDE()
# -----------------
# Check whether make has an 'include' directive that can support all
# the idioms we need for our automatic dependency tracking code.
AC_DEFUN([AM_MAKE_INCLUDE],
[AC_MSG_CHECKING([whether ${MAKE-make} supports the include directive])
cat > confinc.mk << 'END'
am__doit:
	@echo this is the am__doit target >confinc.out
.PHONY: am__doit
END
am__include="#"
am__quote=
# BSD make does it like this.
echo '.include "confinc.mk" # ignored' > confmf.BSD
# Other make implementations (GNU, Solaris 10, AIX) do it like this.
echo 'include confinc.mk # ignored' > confmf.GNU
_am_result=no
for s in GNU BSD; do
  AM_RUN_LOG([${MAKE-make} -f confmf.$s && cat confinc.out])
  AS_CASE([$?:`cat confinc.out 2>/dev/null`],
      ['0:this is the am__doit target'],
      [AS_CASE([$s],
          [BSD], [am__include='.include' am__quote='"'],
          [am__include='include' am__quote=''])])
  if test "$am__include" != "#"; then
    _am_result="yes ($s style)"
    break
  fi
done
rm -f confinc.* confmf.*
AC_MSG_RESULT([${_am_result}])
AC_SUBST([am__include])])
AC_SUBST([am__quote])])

# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-

# Copyright (C) 1997-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_MISSING_PROG(NAME, PROGRAM)
# ------------------------------
AC_DEFUN([AM_MISSING_PROG],
[AC_REQUIRE([AM_MISSING_HAS_RUN])
$1=${$1-"${am_missing_run}$2"}
AC_SUBST($1)])

# AM_MISSING_HAS_RUN
# ------------------
# Define MISSING if not defined so far and test if it is modern enough.
# If it is, set am_missing_run to use it, otherwise, to nothing.
AC_DEFUN([AM_MISSING_HAS_RUN],
[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
AC_REQUIRE_AUX_FILE([missing])dnl
if test x"${MISSING+set}" != xset; then
  case $am_aux_dir in
  *\ * | *\	*)
    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
  *)
    MISSING="\${SHELL} $am_aux_dir/missing" ;;
  esac
fi
# Use eval to expand $SHELL
if eval "$MISSING --is-lightweight"; then
  am_missing_run="$MISSING "
else
  am_missing_run=
  AC_MSG_WARN(['missing' script is too old or missing])
fi
])

# Helper functions for option handling.                     -*- Autoconf -*-

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# _AM_MANGLE_OPTION(NAME)
# -----------------------
AC_DEFUN([_AM_MANGLE_OPTION],
[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])

# _AM_SET_OPTION(NAME)
# --------------------
# Set option NAME.  Presently that only means defining a flag for this option.
AC_DEFUN([_AM_SET_OPTION],
[m4_define(_AM_MANGLE_OPTION([$1]), [1])])

# _AM_SET_OPTIONS(OPTIONS)
# ------------------------
# OPTIONS is a space-separated list of Automake options.
AC_DEFUN([_AM_SET_OPTIONS],
[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])

# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
# -------------------------------------------
# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
AC_DEFUN([_AM_IF_OPTION],
[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_RUN_LOG(COMMAND)
# -------------------
# Run COMMAND, save the exit status in ac_status, and log it.
# (This has been adapted from Autoconf's _AC_RUN_LOG macro.)
AC_DEFUN([AM_RUN_LOG],
[{ echo "$as_me:$LINENO: $1" >&AS_MESSAGE_LOG_FD
   ($1) >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
   (exit $ac_status); }])

# Check to make sure that the build environment is sane.    -*- Autoconf -*-

# Copyright (C) 1996-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_SANITY_CHECK
# ---------------
AC_DEFUN([AM_SANITY_CHECK],
[AC_MSG_CHECKING([whether build environment is sane])
# Reject unsafe characters in $srcdir or the absolute working directory
# name.  Accept space and tab only in the latter.
am_lf='
'
case `pwd` in
  *[[\\\"\#\$\&\'\`$am_lf]]*)
    AC_MSG_ERROR([unsafe absolute working directory name]);;
esac
case $srcdir in
  *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;
esac

# Do 'set' in a subshell so we don't clobber the current shell's
# arguments.  Must try -L first in case configure is actually a
# symlink; some systems play weird games with the mod time of symlinks
# (eg FreeBSD returns the mod time of the symlink's containing
# directory).
if (
   am_has_slept=no
   for am_try in 1 2; do
     echo "timestamp, slept: $am_has_slept" > conftest.file
     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
     if test "$[*]" = "X"; then
	# -L didn't work.
	set X `ls -t "$srcdir/configure" conftest.file`
     fi
     if test "$[*]" != "X $srcdir/configure conftest.file" \
	&& test "$[*]" != "X conftest.file $srcdir/configure"; then

	# If neither matched, then we have a broken ls.  This can happen
	# if, for instance, CONFIG_SHELL is bash and it inherits a
	# broken ls alias from the environment.  This has actually
	# happened.  Such a system could not be considered "sane".
	AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
  alias in your environment])
     fi
     if test "$[2]" = conftest.file || test $am_try -eq 2; then
       break
     fi
     # Just in case.
     sleep 1
     am_has_slept=yes
   done
   test "$[2]" = conftest.file
   )
then
   # Ok.
   :
else
   AC_MSG_ERROR([newly created file is older than distributed files!
Check your system clock])
fi
AC_MSG_RESULT([yes])
# If we didn't sleep, we still need to ensure time stamps of config.status and
# generated files are strictly newer.
am_sleep_pid=
if grep 'slept: no' conftest.file >/dev/null 2>&1; then
  ( sleep 1 ) &
  am_sleep_pid=$!
fi
AC_CONFIG_COMMANDS_PRE(
  [AC_MSG_CHECKING([that generated files are newer than configure])
   if test -n "$am_sleep_pid"; then
     # Hide warnings about reused PIDs.
     wait $am_sleep_pid 2>/dev/null
   fi
   AC_MSG_RESULT([done])])
rm -f conftest.file
])

# Copyright (C) 2009-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_SILENT_RULES([DEFAULT])
# --------------------------
# Enable less verbose build rules; with the default set to DEFAULT
# ("yes" being less verbose, "no" or empty being verbose).
AC_DEFUN([AM_SILENT_RULES],
[AC_ARG_ENABLE([silent-rules], [dnl
AS_HELP_STRING(
  [--enable-silent-rules],
  [less verbose build output (undo: "make V=1")])
AS_HELP_STRING(
  [--disable-silent-rules],
  [verbose build output (undo: "make V=0")])dnl
])
case $enable_silent_rules in @%:@ (((
  yes) AM_DEFAULT_VERBOSITY=0;;
   no) AM_DEFAULT_VERBOSITY=1;;
    *) AM_DEFAULT_VERBOSITY=m4_if([$1], [yes], [0], [1]);;
esac
dnl
dnl A few 'make' implementations (e.g., NonStop OS and NextStep)
dnl do not support nested variable expansions.
dnl See automake bug#9928 and bug#10237.
am_make=${MAKE-make}
AC_CACHE_CHECK([whether $am_make supports nested variables],
   [am_cv_make_support_nested_variables],
   [if AS_ECHO([['TRUE=$(BAR$(V))
BAR0=false
BAR1=true
V=1
am__doit:
	@$(TRUE)
.PHONY: am__doit']]) | $am_make -f - >/dev/null 2>&1; then
  am_cv_make_support_nested_variables=yes
else
  am_cv_make_support_nested_variables=no
fi])
if test $am_cv_make_support_nested_variables = yes; then
  dnl Using '$V' instead of '$(V)' breaks IRIX make.
  AM_V='$(V)'
  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
else
  AM_V=$AM_DEFAULT_VERBOSITY
  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY
fi
AC_SUBST([AM_V])dnl
AM_SUBST_NOTMAKE([AM_V])dnl
AC_SUBST([AM_DEFAULT_V])dnl
AM_SUBST_NOTMAKE([AM_DEFAULT_V])dnl
AC_SUBST([AM_DEFAULT_VERBOSITY])dnl
AM_BACKSLASH='\'
AC_SUBST([AM_BACKSLASH])dnl
_AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl
])

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_PROG_INSTALL_STRIP
# ---------------------
# One issue with vendor 'install' (even GNU) is that you can't
# specify the program used to strip binaries.  This is especially
# annoying in cross-compiling environments, where the build's strip
# is unlikely to handle the host's binaries.
# Fortunately install-sh will honor a STRIPPROG variable, so we
# always use install-sh in "make install-strip", and initialize
# STRIPPROG with the value of the STRIP variable (set by the user).
AC_DEFUN([AM_PROG_INSTALL_STRIP],
[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
# Installed binaries are usually stripped using 'strip' when the user
# run "make install-strip".  However 'strip' might not be the right
# tool to use in cross-compilation environments, therefore Automake
# will honor the 'STRIP' environment variable to overrule this program.
dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.
if test "$cross_compiling" != no; then
  AC_CHECK_TOOL([STRIP], [strip], :)
fi
INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
AC_SUBST([INSTALL_STRIP_PROGRAM])])

# Copyright (C) 2006-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# _AM_SUBST_NOTMAKE(VARIABLE)
# ---------------------------
# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
# This macro is traced by Automake.
AC_DEFUN([_AM_SUBST_NOTMAKE])

# AM_SUBST_NOTMAKE(VARIABLE)
# --------------------------
# Public sister of _AM_SUBST_NOTMAKE.
AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])

# Check how to create a tarball.                            -*- Autoconf -*-

# Copyright (C) 2004-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# _AM_PROG_TAR(FORMAT)
# --------------------
# Check how to create a tarball in format FORMAT.
# FORMAT should be one of 'v7', 'ustar', or 'pax'.
#
# Substitute a variable $(am__tar) that is a command
# writing to stdout a FORMAT-tarball containing the directory
# $tardir.
#     tardir=directory && $(am__tar) > result.tar
#
# Substitute a variable $(am__untar) that extract such
# a tarball read from stdin.
#     $(am__untar) < result.tar
#
AC_DEFUN([_AM_PROG_TAR],
[# Always define AMTAR for backward compatibility.  Yes, it's still used
# in the wild :-(  We should find a proper way to deprecate it ...
AC_SUBST([AMTAR], ['$${TAR-tar}'])

# We'll loop over all known methods to create a tar archive until one works.
_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'

m4_if([$1], [v7],
  [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],

  [m4_case([$1],
    [ustar],
     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.
      # There is notably a 21 bits limit for the UID and the GID.  In fact,
      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343
      # and bug#13588).
      am_max_uid=2097151 # 2^21 - 1
      am_max_gid=$am_max_uid
      # The $UID and $GID variables are not portable, so we need to resort
      # to the POSIX-mandated id(1) utility.  Errors in the 'id' calls
      # below are definitely unexpected, so allow the users to see them
      # (that is, avoid stderr redirection).
      am_uid=`id -u || echo unknown`
      am_gid=`id -g || echo unknown`
      AC_MSG_CHECKING([whether UID '$am_uid' is supported by ustar format])
      if test $am_uid -le $am_max_uid; then
         AC_MSG_RESULT([yes])
      else
         AC_MSG_RESULT([no])
         _am_tools=none
      fi
      AC_MSG_CHECKING([whether GID '$am_gid' is supported by ustar format])
      if test $am_gid -le $am_max_gid; then
         AC_MSG_RESULT([yes])
      else
        AC_MSG_RESULT([no])
        _am_tools=none
      fi],

  [pax],
    [],

  [m4_fatal([Unknown tar format])])

  AC_MSG_CHECKING([how to create a $1 tar archive])

  # Go ahead even if we have the value already cached.  We do so because we
  # need to set the values for the 'am__tar' and 'am__untar' variables.
  _am_tools=${am_cv_prog_tar_$1-$_am_tools}

  for _am_tool in $_am_tools; do
    case $_am_tool in
    gnutar)
      for _am_tar in tar gnutar gtar; do
        AM_RUN_LOG([$_am_tar --version]) && break
      done
      am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
      am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
      am__untar="$_am_tar -xf -"
      ;;
    plaintar)
      # Must skip GNU tar: if it does not support --format= it doesn't create
      # ustar tarball either.
      (tar --version) >/dev/null 2>&1 && continue
      am__tar='tar chf - "$$tardir"'
      am__tar_='tar chf - "$tardir"'
      am__untar='tar xf -'
      ;;
    pax)
      am__tar='pax -L -x $1 -w "$$tardir"'
      am__tar_='pax -L -x $1 -w "$tardir"'
      am__untar='pax -r'
      ;;
    cpio)
      am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
      am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
      am__untar='cpio -i -H $1 -d'
      ;;
    none)
      am__tar=false
      am__tar_=false
      am__untar=false
      ;;
    esac

    # If the value was cached, stop now.  We just wanted to have am__tar
    # and am__untar set.
    test -n "${am_cv_prog_tar_$1}" && break

    # tar/untar a dummy directory, and stop if the command works.
    rm -rf conftest.dir
    mkdir conftest.dir
    echo GrepMe > conftest.dir/file
    AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
    rm -rf conftest.dir
    if test -s conftest.tar; then
      AM_RUN_LOG([$am__untar <conftest.tar])
      AM_RUN_LOG([cat conftest.dir/file])
      grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
    fi
  done
  rm -rf conftest.dir

  AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
  AC_MSG_RESULT([$am_cv_prog_tar_$1])])

AC_SUBST([am__tar])
AC_SUBST([am__untar])
]) # _AM_PROG_TAR

		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	Appendix: How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 19yy  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) 19yy name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
This directory contains pic16 specific libraries
/*-------------------------------------------------------------------------
   strcmp.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

int
strcmp (char *asrc, char *adst)
{
  register int ret = 0 ;

  while (!(ret = *asrc - *adst) && *adst)
    ++asrc, ++adst;

  if (ret < 0)
    ret = -1 ;
  else if (ret > 0)
    ret = 1 ;

  return ret;
}

/*-------------------------------------------------------------------------
   strlen.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

int
strlen (char *str) 
{
  register int i = 0 ;

  while (*str++)
    i++;

  return i;
}
/*-------------------------------------------------------------------------
   strchr.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char *
strchr (char *string, char ch)
{
  while (*string && *string != ch)
    ++string;

  if (*string == ch)
    return string;

  return NULL;
}
/*-------------------------------------------------------------------------
   strncpy.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char *
strncpy (char *d, char *s, size_t n)
{
  register char *d1 = d;

  while (n && *s)
  {
    n--;
    *d1++ = *s++;
  }

  while (n--)
  {
    *d1++ = '\0';
  }

  return d;
}
/*-------------------------------------------------------------------------
   memrchr.c - part of string library functions

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>
   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

void *
memrchr (void *s, char c, size_t count)
{
  if (!count)
    return NULL;

  s = (char *)s + sizeof (char *) * count;

  while (*(char *)s != c && count)
    {
      s = (char *)s - sizeof(char *);
      --count;
    }

  if (count)
    return s;
  else
    return NULL;
}
/*-------------------------------------------------------------------------
   memchrram.c - part of string library functions

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>
   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

__data void *
memchrram (__data void *s, char c, size_t count)
{
  if (!count)
    return NULL;
	
  while ((*(__data char *)s != c) && count)
    {
      s = (__data char *)s + sizeof (__data char *);
      --count;
    }

  if (count)
    return s;
  else
    return NULL;
}
/*-------------------------------------------------------------------------
   strtok.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char *
strtok (char *str, char *control) 
{
  static char *s = NULL;
  register char *s1;

  if (str)
    s = str;

  if (!s)
    return NULL;

  while (*s)
    {
      if (strchr (control, *s))
        s++;
      else
        break;
    }
	
  s1 = s;

  while (*s)
    {
      if (strchr (control, *s))
        {
          *s = '\0';
          return s1;
        }
      ++s;
    }

  s = NULL;

  if (*s1)
    return s1;
  else
    return NULL;
}
/*-------------------------------------------------------------------------
   memmove.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>
   Adapted by Erik Petrich <epetrich at users.sourceforge.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

void *
memmove (void *dst, const void *src, size_t acount)
{
  char *d;
  const char *s;

  if (((int)src < (int)dst) && ((((int)src) + acount) > (int)dst))
    {
      /*
       * copy from higher addresses to lower addresses
       */
      d = ((char *)dst) + acount - 1;
      s = ((char *)src) + acount - 1;
      while (acount--)
      	*d-- = *s--;
    }
  else
    {
      /*
       * copy from lower addresses to higher addresses
       */
      d = dst;
      s = src;
      while (acount--)
      	*d++ = *s++;
    }

  return dst;
}
/*-------------------------------------------------------------------------
   strncat.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char *
strncat (char *front, char * back, size_t count) 
{
  char *start = front;

  while (*front++)
    ;
    
  front--;
  while (count--)
    if (!(*front++ = *back++))
      return start;

    *front = '\0';

  return start;
}
/*-------------------------------------------------------------------------
   strpbrk.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char *
strpbrk (char *string, char *control) 
{
  register char ch;

  while(ch = *string)
    {
      if (strchr (control, ch))
        return string;
    }

  return NULL;
}
/*-------------------------------------------------------------------------
   strcpy.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char *
strcpy (char *d, char *s)
{
  register char *d1 = d;

  while (*d1++ = *s++)
    ;

  return d;
}
/*-------------------------------------------------------------------------
   memcpyram2ram.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

__data void *
memcpyram2ram (__data void *dst, __data void *src, size_t acount)
{
  char __data *d = dst;
  char __data *s = src;

  /*
   * copy from lower addresses to higher addresses
   */
  while (acount--)
    *d++ = *s++;

  return dst;
}
/*-------------------------------------------------------------------------
   memcpy.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

void *
memcpy (void *dst, const void *src, size_t acount)
{
  char *d = dst;
  const char *s = src;

  /*
   * copy from lower addresses to higher addresses
   */
  while (acount--)
    *d++ = *s++;

  return dst;
}
/*-------------------------------------------------------------------------
   memcpypgm2ram.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

__data void *
memcpypgm2ram (__data void *dst, __code void *src, size_t acount)
{
  char __data *d = dst;
  char __code *s = src;

  /*
   * copy from lower addresses to higher addresses
   */
  while (acount--)
    *d++ = *s++;

  return dst;
}
/*-------------------------------------------------------------------------
   strupr.c - part of string library functions

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>
#include <string.h>

char *
strupr (char *str) 
{
  char *ret = str;

  while (*str)
    {
      *str = toupper (*str);
      ++str;
    }

  return ret;
}
/*-------------------------------------------------------------------------
   strcspn.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>
   Bug fixed by Vangelis Rokas <vrokas at otenet.gr> (2004)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

int
strcspn (char *string, char *control) 
{
  register int count = 0;
  register char ch;
  
  while (ch = *string)
    {
      if (strchr (control, ch))
        break;
      else
        count++ ;
      string++;
    }

  return count;
}
/*-------------------------------------------------------------------------
   strncmp.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

int
strncmp (char *first, char *last, size_t count) 
{
  if (!count)
    return 0;

  while (--count && *first && *first == *last)
    {
      first++;
      last++;
    }

  return *first - *last;
}
/*-------------------------------------------------------------------------
   strrchr.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char *
strrchr (char *string, char ch) 
{
  register char *s = string;

  /* find end of string */
  while (*s++)
    ;
    
  /* search towards front */
  while (--s != string && *s != ch)
      ;

  /* char found ? */
  if (*s == ch)
    return s;

  return NULL;
}
/*-------------------------------------------------------------------------
   strcat.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char *
strcat (char *dst, char *src)
{
  char *cp = dst;

  /* find end of dst */
  while (*cp)
    cp++;

  /* Copy src to end of dst */
  while (*cp++ = *src++)
    ;

  /* return dst */
  return dst;
}
/*-------------------------------------------------------------------------
   memset.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

void *
memset (void _STRING_SPEC *buf, unsigned char ch, size_t count) 
{
  register unsigned char *ret = buf;

  while (count--)
    {
      *(unsigned char *)ret = ch;
      ++ret;
    }

  return buf;
}
/*-------------------------------------------------------------------------
   memccpy.c - part of string library functions

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>
   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

void *
memccpy (void *dst, void *src, char c, size_t acount) 
{
  char *d = dst;
  char *s = src;
	
  /*
   * copy from lower addresses to higher addresses
   */
  while (acount--)
    {
      if (*s == c)
        return ++s;

      *d++ = *s++;
    }

  return NULL;
}
/*-------------------------------------------------------------------------
   strspn.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

int
strspn (char *string, char *control) 
{
  register int count = 0;
  register char ch;

  while (ch = *string)
    {
      if (strchr (control, ch))
        ++count;
      else
        break;
      
      ++string;
    }

  return count;
}
/*-------------------------------------------------------------------------
   strlwr.c - part of string library functions

   Copyright (C)  2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>
#include <string.h>

char *
strlwr (char *str) 
{
  char *ret = str;

  while (*str)
    {
      *str = tolower (*str);
      str++;
    }

  return ret;
}
/*-------------------------------------------------------------------------
   memcmp.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

int
memcmp (const void * buf1, const void * buf2, size_t count)
{
  if (!count)
    return 0;

  while (--count && (*((const char *)buf1) == *((const char *)buf2)))
    {
      buf1 = (const char *)buf1 + 1;
      buf2 = (const char *)buf2 + 1;
    }

  return *((const unsigned char *)buf1) - *((const unsigned char *)buf2);
}
/*-------------------------------------------------------------------------
   strstr.c - part of string library functions

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

char *
strstr (char *str1, char *str2) 
{
  char *cp = str1;
  char *s1;
  char *s2;

    
  if (!*str2)
    return str1;

  while (*cp)
    {
      s1 = cp;
      s2 = str2;

      while (*s1 && *s2 && !(*s1-*s2))
        s1++, s2++;
      
      if (!*s2)
        return cp;

      ++cp;
    }

  return NULL;
}
/*-------------------------------------------------------------------------
   memchrpgm.c - part of string library functions

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>
   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

__code void *
memchrpgm (__code void *s, char c, size_t count)
{
  if (!count)
    return NULL;
	
  while ((*(__code char *)s != c) && count)
    {
      s = (__code char *)s + sizeof (__code char *);
      --count;
    }

  if (count)
    return s;
  else
    return NULL;
}
/*-------------------------------------------------------------------------
   memchr.c - part of string library functions

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>
   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

void *
memchr (const void *s, char c, size_t count)
{
  if (!count)
    return NULL;

  while ((*(char *)s != c) && count)
    {
      s = (char *)s + sizeof (char *);
      --count;
    }

  if (count)
    return s;
  else
    return NULL;
}
/*-------------------------------------------------------------------------
   islower.c - part of ctype.h

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

#define UC(c)	((unsigned char)c)

char islower (unsigned char c)
{
    if  ( c >= UC('a') && c <= UC('z') )
        return 1;
    return 0;
}
/*-------------------------------------------------------------------------
   ispunct.c - part of ctype.h

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

char ispunct (unsigned char c)
{
    if ( isprint (c) &&
         !islower(c) &&
         !isupper(c) &&
         !isspace(c) &&
         !isdigit(c) )
        return 1;
    return 0;
}
/*-------------------------------------------------------------------------
   isppace.c - part of ctype.h

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

#define UC(c)	((unsigned char)c)

char isspace (unsigned char c)
{
    if ( c == UC(' ')  ||
         c == UC('\f') ||
         c == UC('\n') ||
         c == UC('\r') ||
         c == UC('\t') ||
         c == UC('\v') )
        return 1;
    return 0;
}
/*-------------------------------------------------------------------------
   isupper.c - part of ctype.h

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

#define UC(c)	((unsigned char)c)

char isupper (unsigned char c)
{
    if ( c >= UC('A') && c <= UC('Z') )
        return 1;
    return 0;
}
/*-------------------------------------------------------------------------
   isprint.c - part of ctype.h

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

char isprint (unsigned char c)
{
    if ( c >= 0x20 && c <= 0x7e )
        return 1;
    return 0;
}
/*-------------------------------------------------------------------------
   isxdigit.c - part of ctype.h

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

#define UC(c)	((unsigned char)c)

char isxdigit (unsigned char c)
{
    if ( ( c >= UC('0') && c <= UC('9')) ||
         ( c >= UC('a') && c <= UC('f')) ||
         ( c >= UC('A') && c <= UC('F')) )
        return 1;
    return 0;
}
/*-------------------------------------------------------------------------
   iscntrl.c - part of ctype.h

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

char iscntrl (unsigned char c)
{
    if  ( c <= 0x1F || c == 0x7f )
        return 1;
    return 0;
}
/*-------------------------------------------------------------------------
   isdigit.c - part of ctype.h

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

#define UC(c)	((unsigned char)c)

char isdigit (unsigned char c)
{
    if ( c >= UC('0') && c <= UC('9') )
        return 1;
    return 0;
}
/*-------------------------------------------------------------------------
   isgraph.c - part of ctype.h

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>

char isgraph (unsigned char c)
{
    if ( c >= 0x21 && c <= 0x7e )
        return 1;
    return 0;
}
/*-------------------------------------------------------------------------
   printf_tiny.c - source file for reduced version of printf

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT ieee.org>
   Modified for pic16 port, by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* This function uses function putchar() to dump a character
 * to standard output. putchar() is defined in libc18f.lib
 * as dummy function, which will be linked if no putchar()
 * function is provided by the user.
 * The user can write his own putchar() function and link it
 * with the source *BEFORE* the libc18f.lib library. This way
 * the linker will link the first function (i.e. the user's function) */

/* following formats are supported :-
   format     output type       argument-type
     %u*       unsigned            *

     %b        binary
     %d        decimal             int
     %ld       decimal             long
     %hd       decimal             char
     %x        hexadecimal         int
     %lxX      hexadecimal         long
     %hxX      hexadecimal         char
     %o        octal               int
     %lo       octal               long
     %ho       octal               char
     %c        character           char
     %s        character           generic pointer
*/

/*
 * This macro enables the use of the 'b' binary specifier and
 * the use of "%b", "%hb" and "%lb"
 */
/* #define BINARY_SPECIFIER */

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#if 0
#define DPUT(c) putchar(c)
#else
#define DPUT(c)
#endif

#define ISLONG          (flong)
#define ISSTR           (fstr)
#define ISCHAR          (fchar)
#define HAVESIGN        (nosign)

#ifdef BINARY_SPECIFIER
/* "%lb" = "0" - "11111111111111111111111111111111" */
# define BUF_SIZE       33
#else
/* "%lo" = "0" - "37777777777" or  "-21777777777" - "17777777777" */
# define BUF_SIZE       13
#endif

void
printf_tiny (const char *fmt, ...)
{
  char radix;
  char flong, fstr;
  char fchar, nosign;
  char upcase;

  const char *str, *ch;
  __data char *str1;
  long val;
  char buffer[BUF_SIZE];
  va_list ap;

  va_start (ap, fmt);
  ch = fmt;

  while (*ch) //for (; *fmt ; fmt++ )
    {
      if (*ch == '%')
        {
          ISLONG = 0;
          ISSTR = 0;
          ISCHAR = 0;
          HAVESIGN = 0;
          radix = 0;
          upcase = 0;
          ch++;

          if (*ch == 'u')
            {
              HAVESIGN = 1;
              ++ch;
            }

          if (*ch == 'l')
            {
              ISLONG = 1;
              ++ch;
            }
          else if (*ch == 'h')
            {
              ISCHAR = 1;
              ++ch;
            }

          if (*ch == 's')
            ISSTR = 1;
          else if (*ch == 'd')
            radix = 10;
          else if (*ch == 'x')
            {
              radix = 16;
              upcase = 0;
            }
          else if (*ch == 'X')
            {
              radix = 16;
              upcase = 1;
            }
          else if (*ch == 'c')
            radix = 0;
          else if (*ch == 'o')
            radix = 8;
#ifdef BINARX_SPECIFIER
          else if (*ch == 'b')
            radix = 2;
#endif

          if (ISSTR)
            {
              str = va_arg (ap, const char *);
              while (*str)
                {
                  putchar (*str);
                  ++str;
                }
            }
          else
            {
              if (ISLONG)
                val = va_arg (ap, long);
              else if (ISCHAR)
                {
                  val = (unsigned char) va_arg (ap, int);       // FIXME: SDCC casts char arguments into ints
                  if (!HAVESIGN)
                    val = (char) val;   // FIXME cont'd: sign-extend if required
                }
              else
                val = va_arg (ap, int);

              if (radix)
                {
                  if (HAVESIGN)
                    ultoa (val, buffer, radix);
                  else
                    ltoa (val, buffer, radix);

                  str1 = buffer;
                  while ((*str1))
                    {
                      radix = *str1;
                      if (upcase)
                        radix = toupper (radix);
                      putchar (radix);
                      ++str1;
                    }
                }
              else
                putchar ((char) val);
            }
        }
      else
        putchar (*ch);

      ++ch;
    }
}
/*-------------------------------------------------------------------------
   strmusart.c - usart stream putchar

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

extern int WREG;
extern int TXREG;
extern int TXSTA;

/* note that USART should already been initialized */
void
__stream_usart_putchar (char c) __wparam __naked
{
  (void)c;
  __asm
@1:
    BTFSS       _TXSTA, 1
    BRA         @1
    MOVWF       _TXREG
    RETURN
  __endasm;
}
/*-------------------------------------------------------------------------
   vprintf.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

int
vprintf (const char *fmt, va_list ap)
{
  return vfprintf (stdout, fmt, ap);
}
/*-------------------------------------------------------------------------
   strmusart.c - usart stream putchar

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

extern int WREG;

/* note that USART should already been initialized */
void
__stream_gpsim_putchar (char c) __wparam __naked
{
  (void)c;
  __asm
    MOVFF       _WREG, 0xf7f
    RETURN
  __endasm;
}
/*-------------------------------------------------------------------------
   strmmssp.c - MSSP stream putchar

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

extern int SSPBUF;

/* note that USART should already been initialized */
void
__stream_mssp_putchar (char c) __wparam __naked
{
  (void)c;
  __asm
    MOVWF       _SSPBUF, 0
    RETURN
  __endasm;
}
/*-------------------------------------------------------------------------
   sprintf.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

int
sprintf (char *ebuf, char *fmt, ...)
{
  unsigned int i;
  va_list ap;

  ap = va_start (ap, fmt);
  i = vfprintf ((FILE *) ebuf, fmt, ap);
  ebuf[i] = '\0';

  return i;
}
/*-------------------------------------------------------------------------
   printf_small.c - source file for reduced version of printf

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT ieee.org>
   Modified for pic16 port, by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* This function uses function putchar() to dump a character
 * to standard output. putchar() is defined in libc18f.lib
 * as dummy function, which will be linked if no putchar()
 * function is provided by the user.
 * The user can write his own putchar() function and link it
 * with the source *BEFORE* the libc18f.lib library. This way
 * the linker will link the first function (i.e. the user's function) */

/* following formats are supported :-
   format     output type       argument-type
     %d        decimal             int
     %ld       decimal             long
     %hd       decimal             char
     %x        hexadecimal         int
     %lx       hexadecimal         long
     %hx       hexadecimal         char
     %o        octal               int
     %lo       octal               long
     %ho       octal               char
     %c        character           char
     %s        character           generic pointer
     %f        float               float
*/

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

void
printf_small (const char *fmt, ...)
  __reentrant
{
  const char *ch;
  char radix;
  char flong;
  char fstr;
  char fchar;
  char ffloat;
  float flt;
  char *str;
  __data char *str1;
  long val;
  static char buffer[16];
  va_list ap;

  ch = fmt;
  va_start (ap, fmt);

  while (*ch) //for (; *fmt ; fmt++ )
    {
      if (*ch == '%')
        {
          flong = fstr = fchar = ffloat = 0;
          radix = 0;
          ++ch;

          if (*ch == 'l')
            {
              flong = 1;
              ++ch;
            }
          else if (*ch == 'h')
            {
              fchar = 1;
              ++ch;
            }

          if (*ch == 's')
            fstr = 1;
          else if (*ch == 'f')
            ffloat = 1;
          else if (*ch == 'd')
            radix = 10;
          else if (*ch == 'x')
            radix = 16;
          else if (*ch == 'c')
            radix = 0;
          else if (*ch == 'o')
            radix = 8;

          if (fstr)
            {
              str = va_arg (ap, char *);
              while (*str)
                putchar (*str++);
            }
          else if (ffloat)
            {
              flt = va_arg (ap, float);
              x_ftoa (flt, buffer, 32, 6);
              str1 = buffer;
              while (*str1)
                ++str1;
              --str1;
              while (*str1 == '0')
                --str1;
              ++str1;
              *str1 = 0;
              str1 = buffer;
              while (*str1)
                putchar (*str1++);
            }
          else
            {
              if (flong)
                val = va_arg (ap, long);
              else if (fchar)
                val = (char) va_arg (ap, int);  // FIXME: SDCC casts char arguments into ints
              else
                {
                  val = va_arg (ap, int);
                }

              if (radix)
                {
                  ltoa (val, buffer, radix);

                  str1 = buffer;
                  while (*str1)
                    {
                      putchar (*str1++);
                    }
                }
              else
                putchar ((char) val);
            }
        }
      else
        putchar (*ch);

      ++ch;
    }
}
/*-------------------------------------------------------------------------
   printf.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

#if _DEBUG
extern void io_long (unsigned long);
extern void io_str (char *);
#endif

int
printf (const char *fmt, ...)
{
  va_list ap;

#if _DEBUG
  io_str ("printf: ");
  io_long ((unsigned long) stdout);
#endif

  va_start (ap, fmt);
  return vfprintf (stdout, fmt, ap);
}
/*-------------------------------------------------------------------------
   vfprintf.c - source file for reduced version of printf

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT ieee.org>
   Modified for pic16 port, by Vangelis Rokas, 2005 <vrokas AT otenet.gr>
   Bug-fixed and feature-enhanced by Mauro Giachero, 2008 <mauro.giachero AT gmail.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* following formats are supported :-
   format     output type       argument-type
     %%        -                   -
     %u        unsigned            int
     %u*       unsigned            *
     %b        binary              int
     %lb       binary              long
     %hb       binary              char
     %d        decimal             int
     %lu       unsigned            long
     %hu       unsigned            char
     %l[di]    decimal             long
     %lu[di]   unsigned            long
     %h[di]    decimal             char
     %hu[di]   unsigned            char
     %[xX]     hexadecimal         int
     %l[xX]    hexadecimal         long
     %h[xX]    hexadecimal         char
     %o        octal               int
     %lo       octal               long
     %ho       octal               char
     %c        character           char
     %s        character           generic pointer
   Also supported are:
   - the '0', '-' and ' ' alignment modifiers
   - the '+' and ' ' modifiers
   - the width field for integral types
   - the precision field for strings
*/

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

/***********************************************************
 * The following switches enable some "advanced" features. *
 * With all the switches enabled:                          *
 * ; Statistics:                                           *
 * ; code size:     2062 (0x080e) bytes ( 1.57%)           *
 * ;                1031 (0x0407) words                    *
 * ; udata size:      16 (0x0010) bytes ( 1.25%)           *
 * ; access size:     31 (0x001f) bytes                    *
 * With all the switches disabled:                         *
 * ; Statistics:                                           *
 * ; code size:     1278 (0x04fe) bytes ( 0.98%)           *
 * ;                 639 (0x027f) words                    *
 * ; udata size:      16 (0x0010) bytes ( 1.25%)           *
 * ; access size:     25 (0x0019) bytes                    *
 ***********************************************************/
/*
 * Define this to enable support of the field width, which
 * allows to specify the minimum number of characters an
 * integer must use.
 * Costs ~200 code words and 3 bytes in access RAM.
 */
#define FIELD_WIDTH
/*
 * Define this to enable support of the precision, which
 * allows to specify the maximum number of characters a
 * string can use. Note that this implementation doesn't
 * use this field for integers (as it should).
 * Costs ~85 code words and 1 byte in access RAM.
 */
#define PRECISION
/*
 * Define this to enable support of the '+' and ' ' modifiers,
 * which specify that a positive signed number must be
 * preceded respectively with a '+' or a ' ' character.
 * Costs ~70 code words and 2 words of access RAM
 */
#define SIGN_MODIFIERS
/*
 * With this macro defined, trying to print a float number
 * will generate the "<NO FLOAT>" string.
 * Costs ~25 code words
 */
#define FLOAT_PLACEHOLDER
/*
 * With this macro defined, printing floats will work.
 * This also enables PRECISION and disables FLOAT_PLACEHOLDER.
 */
#if defined(USE_FLOATS)
  /* The configure script always defines USE_FLOATS to 0 or 1. */
# if USE_FLOATS < 1
#  undef USE_FLOATS
# endif
#else
/* # define USE_FLOATS */
#endif

#if defined(USE_FLOATS)
#define PRECISION
#undef FLOAT_PLACEHOLDER
#endif
/*
 * This macro enables the use of the 'b' binary specifier and
 * the use of "%b", "%hb" and "%lb"
 */
/* #define BINARY_SPECIFIER */
/*
 * This macro enables the use of the 'i' integer specifier and
 * the use of "%u", "%lu", ... in place of "%ud", "%lud", ... .
 * costs ~10 code words
 */
#define EXTRA_INTEGER

#if defined(USE_FLOATS)
/* x_ftoa requires up to 8 digits (integral part) + '.' + 24 digits
 * (fractional part). Adding a sign and a NUL byte yields 35 byte. */
# define BUF_SIZE       36
#elif defined(BINARY_SPECIFIER)
/* "%lb" = "0" - "11111111111111111111111111111111" */
# define BUF_SIZE       33
#else
/* "%lo" = "0" - "37777777777" or  "-20000000000" - "17777777777" */
# define BUF_SIZE       13
#endif

#if _DEBUG
extern void io_long (unsigned long);
extern void io_str (char *);
extern void io_int (unsigned int);
#endif

int
vfprintf (FILE * stream, const char *fmt, va_list ap)
{
  unsigned char radix;
  unsigned char flong;
  unsigned char fstr;
  unsigned char fchar;
#if defined(FLOAT_PLACEHOLDER) || defined(USE_FLOATS)
  unsigned char ffloat;
#endif
  unsigned char nosign;
  unsigned char upcase;
#ifdef FIELD_WIDTH
  unsigned char fieldwidth;
  unsigned char lalign;
  char padchar;
  const char *str1;
#endif
#ifdef PRECISION
  unsigned char precision;
#endif
#ifdef SIGN_MODIFIERS
  unsigned char printsign;
  char positivechar;
#endif
  int count = 0;
  const char *ch;
  char *str;
  long val;
  char buffer[BUF_SIZE];
  char *stringbuffer;

  if (0x80 == (unsigned char)(((unsigned long)stream) >> 16)) {
    /* strmputchar will modify *(char **)stream, thus confusing the user */
    stringbuffer = (char *) stream;
    stream = (FILE *) &stringbuffer;
  }

#if _DEBUG
  io_str ("vfprintf: ");
  io_long ((unsigned long) stream);
  io_long ((unsigned long) fmt);
#endif

//    va_start(ap,fmt);
  ch = fmt;

  while (*ch) //for (; *fmt ; fmt++ )
    {
      if (*ch == '%')
        {
          flong = 0;
          fstr = 0;
          fchar = 0;
#if defined(FLOAT_PLACEHOLDER) || defined(USE_FLOATS)
          ffloat = 0;
#endif
          nosign = 0;
          radix = 10;
          upcase = 0;
#ifdef FIELD_WIDTH
          fieldwidth = 0;
          lalign = 0;
          padchar = ' ';
#endif
#ifdef PRECISION
          // precision == -1 is used as an "unlimited" precision marker
          precision = (unsigned char)-1;
#endif
#ifdef SIGN_MODIFIERS
          printsign = 0;
          positivechar = '+';
#endif
          ++ch;

          if (*ch == '%')
            {
              __stream_putchar (stream, *ch);
              ++count;
              ++ch;
              continue;
            }

#ifdef FIELD_WIDTH
          if (*ch == '0')
            {
              padchar = '0';
              ++ch;
            }

          if (*ch == '-')
            {
              lalign = 1;
              ++ch;
            }
#endif
#ifdef SIGN_MODIFIERS
          if (*ch == ' ')
            {
              printsign = 1;
              positivechar = ' ';
              ++ch;
            }

          if (*ch == '+')
            {
              printsign = 1;
              ++ch;
            }
#endif

#ifdef FIELD_WIDTH
          if ((*ch >= '1') && (*ch <= '9'))
            {
              while ((*ch >= '0') && (*ch <= '9'))
                {
                  fieldwidth = 10 * fieldwidth + (*ch) - '0';
                  ++ch;
                }
            }
#endif

#ifdef PRECISION
          if (*ch == '.')
            {
              ++ch;
              precision = 0;
              while ((*ch >= '0') && (*ch <= '9'))
                {
                  precision = 10 * precision + (*ch) - '0';
                  ++ch;
                }
            }
#endif

          if (*ch == 'l')
            {
              flong = 1;
              ++ch;
            }
          else if (*ch == 'h')
            {
              fchar = 1;
              ++ch;
            }

          if (*ch == 'u')
            {
              nosign = 1;
              ++ch;
            }

          if (*ch == 's')
            {
              fstr = 1;
#ifdef FIELD_WIDTH
              padchar = ' ';    /* Strings are always space-padded */
#endif
            }
          else if (*ch == 'x')
            radix = 16;
          else if (*ch == 'X')
            {
              radix = 16;
              upcase = 1;
            }
          else if (*ch == 'c')
            radix = 0;
          else if (*ch == 'o')
            radix = 8;
#ifdef BINARX_SPECIFIER
          else if (*ch == 'b')
            radix = 2;
#endif
#if defined(FLOAT_PLACEHOLDER) || defined(USE_FLOATS)
          else if (*ch == 'f')
            {
              ffloat = 1;
            }
#endif
#ifdef EXTRA_INTEGER
          else if ((*ch == 'd') || (*ch == 'i'))  /* This is the default */
            ;
          else if (nosign)                        /* %u alone is the same as %ud */
            --ch;
#else
          else if (*ch == 'd')
            ;
#endif
          else
            {
              __stream_putchar (stream, *ch);
              ++count;
              ++ch;
              continue;
            }

          if (fstr)
            {
              str = va_arg (ap, char *);
#if defined(USE_FLOATS)
            }
          else if (ffloat)
            {
              float f = va_arg(ap, float);
              str = buffer;
              x_ftoa (f, buffer, BUF_SIZE, precision);
              precision = -1;
#elif defined(FLOAT_PLACEHOLDER)
            }
          else if (ffloat)
            {
              str = (char*)"<NO FLOAT>";
              va_arg (ap, float);
#ifdef PRECISION
              precision = (unsigned char)-1;
#endif /* PRECISION */
#endif /* FLOAT_PLACEHOLDER */
            }
          else
            {
#ifdef PRECISION
              precision = (unsigned char)-1; //FIXME: No support for the precision field on numerals
#endif
              val = 0;
              if (flong)
                {
                  val = va_arg (ap, long);
#if _DEBUG
                  io_long (val);
#endif
                }
              else if (fchar)
                {
                  val = (char) va_arg (ap, int);  // FIXME: SDCC passes 1-byte char varargs as 2-byte ints...
                  if ((radix != 10) || nosign)
                    val = (unsigned char) val;    //Avoid unwanted sign extension
#if _DEBUG
                  io_long (val);
#endif
                }
              else
                {
                  val = va_arg (ap, int);
                  if ((radix != 10) || nosign)
                    val = (unsigned int) val;   //Avoid unwanted sign extension
#if _DEBUG
                  io_long (val);
#endif
                }

              str = buffer + 1; //Reserve space for a forced '+'
              if (radix)
                {
                  if (nosign)
                    ultoa (val, buffer + 1, radix);
                  else
                    ltoa (val, buffer + 1, radix);
#ifdef SIGN_MODIFIERS
                  if (printsign && (*str != '-'))
                    {
                      --str;
                      *str = positivechar;
                    }
#endif
                }
              else
                {
                  *str = (unsigned char) val;
                  *(str + 1) = '\0';
                }
            }

#ifdef FIELD_WIDTH
          //Count how many pad chars are required in fieldwidth
          str1 = str;
          while (fieldwidth && *str1)
            {
              ++str1;
              --fieldwidth;
            }
          //Left padding
          if (!lalign)
            {
              while (fieldwidth)
                {
                  __stream_putchar (stream, padchar);
                  ++count;
                  --fieldwidth;
                }
            }
#endif
          while (*str
#ifdef PRECISION
                 && (!~precision || precision--)
#endif
            )
            {
              radix = *str;
              if (upcase)
                {
                  radix = toupper (radix);
                }
              __stream_putchar (stream, radix);
              ++str;
              ++count;
              if (fieldwidth)
                {
                  fieldwidth--;
                }
            }
#ifdef FIELD_WIDTH
          //Right padding (with spaces)
          if (lalign)
            {
              while (fieldwidth)
                {
                  __stream_putchar (stream, ' ');
                  ++count;
                  --fieldwidth;
                }
            }
#endif
        }
      else
        {
          __stream_putchar (stream, *ch);
          ++count;
        }

      ++ch;
    }

  return count;
}
/*-------------------------------------------------------------------------
   vsprintf.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

int
vsprintf (char *ebuf, const char *fmt, va_list ap)
{
  unsigned int i;

  i = vfprintf ((FILE *) ebuf, fmt, ap);
  ebuf[i] = '\0';

  return i;
}
/*-------------------------------------------------------------------------
   fprintf.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

#if _DEBUG
extern void io_long (unsigned long);
extern void io_str (char *);
#endif

int
fprintf (FILE *stream, const char *fmt, ...)
{
  va_list ap;

#if _DEBUG
  io_str ("fprintf: ");
  io_long ((unsigned long) stream);
  io_long ((unsigned long) fmt);
#endif

  va_start (ap, fmt);
  return vfprintf (stream, fmt, ap);
}
/*-------------------------------------------------------------------------
   putchar.c - putchar dummy function

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

/* This is a dummy function so that sources compile,
 * even when user doesn't give a putchar() function. */

PUTCHAR (c)
{
  (void)c;
}
/*-------------------------------------------------------------------------
   streams.c - source file for stream declarations

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

FILE *stdout;
// = STREAM_USER;
FILE *stdin;
// = STREAM_USER;
/*-------------------------------------------------------------------------
   strmputchar.c - stream putchar dispatch function

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

void
__stream_putchar (FILE *stream, char c)
{
  unsigned char deref;

  deref = (unsigned char) (((unsigned long) stream) >> 16);

#if _DEBUG
  io_str ("__stream_putchar: ");
  io_long ((unsigned long) stream);
#endif

  if (deref == 0x80)
    {
      /* this is a data/near memory pointer */
      *(*(char **) stream) = c;
      *(char **) stream += 1;
    }
  else if (deref & 0x20)
    {
      deref ^= 0x20;
      if (deref == USART_DEREF)
        __stream_usart_putchar (c);
      else if (deref == MSSP_DEREF)
        __stream_mssp_putchar (c);
      else if (deref == USER_DEREF)
        putchar (c);
      else if (deref == GPSIM_DEREF)    /* see stdio.h for info on this */
        __stream_gpsim_putchar (c);     /* feature */
    }
}
;--------------------------------------------------------------------------
;  delay10ktcy.S
;
;  Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        include <p18fxxx.inc>

        extern  _delay10tcy
        extern  _delay1ktcy

        global  _delay10ktcy
    
        code

_delay10ktcy:
        ; polynomial for 10ktcy delay is f(x) = 10000 * (x-1) + 10000
        decf    WREG, f
    
        movwf    POSTDEC1
        movlw    9
        call    _delay1ktcy

        movlw       99
        call        _delay10tcy

        movf    PREINC1, w
 
        bz        @delay10k_end
        bra        $+2
    
@delay10k_loop:
        movwf    POSTDEC1

        movlw    9
        call    _delay1ktcy

        movlw       99
        call        _delay10tcy

        bra        $+2
        bra        $+2
        nop                         
        movf    PREINC1, w
        decfsz    WREG, f
        bra        @delay10k_loop

@delay10k_end:
        return

        end
;--------------------------------------------------------------------------
;  delay1mtcy.S
;
;  Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        include <p18fxxx.inc>

        extern  _delay10tcy
        extern  _delay100tcy
        extern  _delay10ktcy

        global  _delay1mtcy
    
        code

_delay1mtcy:
        ; polynomial for 1mtcy delay is f(x) = 100000 * (x-1) + 100000
        decf    WREG, f
    
        movwf   POSTDEC1
        movlw   99
        call    _delay10ktcy

        movlw   99
        call    _delay100tcy
        
        movlw   9
        call    _delay10tcy

        movf    PREINC1, w
 
        bz      @delay1m_end
        bra     $+2
    
@delay1m_loop:
        movwf    POSTDEC1

        movlw   99
        call    _delay10ktcy
        
        movlw   99
        call    _delay100tcy
        
        movlw   9
        call    _delay10tcy

        bra     $+2
        bra     $+2
        nop                         
        movf    PREINC1, w
        decfsz  WREG, f
        bra     @delay1m_loop

@delay1m_end:
        return

        end
;--------------------------------------------------------------------------
;  delay100ktcy.S
;
;  Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        include <p18fxxx.inc>

        extern  _delay10tcy
        extern  _delay1ktcy

        global  _delay100ktcy
    
        code

_delay100ktcy:
        ; polynomial for 100ktcy delay is f(x) = 100000 * (x-1) + 100000
        decf    WREG, f
    
        movwf    POSTDEC1
        movlw    99
        call    _delay1ktcy

        movlw       99
        call        _delay10tcy

        movf    PREINC1, w
 
        bz        @delay100k_end
        bra        $+2
    
@delay100k_loop:
        movwf    POSTDEC1

        movlw    99
        call    _delay1ktcy

        movlw       99
        call        _delay10tcy

        bra        $+2
        bra        $+2
        nop                         
        movf    PREINC1, w
        decfsz    WREG, f
        bra        @delay100k_loop

@delay100k_end:
        return

        end
;--------------------------------------------------------------------------
;  delay10tcy.S
;
;  Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

    include <p18fxxx.inc>

    global    _delay10tcy
    
    code

_delay10tcy:
      ; polynomial for 10tcy delay is f(x) = 10 * (x-1) + 10
      decf      WREG, f
      nop

      movf      WREG, w
      bz        @delay10_end

      bra       $+2

@delay10_loop:
      bra       $+2
      bra       $+2
      bra       $+2

      nop
      decfsz    WREG, f
      bra       @delay10_loop

@delay10_end:

      return

      end
;--------------------------------------------------------------------------
;  delay1ktcy.S
;
;  Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        include <p18fxxx.inc>

        extern  _delay10tcy

        global  _delay1ktcy
    
        code

_delay1ktcy:
        ; polynomial for 1ktcy delay is f(x) = 1000 * (x-1) + 1000
        decf    WREG, f

        movwf   POSTDEC1
        movlw    99
        call    _delay10tcy

        movf    PREINC1, w
 
        bz      @delay1k_end
        bra     $+2
    
@delay1k_loop:
        movwf   POSTDEC1
        movlw   99
        call    _delay10tcy

        bra     $+2
        bra     $+2
        nop

        movf    PREINC1, w
        decfsz  WREG, f
        bra     @delay1k_loop

@delay1k_end:
        return

        end
;--------------------------------------------------------------------------
;  delay100tcy.S
;
;  Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        include <p18fxxx.inc>

        extern  _delay10tcy

        global  _delay100tcy
    
        code

_delay100tcy:
        ; polynomial for 100tcy delay is f(x) = 100 * (x-1) + 100
        decf    WREG, f
        movwf   POSTDEC1
        movlw   9
        call    _delay10tcy

        movf    PREINC1, w

        bz      @delay100_end
        bra     $+2

@delay100_loop:
        movwf   POSTDEC1

        movlw   9
        call    _delay10tcy

        bra     $+2

        movf    PREINC1, w
        nop
        bra     $+2
        decfsz  WREG, f
        bra     @delay100_loop

@delay100_end:
        return

        end
;--------------------------------------------------------------------------
;  cvtdec.S - convert a 16-bit binary word to 5 BCD bytes
;
;  Copyright (C) 2004, George Gallant <ggallant571 AT verizon.net>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

;--
;
;	File:	cvtdec.asm
;	Author:	George Gallant
;	Date:	19OCT04
;	
;	This routine is based on the code and algorithm by
;	Nikolai Golovchenko and Scott Dattalo presented in
;	the piclist webb site on radix conversion methods.
;	Modified to support integers from 0 to 65535 and coded
;	for the pic18 chip set.
;
;			   Digit
;	BIT  Weight  4   3   2   1   0
;	---  ------ --- --- --- --- ---
;	 0      1    0   0   0   0   1
;	 1      2    0   0   0   0   2
;	 2      4    0   0   0   0   4
;	 3      8    0   0   0   0   8
;	
;	 4     16    0   0   0   1   6
;	 5     32    0   0   0   3   2
;	 6     64    0   0   0   6   4
;	 7    128    0   0   1   2   8
;
;	 8    256    0   0   2   5   6
;	 9    512    0   0   5   1   2
;	10   1024    0   1   0   2   4
;	11   2048    0   2   0   4   8
;
;	12   4096    0   4   0   9   6
;	13   8192    0   8   1   9   2
;	14  16384    1   6   3   8   4
;	15  32768    3   2   7   6   8
;
;--
		nolist
		include	<p18fxxx.inc>
		list

	
		global	cvt_dec_word

		udata

		global	digits

digits:		res	6

		code


;--
;
;	Convert a 16-bit binary word to 5 BCD bytes
;
;	On Call
;		PROD	16 bit word
;		FSR0	pointer to ascii buffer
;
;	On Return
;		digits[4:0] contain the BCD integers
;
;	Notes:	1. strip leading zeros
;		2. only positive integers on input
;		3. FSR0, PROD & W are modified and not preserved
;
;--
cvt_dec_word:	clrw				;calculate digit 0 - lsd

		btfsc	PRODL,0			;bit0
		addlw	1

		btfsc	PRODL,1			;bit1
		addlw	2

		btfsc	PRODL,2			;bit2
		addlw	4

		btfsc	PRODL,3			;bit3
		addlw	8

		btfsc	PRODL,4			;bit4
		addlw	6

		btfsc	PRODL,5			;bit5
		addlw	2

		btfsc	PRODL,6			;bit6
		addlw	4

		btfsc	PRODL,7			;bit7
		addlw	8

		btfsc	PRODH,0			;bit8
		addlw	6

		btfsc	PRODH,1			;bit9
		addlw	2

		btfsc	PRODH,2			;bit10
		addlw	4

		btfsc	PRODH,3			;bit11
		addlw	8

		btfsc	PRODH,4			;bit12
		addlw	6

		btfsc	PRODH,5			;bit13
		addlw	2

		btfsc	PRODH,6			;bit14
		addlw	4

		btfsc	PRODH,7			;bit15
		addlw	8

		clrf	digits+1		;setup for carry in 10's
@1:		addlw	-10
		bnc	@2
		incf	digits+1,f
		bra	@1

@2:		addlw	10
		movwf	digits+0

;	calculate digit 1

		movf	digits+1,w

		btfsc	PRODL,4			;bit4
		addlw	1

		btfsc	PRODL,5			;bit5
		addlw	3

		btfsc	PRODL,6			;bit6
		addlw	6

		btfsc	PRODL,7			;bit7
		addlw	2

		btfsc	PRODH,0			;bit8
		addlw	5

		btfsc	PRODH,1			;bit9
		addlw	1

		btfsc	PRODH,2			;bit10
		addlw	2

		btfsc	PRODH,3			;bit11
		addlw	4

		btfsc	PRODH,4			;bit12
		addlw	9

		btfsc	PRODH,5			;bit13
		addlw	9

		btfsc	PRODH,6			;bit14
		addlw	8

		btfsc	PRODH,7			;bit15
		addlw	6

		clrf	digits+2		;setup for carry into 100's
@3:		addlw	-10
		bnc	@4
		incf	digits+2,f
		bra	@3

@4:		addlw	10
		movwf	digits+1

;	calculate digit 2

		movf	digits+2,w

		btfsc	PRODL,7			;bit7
		addlw	1

		btfsc	PRODH,0			;bit8
		addlw	2

		btfsc	PRODH,1			;bit9
		addlw	5

		btfsc	PRODH,5			;bit13
		addlw	1

		btfsc	PRODH,6			;bit14
		addlw	3

		btfsc	PRODH,7			;bit15
		addlw	7

		clrf	digits+3		;setup for carry into 1000's
@5:		addlw	-10
		bnc	@6
		incf	digits+3,f
		bra	@5
@6:		addlw	10

		movwf	digits+2

;	calculate digit 3

		movf	digits+3,w

		btfsc	PRODH,2			;bit10
		addlw	1

		btfsc	PRODH,3			;bit11
		addlw	2

		btfsc	PRODH,4			;bit12
		addlw	4

		btfsc	PRODH,5			;bit13
		addlw	8

		btfsc	PRODH,6			;bit14
		addlw	6

		btfsc	PRODH,7			;bit15
		addlw	2

		clrf	digits+4		;setup for carry into 10000's
@7:		addlw	-10
		bnc	@8
		incf	digits+4,f
		bra	@7

@8:		addlw	10
		movwf	digits+3

;	calculate digit 4

		movf	digits+4,w

		btfsc	PRODH,6			;bit14
		addlw	1

		btfsc	PRODH,7			;bit15
		addlw	3

@9:		addlw	-10
		bc	@9

		addlw	10
;		movwf	digits+4

;		movf	digits+4,w
		bnz	@11
		movf	digits+3,w
		bnz	@12
		movf	digits+2,w
		bnz	@13
		movf	digits+1,w
		bnz	@14
		bra	@15

@11:		addlw	0x30
		movwf	POSTINC0

		movf	digits+3,w
@12:		addlw	0x30
		movwf	POSTINC0

		movf	digits+2,w
@13:		addlw	0x30
		movwf	POSTINC0

		movf	digits+1,w
@14:		addlw	0x30
		movwf	POSTINC0

@15:		movf	digits+0,w
		addlw	0x30
		movwf	POSTINC0

		return

		end
;--------------------------------------------------------------------------
;  cnvfrac.S - convertion routine of 24 bits floating point to ASCII
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec
	list
	nolist


WREG	equ	0xfe8
POSTINC0	equ	0xfee
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
STATUS	equ	0xfd8


	global	_convert_frac


.registers	udata_ovr	0x000
r0x00	res	1
r0x01	res	1
r0x02	res	1
r0x03	res	1
round_digit	res	1
d0x00	res	1
d0x01	res	1
d0x02	res	1
d0x03	res	1
d0x04	res	1
d0x05	res	1
d0x06	res	1
d0x07	res	1
d0x08	res	1
d0x09	res	1
d0x10	res	1
d0x11	res	1
d0x12	res	1
d0x13	res	1
d0x14	res	1
d0x15	res	1
d0x16	res	1
d0x17	res	1
d0x18	res	1
d0x19	res	1
d0x20	res	1
d0x21	res	1
d0x22	res	1
d0x23	res	1
d0x24	res	1


S__convert_frac	code
_convert_frac:

	movff	d0x00, POSTDEC1
	movff	d0x01, POSTDEC1
	movff	d0x02, POSTDEC1
	movff	d0x03, POSTDEC1
	movff	d0x04, POSTDEC1
	movff	d0x05, POSTDEC1
	movff	d0x06, POSTDEC1
	movff	d0x07, POSTDEC1
	movff	d0x08, POSTDEC1
	movff	d0x09, POSTDEC1
	movff	d0x10, POSTDEC1
	movff	d0x11, POSTDEC1
	movff	d0x12, POSTDEC1
	movff	d0x13, POSTDEC1
	movff	d0x14, POSTDEC1
	movff	d0x15, POSTDEC1
	movff	d0x16, POSTDEC1
	movff	d0x17, POSTDEC1
	movff	d0x18, POSTDEC1
	movff	d0x19, POSTDEC1
	movff	d0x20, POSTDEC1
	movff	d0x21, POSTDEC1
	movff	d0x22, POSTDEC1
	movff	d0x23, POSTDEC1
	movff	d0x24, POSTDEC1


; adding digit 0
;	movff	0xf7f, 0xfe8

	movlw	0

	btfsc	r0x00, 0		; bit 0
	addlw	5


	clrf	d0x01
@1:
	addlw	-10
	bnc	@2
	incf	d0x01, f
	bra	@1
@2:
	addlw	10
	movwf	d0x00


	decfsz	round_digit, f
	bra	@3
	addlw	251
	bnc	@3
	incf	d0x01, f

@3:

; adding digit 1
	movf	d0x01, w

	btfsc	r0x00, 0		; bit 0
	addlw	2

	btfsc	r0x00, 1		; bit 1
	addlw	5


	clrf	d0x02
@4:
	addlw	-10
	bnc	@5
	incf	d0x02, f
	bra	@4
@5:
	addlw	10
	movwf	d0x01


	decfsz	round_digit, f
	bra	@6
	addlw	251
	bnc	@6
	incf	d0x02, f

@6:

; adding digit 2
	movf	d0x02, w

	btfsc	r0x00, 0		; bit 0
	addlw	6

	btfsc	r0x00, 1		; bit 1
	addlw	2

	btfsc	r0x00, 2		; bit 2
	addlw	5


	clrf	d0x03
@7:
	addlw	-10
	bnc	@8
	incf	d0x03, f
	bra	@7
@8:
	addlw	10
	movwf	d0x02


	decfsz	round_digit, f
	bra	@9
	addlw	251
	bnc	@9
	incf	d0x03, f

@9:

; adding digit 3
	movf	d0x03, w

	btfsc	r0x00, 1		; bit 1
	addlw	1

	btfsc	r0x00, 2		; bit 2
	addlw	2

	btfsc	r0x00, 3		; bit 3
	addlw	5


	clrf	d0x04
@10:
	addlw	-10
	bnc	@11
	incf	d0x04, f
	bra	@10
@11:
	addlw	10
	movwf	d0x03


	decfsz	round_digit, f
	bra	@12
	addlw	251
	bnc	@12
	incf	d0x04, f

@12:

; adding digit 4
	movf	d0x04, w

	btfsc	r0x00, 0		; bit 0
	addlw	9

	btfsc	r0x00, 1		; bit 1
	addlw	8

	btfsc	r0x00, 2		; bit 2
	addlw	6

	btfsc	r0x00, 3		; bit 3
	addlw	2

	btfsc	r0x00, 4		; bit 4
	addlw	5


	clrf	d0x05
@13:
	addlw	-10
	bnc	@14
	incf	d0x05, f
	bra	@13
@14:
	addlw	10
	movwf	d0x04


	decfsz	round_digit, f
	bra	@15
	addlw	251
	bnc	@15
	incf	d0x05, f

@15:

; adding digit 5
	movf	d0x05, w

	btfsc	r0x00, 0		; bit 0
	addlw	3

	btfsc	r0x00, 1		; bit 1
	addlw	7

	btfsc	r0x00, 2		; bit 2
	addlw	5

	btfsc	r0x00, 3		; bit 3
	addlw	1

	btfsc	r0x00, 4		; bit 4
	addlw	2

	btfsc	r0x00, 5		; bit 5
	addlw	5


	clrf	d0x06
@16:
	addlw	-10
	bnc	@17
	incf	d0x06, f
	bra	@16
@17:
	addlw	10
	movwf	d0x05


	decfsz	round_digit, f
	bra	@18
	addlw	251
	bnc	@18
	incf	d0x06, f

@18:

; adding digit 6
	movf	d0x06, w

	btfsc	r0x00, 0		; bit 0
	addlw	5

	btfsc	r0x00, 2		; bit 2
	addlw	1

	btfsc	r0x00, 3		; bit 3
	addlw	3

	btfsc	r0x00, 4		; bit 4
	addlw	6

	btfsc	r0x00, 5		; bit 5
	addlw	2

	btfsc	r0x00, 6		; bit 6
	addlw	5


	clrf	d0x07
@19:
	addlw	-10
	bnc	@20
	incf	d0x07, f
	bra	@19
@20:
	addlw	10
	movwf	d0x06


	decfsz	round_digit, f
	bra	@21
	addlw	251
	bnc	@21
	incf	d0x07, f

@21:

; adding digit 7
	movf	d0x07, w

	btfsc	r0x00, 0		; bit 0
	addlw	7

	btfsc	r0x00, 1		; bit 1
	addlw	5

	btfsc	r0x00, 5		; bit 5
	addlw	1

	btfsc	r0x00, 6		; bit 6
	addlw	2

	btfsc	r0x00, 7		; bit 7
	addlw	5


	clrf	d0x08
@22:
	addlw	-10
	bnc	@23
	incf	d0x08, f
	bra	@22
@23:
	addlw	10
	movwf	d0x07


	decfsz	round_digit, f
	bra	@24
	addlw	251
	bnc	@24
	incf	d0x08, f

@24:

; adding digit 8
	movf	d0x08, w

	btfsc	r0x00, 0		; bit 0
	addlw	7

	btfsc	r0x00, 1		; bit 1
	addlw	5

	btfsc	r0x00, 2		; bit 2
	addlw	1

	btfsc	r0x00, 3		; bit 3
	addlw	2

	btfsc	r0x00, 4		; bit 4
	addlw	4

	btfsc	r0x00, 5		; bit 5
	addlw	8

	btfsc	r0x00, 6		; bit 6
	addlw	6

	btfsc	r0x00, 7		; bit 7
	addlw	2

	btfsc	r0x01, 0		; bit 8
	addlw	5


	clrf	d0x09
@25:
	addlw	-10
	bnc	@26
	incf	d0x09, f
	bra	@25
@26:
	addlw	10
	movwf	d0x08


	decfsz	round_digit, f
	bra	@27
	addlw	251
	bnc	@27
	incf	d0x09, f

@27:

; adding digit 9
	movf	d0x09, w

	btfsc	r0x00, 0		; bit 0
	addlw	4

	btfsc	r0x00, 1		; bit 1
	addlw	9

	btfsc	r0x00, 2		; bit 2
	addlw	9

	btfsc	r0x00, 3		; bit 3
	addlw	8

	btfsc	r0x00, 4		; bit 4
	addlw	6

	btfsc	r0x00, 5		; bit 5
	addlw	2

	btfsc	r0x00, 6		; bit 6
	addlw	5

	btfsc	r0x00, 7		; bit 7
	addlw	1

	btfsc	r0x01, 0		; bit 8
	addlw	2

	btfsc	r0x01, 1		; bit 9
	addlw	5


	clrf	d0x10
@28:
	addlw	-10
	bnc	@29
	incf	d0x10, f
	bra	@28
@29:
	addlw	10
	movwf	d0x09


	decfsz	round_digit, f
	bra	@30
	addlw	251
	bnc	@30
	incf	d0x10, f

@30:

; adding digit 10
	movf	d0x10, w

	btfsc	r0x00, 0		; bit 0
	addlw	4

	btfsc	r0x00, 1		; bit 1
	addlw	8

	btfsc	r0x00, 2		; bit 2
	addlw	7

	btfsc	r0x00, 3		; bit 3
	addlw	5

	btfsc	r0x00, 4		; bit 4
	addlw	1

	btfsc	r0x00, 5		; bit 5
	addlw	3

	btfsc	r0x00, 6		; bit 6
	addlw	6

	btfsc	r0x00, 7		; bit 7
	addlw	3

	btfsc	r0x01, 0		; bit 8
	addlw	6

	btfsc	r0x01, 1		; bit 9
	addlw	2

	btfsc	r0x01, 2		; bit 10
	addlw	5


	clrf	d0x11
@31:
	addlw	-10
	bnc	@32
	incf	d0x11, f
	bra	@31
@32:
	addlw	10
	movwf	d0x10


	decfsz	round_digit, f
	bra	@33
	addlw	251
	bnc	@33
	incf	d0x11, f

@33:

; adding digit 11
	movf	d0x11, w

	btfsc	r0x00, 0		; bit 0
	addlw	6

	btfsc	r0x00, 1		; bit 1
	addlw	2

	btfsc	r0x00, 2		; bit 2
	addlw	5

	btfsc	r0x00, 3		; bit 3
	addlw	1

	btfsc	r0x00, 4		; bit 4
	addlw	3

	btfsc	r0x00, 5		; bit 5
	addlw	6

	btfsc	r0x00, 6		; bit 6
	addlw	2

	btfsc	r0x00, 7		; bit 7
	addlw	5

	btfsc	r0x01, 1		; bit 9
	addlw	1

	btfsc	r0x01, 2		; bit 10
	addlw	2

	btfsc	r0x01, 3		; bit 11
	addlw	5


	clrf	d0x12
@34:
	addlw	-10
	bnc	@35
	incf	d0x12, f
	bra	@34
@35:
	addlw	10
	movwf	d0x11


	decfsz	round_digit, f
	bra	@36
	addlw	251
	bnc	@36
	incf	d0x12, f

@36:

; adding digit 12
	movf	d0x12, w

	btfsc	r0x00, 0		; bit 0
	addlw	4

	btfsc	r0x00, 1		; bit 1
	addlw	9

	btfsc	r0x00, 2		; bit 2
	addlw	8

	btfsc	r0x00, 3		; bit 3
	addlw	7

	btfsc	r0x00, 4		; bit 4
	addlw	4

	btfsc	r0x00, 5		; bit 5
	addlw	8

	btfsc	r0x00, 6		; bit 6
	addlw	7

	btfsc	r0x00, 7		; bit 7
	addlw	4

	btfsc	r0x01, 0		; bit 8
	addlw	9

	btfsc	r0x01, 1		; bit 9
	addlw	8

	btfsc	r0x01, 2		; bit 10
	addlw	6

	btfsc	r0x01, 3		; bit 11
	addlw	2

	btfsc	r0x01, 4		; bit 12
	addlw	5


	clrf	d0x13
@37:
	addlw	-10
	bnc	@38
	incf	d0x13, f
	bra	@37
@38:
	addlw	10
	movwf	d0x12


	decfsz	round_digit, f
	bra	@39
	addlw	251
	bnc	@39
	incf	d0x13, f

@39:

; adding digit 13
	movf	d0x13, w

	btfsc	r0x00, 2		; bit 2
	addlw	1

	btfsc	r0x00, 3		; bit 3
	addlw	3

	btfsc	r0x00, 4		; bit 4
	addlw	7

	btfsc	r0x00, 5		; bit 5
	addlw	4

	btfsc	r0x00, 6		; bit 6
	addlw	9

	btfsc	r0x00, 7		; bit 7
	addlw	9

	btfsc	r0x01, 0		; bit 8
	addlw	8

	btfsc	r0x01, 1		; bit 9
	addlw	7

	btfsc	r0x01, 2		; bit 10
	addlw	5

	btfsc	r0x01, 3		; bit 11
	addlw	1

	btfsc	r0x01, 4		; bit 12
	addlw	2

	btfsc	r0x01, 5		; bit 13
	addlw	5


	clrf	d0x14
@40:
	addlw	-10
	bnc	@41
	incf	d0x14, f
	bra	@40
@41:
	addlw	10
	movwf	d0x13


	decfsz	round_digit, f
	bra	@42
	addlw	251
	bnc	@42
	incf	d0x14, f

@42:

; adding digit 14
	movf	d0x14, w

	btfsc	r0x00, 0		; bit 0
	addlw	6

	btfsc	r0x00, 1		; bit 1
	addlw	2

	btfsc	r0x00, 2		; bit 2
	addlw	4

	btfsc	r0x00, 3		; bit 3
	addlw	8

	btfsc	r0x00, 4		; bit 4
	addlw	6

	btfsc	r0x00, 5		; bit 5
	addlw	3

	btfsc	r0x00, 6		; bit 6
	addlw	6

	btfsc	r0x00, 7		; bit 7
	addlw	3

	btfsc	r0x01, 0		; bit 8
	addlw	7

	btfsc	r0x01, 1		; bit 9
	addlw	5

	btfsc	r0x01, 2		; bit 10
	addlw	1

	btfsc	r0x01, 3		; bit 11
	addlw	3

	btfsc	r0x01, 4		; bit 12
	addlw	6

	btfsc	r0x01, 5		; bit 13
	addlw	2

	btfsc	r0x01, 6		; bit 14
	addlw	5


	clrf	d0x15
@43:
	addlw	-10
	bnc	@44
	incf	d0x15, f
	bra	@43
@44:
	addlw	10
	movwf	d0x14


	decfsz	round_digit, f
	bra	@45
	addlw	251
	bnc	@45
	incf	d0x15, f

@45:

; adding digit 15
	movf	d0x15, w

	btfsc	r0x00, 0		; bit 0
	addlw	9

	btfsc	r0x00, 1		; bit 1
	addlw	9

	btfsc	r0x00, 2		; bit 2
	addlw	8

	btfsc	r0x00, 3		; bit 3
	addlw	6

	btfsc	r0x00, 4		; bit 4
	addlw	3

	btfsc	r0x00, 5		; bit 5
	addlw	7

	btfsc	r0x00, 6		; bit 6
	addlw	4

	btfsc	r0x00, 7		; bit 7
	addlw	9

	btfsc	r0x01, 0		; bit 8
	addlw	8

	btfsc	r0x01, 1		; bit 9
	addlw	7

	btfsc	r0x01, 2		; bit 10
	addlw	5

	btfsc	r0x01, 5		; bit 13
	addlw	1

	btfsc	r0x01, 6		; bit 14
	addlw	2

	btfsc	r0x01, 7		; bit 15
	addlw	5


	clrf	d0x16
@46:
	addlw	-10
	bnc	@47
	incf	d0x16, f
	bra	@46
@47:
	addlw	10
	movwf	d0x15


	decfsz	round_digit, f
	bra	@48
	addlw	251
	bnc	@48
	incf	d0x16, f

@48:

; adding digit 16
	movf	d0x16, w

	btfsc	r0x00, 0		; bit 0
	addlw	5

	btfsc	r0x00, 1		; bit 1
	addlw	1

	btfsc	r0x00, 2		; bit 2
	addlw	3

	btfsc	r0x00, 3		; bit 3
	addlw	7

	btfsc	r0x00, 4		; bit 4
	addlw	5

	btfsc	r0x00, 6		; bit 6
	addlw	1

	btfsc	r0x00, 7		; bit 7
	addlw	2

	btfsc	r0x01, 0		; bit 8
	addlw	5

	btfsc	r0x01, 1		; bit 9
	addlw	1

	btfsc	r0x01, 2		; bit 10
	addlw	3

	btfsc	r0x01, 3		; bit 11
	addlw	7

	btfsc	r0x01, 4		; bit 12
	addlw	4

	btfsc	r0x01, 5		; bit 13
	addlw	8

	btfsc	r0x01, 6		; bit 14
	addlw	6

	btfsc	r0x01, 7		; bit 15
	addlw	2

	btfsc	r0x02, 0		; bit 16
	addlw	5


	clrf	d0x17
@49:
	addlw	-10
	bnc	@50
	incf	d0x17, f
	bra	@49
@50:
	addlw	10
	movwf	d0x16


	decfsz	round_digit, f
	bra	@51
	addlw	251
	bnc	@51
	incf	d0x17, f

@51:

; adding digit 17
	movf	d0x17, w

	btfsc	r0x00, 1		; bit 1
	addlw	1

	btfsc	r0x00, 2		; bit 2
	addlw	2

	btfsc	r0x00, 3		; bit 3
	addlw	4

	btfsc	r0x00, 4		; bit 4
	addlw	9

	btfsc	r0x00, 5		; bit 5
	addlw	9

	btfsc	r0x00, 6		; bit 6
	addlw	8

	btfsc	r0x00, 7		; bit 7
	addlw	6

	btfsc	r0x01, 0		; bit 8
	addlw	2

	btfsc	r0x01, 1		; bit 9
	addlw	5

	btfsc	r0x01, 4		; bit 12
	addlw	1

	btfsc	r0x01, 5		; bit 13
	addlw	2

	btfsc	r0x01, 6		; bit 14
	addlw	5

	btfsc	r0x01, 7		; bit 15
	addlw	1

	btfsc	r0x02, 0		; bit 16
	addlw	2

	btfsc	r0x02, 1		; bit 17
	addlw	5


	clrf	d0x18
@52:
	addlw	-10
	bnc	@53
	incf	d0x18, f
	bra	@52
@53:
	addlw	10
	movwf	d0x17


	decfsz	round_digit, f
	bra	@54
	addlw	251
	bnc	@54
	incf	d0x18, f

@54:

; adding digit 18
	movf	d0x18, w

	btfsc	r0x00, 5		; bit 5
	addlw	1

	btfsc	r0x00, 6		; bit 6
	addlw	3

	btfsc	r0x00, 7		; bit 7
	addlw	7

	btfsc	r0x01, 0		; bit 8
	addlw	5

	btfsc	r0x01, 2		; bit 10
	addlw	1

	btfsc	r0x01, 3		; bit 11
	addlw	2

	btfsc	r0x01, 4		; bit 12
	addlw	4

	btfsc	r0x01, 5		; bit 13
	addlw	8

	btfsc	r0x01, 6		; bit 14
	addlw	6

	btfsc	r0x01, 7		; bit 15
	addlw	3

	btfsc	r0x02, 0		; bit 16
	addlw	6

	btfsc	r0x02, 1		; bit 17
	addlw	2

	btfsc	r0x02, 2		; bit 18
	addlw	5


	clrf	d0x19
@55:
	addlw	-10
	bnc	@56
	incf	d0x19, f
	bra	@55
@56:
	addlw	10
	movwf	d0x18


	decfsz	round_digit, f
	bra	@57
	addlw	251
	bnc	@57
	incf	d0x19, f

@57:

; adding digit 19
	movf	d0x19, w

	btfsc	r0x01, 0		; bit 8
	addlw	1

	btfsc	r0x01, 1		; bit 9
	addlw	3

	btfsc	r0x01, 2		; bit 10
	addlw	6

	btfsc	r0x01, 3		; bit 11
	addlw	2

	btfsc	r0x01, 4		; bit 12
	addlw	4

	btfsc	r0x01, 5		; bit 13
	addlw	8

	btfsc	r0x01, 6		; bit 14
	addlw	7

	btfsc	r0x01, 7		; bit 15
	addlw	5

	btfsc	r0x02, 1		; bit 17
	addlw	1

	btfsc	r0x02, 2		; bit 18
	addlw	2

	btfsc	r0x02, 3		; bit 19
	addlw	5


	clrf	d0x20
@58:
	addlw	-10
	bnc	@59
	incf	d0x20, f
	bra	@58
@59:
	addlw	10
	movwf	d0x19


	decfsz	round_digit, f
	bra	@60
	addlw	251
	bnc	@60
	incf	d0x20, f

@60:

; adding digit 20
	movf	d0x20, w

	btfsc	r0x01, 3		; bit 11
	addlw	1

	btfsc	r0x01, 4		; bit 12
	addlw	2

	btfsc	r0x01, 5		; bit 13
	addlw	4

	btfsc	r0x01, 6		; bit 14
	addlw	9

	btfsc	r0x01, 7		; bit 15
	addlw	9

	btfsc	r0x02, 0		; bit 16
	addlw	9

	btfsc	r0x02, 1		; bit 17
	addlw	8

	btfsc	r0x02, 2		; bit 18
	addlw	6

	btfsc	r0x02, 3		; bit 19
	addlw	2

	btfsc	r0x02, 4		; bit 20
	addlw	5


	clrf	d0x21
@61:
	addlw	-10
	bnc	@62
	incf	d0x21, f
	bra	@61
@62:
	addlw	10
	movwf	d0x20


	decfsz	round_digit, f
	bra	@63
	addlw	251
	bnc	@63
	incf	d0x21, f

@63:

; adding digit 21
	movf	d0x21, w

	btfsc	r0x01, 7		; bit 15
	addlw	1

	btfsc	r0x02, 0		; bit 16
	addlw	3

	btfsc	r0x02, 1		; bit 17
	addlw	7

	btfsc	r0x02, 2		; bit 18
	addlw	5

	btfsc	r0x02, 3		; bit 19
	addlw	1

	btfsc	r0x02, 4		; bit 20
	addlw	2

	btfsc	r0x02, 5		; bit 21
	addlw	5


	clrf	d0x22
@64:
	addlw	-10
	bnc	@65
	incf	d0x22, f
	bra	@64
@65:
	addlw	10
	movwf	d0x21


	decfsz	round_digit, f
	bra	@66
	addlw	251
	bnc	@66
	incf	d0x22, f

@66:

; adding digit 22
	movf	d0x22, w

	btfsc	r0x02, 2		; bit 18
	addlw	1

	btfsc	r0x02, 3		; bit 19
	addlw	3

	btfsc	r0x02, 4		; bit 20
	addlw	6

	btfsc	r0x02, 5		; bit 21
	addlw	2

	btfsc	r0x02, 6		; bit 22
	addlw	5


	clrf	d0x23
@67:
	addlw	-10
	bnc	@68
	incf	d0x23, f
	bra	@67
@68:
	addlw	10
	movwf	d0x22


	decfsz	round_digit, f
	bra	@69
	addlw	251
	bnc	@69
	incf	d0x23, f

@69:

; adding digit 23
	movf	d0x23, w

	btfsc	r0x02, 5		; bit 21
	addlw	1

	btfsc	r0x02, 6		; bit 22
	addlw	2

	btfsc	r0x02, 7		; bit 23
	addlw	5


	clrf	d0x24
@70:
	addlw	-10
	bnc	@71
	incf	d0x24, f
	bra	@70
@71:
	addlw	10
	movwf	d0x23


	decfsz	round_digit, f
	bra	@72
	addlw	251
	bnc	@72
	incf	d0x24, f

@72:


; finalization
@73:
	addlw	48
	movwf	POSTINC0
	movf	d0x22, w
@74:
	addlw	48
	movwf	POSTINC0
	movf	d0x21, w
@75:
	addlw	48
	movwf	POSTINC0
	movf	d0x20, w
@76:
	addlw	48
	movwf	POSTINC0
	movf	d0x19, w
@77:
	addlw	48
	movwf	POSTINC0
	movf	d0x18, w
@78:
	addlw	48
	movwf	POSTINC0
	movf	d0x17, w
@79:
	addlw	48
	movwf	POSTINC0
	movf	d0x16, w
@80:
	addlw	48
	movwf	POSTINC0
	movf	d0x15, w
@81:
	addlw	48
	movwf	POSTINC0
	movf	d0x14, w
@82:
	addlw	48
	movwf	POSTINC0
	movf	d0x13, w
@83:
	addlw	48
	movwf	POSTINC0
	movf	d0x12, w
@84:
	addlw	48
	movwf	POSTINC0
	movf	d0x11, w
@85:
	addlw	48
	movwf	POSTINC0
	movf	d0x10, w
@86:
	addlw	48
	movwf	POSTINC0
	movf	d0x09, w
@87:
	addlw	48
	movwf	POSTINC0
	movf	d0x08, w
@88:
	addlw	48
	movwf	POSTINC0
	movf	d0x07, w
@89:
	addlw	48
	movwf	POSTINC0
	movf	d0x06, w
@90:
	addlw	48
	movwf	POSTINC0
	movf	d0x05, w
@91:
	addlw	48
	movwf	POSTINC0
	movf	d0x04, w
@92:
	addlw	48
	movwf	POSTINC0
	movf	d0x03, w
@93:
	addlw	48
	movwf	POSTINC0
	movf	d0x02, w
@94:
	addlw	48
	movwf	POSTINC0
	movf	d0x01, w
@95:
	addlw	48
	movwf	POSTINC0
	movf	d0x00, w
@96:
	addlw	48
	movwf	POSTINC0

	movlw	23

	movff	PREINC1, d0x24
	movff	PREINC1, d0x23
	movff	PREINC1, d0x22
	movff	PREINC1, d0x21
	movff	PREINC1, d0x20
	movff	PREINC1, d0x19
	movff	PREINC1, d0x18
	movff	PREINC1, d0x17
	movff	PREINC1, d0x16
	movff	PREINC1, d0x15
	movff	PREINC1, d0x14
	movff	PREINC1, d0x13
	movff	PREINC1, d0x12
	movff	PREINC1, d0x11
	movff	PREINC1, d0x10
	movff	PREINC1, d0x09
	movff	PREINC1, d0x08
	movff	PREINC1, d0x07
	movff	PREINC1, d0x06
	movff	PREINC1, d0x05
	movff	PREINC1, d0x04
	movff	PREINC1, d0x03
	movff	PREINC1, d0x02
	movff	PREINC1, d0x01
	movff	PREINC1, d0x00
	return

	end

; Converstion table
;
;00	0.5000000000000000000000000	5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
;01	0.2500000000000000000000000	2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
;02	0.1250000000000000000000000	1 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
;03	0.0625000000000000000000000	0 6 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
;04	0.0312500000000000000000000	0 3 1 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
;05	0.0156250000000000000000000	0 1 5 6 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
;06	0.0078125000000000000000000	0 0 7 8 1 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
;07	0.0039062500000000000000000	0 0 3 9 0 6 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
;08	0.0019531250000000000000000	0 0 1 9 5 3 1 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
;09	0.0009765625000000000000000	0 0 0 9 7 6 5 6 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
;10	0.0004882812500000000000000	0 0 0 4 8 8 2 8 1 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 
;11	0.0002441406250000000000000	0 0 0 2 4 4 1 4 0 6 2 5 0 0 0 0 0 0 0 0 0 0 0 0 
;12	0.0001220703125000000000000	0 0 0 1 2 2 0 7 0 3 1 2 5 0 0 0 0 0 0 0 0 0 0 0 
;13	0.0000610351562500000000000	0 0 0 0 6 1 0 3 5 1 5 6 2 5 0 0 0 0 0 0 0 0 0 0 
;14	0.0000305175781250000000000	0 0 0 0 3 0 5 1 7 5 7 8 1 2 5 0 0 0 0 0 0 0 0 0 
;15	0.0000152587890625000000000	0 0 0 0 1 5 2 5 8 7 8 9 0 6 2 5 0 0 0 0 0 0 0 0 
;16	0.0000076293945312500000000	0 0 0 0 0 7 6 2 9 3 9 4 5 3 1 2 5 0 0 0 0 0 0 0 
;17	0.0000038146972656250000000	0 0 0 0 0 3 8 1 4 6 9 7 2 6 5 6 2 5 0 0 0 0 0 0 
;18	0.0000019073486328125000000	0 0 0 0 0 1 9 0 7 3 4 8 6 3 2 8 1 2 5 0 0 0 0 0 
;19	0.0000009536743164062500000	0 0 0 0 0 0 9 5 3 6 7 4 3 1 6 4 0 6 2 5 0 0 0 0 
;20	0.0000004768371582031250000	0 0 0 0 0 0 4 7 6 8 3 7 1 5 8 2 0 3 1 2 5 0 0 0 
;21	0.0000002384185791015625000	0 0 0 0 0 0 2 3 8 4 1 8 5 7 9 1 0 1 5 6 2 5 0 0 
;22	0.0000001192092895507812500	0 0 0 0 0 0 1 1 9 2 0 9 2 8 9 5 5 0 7 8 1 2 5 0 
;23	0.0000000596046447753906250	0 0 0 0 0 0 0 5 9 6 0 4 6 4 4 7 7 5 3 9 0 6 2 5 
;--------------------------------------------------------------------------
;  cnvint.S - convertion routine of 24 bits integer to ASCII
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec
	list
	nolist


POSTINC0	equ	0xfee
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
STATUS	equ	0xfd8


	global	_convert_int


.registers	udata_ovr	0x000
r0x00	res	1
r0x01	res	1
r0x02	res	1
r0x03	res	1
d0x00	res	1
d0x01	res	1
d0x02	res	1
d0x03	res	1
d0x04	res	1
d0x05	res	1
d0x06	res	1
d0x07	res	1
d0x08	res	1
d0x09	res	1
digit_count	res	1


S__convert_int	code
_convert_int:

	movff	r0x00, POSTDEC1
	movff	r0x01, POSTDEC1
	movff	r0x02, POSTDEC1
	movff	r0x03, POSTDEC1
	movff	d0x00, POSTDEC1
	movff	d0x01, POSTDEC1
	movff	d0x02, POSTDEC1
	movff	d0x03, POSTDEC1
	movff	d0x04, POSTDEC1
	movff	d0x05, POSTDEC1
	movff	d0x06, POSTDEC1
	movff	d0x07, POSTDEC1
	movff	d0x08, POSTDEC1
	movff	d0x09, POSTDEC1
	movff	digit_count, POSTDEC1


; adding digit 0
	movlw	0

	btfsc	r0x00, 0		; bit 0
	addlw	1

	btfsc	r0x00, 1		; bit 1
	addlw	2

	btfsc	r0x00, 2		; bit 2
	addlw	4

	btfsc	r0x00, 3		; bit 3
	addlw	8

	btfsc	r0x00, 4		; bit 4
	addlw	6

	btfsc	r0x00, 5		; bit 5
	addlw	2

	btfsc	r0x00, 6		; bit 6
	addlw	4

	btfsc	r0x00, 7		; bit 7
	addlw	8

	btfsc	r0x01, 0		; bit 8
	addlw	6

	btfsc	r0x01, 1		; bit 9
	addlw	2

	btfsc	r0x01, 2		; bit 10
	addlw	4

	btfsc	r0x01, 3		; bit 11
	addlw	8

	btfsc	r0x01, 4		; bit 12
	addlw	6

	btfsc	r0x01, 5		; bit 13
	addlw	2

	btfsc	r0x01, 6		; bit 14
	addlw	4

	btfsc	r0x01, 7		; bit 15
	addlw	8

	btfsc	r0x02, 0		; bit 16
	addlw	6

	btfsc	r0x02, 1		; bit 17
	addlw	2

	btfsc	r0x02, 2		; bit 18
	addlw	4

	btfsc	r0x02, 3		; bit 19
	addlw	8

	btfsc	r0x02, 4		; bit 20
	addlw	6

	btfsc	r0x02, 5		; bit 21
	addlw	2

	btfsc	r0x02, 6		; bit 22
	addlw	4

	btfsc	r0x02, 7		; bit 23
	addlw	8


	clrf	d0x01
@1:
	addlw	-10
	bnc	@2
	incf	d0x01, f
	bra	@1
@2:
	addlw	10
	movwf	d0x00

; adding digit 1
	movf	d0x01, w

	btfsc	r0x00, 4		; bit 4
	addlw	1

	btfsc	r0x00, 5		; bit 5
	addlw	3

	btfsc	r0x00, 6		; bit 6
	addlw	6

	btfsc	r0x00, 7		; bit 7
	addlw	2

	btfsc	r0x01, 0		; bit 8
	addlw	5

	btfsc	r0x01, 1		; bit 9
	addlw	1

	btfsc	r0x01, 2		; bit 10
	addlw	2

	btfsc	r0x01, 3		; bit 11
	addlw	4

	btfsc	r0x01, 4		; bit 12
	addlw	9

	btfsc	r0x01, 5		; bit 13
	addlw	9

	btfsc	r0x01, 6		; bit 14
	addlw	8

	btfsc	r0x01, 7		; bit 15
	addlw	6

	btfsc	r0x02, 0		; bit 16
	addlw	3

	btfsc	r0x02, 1		; bit 17
	addlw	7

	btfsc	r0x02, 2		; bit 18
	addlw	4

	btfsc	r0x02, 3		; bit 19
	addlw	8

	btfsc	r0x02, 4		; bit 20
	addlw	7

	btfsc	r0x02, 5		; bit 21
	addlw	5


	clrf	d0x02
@3:
	addlw	-10
	bnc	@4
	incf	d0x02, f
	bra	@3
@4:
	addlw	10
	movwf	d0x01

; adding digit 2
	movf	d0x02, w

	btfsc	r0x00, 7		; bit 7
	addlw	1

	btfsc	r0x01, 0		; bit 8
	addlw	2

	btfsc	r0x01, 1		; bit 9
	addlw	5

	btfsc	r0x01, 5		; bit 13
	addlw	1

	btfsc	r0x01, 6		; bit 14
	addlw	3

	btfsc	r0x01, 7		; bit 15
	addlw	7

	btfsc	r0x02, 0		; bit 16
	addlw	5

	btfsc	r0x02, 2		; bit 18
	addlw	1

	btfsc	r0x02, 3		; bit 19
	addlw	2

	btfsc	r0x02, 4		; bit 20
	addlw	5

	btfsc	r0x02, 5		; bit 21
	addlw	1

	btfsc	r0x02, 6		; bit 22
	addlw	3

	btfsc	r0x02, 7		; bit 23
	addlw	6


	clrf	d0x03
@5:
	addlw	-10
	bnc	@6
	incf	d0x03, f
	bra	@5
@6:
	addlw	10
	movwf	d0x02

; adding digit 3
	movf	d0x03, w

	btfsc	r0x01, 2		; bit 10
	addlw	1

	btfsc	r0x01, 3		; bit 11
	addlw	2

	btfsc	r0x01, 4		; bit 12
	addlw	4

	btfsc	r0x01, 5		; bit 13
	addlw	8

	btfsc	r0x01, 6		; bit 14
	addlw	6

	btfsc	r0x01, 7		; bit 15
	addlw	2

	btfsc	r0x02, 0		; bit 16
	addlw	5

	btfsc	r0x02, 1		; bit 17
	addlw	1

	btfsc	r0x02, 2		; bit 18
	addlw	2

	btfsc	r0x02, 3		; bit 19
	addlw	4

	btfsc	r0x02, 4		; bit 20
	addlw	8

	btfsc	r0x02, 5		; bit 21
	addlw	7

	btfsc	r0x02, 6		; bit 22
	addlw	4

	btfsc	r0x02, 7		; bit 23
	addlw	8


	clrf	d0x04
@7:
	addlw	-10
	bnc	@8
	incf	d0x04, f
	bra	@7
@8:
	addlw	10
	movwf	d0x03

; adding digit 4
	movf	d0x04, w

	btfsc	r0x01, 6		; bit 14
	addlw	1

	btfsc	r0x01, 7		; bit 15
	addlw	3

	btfsc	r0x02, 0		; bit 16
	addlw	6

	btfsc	r0x02, 1		; bit 17
	addlw	3

	btfsc	r0x02, 2		; bit 18
	addlw	6

	btfsc	r0x02, 3		; bit 19
	addlw	2

	btfsc	r0x02, 4		; bit 20
	addlw	4

	btfsc	r0x02, 5		; bit 21
	addlw	9

	btfsc	r0x02, 6		; bit 22
	addlw	9

	btfsc	r0x02, 7		; bit 23
	addlw	8


	clrf	d0x05
@9:
	addlw	-10
	bnc	@10
	incf	d0x05, f
	bra	@9
@10:
	addlw	10
	movwf	d0x04

; adding digit 5
	movf	d0x05, w

	btfsc	r0x02, 1		; bit 17
	addlw	1

	btfsc	r0x02, 2		; bit 18
	addlw	2

	btfsc	r0x02, 3		; bit 19
	addlw	5

	btfsc	r0x02, 6		; bit 22
	addlw	1

	btfsc	r0x02, 7		; bit 23
	addlw	3


	clrf	d0x06
@11:
	addlw	-10
	bnc	@12
	incf	d0x06, f
	bra	@11
@12:
	addlw	10
	movwf	d0x05

; adding digit 6
	movf	d0x06, w

	btfsc	r0x02, 4		; bit 20
	addlw	1

	btfsc	r0x02, 5		; bit 21
	addlw	2

	btfsc	r0x02, 6		; bit 22
	addlw	4

	btfsc	r0x02, 7		; bit 23
	addlw	8


	clrf	d0x07
@13:
	addlw	-10
	bnc	@14
	incf	d0x07, f
	bra	@13
@14:
	addlw	10
	movwf	d0x06

; adding digit 7
	movf	d0x07, w

	clrf	digit_count


; finalization
	bnz	@15
	movf	d0x06, w
	bnz	@16
	movf	d0x05, w
	bnz	@17
	movf	d0x04, w
	bnz	@18
	movf	d0x03, w
	bnz	@19
	movf	d0x02, w
	bnz	@20
	movf	d0x01, w
	bnz	@21
	movf	d0x00, w
	bra	@22
@15:
	incf	digit_count, f
	addlw	48
	movwf	POSTINC0
	movf	d0x06, w
@16:
	incf	digit_count, f
	addlw	48
	movwf	POSTINC0
	movf	d0x05, w
@17:
	incf	digit_count, f
	addlw	48
	movwf	POSTINC0
	movf	d0x04, w
@18:
	incf	digit_count, f
	addlw	48
	movwf	POSTINC0
	movf	d0x03, w
@19:
	incf	digit_count, f
	addlw	48
	movwf	POSTINC0
	movf	d0x02, w
@20:
	incf	digit_count, f
	addlw	48
	movwf	POSTINC0
	movf	d0x01, w
@21:
	incf	digit_count, f
	addlw	48
	movwf	POSTINC0
	movf	d0x00, w
@22:
	incf	digit_count, f
	addlw	48
	movwf	POSTINC0

	movf	digit_count, w

	movff	PREINC1, digit_count
	movff	PREINC1, d0x09
	movff	PREINC1, d0x08
	movff	PREINC1, d0x07
	movff	PREINC1, d0x06
	movff	PREINC1, d0x05
	movff	PREINC1, d0x04
	movff	PREINC1, d0x03
	movff	PREINC1, d0x02
	movff	PREINC1, d0x01
	movff	PREINC1, d0x00
	movff	PREINC1, r0x03
	movff	PREINC1, r0x02
	movff	PREINC1, r0x01
	movff	PREINC1, r0x00
	return

	end

; Converstion table
;
;00	000000000000000000000001	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 
;01	000000000000000000000002	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 
;02	000000000000000000000004	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 
;03	000000000000000000000008	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 
;04	000000000000000000000016	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 6 
;05	000000000000000000000032	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 2 
;06	000000000000000000000064	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 4 
;07	000000000000000000000128	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 8 
;08	000000000000000000000256	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 5 6 
;09	000000000000000000000512	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 1 2 
;10	000000000000000000001024	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 2 4 
;11	000000000000000000002048	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 4 8 
;12	000000000000000000004096	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 9 6 
;13	000000000000000000008192	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 1 9 2 
;14	000000000000000000016384	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 6 3 8 4 
;15	000000000000000000032768	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 2 7 6 8 
;16	000000000000000000065536	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 5 5 3 6 
;17	000000000000000000131072	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 3 1 0 7 2 
;18	000000000000000000262144	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 6 2 1 4 4 
;19	000000000000000000524288	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 2 4 2 8 8 
;20	000000000000000001048576	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 4 8 5 7 6 
;21	000000000000000002097152	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 9 7 1 5 2 
;22	000000000000000004194304	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 1 9 4 3 0 4 
;23	000000000000000008388608	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 3 8 8 6 0 8 
/*-------------------------------------------------------------------------
   crc16.c - CRC16 checksum generation

   Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 *	The CRC code was devised by Don P. Mitchell of AT&T Bell Laboratories
 *	and Ned W. Rhodes of Software Systems Group. It has been published in
 *	"Design and Validation of Computer Protocols", Prentice Hall,
 *	Englewood Cliffs, NJ, 1991, Chapter 3, ISBN 0-13-539925-4.
 *
 *	Copyright is held by AT&T.
 *
 *	AT&T gives permission for the free use of the CRC source code.
 */

#include <stdint.h>

__code uint16_t crc_table[256] = {
	0x0000U, 0x1021U, 0x2042U, 0x3063U, 0x4084U, 0x50a5U, 0x60c6U, 0x70e7U,
	0x8108U, 0x9129U, 0xa14aU, 0xb16bU, 0xc18cU, 0xd1adU, 0xe1ceU, 0xf1efU,
	0x1231U, 0x0210U, 0x3273U, 0x2252U, 0x52b5U, 0x4294U, 0x72f7U, 0x62d6U,
	0x9339U, 0x8318U, 0xb37bU, 0xa35aU, 0xd3bdU, 0xc39cU, 0xf3ffU, 0xe3deU,
	0x2462U, 0x3443U, 0x0420U, 0x1401U, 0x64e6U, 0x74c7U, 0x44a4U, 0x5485U,
	0xa56aU, 0xb54bU, 0x8528U, 0x9509U, 0xe5eeU, 0xf5cfU, 0xc5acU, 0xd58dU,
	0x3653U, 0x2672U, 0x1611U, 0x0630U, 0x76d7U, 0x66f6U, 0x5695U, 0x46b4U,
	0xb75bU, 0xa77aU, 0x9719U, 0x8738U, 0xf7dfU, 0xe7feU, 0xd79dU, 0xc7bcU,
	0x48c4U, 0x58e5U, 0x6886U, 0x78a7U, 0x0840U, 0x1861U, 0x2802U, 0x3823U,
	0xc9ccU, 0xd9edU, 0xe98eU, 0xf9afU, 0x8948U, 0x9969U, 0xa90aU, 0xb92bU,
	0x5af5U, 0x4ad4U, 0x7ab7U, 0x6a96U, 0x1a71U, 0x0a50U, 0x3a33U, 0x2a12U,
	0xdbfdU, 0xcbdcU, 0xfbbfU, 0xeb9eU, 0x9b79U, 0x8b58U, 0xbb3bU, 0xab1aU,
	0x6ca6U, 0x7c87U, 0x4ce4U, 0x5cc5U, 0x2c22U, 0x3c03U, 0x0c60U, 0x1c41U,
	0xedaeU, 0xfd8fU, 0xcdecU, 0xddcdU, 0xad2aU, 0xbd0bU, 0x8d68U, 0x9d49U,
	0x7e97U, 0x6eb6U, 0x5ed5U, 0x4ef4U, 0x3e13U, 0x2e32U, 0x1e51U, 0x0e70U,
	0xff9fU, 0xefbeU, 0xdfddU, 0xcffcU, 0xbf1bU, 0xaf3aU, 0x9f59U, 0x8f78U,
	0x9188U, 0x81a9U, 0xb1caU, 0xa1ebU, 0xd10cU, 0xc12dU, 0xf14eU, 0xe16fU,
	0x1080U, 0x00a1U, 0x30c2U, 0x20e3U, 0x5004U, 0x4025U, 0x7046U, 0x6067U,
	0x83b9U, 0x9398U, 0xa3fbU, 0xb3daU, 0xc33dU, 0xd31cU, 0xe37fU, 0xf35eU,
	0x02b1U, 0x1290U, 0x22f3U, 0x32d2U, 0x4235U, 0x5214U, 0x6277U, 0x7256U,
	0xb5eaU, 0xa5cbU, 0x95a8U, 0x8589U, 0xf56eU, 0xe54fU, 0xd52cU, 0xc50dU,
	0x34e2U, 0x24c3U, 0x14a0U, 0x0481U, 0x7466U, 0x6447U, 0x5424U, 0x4405U,
	0xa7dbU, 0xb7faU, 0x8799U, 0x97b8U, 0xe75fU, 0xf77eU, 0xc71dU, 0xd73cU,
	0x26d3U, 0x36f2U, 0x0691U, 0x16b0U, 0x6657U, 0x7676U, 0x4615U, 0x5634U,
	0xd94cU, 0xc96dU, 0xf90eU, 0xe92fU, 0x99c8U, 0x89e9U, 0xb98aU, 0xa9abU,
	0x5844U, 0x4865U, 0x7806U, 0x6827U, 0x18c0U, 0x08e1U, 0x3882U, 0x28a3U,
	0xcb7dU, 0xdb5cU, 0xeb3fU, 0xfb1eU, 0x8bf9U, 0x9bd8U, 0xabbbU, 0xbb9aU,
	0x4a75U, 0x5a54U, 0x6a37U, 0x7a16U, 0x0af1U, 0x1ad0U, 0x2ab3U, 0x3a92U,
	0xfd2eU, 0xed0fU, 0xdd6cU, 0xcd4dU, 0xbdaaU, 0xad8bU, 0x9de8U, 0x8dc9U,
	0x7c26U, 0x6c07U, 0x5c64U, 0x4c45U, 0x3ca2U, 0x2c83U, 0x1ce0U, 0x0cc1U,
	0xef1fU, 0xff3eU, 0xcf5dU, 0xdf7cU, 0xaf9bU, 0xbfbaU, 0x8fd9U, 0x9ff8U,
	0x6e17U, 0x7e36U, 0x4e55U, 0x5e74U, 0x2e93U, 0x3eb2U, 0x0ed1U, 0x1ef0U
};

uint16_t crc16(uint8_t *data, uint32_t size, uint16_t crc)
{
  while (size--)
    crc = crc_table[((crc >> 8) ^ *(data++)) & 0xffU] ^ (crc << 8);

  return crc;
}
/*-------------------------------------------------------------------------
   free.c - dynamic memory allocation

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <malloc.h>

extern char _MALLOC_SPEC *heap;

void free(unsigned char _MALLOC_SPEC *buf)
{
  /* mark block as deallocated */
  ((_MALLOC_SPEC _malloc_rec *)((unsigned int)buf - 1))->bits.alloc = 0;
}
/*-------------------------------------------------------------------------
   realloc.c - dynamic memory allocation

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <malloc.h>

extern unsigned char _MALLOC_SPEC *heap;

unsigned char _MALLOC_SPEC *realloc(unsigned char _MALLOC_SPEC *mblock, unsigned char len)
{
  _malloc_rec _MALLOC_SPEC *pHeap;			/* pointer to block header */
  _malloc_rec _MALLOC_SPEC *temp;
  unsigned char bLen;			/* size of block  */

  if(len >= MAX_BLOCK_SIZE)
    return ((unsigned char _MALLOC_SPEC *)0);

  /* if mblock is NULL, then same as malloc */
  if(!mblock)
    return (malloc(len));

  /* if len is 0 */
  if(len == 0) {
    free(mblock);
    return ((unsigned char _MALLOC_SPEC *)0);
  }
  
  pHeap = (_malloc_rec _MALLOC_SPEC *)((unsigned int)mblock - 1);
  bLen = pHeap->bits.count;

  /* block too small for len bytes + 1 byte header <===> bLen < len + 1 <===> blen <= len */
  if (bLen <= len) {
    /* so, new segment has size bigger than the old one, we can return a
     * valid pointer only when after the block there is an empty block that
     * can be merged to produce a new block of the requested size, otherwise
     * we return NULL */
    temp = _mergeHeapBlock(pHeap, len);

    if(!temp) {
      /* no could not find a valid block, return NULL */
      return ((unsigned char _MALLOC_SPEC *)0);
    }

    //pHeap = temp; /* temp == pHeap */
    bLen = pHeap->bits.count;
  }

  len++; /* increase to also count the header */
  
  if(bLen > len) {
    /* new segment is smaller than the old one (or the merged one), that's easy! */
    pHeap->bits.count = len;
    temp = (_malloc_rec _MALLOC_SPEC *)((unsigned int)pHeap + len);
    temp->bits.alloc = 0;
    temp->bits.count = bLen - len;
  }

  return (mblock);
}
/*-------------------------------------------------------------------------
   atol.c - convert a string to long integer and return it

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

long atol(char * s)
{
     register long rv=0; 
     register char sign = 0;

     /* skip till we find either a digit or '+' or '-' */
     while (*s) {
	if (*s <= '9' && *s >= '0')
		break;
	if (*s == '-' || *s == '+') 
		break;
	s++;
     } 	  

     sign = (*s == '-');
     if (*s == '-' || *s == '+') s++;

     while (*s && *s >= '0' && *s <= '9') {
	rv = (rv * 10) + (*s - '0');
        s++;
     }

     return (sign ? -rv : rv);
}
/*-------------------------------------------------------------------------
   memfreemax.c - return size of maximum unallocated heap block

   Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <malloc.h>

extern unsigned char _MALLOC_SPEC *heap;

unsigned int memfreemax(void)
{
  _malloc_rec _MALLOC_SPEC *pHeap;
  unsigned char maxSize = 1;
  unsigned char bLen;

    pHeap = (_malloc_rec _MALLOC_SPEC *)&heap;
    
    while ((bLen = pHeap->bits.count)) {
      if(!pHeap->bits.alloc && (bLen > maxSize))
          maxSize = bLen;
      
      pHeap = (_malloc_rec _MALLOC_SPEC *)((unsigned int)pHeap + bLen);
    }

  /* do not count the block header */
  --maxSize;
  
  return (maxSize);
}
/*-------------------------------------------------------------------------
   atoi.c - convert a string to an integer and return it

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

int atoi(char * s)
{
  int rv=0; 
  char sign = 0;

     /* skip till we find either a digit or '+' or '-' */
     while (*s) {
	if (*s <= '9' && *s >= '0')
		break;
	if (*s == '-' || *s == '+') 
		break;
	s++;
     } 	  

     if(*s == '-')sign=1;

//     sign = (*s == '-');
     if (*s == '-' || *s == '+') s++;

     while (*s && *s >= '0' && *s <= '9') {
	rv = (rv * 10) + (*s - '0');
        s++;
     }

     if(sign)return (-rv);
     else return (rv);
     
//     return (sign ? -rv : rv);
}
/*-------------------------------------------------------------------------
   memfree.c - return size of all unallocated heap

   Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <malloc.h>

extern unsigned char _MALLOC_SPEC *heap;

unsigned int memfree(void)
{
  _malloc_rec _MALLOC_SPEC *pHeap;
  unsigned int hsize=0;
  unsigned char bLen;
  
  pHeap = (_malloc_rec _MALLOC_SPEC *)&heap;
  
  while ((bLen = pHeap->bits.count)) {
    if(!pHeap->bits.alloc)
      hsize += bLen - 1;
    
    pHeap = (_malloc_rec _MALLOC_SPEC *)((unsigned int)pHeap + bLen);
  }
  
  return (hsize);
}
/*-------------------------------------------------------------------------
   x_ftoa.c - wrapper function to use _convert_float

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

extern int convert_frac;
extern int convert_int;

/* char x_ftoa(float, __data char *, unsigned char, unsigned char); */


extern int POSTDEC1;
extern int PLUSW2;
extern int FSR0L;
extern int FSR0H;
extern int PREINC1;
extern int PREINC2;
extern int FSR2L;
extern int FSR2H;

#define _vv0x00	0x00
#define _vv0x01	0x01
#define _vv0x02	0x02
#define _vv0x03	0x03
#define _vv0x04	0x04

/* do not warn about unreferenced arguments/missing return values */
#pragma save
#pragma disable_warning 59
#pragma disable_warning 85

char x_cnvint_wrap(unsigned long num, __data char *buffer)
{
  __asm
    movff	_vv0x00, _POSTDEC1
    movff	_vv0x01, _POSTDEC1
    movff	_vv0x02, _POSTDEC1
    movff	_vv0x03, _POSTDEC1

    movlw	2
    movff	_PLUSW2, _vv0x00
    movlw	3
    movff	_PLUSW2, _vv0x01
    movlw	4
    movff	_PLUSW2, _vv0x02
    movlw	5
    movff	_PLUSW2, _vv0x03

    movlw	6
    movff	_PLUSW2, _FSR0L
    movlw	7
    movff	_PLUSW2, _FSR0H

    call	_convert_int

    /* return value is already in WREG */

    movff	_PREINC1, _vv0x03
    movff	_PREINC1, _vv0x02
    movff	_PREINC1, _vv0x01
    movff	_PREINC1, _vv0x00
  __endasm ;
}

char x_cnvfrac_wrap(unsigned long num, __data char *buffer, unsigned char prec)
{
  num;
  buffer;
  prec;

  __asm
    movff	_vv0x00, _POSTDEC1
    movff	_vv0x01, _POSTDEC1
    movff	_vv0x02, _POSTDEC1
    movff	_vv0x03, _POSTDEC1
    movff	_vv0x04, _POSTDEC1

    movlw	2
    movff	_PLUSW2, _vv0x00
    movlw	3
    movff	_PLUSW2, _vv0x01
    movlw	4
    movff	_PLUSW2, _vv0x02
    movlw	5
    movff	_PLUSW2, _vv0x03

    movlw	6
    movff	_PLUSW2, _FSR0L
    movlw	7
    movff	_PLUSW2, _FSR0H

    movlw	8
    movff	_PLUSW2, _vv0x04

    call	_convert_frac

    /* return value is already in WREG */

    movff	_PREINC1, _vv0x04
    movff	_PREINC1, _vv0x03
    movff	_PREINC1, _vv0x02
    movff	_PREINC1, _vv0x01
    movff	_PREINC1, _vv0x00
  __endasm ;
}
#pragma restore


union float_long {
  unsigned long l;
  float f;
};

char x_ftoa(float num, __data char *buffer, unsigned char buflen, unsigned char prec)
{
  char len;
  signed char expn;
  unsigned long ll;
  unsigned long li;
//  volatile
  union float_long f_l;

    len = buflen;
    while(len--)buffer[len] = 0;

    f_l.f = num;

    if((f_l.l & SIGNBIT) == SIGNBIT) {
      f_l.l &= ~SIGNBIT;
      *buffer = '-';
      buffer++;
    }

    expn = EXCESS - EXP(f_l.l);	// - 24;

    ll = MANT(f_l.l);
    li = 0;

    while( expn ) {
      if(expn < 0) {
        li <<= 1;
        if(ll & 0x00800000UL)li |= 1;
        ll <<= 1;
        expn++;
      } else {
        ll >>= 1;
        expn--;
      }
    }

    if(li)
      len = x_cnvint_wrap(li, buffer);
    else {
      *buffer = '0'; len = 1;
    }

    buffer += len;

    if(prec) {
      *buffer = '.'; len++;
      buffer++;

      len += x_cnvfrac_wrap(ll, buffer, 24-prec);
      buffer[ prec ] = '\0';
    }

  return (len);
}
/*-------------------------------------------------------------------------
   malloc.c - dynamic memory allocation

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <malloc.h>

/* this is an external pointer to HEAP. It should be defined in
 * the user's program, or it can be a symbol created by linker */
extern unsigned char _MALLOC_SPEC *heap;

unsigned char _MALLOC_SPEC *malloc(unsigned char len)
{
  _malloc_rec _MALLOC_SPEC *pHeap;			/* pointer to block header */
  _malloc_rec _MALLOC_SPEC *temp;
  unsigned char bLen, eLen;			/* size of block  */
#if MALLOC_MAX_FIRST
  unsigned char pass=1;
#endif

    if(len >= MAX_BLOCK_SIZE)
      goto do_end;

    pHeap = (_malloc_rec _MALLOC_SPEC *)&heap;

    while(1) {
      bLen = pHeap->bits.count;
      
      /* if datum is zero, then last block, return NULL */
      if(pHeap->datum == 0) {
#if !MALLOC_MAX_FIRST
        goto do_end;
#else
        if(!pass)
          goto do_end;
        
        /* in the first pass, we search for blocks that have
         * the requested size, in the second pass, try to merge
         * adjacent blocks to 'make' the requested block */
        pHeap = (_malloc_rec _MALLOC_SPEC *)&heap;
        pass--;
        continue;
#endif
      }

      /* if current block is allocated then proceed to next */
      if(pHeap->bits.alloc)
        goto do_continue;

		
      /* current block is not allocated, try to allocate */
			
      /* if current block is not enough for allocation, then proceed to next */
      if(bLen <= len) {

#if MALLOC_MAX_FIRST
        /* if we are in the first pass, check next block */
        if(pass)
          goto do_continue;

        /* otherwise try merge */
#endif

        temp = _mergeHeapBlock(pHeap, len);
        
        if(!temp)
          /* otherwise proceed with next block */
          goto do_continue;

        //pHeap = temp; /* temp == pHeap */
        bLen = pHeap->bits.count;
      }

      /* current block is enough to hold the new block */

      /* allocate by filling the fields */
      eLen = (len+1);
      pHeap->datum = 0x80 | eLen;

      if(bLen > eLen) {
        /* if current block size is greater than the requested one,
         * create a new empty block at the end of the newly allocated */
        temp = (_malloc_rec _MALLOC_SPEC *)((unsigned int)pHeap + eLen);
        temp->datum = (bLen - eLen);
      }

      return ((unsigned char _MALLOC_SPEC *)((unsigned int)pHeap + 1));

do_continue:
      pHeap = (_malloc_rec _MALLOC_SPEC *)((unsigned int)pHeap + bLen);
    }

do_end:
  return ((unsigned char _MALLOC_SPEC *)0);

}
/*-------------------------------------------------------------------------
   itoa.c - convert (unsigned) int to strings

   Copyright (C) 2005, Raphael Neider <rneider at web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

void uitoa (unsigned int value, __data char *str, unsigned char radix)
{
  ultoa (value, str, radix);
}

void itoa (int value, __data char *str, unsigned char radix)
{
  ltoa (value, str, radix);
}
/*-------------------------------------------------------------------------
   rand.c - random number generation routines

   Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * derived from the book "The C Programming Language," by Kernighan and Ritchie
 */

#include <stdlib.h>

static long do_rand(unsigned long *ctx)
{
  return ((*ctx = *ctx * 1103515245UL + 12345UL) % ((unsigned long)RAND_MAX + 1));
}

long rand_r(unsigned long *ctx)
{
  unsigned long val = (unsigned long) *ctx;
  
    *ctx = do_rand(&val);
    return (long) *ctx;
}

static unsigned long next = 1;

long rand(void)
{
  return do_rand(&next);
}

void srand(unsigned long seed)
{
  next = seed;
}

#ifdef TEST

main()
{
  int i;
  unsigned long myseed;

  stdout = STREAM_GPSIM;

  printf("seeding rand with 0x19610910: \n");
  srand(0x19610910);

  printf("generating three pseudo-random numbers:\n");
  for (i = 0; i < 10; i++)
  {
    printf("next random number = %ld\n", rand());
  }

  printf("generating the same sequence with rand_r:\n");
  myseed = 0x19610910;
  for (i = 0; i < 10; i++)
  {
    printf("next random number = %ld\n", rand_r(&myseed));
  }

  return 0;
}

#endif /* TEST */

/*-------------------------------------------------------------------------
   ltoa.c - long integer to string conversion

   Copyright (C) 1999, Bela Torok <bela.torok at kssg.ch>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
 value  ->  Number to be converted
 string ->  Result
 radix  ->  Base of value (e.g.: 2 for binary, 10 for decimal, 16 for hex)
---------------------------------------------------------------------------*/

#define NUMBER_OF_DIGITS 32

#if _DEBUG
extern void io_long(unsigned long);
extern void io_str(char *);
#endif


void ultoa(unsigned long value, __data char* str, unsigned char radix)
{
  unsigned int index;
  unsigned char ch;
  unsigned char buffer[NUMBER_OF_DIGITS];  /* space for NUMBER_OF_DIGITS + '\0' */

    index = NUMBER_OF_DIGITS;

    do {
      ch = '0' + (value % radix);
      if ( ch > (unsigned char)'9') ch += 'a' - '9' - 1;

#if _DEBUG
      io_str( "ultoa: " );
      io_long( value );
      io_long( (unsigned long) ch );
#endif

      buffer[ --index ] = ch;
      value /= radix;
    } while (value != 0);

    do {
      *str++ = buffer[index++];
    } while ( index < NUMBER_OF_DIGITS );

    *str = 0;  /* string terminator */
}

void ltoa(long value, __data char* str, unsigned char radix)
{
#if _DEBUG
  io_str( "ltoa: " );
  io_long( (unsigned long)value );
#endif

  if (value < 0 && radix == 10) {
    *str++ = '-';
    value = -value;
  }



  ultoa((unsigned long)value, str, radix);
}
/*-------------------------------------------------------------------------
   memmisc.c - heap handling functions

   Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <malloc.h>

void _initHeap(unsigned char _MALLOC_SPEC *dheap, unsigned int heapsize)
{
  _malloc_rec _MALLOC_SPEC *pHeap;
  unsigned int hsize=0;
  int bsize;
  
    pHeap = (_malloc_rec _MALLOC_SPEC *)dheap;
    if (heapsize == 0) return;
    /* we need one byte as the end of block list marker */
    heapsize--;
    
    while (hsize < heapsize) {
      /* a guess of the next block size */
      bsize = (heapsize - hsize); /* thus: bsize > 0 */
      if(bsize > MAX_BLOCK_SIZE) bsize = MAX_BLOCK_SIZE;
      
      /* now we can create the block */
      pHeap->datum = bsize;
      pHeap = (_malloc_rec _MALLOC_SPEC *)((unsigned int)pHeap + bsize);

      hsize += bsize;
    }

    /* mark end of block list */
    pHeap->datum = 0;
}

/* search heap starting from sBlock for a block of size bSize, merging
 * adjacent blocks if necessery */
_malloc_rec _MALLOC_SPEC *_mergeHeapBlock(_malloc_rec _MALLOC_SPEC *sBlock, unsigned char bSize)
{
  _malloc_rec _MALLOC_SPEC *temp;
  unsigned char bLen;
  unsigned char eLen;
  unsigned char dat;
  
    bLen = sBlock->bits.count;
  
    /* current block is not enough, see if we can merge some adjacent memory
     * blocks to make it fit */
    temp = (_malloc_rec _MALLOC_SPEC *)((unsigned int)sBlock + bLen);	//sBlock->bits.count);
    eLen = bLen;
    while((temp->datum) && (!temp->bits.alloc) && (eLen <= bSize)) {
      eLen += (dat=temp->bits.count);
      temp = (_malloc_rec _MALLOC_SPEC *)((unsigned int)temp + dat);
    }

    if(eLen > bSize) {
      unsigned char i;
            
        /* yes, there are some free blocks that can be merged, so merge them... */
        temp = sBlock;
        while(eLen > 0) {
          if(eLen > MAX_BLOCK_SIZE)i = MAX_BLOCK_SIZE;
            else i = eLen;
          temp->datum = i;
          temp = (_malloc_rec _MALLOC_SPEC *)((unsigned int)temp + i);
          eLen -= i;
        }

        /* return block starts at the old block start address */
        return (sBlock);
    } else {
      
      /* no, there are no free blocks after sBlock, so return NULL */
      return ((_malloc_rec _MALLOC_SPEC *)0);
    }
}
;--------------------------------------------------------------------------
;  g_ftoa.S - floating point to ascii conversion
;
;  Copyright (C) 2004, George Gallant <ggallant571 AT verizon.net>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

;--
;
;	File:	ftoa.asm
;	Author:	George Gallant
;	Date:	19OCT04
;
;	This routine provides a floating point to ascii conversion.
;	It was written support the SDCC project.
;
;	SDCC C Syntax:
;
;	extern void g_ftoa(data char *buf, float num, char precision);
;
;	The routine is NOT reenterant but expects the entire parameter list
;	to be placed on the stack.
;
;	Notes:	1. measured 105usec to convert -65535.996 on a 20MHz 18f252
;		2. Software stack can not cross a RAM page boundary
;
;--
		list	r=dec, n=96, st=off, mm=off

		nolist
		include		<p18fxxx.inc>
		list

		extern	cvt_dec_word
		global	_g_ftoa

		udata


exp:		res	1
man:		res	4
r:		res	5
x:		res	3
bp:		res	2
prec:		res	1
ctr:		res	1

		code


_g_ftoa:	movff	FSR2H,POSTDEC1
		movff	FSR2L,POSTDEC1

		movff	FSR1H,FSR2H
		movff	FSR1L,FSR2L

		movff	exp, POSTDEC1
		movff	man+0, POSTDEC1
		movff	man+1, POSTDEC1
		movff	man+2, POSTDEC1
		movff	man+3, POSTDEC1
		movff	r+0, POSTDEC1
		movff	r+1, POSTDEC1
		movff	r+2, POSTDEC1
		movff	r+3, POSTDEC1
		movff	r+4, POSTDEC1
		movff	x+0, POSTDEC1
		movff	x+1, POSTDEC1
		movff	bp+0, POSTDEC1
		movff	bp+1, POSTDEC1
		movff	prec, POSTDEC1
		movff	ctr, POSTDEC1

		movff	FSR0H,POSTDEC1
		movff	FSR0L,POSTDEC1

		movlw	3
		addwf	FSR2L, f
		btfsc	STATUS,C
		incf	FSR2H, f

		movff	POSTINC2,FSR0L		;get the low byte of buf pointer
		movff	POSTINC2,FSR0H

		movff	POSTINC2,man+0		;get the low byte of float
		movff	POSTINC2,man+1
		movff	POSTINC2,man+2
		movff	POSTINC2,exp

		movff	POSTINC2,prec

		rlcf	man+2,w
		rlcf	exp,f
		bnc	@1
		movlw	'-'
		movwf	POSTINC0

@1:		movff	man+0,r+0
		movff	man+1,r+1
		movff	man+2,r+2
		bsf	r+2,7
		clrf	r+3
		clrf	r+4

;	Shift the mantissa left or right by the expondent

		movf	exp,w			;get the expondent
		sublw	127			;subtract the bais
		bz	@4			;skip shifting if zero
		bn	@3			;shift left if neg

@2:		bcf	STATUS,C		;otherwise, shift right
		rrcf	r+4,f
		rrcf	r+3,f
		rrcf	r+2,f
		rrcf	r+1,f
		rrcf	r+0,f
		decfsz	WREG,w
		bra	@2
		bra	@4

@3:		bcf	STATUS,C
		rlcf	r+0, f
		rlcf	r+1, f
		rlcf	r+2, f
		rlcf	r+3, f
		rlcf	r+4, f
		incfsz	WREG,w
		bra	@3

@4:		rlcf	r+2,w			;extract bit 23
		rlcf	r+3,f			;shift rest of whole number
		rlcf	r+4,f

		movff	r+3,PRODL
		movff	r+4,PRODH
		call	cvt_dec_word

		movlw	'.'
		movwf	POSTINC0

@10:		movlw	0x7F			
		andwf	r+2,f
		clrf	r+3

		movff	r+0,x+0			;temp copy
		movff	r+1,x+1
		movff	r+2,x+2

		bcf	STATUS,C		;mult by 2
		rlcf	r+0,f
		rlcf	r+1,f
		rlcf	r+2,f
		rlcf	r+3,f

		bcf	STATUS,C		;mult by 4
		rlcf	r+0,f
		rlcf	r+1,f
		rlcf	r+2,f
		rlcf	r+3,f

		movf	x+0,w			;mult by 5
		addwf	r+0,f
		movf	x+1,w
		addwfc	r+1,f
		movf	x+2,w
		addwfc	r+2,f
		movlw	0
		addwfc	r+3,f

		rlcf	r+2,w			;div by 0x400000			
		rlcf	r+3,f			;or just extract bits 24-22
		rlcf	WREG,w
		rlcf	r+3,f

		movf	r+3,w			;this is the bcd value
		addlw	0x30			;convert to ascii
		movwf	POSTINC0		;and save in memory

		bcf	STATUS,C		;mult by 2
		rlcf	r+0,f
		rlcf	r+1,f
		rlcf	r+2,f

		decfsz	prec,f
		bra	@10

		clrf	POSTINC0		;pack a nullbyte at the end


		movff	ctr, POSTDEC1
		movff	prec, POSTDEC1
		movff	bp+1, POSTDEC1
		movff	bp+0, POSTDEC1
		movff	x+1, POSTDEC1
		movff	x+0, POSTDEC1
		movff	r+4, POSTDEC1
		movff	r+3, POSTDEC1
		movff	r+2, POSTDEC1
		movff	r+1, POSTDEC1
		movff	r+0, POSTDEC1
 		movff	man+3, POSTDEC1
		movff	man+2, POSTDEC1
		movff	man+1, POSTDEC1
		movff	man+0, POSTDEC1
		movff	exp, POSTDEC1

		movff	PREINC1,FSR0L
		movff	PREINC1,FSR0H

		movff	PREINC1,FSR2L
		movff	PREINC1,FSR2H
		return

		end
/*-------------------------------------------------------------------------
   calloc.c - dynamic memory allocation

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <malloc.h>

extern unsigned char _MALLOC_SPEC *heap;

unsigned char _MALLOC_SPEC *calloc(unsigned char len)
{
  unsigned char _MALLOC_SPEC *result, *ch;

    if (len >= MAX_BLOCK_SIZE) return ((unsigned char _MALLOC_SPEC *)0);
    ch = malloc( len );
    result = ch;

    if (result != 0) {
      while (len) {
        --len;
        *ch = 0;
        ch++;
      }
    }
  
  return (result);
}
/*-------------------------------------------------------------------------
   atof.c - converts an ASCII string to float

   Copyright (C) 2003, Jesus Calvino-Fraga <jesusc at ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>
#include <stdlib.h>

float atof(char * s)
{
	float value, fraction;
	signed char iexp;
	char sign;

	//Skip leading blanks
	while (isspace(*s)) s++;

	//Get the sign
	if (*s == '-')
	{
		sign=1;
		s++;
	}
	else
	{
		sign=0;
		if (*s == '+') s++;
	}

	//Get the integer part
	for (value=0.0; isdigit(*s); s++)
	{
		value=10.0*value+(*s-'0');
	}

	//Get the fraction
	if (*s == '.')
	{
		s++;
		for (fraction=0.1; isdigit(*s); s++)
		{
			value+=(*s-'0')*fraction;
			fraction*=0.1;
		}
	}

	//Finally, the exponent (not very efficient, but enough for now*/
	if (toupper(*s)=='E')
	{
		s++;
		iexp=(signed char)atoi(s);
		{
			while(iexp!=0)
			{
				if(iexp<0)
				{
					value*=0.1;
					iexp++;
				}
				else
				{
					value*=10.0;
					iexp--;
				}
			}
		}
	}

	if(sign) value*=-1.0;
	return (value);
}
/*-------------------------------------------------------------------------
   crt0.c - SDCC pic16 port runtime start code

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * based on Microchip MPLAB-C18 startup files
 */

extern int stack_end;
extern int TBLPTRU;

/* external reference to the user's main routine */
extern void main (void);

void _entry (void) __naked __interrupt 0;
void _startup (void) __naked;

/* Access bank selector. */
#define a 0


/*
 * entry function, placed at interrupt vector 0 (RESET)
 */
void
_entry (void) __naked __interrupt 0
{
  __asm
    goto    __startup
  __endasm;
}

void
_startup (void) __naked
{
  __asm
    ; Initialize the stack pointer
    lfsr    1, _stack_end
    lfsr    2, _stack_end

    ; 1st silicon does not do this on POR
    clrf    _TBLPTRU, a

    ; Initialize the flash memory access configuration.
    ; This is harmless for non-flash devices, so we do it on all parts.
    bsf     0xa6, 7, a      ; EECON1.EEPGD = 1, TBLPTR accesses program memory
    bcf     0xa6, 6, a      ; EECON1.CFGS  = 0, TBLPTR accesses program memory
  __endasm;

  /* Call the main routine. */
  main ();

  __asm
lockup:
    ; Returning from main will lock up.
    bra     lockup
  __endasm;
}
/*-------------------------------------------------------------------------
   crt0i.c - SDCC pic16 port runtime start code with initialisation

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>
   Copyright (C) 2012, Moln√°r K√°roly <molnarkaroly@users.sf.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------

  $Id: crt0i.c 9317 2015-09-13 08:19:01Z spth $
*/

/*
 * based on Microchip MPLAB-C18 startup files
 */

extern int stack_end;
extern int TBLPTRU;
extern int TBLPTRH;
extern int TBLPTRL;
extern int FSR0L;
extern int FSR0H;
extern int TABLAT;
extern int POSTINC0;


#if 1
/* Global variable for forcing gplink to add _cinit section. */
char __uflags = 0;
#endif

/* External reference to the user's main routine. */
extern void main (void);

void _entry (void) __naked __interrupt 0;
void _startup (void) __naked;

/* Access bank selector. */
#define a 0


/*
 * Entry function, placed at interrupt vector 0 (RESET).
 */
void
_entry (void) __naked __interrupt 0
{
  __asm
    goto    __startup
  __endasm;
}

/* The cinit table will be filled by the linker. */
extern __code struct
  {
    unsigned short num_init;
    struct
      {
        unsigned long from;
        unsigned long to;
        unsigned long size;
      } entries[1];
  } cinit;

#define TBLRDPOSTINC	tblrd*+

#define src_ptr		0x00		/* 0x00 0x01 0x02*/
#define byte_count	0x03		/* 0x03 0x04 */
#define entry_count	0x05		/* 0x05 0x06 */
#define entry_ptr	0x07		/* 0x07 0x08 0x09 */

void
_startup (void) __naked
{
  __asm
    ; Initialize the stack pointer
    lfsr    1, _stack_end
    lfsr    2, _stack_end

    ; 1st silicon does not do this on POR
    clrf    _TBLPTRU, a

    ; Initialize the flash memory access configuration.
    ; This is harmless for non-flash devices, so we do it on all parts.
    bsf     0xa6, 7, a      ; EECON1.EEPGD = 1, TBLPTR accesses program memory
    bcf     0xa6, 6, a      ; EECON1.CFGS  = 0, TBLPTR accesses program memory

  /* Initialize global and/or static variables. */

  /*
   * Access registers 0x00 - 0x09 are not saved in this code.
   */
    ; TBLPTR = &cinit
    movlw   low(_cinit)
    movwf   _TBLPTRL, a
    movlw   high(_cinit)
    movwf   _TBLPTRH, a
    movlw   upper(_cinit)
    movwf   _TBLPTRU, a

    ; entry_count = cinit.num_init
    TBLRDPOSTINC
    movff   _TABLAT, entry_count

    TBLRDPOSTINC
    movff   _TABLAT, (entry_count + 1)

    ; while (entry_count)

    bra	    entry_loop_dec

entry_loop:

    ; Count down so we only have to look up the data in _cinit once.

    ; At this point we know that TBLPTR points to the top of the current
    ; entry in _cinit, so we can just start reading the from, to, and
    ; size values.

    ; Read the source address low.

    ; src_ptr = entry_ptr->from; 

    TBLRDPOSTINC
    movff   _TABLAT, src_ptr

    ; source address high
    TBLRDPOSTINC
    movff   _TABLAT, (src_ptr + 1)

    ; source address upper
    TBLRDPOSTINC
    movff   _TABLAT, (src_ptr + 2)

    ; Skip a byte since it is stored as a 32bit int.
    TBLRDPOSTINC

    ; Read the destination address directly into FSR0
    ; destination address low.

    ; FSR0 = (unsigned short)entry_ptr->to; 

    TBLRDPOSTINC
    movff   _TABLAT, _FSR0L

    ; destination address high
    TBLRDPOSTINC
    movff   _TABLAT, _FSR0H

    ; Skip two bytes since it is stored as a 32bit int.
    TBLRDPOSTINC
    TBLRDPOSTINC

    ; Read the size of data to transfer to destination address.

    ; byte_count = (unsigned short)entry_ptr->size; 

    TBLRDPOSTINC
    movff   _TABLAT, byte_count

    TBLRDPOSTINC
    movff   _TABLAT, (byte_count + 1)

    ; Skip two bytes since it is stored as a 32bit int.
    TBLRDPOSTINC
    TBLRDPOSTINC

    ; src_ptr = entry_ptr->from;
    ; FSR0 = (unsigned short)entry_ptr->to;
    ; byte_count = (unsigned short)entry_ptr->size;

    ; The table pointer now points to the next entry. Save it
    ; off since we will be using the table pointer to do the copying
    ; for the entry.

    ; entry_ptr = TBLPTR
    movff   _TBLPTRL, entry_ptr
    movff   _TBLPTRH, (entry_ptr + 1)
    movff   _TBLPTRU, (entry_ptr + 2)

    ; Now assign the source address to the table pointer.
    ; TBLPTR = src_ptr
    movff   src_ptr, _TBLPTRL
    movff   (src_ptr + 1), _TBLPTRH
    movff   (src_ptr + 2), _TBLPTRU
    bra	    copy_loop_dec

copy_loop:
    TBLRDPOSTINC
    movff   _TABLAT, _POSTINC0

copy_loop_dec:
    ; while (--byte_count);

    ; Decrement and test the byte counter.
    ; The cycle ends when the value of counter reaches the -1.
    decf    byte_count, f, a
    bc      copy_loop
    decf    (byte_count + 1), f, a
    bc      copy_loop

    ; Restore the table pointer for the next entry.
    ; TBLPTR = entry_ptr
    movff   entry_ptr, _TBLPTRL
    movff   (entry_ptr + 1), _TBLPTRH
    movff   (entry_ptr + 2), _TBLPTRU

entry_loop_dec:
    ; while (--entry_count);

    ; Decrement and test the entry counter.
    ; The cycle ends when the value of counter reaches the -1.
    decf    entry_count, f, a
    bc      entry_loop
    decf    (entry_count + 1), f, a
    bc      entry_loop
  __endasm;

  /* Call the main routine. */
  main ();

  __asm
lockup:
    ; Returning from main will lock up.
    bra     lockup
  __endasm;
}
/*-------------------------------------------------------------------------
   crt0iz.c - SDCC pic16 port runtime start code with initialisation and
              clear RAM

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>
   Copyright (C) 2012, Moln√°r K√°roly <molnarkaroly@users.sf.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------

  $Id: crt0iz.c 9317 2015-09-13 08:19:01Z spth $
*/

/*
 * based on Microchip MPLAB-C18 startup files
 */

extern int stack_end;
extern int TBLPTRU;
extern int TBLPTRH;
extern int TBLPTRL;
extern int FSR0L;
extern int FSR0H;
extern int TABLAT;
extern int POSTINC0;
extern int POSTDEC0;

#if 1
/* Global variable for forcing gplink to add _cinit section. */
char __uflags = 0;
#endif

/* External reference to the user's main routine. */
extern void main (void);

void _entry (void) __naked __interrupt 0;
void _startup (void) __naked;

/* Access bank selector. */
#define a 0


/*
 * Entry function, placed at interrupt vector 0 (RESET).
 */
void
_entry (void) __naked __interrupt 0
{
  __asm
    goto    __startup
  __endasm;
}

/* The cinit table will be filled by the linker. */
extern __code struct
  {
    unsigned short num_init;
    struct
      {
        unsigned long from;
        unsigned long to;
        unsigned long size;
      } entries[1];
  } cinit;

#define TBLRDPOSTINC	tblrd*+

#define src_ptr		0x00		/* 0x00 0x01 0x02*/
#define byte_count	0x03		/* 0x03 0x04 */
#define entry_count	0x05		/* 0x05 0x06 */
#define entry_ptr	0x07		/* 0x07 0x08 0x09 */

void
_startup (void) __naked
{
  __asm
    ; Initialize the stack pointer
    lfsr    1, _stack_end
    lfsr    2, _stack_end

    ; 1st silicon does not do this on POR
    clrf    _TBLPTRU, a

    ; Initialize the flash memory access configuration.
    ; This is harmless for non-flash devices, so we do it on all parts.
    bsf     0xa6, 7, a      ; EECON1.EEPGD = 1, TBLPTR accesses program memory
    bcf     0xa6, 6, a      ; EECON1.CFGS  = 0, TBLPTR accesses program memory

  /* cleanup the RAM */
    ; Load FSR0 with top of RAM.
    setf    _FSR0L, a
    movlw   0x0e
    movwf   _FSR0H, a

    ; Place 0xff at address 0x00 as a sentinel.
    setf    0x00, a

clear_loop:
    clrf    _POSTDEC0, a
    movf    0x00, w, a
    bnz     clear_loop

  /* Initialize global and/or static variables. */

  /*
   * Access registers 0x00 - 0x09 are not saved in this code.
   */
    ; TBLPTR = &cinit
    movlw   low(_cinit)
    movwf   _TBLPTRL, a
    movlw   high(_cinit)
    movwf   _TBLPTRH, a
    movlw   upper(_cinit)
    movwf   _TBLPTRU, a

    ; entry_count = cinit.num_init
    TBLRDPOSTINC
    movff   _TABLAT, entry_count

    TBLRDPOSTINC
    movff   _TABLAT, (entry_count + 1)

    ; while (entry_count)

    bra	    entry_loop_dec

entry_loop:

    ; Count down so we only have to look up the data in _cinit once.

    ; At this point we know that TBLPTR points to the top of the current
    ; entry in _cinit, so we can just start reading the from, to, and
    ; size values.

    ; Read the source address low.

    ; src_ptr = entry_ptr->from; 

    TBLRDPOSTINC
    movff   _TABLAT, src_ptr

    ; source address high
    TBLRDPOSTINC
    movff   _TABLAT, (src_ptr + 1)

    ; source address upper
    TBLRDPOSTINC
    movff   _TABLAT, (src_ptr + 2)

    ; Skip a byte since it is stored as a 32bit int.
    TBLRDPOSTINC

    ; Read the destination address directly into FSR0
    ; destination address low.

    ; FSR0 = (unsigned short)entry_ptr->to; 

    TBLRDPOSTINC
    movff   _TABLAT, _FSR0L

    ; destination address high
    TBLRDPOSTINC
    movff   _TABLAT, _FSR0H

    ; Skip two bytes since it is stored as a 32bit int.
    TBLRDPOSTINC
    TBLRDPOSTINC

    ; Read the size of data to transfer to destination address.

    ; byte_count = (unsigned short)entry_ptr->size; 

    TBLRDPOSTINC
    movff   _TABLAT, byte_count

    TBLRDPOSTINC
    movff   _TABLAT, (byte_count + 1)

    ; Skip two bytes since it is stored as a 32bit int.
    TBLRDPOSTINC
    TBLRDPOSTINC

    ; src_ptr = entry_ptr->from;
    ; FSR0 = (unsigned short)entry_ptr->to;
    ; byte_count = (unsigned short)entry_ptr->size;

    ; The table pointer now points to the next entry. Save it
    ; off since we will be using the table pointer to do the copying
    ; for the entry.

    ; entry_ptr = TBLPTR
    movff   _TBLPTRL, entry_ptr
    movff   _TBLPTRH, (entry_ptr + 1)
    movff   _TBLPTRU, (entry_ptr + 2)

    ; Now assign the source address to the table pointer.
    ; TBLPTR = src_ptr
    movff   src_ptr, _TBLPTRL
    movff   (src_ptr + 1), _TBLPTRH
    movff   (src_ptr + 2), _TBLPTRU
    bra	    copy_loop_dec

copy_loop:
    TBLRDPOSTINC
    movff   _TABLAT, _POSTINC0

copy_loop_dec:
    ; while (--byte_count);

    ; Decrement and test the byte counter.
    ; The cycle ends when the value of counter reaches the -1.
    decf    byte_count, f, a
    bc      copy_loop
    decf    (byte_count + 1), f, a
    bc      copy_loop

    ; Restore the table pointer for the next entry.
    ; TBLPTR = entry_ptr
    movff   entry_ptr, _TBLPTRL
    movff   (entry_ptr + 1), _TBLPTRH
    movff   (entry_ptr + 2), _TBLPTRU

entry_loop_dec:
    ; while (--entry_count);

    ; Decrement and test the entry counter.
    ; The cycle ends when the value of counter reaches the -1.
    decf    entry_count, f, a
    bc      entry_loop
    decf    (entry_count + 1), f, a
    bc      entry_loop
  __endasm;

  /* Call the main routine. */
  main ();

  __asm
lockup:
    ; Returning from main will lock up.
    bra     lockup
  __endasm;
}
This directory contains the startup files for the SDCC pic16 port.
There are 3 startup files,
crt0.o		minimal initialisation routine
crt0i.o		initialisation of variables
crt0iz.o	RAM cleanup and initialisation of variables
/*-------------------------------------------------------------------------
   lrst.c - store local registers in stack upon function entry

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* FSR0 points to first register to store, WREG holds the register count
 */
 
extern int POSTDEC1;
extern int POSTINC0;
extern int WREG;

void _lr_store(void) __naked
{
  __asm
loop:
    movff	_POSTINC0, _POSTDEC1
    decfsz	_WREG, f
    bra		loop
    
    return
  __endasm;
}
/*-------------------------------------------------------------------------
   lrrest.c - restore local registers in stack upon function exit

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* FSR0 points to last register to store, WREG holds the register count
 */
 
extern int PREINC1;
extern int POSTDEC0;
extern int WREG;

void _lr_restore(void) __naked
{
  __asm
loop:
    movff	_PREINC1, _POSTDEC0
    decfsz	_WREG, f
    bra		loop
    
    return
  __endasm;
}
/*-------------------------------------------------------------------------
   eeprom8_gptrget3.c - get 3 byte value from EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int EEADR;
extern int EECON1;
extern int EEDATA;
extern int FSR0L;
extern int INTCON;
extern int PRODH;
extern int PRODL;
extern int TBLPTRL;

void
__eeprom8_gptrget3(void) __naked
{
    __asm
        MOVFF   _INTCON, _TBLPTRL   ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words

        MOVFF   _FSR0L, _EEADR      ; address first byte
        BSF     _EECON1, 0, 0       ; RD = 1
        MOVF    _EEDATA, 0, 0       ; W = EEPROM[adr]

        INCF    _EEADR, 1, 0        ; address second byte
        BSF     _EECON1, 0, 0       ; RD = 1
        MOVFF   _EEDATA, _PRODL     ; PRODL = EEPROM[adr+1]

        INCF    _EEADR, 1, 0        ; address third byte
        BSF     _EECON1, 0, 0       ; RD = 1
        MOVFF   _EEDATA, _PRODH     ; PRODH = EEPROM[adr+2]

        BTFSC   _TBLPTRL, 7, 0      ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   gptrput2.c - put 2 byte value at generic pointer

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adopted for pic16 port by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */
 
extern int FSR0H;
extern int POSTINC0;
extern int PREINC1;
extern int PRODH;
extern int PRODL;
extern int WREG;
extern int __eeprom_gptrput2;

void _gptrput2(void) __naked
{
  __asm
    /* decode generic pointer MSB (in WREG) bits 6 and 7:
     * 00 -> code (unimplemented)
     * 01 -> EEPROM
     * 10 -> data
     * 11 -> data
     *
     * address: (WREG, PRODL, FSR0L)
     * value: (TBLPTRH, TBLPTRL, PRODH, STACK1[+1])
     */
    btfss	_WREG, 7
    bra		_lab_01_
    
    /* data pointer  */
    /* FSR0L is already set up */
    movff	_PRODL, _FSR0H
    
    movff	_PREINC1, _POSTINC0
    movff	_PRODH, _POSTINC0
    
    return
    

_lab_01_:
    /* code or eeprom */
    btfsc	_WREG, 6
    goto        ___eeprom_gptrput2

    /* code pointer, cannot write code pointers */
    return

  __endasm;
}
/*-------------------------------------------------------------------------
   gptrget4.c - get 4 byte value from generic pointer

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adopted for pic16 port by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int POSTINC0;
extern int INDF0;
extern int FSR0L;
extern int FSR0H;
extern int WREG;
extern int TBLPTRL;
extern int TBLPTRH;
extern int TBLPTRU;
extern int TABLAT;
extern int PRODL;
extern int PRODH;
extern int __eeprom_gptrget4;

void _gptrget4(void) __naked
{
  __asm
    /* decode generic pointer MSB (in WREG) bits 6 and 7:
     * 00 -> code
     * 01 -> EEPROM
     * 10 -> data
     * 11 -> data
     *
     * address in (WREG, PRODL, FSR0L)
     * result in (FSR0L, PRODH, PRODL, WREG)
     */
    btfss	_WREG, 7, 0
    bra		_lab_01_
    
    /* data pointer  */
    /* FSR0L is already set up */
    movff	_PRODL, _FSR0H
    
    movf	_POSTINC0, 0, 0
    movff	_POSTINC0, _PRODL
    movff	_POSTINC0, _PRODH
    movff	_POSTINC0, _FSR0L
    
    return
    

_lab_01_:
    /* code or eeprom */
    btfsc	_WREG, 6, 0
    goto        ___eeprom_gptrget4
    
    ; code pointer
    movff	_FSR0L, _TBLPTRL    
    movff	_PRODL, _TBLPTRH
    movwf	_TBLPTRU, 0
    
    /* fetch first byte */
    TBLRD*+
    movf	_TABLAT, 0, 0

    /* fetch second byte  */
    TBLRD*+
    movff	_TABLAT, _PRODL
    
    /* fetch third byte */
    TBLRD*+
    movff	_TABLAT, _PRODH
    
    /* fetch fourth byte */
    TBLRD*+
    movff	_TABLAT, _FSR0L
    
    return 
  
  __endasm;
}
/*-------------------------------------------------------------------------
   eeprom8_gptrput2.c - write 2 byte value to EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */

extern int EEADR;
extern int EECON1;
extern int EEDATA;
extern int FSR0H;
extern int FSR0L;
extern int INTCON;
extern int PREINC1;
extern int PRODH;
extern int __eeprom8_write;

void
__eeprom8_gptrput2(void) __naked
{
    __asm
        MOVFF   _INTCON, _FSR0H     ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words
        BSF     _EECON1, 2, 0       ; WREN = 1: enable write access

        MOVFF   _FSR0L, _EEADR      ; address first byte

        MOVFF   _PREINC1, _EEDATA   ; load first byte
        CALL    ___eeprom8_write    ; write and address next byte

        MOVFF   _PRODH, _EEDATA     ; load second byte
        CALL    ___eeprom8_write    ; write and address next byte

        BCF     _EECON1, 2, 0       ; WREN = 0: disable write access

        BTFSC   _FSR0H, 7, 0        ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom_write8.c - write one byte to EEPROM and wait for completion

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adopted for pic16 port by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

extern char EEADR;
extern char EECON1;
extern char EECON2;

void __eeprom8_write(void) __naked
{
  __asm
    movlw       0x55
    movwf       _EECON2, 0
    movlw       0xAA
    movwf       _EECON2, 0
    bsf         _EECON1, 1, 0   ; WR

    wait_till_done:
    btfsc       _EECON1, 1, 0   ; WR still set?
    bra         wait_till_done

    infsnz      _EEADR, 1, 0    ; address next byte
  __endasm;
}
/*-------------------------------------------------------------------------
   eeprom16_gptrget2.c - get 2 byte value from EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int EEADR;
extern int EEADRH;
extern int EECON1;
extern int EEDATA;
extern int FSR0L;
extern int INTCON;
extern int PRODL;
extern int TBLPTRL;

void
__eeprom16_gptrget2(void) __naked
{
    __asm
        MOVFF   _INTCON, _TBLPTRL   ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words

        MOVFF   _FSR0L, _EEADR      ; address first byte
        MOVFF   _PRODL, _EEADRH     ; address first byte, high address bits
        BSF     _EECON1, 0, 0       ; RD = 1: read EEPROM
        MOVF    _EEDATA, 0, 0       ; W = EEPROM[adr]

        INFSNZ  _EEADR, 1, 0        ; address second byte
        INCF    _EEADRH, 1, 0       ; high address bits
        BSF     _EECON1, 0, 0       ; RD = 1: read EEPROM
        MOVFF   _EEDATA, _PRODL     ; PRODL = EEPROM[adr+1]

        BTFSC   _TBLPTRL, 7, 0      ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   gptrput3.c - put 3 byte value at generic pointer

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adopted for pic16 port by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */
 
extern int FSR0H;
extern int POSTINC0;
extern int PREINC1;
extern int PRODH;
extern int PRODL;
extern int TBLPTRL;
extern int WREG;
extern int __eeprom_gptrput3;

void _gptrput3(void) __naked
{
  __asm
    /* decode generic pointer MSB (in WREG) bits 6 and 7:
     * 00 -> code (unimplemented)
     * 01 -> EEPROM
     * 10 -> data
     * 11 -> data
     *
     * address: (WREG, PRODL, FSR0L)
     * value: (TBLPTRH, TBLPTRL, PRODH, STACK1[+1])
     */
    btfss	_WREG, 7
    bra		_lab_01_
    
    /* data pointer  */
    /* FSR0L is already set up */
    movff	_PRODL, _FSR0H
    
    movff	_PREINC1, _POSTINC0
    movff	_PRODH, _POSTINC0
    movff	_TBLPTRL, _POSTINC0
    
    return
    

_lab_01_:
    /* code or eeprom */
    btfsc	_WREG, 6
    goto        ___eeprom_gptrput3

    /* code pointer, cannot write code pointers */
    return

  __endasm;
}
/*-------------------------------------------------------------------------
   eeprom8_gptrput4.c - write 4 byte value to EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */

extern int EEADR;
extern int EECON1;
extern int EEDATA;
extern int FSR0H;
extern int FSR0L;
extern int INTCON;
extern int PREINC1;
extern int PRODH;
extern int TBLPTRL;
extern int TBLPTRH;
extern int __eeprom8_write;

void
__eeprom8_gptrput4(void) __naked
{
    __asm
        MOVFF   _INTCON, _FSR0H     ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words
        BSF     _EECON1, 2, 0       ; WREN = 1: enable write access

        MOVFF   _FSR0L, _EEADR      ; address first byte
        MOVFF   _PREINC1, _EEDATA   ; load first byte
        CALL    ___eeprom8_write    ; write and address next byte

        MOVFF   _PRODH, _EEDATA     ; load second byte
        CALL    ___eeprom8_write    ; write and address next byte

        MOVFF   _TBLPTRL, _EEDATA   ; load third byte
        CALL    ___eeprom8_write    ; write and address next byte

        MOVFF   _TBLPTRH, _EEDATA   ; load fourth byte
        CALL    ___eeprom8_write    ; write and address next byte

        BCF     _EECON1, 2, 0       ; WREN = 0: disable write access

        BTFSC   _FSR0H, 7, 0        ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom8_gptrget1.c - get 1 byte value from EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int EEADR;
extern int EECON1;
extern int EEDATA;
extern int FSR0L;
extern int INTCON;
extern int TBLPTRL;

void
__eeprom8_gptrget1(void) __naked
{
    __asm
        MOVFF   _INTCON, _TBLPTRL   ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words

        MOVFF   _FSR0L, _EEADR      ; address first byte
        BSF     _EECON1, 0, 0       ; RD = 1
        MOVF    _EEDATA, 0, 0       ; W = EEPROM[adr]

        BTFSC   _TBLPTRL, 7, 0      ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom16_gptrput4.c - write 4 byte value to EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */

extern int EEADR;
extern int EEADRH;
extern int EECON1;
extern int EEDATA;
extern int FSR0H;
extern int FSR0L;
extern int INTCON;
extern int PREINC1;
extern int PRODH;
extern int PRODL;
extern int TBLPTRL;
extern int TBLPTRH;
extern int __eeprom16_write;

void
__eeprom16_gptrput4(void) __naked
{
    __asm
        MOVFF   _INTCON, _FSR0H     ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words
        BSF     _EECON1, 2, 0       ; WREN = 1: enable write access

        MOVFF   _FSR0L, _EEADR      ; address first byte
        MOVFF   _PRODL, _EEADRH     ; high address bits

        MOVFF   _PREINC1, _EEDATA   ; load first byte
        CALL    ___eeprom16_write   ; write and address next byte

        MOVFF   _PRODH, _EEDATA     ; load second byte
        CALL    ___eeprom16_write   ; write and address next byte

        MOVFF   _TBLPTRL, _EEDATA   ; load third byte
        CALL    ___eeprom16_write   ; write and address next byte

        MOVFF   _TBLPTRH, _EEDATA   ; load fourth byte
        CALL    ___eeprom16_write   ; write and address next byte

        BCF     _EECON1, 2, 0       ; WREN = 0: disable write access

        BTFSC   _FSR0H, 7, 0        ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom16_gptrput2.c - write 2 byte value to EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */

extern int EEADR;
extern int EEADRH;
extern int EECON1;
extern int EEDATA;
extern int FSR0H;
extern int FSR0L;
extern int INTCON;
extern int PREINC1;
extern int PRODH;
extern int PRODL;
extern int __eeprom16_write;

void
__eeprom16_gptrput2(void) __naked
{
    __asm
        MOVFF   _INTCON, _FSR0H     ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words
        BSF     _EECON1, 2, 0       ; WREN = 1: enable write access

        MOVFF   _FSR0L, _EEADR      ; address first byte
        MOVFF   _PRODL, _EEADRH     ; high address bits

        MOVFF   _PREINC1, _EEDATA   ; load first byte
        CALL    ___eeprom16_write   ; write and address next byte

        MOVFF   _PRODH, _EEDATA     ; load second byte
        CALL    ___eeprom16_write   ; write and address next byte

        BCF     _EECON1, 2, 0       ; WREN = 0: disable write access

        BTFSC   _FSR0H, 7, 0        ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom16_gptrget1.c - get 1 byte value from EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int EEADR;
extern int EEADRH;
extern int EECON1;
extern int EEDATA;
extern int FSR0L;
extern int INTCON;
extern int PRODL;
extern int TBLPTRL;

void
__eeprom16_gptrget1(void) __naked
{
    __asm
        MOVFF   _INTCON, _TBLPTRL   ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words

        MOVFF   _FSR0L, _EEADR      ; address first byte
        MOVFF   _PRODL, _EEADRH     ; high address bits
        BSF     _EECON1, 0, 0       ; RD = 1: read EEPROM
        MOVF    _EEDATA, 0, 0       ; W = EEPROM[adr]

        BTFSC   _TBLPTRL, 7, 0      ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom8_gptrget2.c - get 2 byte value from EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int EEADR;
extern int EECON1;
extern int EEDATA;
extern int FSR0L;
extern int INTCON;
extern int PRODL;
extern int TBLPTRL;

void
__eeprom8_gptrget2(void) __naked
{
    __asm
        MOVFF   _INTCON, _TBLPTRL   ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words

        MOVFF   _FSR0L, _EEADR      ; address first byte
        BSF     _EECON1, 0, 0       ; RD = 1
        MOVF    _EEDATA, 0, 0       ; W = EEPROM[adr]

        INCF    _EEADR, 1, 0        ; address second byte
        BSF     _EECON1, 0, 0       ; RD = 1
        MOVFF   _EEDATA, _PRODL     ; PRODL = EEPROM[adr+1]

        BTFSC   _TBLPTRL, 7, 0      ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   gptrget3.c - get 3 byte value from generic pointer

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adopted for pic16 port by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int POSTINC0;
extern int INDF0;
extern int FSR0L;
extern int FSR0H;
extern int WREG;
extern int TBLPTRL;
extern int TBLPTRH;
extern int TBLPTRU;
extern int TABLAT;
extern int PRODL;
extern int PRODH;
extern int __eeprom_gptrget3;

void _gptrget3(void) __naked
{
  __asm
    /* decode generic pointer MSB (in WREG) bits 6 and 7:
     * 00 -> code
     * 01 -> EEPROM
     * 10 -> data
     * 11 -> data
     *
     * address in (WREG, PRODL, FSR0L)
     * result in (FSR0L, PRODH, PRODL, WREG)
     */
    btfss	_WREG, 7, 0
    bra		_lab_01_
    
    /* data pointer  */
    /* FSR0L is already set up */
    movff	_PRODL, _FSR0H
    
    movf	_POSTINC0, 0, 0
    movff	_POSTINC0, _PRODL
    movff	_POSTINC0, _PRODH
    
    return
    

_lab_01_:
    /* code or eeprom */
    btfsc	_WREG, 6, 0
    goto        ___eeprom_gptrget3
    
    ; code pointer
    movff	_FSR0L, _TBLPTRL    
    movff	_PRODL, _TBLPTRH
    movwf	_TBLPTRU, 0
    
    /* fetch first byte */
    TBLRD*+
    movf	_TABLAT, 0, 0

    /* fetch second byte  */
    TBLRD*+
    movff	_TABLAT, _PRODL
    
    /* fetch third byte */
    TBLRD*+
    movff	_TABLAT, _PRODH
    
    return 
  
  __endasm;
}
/*-------------------------------------------------------------------------
   eeprom8_gptrget4.c - get 4 byte value from EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int EEADR;
extern int EECON1;
extern int EEDATA;
extern int FSR0H;
extern int FSR0L;
extern int INTCON;
extern int PRODH;
extern int PRODL;
extern int TBLPTRL;

void
__eeprom8_gptrget4(void) __naked
{
    __asm
        MOVFF   _INTCON, _TBLPTRL   ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words

        MOVFF   _FSR0L, _EEADR      ; address first byte
        BSF     _EECON1, 0, 0       ; RD = 1
        MOVF    _EEDATA, 0, 0       ; W = EEPROM[adr]

        INCF    _EEADR, 1, 0        ; address second byte
        BSF     _EECON1, 0, 0       ; RD = 1
        MOVFF   _EEDATA, _PRODL     ; PRODL = EEPROM[adr+1]

        INCF    _EEADR, 1, 0        ; address third byte
        BSF     _EECON1, 0, 0       ; RD = 1
        MOVFF   _EEDATA, _PRODH     ; PRODH = EEPROM[adr+2]

        INCF    _EEADR, 1, 0        ; address fourth byte
        BSF     _EECON1, 0, 0       ; RD = 1
        MOVFF   _EEDATA, _FSR0H     ; PRODL = EEPROM[adr+3]

        BTFSC   _TBLPTRL, 7, 0      ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   gptrget1.c - get 1 byte value from generic pointer

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adopted for pic16 port by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int POSTINC0;
extern int INDF0;
extern int FSR0L;
extern int FSR0H;
extern int WREG;
extern int TBLPTRL;
extern int TBLPTRH;
extern int TBLPTRU;
extern int TABLAT;
extern int PRODL;
extern int __eeprom_gptrget1;

void _gptrget1(void) __naked
{
  __asm
    /* decode generic pointer MSB (in WREG) bits 6 and 7:
     * 00 -> code
     * 01 -> EEPROM
     * 10 -> data
     * 11 -> data
     *
     * address in (WREG, PRODL, FSR0L)
     * result in (FSR0L, PRODH, PRODL, WREG)
     */
    btfss	_WREG, 7, 0
    bra		_lab_01_
    
    /* data pointer  */
    /* FSR0L is already set up */
    movff	_PRODL, _FSR0H
    
    movf	_POSTINC0, 0, 0
    
    return
    

_lab_01_:
    /* code or eeprom */
    btfsc	_WREG, 6, 0
    goto        ___eeprom_gptrget1
    
    ; code pointer
    movff	_FSR0L, _TBLPTRL    
    movff	_PRODL, _TBLPTRH
    movwf	_TBLPTRU, 0
    
    /* fetch first byte */
    TBLRD*+
    movf	_TABLAT, 0, 0

    return 
  
  __endasm;
}
/*-------------------------------------------------------------------------
   gptrput1.c - put 1 byte value at generic pointer

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adopted for pic16 port by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */
 
extern int FSR0H;
extern int POSTINC0;
extern int PREINC1;
extern int PRODL;
extern int WREG;
extern int __eeprom_gptrput1;

void _gptrput1(void) __naked
{
  __asm
    /* decode generic pointer MSB (in WREG) bits 6 and 7:
     * 00 -> code (unimplemented)
     * 01 -> EEPROM
     * 10 -> data
     * 11 -> data
     *
     * address: (WREG, PRODL, FSR0L)
     * value: (TBLPTRH, TBLPTRL, PRODH, STACK1[+1])
     */
    btfss	_WREG, 7
    bra		_lab_01_
    
    /* data pointer  */
    /* FSR0L is already set up */
    movff	_PRODL, _FSR0H
    
    movff	_PREINC1, _POSTINC0
    
    return
    

_lab_01_:
    /* code or eeprom */
    btfsc	_WREG, 6
    goto        ___eeprom_gptrput1

    /* code pointer, cannot write code pointers */
    return

  __endasm;
}
/*-------------------------------------------------------------------------
   eeprom16_gptrget3.c - get 3 byte value from EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int EEADR;
extern int EEADRH;
extern int EECON1;
extern int EEDATA;
extern int FSR0L;
extern int INTCON;
extern int PRODH;
extern int PRODL;
extern int TBLPTRL;

void
__eeprom16_gptrget3(void) __naked
{
    __asm
        MOVFF   _INTCON, _TBLPTRL   ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words

        MOVFF   _FSR0L, _EEADR      ; address first byte
        MOVFF   _PRODL, _EEADRH     ; high address bits
        BSF     _EECON1, 0, 0       ; RD = 1: read EEPROM
        MOVF    _EEDATA, 0, 0       ; W = EEPROM[adr]

        INFSNZ  _EEADR, 1, 0        ; address second byte
        INCF    _EEADRH, 1, 0       ; high address bits
        BSF     _EECON1, 0, 0       ; RD = 1: read EEPROM
        MOVFF   _EEDATA, _PRODL     ; PRODL = EEPROM[adr+1]

        INFSNZ  _EEADR, 1, 0        ; address third byte
        INCF    _EEADRH, 1, 0       ; high address bits
        BSF     _EECON1, 0, 0       ; RD = 1: read EEPROM
        MOVFF   _EEDATA, _PRODH     ; PRODH = EEPROM[adr+2]

        BTFSC   _TBLPTRL, 7, 0      ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom16_gptrput1.c - write 1 byte value to EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */

extern int EEADR;
extern int EEADRH;
extern int EECON1;
extern int EEDATA;
extern int FSR0H;
extern int FSR0L;
extern int INTCON;
extern int PREINC1;
extern int PRODL;
extern int __eeprom16_write;

void
__eeprom16_gptrput1(void) __naked
{
    __asm
        MOVFF   _INTCON, _FSR0H     ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words
        BSF     _EECON1, 2, 0       ; WREN = 1: enable write access

        MOVFF   _FSR0L, _EEADR      ; address first byte
        MOVFF   _PRODL, _EEADRH     ; high address bits

        MOVFF   _PREINC1, _EEDATA   ; load first byte
        CALL    ___eeprom16_write   ; write and address next byte

        BCF     _EECON1, 2, 0       ; WREN = 0: disable write access

        BTFSC   _FSR0H, 7, 0        ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom_write16.c - write one byte to EEPROM and wait for completion

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adopted for pic16 port by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

extern char EEADR;
extern char EEADRH;
extern char EECON1;
extern char EECON2;

void __eeprom16_write(void) __naked
{
  __asm
    movlw       0x55
    movwf       _EECON2, 0
    movlw       0xAA
    movwf       _EECON2, 0
    bsf         _EECON1, 1, 0   ; WR

    wait_till_done:
    btfsc       _EECON1, 1, 0   ; WR still set?
    bra         wait_till_done

    infsnz      _EEADR, 1, 0    ; address next byte
    incf        _EEADRH, 1, 0   ; address next byte
  __endasm;
}
/*-------------------------------------------------------------------------
   eeprom16_gptrget4.c - get 4 byte value from EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int EEADR;
extern int EEADRH;
extern int EECON1;
extern int EEDATA;
extern int FSR0H;
extern int FSR0L;
extern int INTCON;
extern int PRODH;
extern int PRODL;
extern int TBLPTRL;

void
__eeprom16_gptrget4(void) __naked
{
    __asm
        MOVFF   _INTCON, _TBLPTRL   ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words

        MOVFF   _FSR0L, _EEADR      ; address first byte
        MOVFF   _PRODL, _EEADRH     ; high address bits
        BSF     _EECON1, 0, 0       ; RD = 1: read EEPROM
        MOVF    _EEDATA, 0, 0       ; W = EEPROM[adr]

        INFSNZ  _EEADR, 1, 0        ; address second byte
        INCF    _EEADRH, 1, 0       ; high address bits
        BSF     _EECON1, 0, 0       ; RD = 1: read EEPROM
        MOVFF   _EEDATA, _PRODL     ; PRODL = EEPROM[adr+1]

        INFSNZ  _EEADR, 1, 0        ; address third byte
        INCF    _EEADRH, 1, 0       ; high address bits
        BSF     _EECON1, 0, 0       ; RD = 1: read EEPROM
        MOVFF   _EEDATA, _PRODH     ; PRODH = EEPROM[adr+2]

        INFSNZ  _EEADR, 1, 0        ; address fourth byte
        INCF    _EEADRH, 1, 0       ; high address bits
        BSF     _EECON1, 0, 0       ; RD = 1: read EEPROM
        MOVFF   _EEDATA, _FSR0H     ; FSR0H = EEPROM[adr+3]

        BTFSC   _TBLPTRL, 7, 0      ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom8_gptrput1.c - write 1 byte value to EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */

extern int EEADR;
extern int EECON1;
extern int EEDATA;
extern int FSR0H;
extern int FSR0L;
extern int INTCON;
extern int PREINC1;
extern int __eeprom8_write;

void
__eeprom8_gptrput1(void) __naked
{
    __asm
        MOVFF   _INTCON, _FSR0H     ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words
        BSF     _EECON1, 2, 0       ; WREN = 1: enable write access

        MOVFF   _FSR0L, _EEADR      ; address first byte

        MOVFF   _PREINC1, _EEDATA   ; load first byte
        CALL    ___eeprom8_write    ; write and address next byte

        BCF     _EECON1, 2, 0       ; WREN = 0: disable write access

        BTFSC   _FSR0H, 7, 0        ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom16_gptrput3.c - write 3 byte value to EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */

extern int EEADR;
extern int EEADRH;
extern int EECON1;
extern int EEDATA;
extern int FSR0H;
extern int FSR0L;
extern int INTCON;
extern int PREINC1;
extern int PRODH;
extern int PRODL;
extern int TBLPTRL;
extern int __eeprom16_write;

void
__eeprom16_gptrput3(void) __naked
{
    __asm
        MOVFF   _INTCON, _FSR0H     ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words
        BSF     _EECON1, 2, 0       ; WREN = 1: enable write access

        MOVFF   _FSR0L, _EEADR      ; address first byte
        MOVFF   _PRODL, _EEADRH     ; high address bits

        MOVFF   _PREINC1, _EEDATA   ; load first byte
        CALL    ___eeprom16_write   ; write and address next byte

        MOVFF   _PRODH, _EEDATA     ; load second byte
        CALL    ___eeprom16_write   ; write and address next byte

        MOVFF   _TBLPTRL, _EEDATA   ; load third byte
        CALL    ___eeprom16_write   ; write and address next byte

        BCF     _EECON1, 2, 0       ; WREN = 0: disable write access

        BTFSC   _FSR0H, 7, 0        ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   eeprom8_gptrput3.c - write 3 byte value to EEPROM via a generic pointer

   Copyright (C) 2012 Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */

extern int EEADR;
extern int EECON1;
extern int EEDATA;
extern int FSR0H;
extern int FSR0L;
extern int INTCON;
extern int PREINC1;
extern int PRODH;
extern int TBLPTRL;
extern int __eeprom8_write;

void
__eeprom8_gptrput3(void) __naked
{
    __asm
        MOVFF   _INTCON, _FSR0H     ; save previous interupt state
        BCF     _INTCON, 7, 0       ; GIE = 0: disable interrupts

        BCF     _EECON1, 7, 0       ; EEPGD = 0: access EEPROM, not program memory
        BCF     _EECON1, 6, 0       ; CFGS = 0: access EEPROM, not config words
        BSF     _EECON1, 2, 0       ; WREN = 1: enable write access

        MOVFF   _FSR0L, _EEADR      ; address first byte

        MOVFF   _PREINC1, _EEDATA   ; load first byte
        CALL    ___eeprom8_write    ; write and address next byte

        MOVFF   _PRODH, _EEDATA     ; load second byte
        CALL    ___eeprom8_write    ; write and address next byte

        MOVFF   _TBLPTRL, _EEDATA   ; load third byte
        CALL    ___eeprom8_write    ; write and address next byte

        BCF     _EECON1, 2, 0       ; WREN = 0: disable write access

        BTFSC   _FSR0H, 7, 0        ; check previous interrupt state
        BSF     _INTCON, 7, 0       ; conditionally re-enable interrupts

        RETURN
    __endasm;
}
/*-------------------------------------------------------------------------
   gptrput4.c - put 4 byte value at generic pointer

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adopted for pic16 port by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* write address is expected to be in WREG:PRODL:FSR0L while
 * write value is in TBLPTRH:TBLPTRL:PRODH:[stack] */
 
extern int FSR0H;
extern int POSTINC0;
extern int PREINC1;
extern int PRODH;
extern int PRODL;
extern int TBLPTRH;
extern int TBLPTRL;
extern int WREG;
extern int __eeprom_gptrput4;

void _gptrput4(void) __naked
{
  __asm
    /* decode generic pointer MSB (in WREG) bits 6 and 7:
     * 00 -> code (unimplemented)
     * 01 -> EEPROM
     * 10 -> data
     * 11 -> data
     *
     * address: (WREG, PRODL, FSR0L)
     * value: (TBLPTRH, TBLPTRL, PRODH, STACK1[+1])
     */
    btfss	_WREG, 7
    bra		_lab_01_
    
    /* data pointer  */
    /* FSR0L is already set up */
    movff	_PRODL, _FSR0H
    
    movff	_PREINC1, _POSTINC0
    movff	_PRODH, _POSTINC0
    movff	_TBLPTRL, _POSTINC0
    movff	_TBLPTRH, _POSTINC0
    
    return
    

_lab_01_:
    /* code or eeprom */
    btfsc	_WREG, 6
    goto        ___eeprom_gptrput4

    /* code pointer, cannot write code pointers */
    return
    
  __endasm;
}
/*-------------------------------------------------------------------------
   gptrget2.c - get 2 byte value from generic pointer

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Adopted for pic16 port by Vangelis Rokas, 2004 <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* the return value is expected to be in (FSR0H, PRODH, PRODL, WREG),
 * therefore we choose return type void here. Generic pointer is expected
 * to be in (WREG, PRODL, FSR0L), so function arguments are void, too */

extern int POSTINC0;
extern int INDF0;
extern int FSR0L;
extern int FSR0H;
extern int WREG;
extern int TBLPTRL;
extern int TBLPTRH;
extern int TBLPTRU;
extern int TABLAT;
extern int PRODL;
extern int __eeprom_gptrget2;

void _gptrget2(void) __naked
{
  __asm
    /* decode generic pointer MSB (in WREG) bits 6 and 7:
     * 00 -> code
     * 01 -> EEPROM
     * 10 -> data
     * 11 -> data
     *
     * address in (WREG, PRODL, FSR0L)
     * result in (FSR0L, PRODH, PRODL, WREG)
     */
    btfss	_WREG, 7, 0
    bra		_lab_01_
    
    /* data pointer  */
    /* FSR0L is already set up */
    movff	_PRODL, _FSR0H
    
    movf	_POSTINC0, 0, 0
    movff	_POSTINC0, _PRODL
    
    return
    

_lab_01_:
    /* code or eeprom */
    btfsc	_WREG, 6, 0
    goto        ___eeprom_gptrget2
    
    ; code pointer
    movff	_FSR0L, _TBLPTRL    
    movff	_PRODL, _TBLPTRH
    movwf	_TBLPTRU, 0
    
    /* fetch first byte */
    TBLRD*+
    movf	_TABLAT, 0, 0

    /* fetch second byte  */
    TBLRD*+
    movff	_TABLAT, _PRODL
    
    return 

  __endasm;
}
;--------------------------------------------------------------------------
;  stack.S - automatically allocate stack for PIC16 targets
;            with out the need for using the #pragma stack
;            directive
;
;  Copyright (C) 2006, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
        global _stack
        global _stack_end

; allocate space for stack
stack_section   udata
_stack          res     0xff
_stack_end      res     1

        end
/*-------------------------------------------------------------------------
   divulong.c - routine for division of 32 bit unsigned long

   Copyright (C) 1999, Jean-Louis Vern <jlvern AT gmail.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1)

unsigned long
_divulong (unsigned long a, unsigned long b) _IL_REENTRANT
{
  unsigned long reste = 0L;
  unsigned char count = 32;
  unsigned char c;

  do
  {
    // reste: a <- 0;
    c = MSB_SET(a);
    a <<= 1;
    reste <<= 1;
    if (c)
      reste |= 1L;

    if (reste >= b)
    {
      reste -= b;
      // a <- (result = 1)
      a |= 1L;
    }
  }
  while (--count);
  return a;
}
/*-------------------------------------------------------------------------
   _mullong.c - routine for multiplication of 32 bit (unsigned) long

   Copyright (C) 1999, Jean-Louis Vern <jlvern AT gmail.com>
   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT ieee.org>
   Modified for pic16 port by - Vangelis Rokas <vrokas AT otenet.gr> (2004)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

union bil {
        struct {unsigned char b0,b1,b2,b3 ;} b;
        struct {unsigned short lo,hi ;} i;
        unsigned long l;
        struct { unsigned char b0; unsigned short i12; unsigned char b3;} bi;
};

#define bcast(x) ((union bil near  *)&(x))

/*
                     3   2   1   0
       X             3   2   1   0
       ----------------------------
                   0.3 0.2 0.1 0.0
               1.3 1.2 1.1 1.0
           2.3 2.2 2.1 2.0
       3.3 3.2 3.1 3.0
       ----------------------------
                  |3.3|1.3|0.2|0.0|   A
                    |2.3|0.3|0.1|     B
                    |3.2|1.2|1.0|     C
                      |2.2|1.1|       D
                      |3.1|2.0|       E
                        |2.1|         F
                        |3.0|         G
                          |-------> only this side 32 x 32 -> 32
*/

long _mullong (long a, long b) _IL_REENTRANT
{
#if 0
        union bil t;

        t.i.hi = bcast(a)->b.b0 * bcast(b)->b.b2;       // A
        t.i.lo = bcast(a)->b.b0 * bcast(b)->b.b0;       // A
        t.b.b3 += bcast(a)->b.b3 *
                                  bcast(b)->b.b0;       // G
        t.b.b3 += bcast(a)->b.b2 *
                                  bcast(b)->b.b1;       // F
        t.i.hi += bcast(a)->b.b2 * bcast(b)->b.b0;      // E <- b lost in .lst
        // bcast(a)->i.hi is free !
        t.i.hi += bcast(a)->b.b1 * bcast(b)->b.b1;      // D <- b lost in .lst

        bcast(a)->bi.b3 = bcast(a)->b.b1 *
                                          bcast(b)->b.b2;
        bcast(a)->bi.i12 = bcast(a)->b.b1 *
                           bcast(b)->b.b0;              // C

        bcast(b)->bi.b3 = bcast(a)->b.b0 *
                                          bcast(b)->b.b3;
        bcast(b)->bi.i12 = bcast(a)->b.b0 *
                           bcast(b)->b.b1;              // B
        bcast(b)->bi.b0 = 0;                            // B
        bcast(a)->bi.b0 = 0;                            // C
        t.l += a;

        return t.l + b;
#else

  union bil x;
  union bil y;
  union bil t;
  union bil t1, t2;
  
	x.l = a;
	y.l = b;
	
	t.i.hi = x.b.b0 * y.b.b2;
	t.i.lo = x.b.b0 * y.b.b0;
	
	t.b.b3 += x.b.b3 * y.b.b0;
	t.b.b3 += x.b.b2 * y.b.b1;
	
	t.i.hi += x.b.b2 * y.b.b0;
	t.i.hi += x.b.b1 * y.b.b1;
	
	t1.bi.b3 = x.b.b1 * y.b.b2;
	t1.bi.i12 = x.b.b1 * y.b.b0;
	
	t2.bi.b3 = x.b.b0 * y.b.b3;
	t2.bi.i12 = x.b.b0 * y.b.b1;
	
	t1.bi.b0 = 0;
	t2.bi.b0 = 0;
	t.l += t1.l;

  return (t.l + t2.l);

#endif
}
/*-------------------------------------------------------------------------
   _modulong.c - routine for modulus of 32 bit unsigned long

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT usa.net>
   Bug fixes by Martijn van Balen, <aed AT iae.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1)

unsigned long _modulong (unsigned long a, unsigned long b) _IL_REENTRANT
{
  unsigned char count = 0;

  if (!b)
    {
      /* Prevent endless loop in case of division by 0. */
      return ~0UL;
    } // if

  while (!MSB_SET(b))
  {
     b <<= 1;
     if (b > a)
     {
        b >>=1;
        break;
     }
     count++;
  }
  do
  {
    if (a >= b)
      a -= b;
    b >>= 1;
  }
  while (count--);

  return a;
}
/*-------------------------------------------------------------------------
   _divslong.c - routine for division of 32 bit long

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

unsigned long _divulong(unsigned long a, unsigned long b);

long _divslong (long a, long b) _IL_REENTRANT
{
  long r;

  r = _divulong((a < 0 ? -a : a),
                (b < 0 ? -b : b));
  if ( (a < 0) ^ (b < 0))
    return -r;
  else
    return r;
}
/*-------------------------------------------------------------------------
   _modslong.c - routine for modulus of 32 bit signed long

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

unsigned long _modulong (unsigned long a, unsigned long b);

long _modslong (long a, long b) _IL_REENTRANT
{
  long r;

  r = _modulong((a < 0 ? -a : a),
                (b < 0 ? -b : b));
  if (a < 0)
    return -r;
  else
    return r;
}
/*-------------------------------------------------------------------------
   fps16x16_eq.c - compare two __fixed16x16 values for equality

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

union u_t {
  long value;
  __fixed16x16 fix;
};

char
__fps16x16_eq (__fixed16x16 a, __fixed16x16 b)
{
  union u_t u1, u2;

  u1.fix = a;
  u2.fix = b;
  
  return (u1.value == u2.value);
}
/*-------------------------------------------------------------------------
   fps16x16_div.c

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

union u_t {
  long value;
  __fixed16x16 fix;
};

__fixed16x16 __fps16x16_div(__fixed16x16 a, __fixed16x16 b)
{
  volatile union u_t u1, u2;

  u1.fix = a;
  u2.fix = b;
  
  u1.value = ((u1.value << 6) / u2.value) << 10;

  return (u1.fix);
}
;--------------------------------------------------------------------------
;  fps16x162uint.S - convert fixed16x16 to signed char
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___fps16x162uint

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW2	equ	0xfdb
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


; Internal registers
.registers	udata_ovr	0x0000
r0x00	res	1
r0x01	res	1
r0x02	res	1
r0x03	res	1


S_fps16x162uint____fps16x162uint	code
___fps16x162uint:

	movlw	0x04
	movff	PLUSW1, PRODL

	movlw	0x03
	movf	PLUSW1, w

	return

	end
;--------------------------------------------------------------------------
;  fps16x162sint.S - convert fixed16x16 to signed char
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___fps16x162sint

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW2	equ	0xfdb
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


S_fps16x162sint____fps16x162sint	code
___fps16x162sint:

	movlw	0x04
	movff	PLUSW1, PRODL

	movlw	0x03
	movf	PLUSW1, w

	btfss	PRODL, 7
	bra	@1

	bcf	PRODL, 7

	comf	WREG, f
	comf	PRODL, f
	infsnz	WREG, f
	incf	PRODL, f

@1:
	return

	end
/*-------------------------------------------------------------------------
   fps16x16_sub.c

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

union u_t {
  long value;
  __fixed16x16 fix;
};

__fixed16x16 __fps16x16_sub(__fixed16x16 a, __fixed16x16 b)
{
  volatile union u_t u1, u2;

  u1.fix = a;
  u2.fix = b;
  
  u1.value -= u2.value;

  return (u1.fix);
}
/*-------------------------------------------------------------------------
   fps16x16_lt.c - compare two __fixed16x16 values

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

union u_t {
  long value;
  __fixed16x16 fix;
};

char
__fps16x16_lt (__fixed16x16 a, __fixed16x16 b)
{
  union u_t u1, u2;

  u1.fix = a;
  u2.fix = b;
  
  return (u1.value < u2.value);
}
/*-------------------------------------------------------------------------
   fps16x16_gt.c - compare two __fixed16x16 values

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

union u_t {
  long value;
  __fixed16x16 fix;
};

char
__fps16x16_gt (__fixed16x16 a, __fixed16x16 b)
{
  union u_t u1, u2;

  u1.fix = a;
  u2.fix = b;
  
  return (u1.value > u2.value);
}
/*-------------------------------------------------------------------------
   fps16x16_mul.c

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

union u_t {
  long value;
  __fixed16x16 fix;
};

__fixed16x16 __fps16x16_mul(__fixed16x16 a, __fixed16x16 b)
{
  volatile union u_t u1, u2;

  u1.fix = a;
  u2.fix = b;
  
  u1.value = (u1.value >> 4) * (u2.value >> 4) >> 8;
  
  return (u1.fix);
}
;--------------------------------------------------------------------------
;  uchar2fps16x16.S - convert signed char to fixed16x16
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___uchar2fps16x16

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


S_uchar2fps16x16____uchar2fps16x16	code
___uchar2fps16x16:

	movlw	0x01
	movff	PLUSW1, PRODH

	clrf	WREG
	clrf	PRODL
	clrf	FSR0L

	bcf	FSR0L, 7

@1:
	return

	end
/*-------------------------------------------------------------------------
   fps16x16_lteq.c - compare two __fixed16x16 values

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

union u_t {
  long value;
  __fixed16x16 fix;
};

char
__fps16x16_lteq (__fixed16x16 a, __fixed16x16 b)
{
  union u_t u1, u2;

  u1.fix = a;
  u2.fix = b;
  
  return (u1.value <= u2.value);
}
;--------------------------------------------------------------------------
;  fps16x162uchar.S - convert fixed16x16 to signed char
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___fps16x162uchar

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW2	equ	0xfdb
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


; Internal registers
.registers	udata_ovr	0x0000
r0x00	res	1
r0x01	res	1
r0x02	res	1
r0x03	res	1


S_fps16x162uchar____fps16x162uchar	code
___fps16x162uchar:

	; normally would read from 0x04 but since we haven't setup
	; a stack frame, then read from 0x04 - 1 (VR)

	movlw	0x03
	movf	PLUSW1, w

	return

	end
;--------------------------------------------------------------------------
;  sint2fps16x16.S - convert signed char to fixed16x16
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___sint2fps16x16

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


S_sint2fps16x16____sint2fps16x16	code
___sint2fps16x16:

	movlw	0x02
	movff	PLUSW1, FSR0L
	movlw	0x01
	movff	PLUSW1, PRODH

	clrf	WREG
	clrf	PRODL

	btfss	FSR0L, 7
	bra	@1

	
	comf	PRODH, f
	comf	FSR0L, f

	infsnz	PRODH, f
	incf	FSR0L, f

	bsf	FSR0L, 7

@1:
	return

	end
;--------------------------------------------------------------------------
;  fps16x162schar.S - convert fixed16x16 to signed char
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___fps16x162schar

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


S_fps16x162schar____fps16x162schar	code
___fps16x162schar:

	movlw	0x04
	movff	PLUSW1, PRODL

	movlw	0x03
	movf	PLUSW1, w

	btfss	PRODL, 7
	bra	@1
	negf	WREG

@1:
	return

	end
/*-------------------------------------------------------------------------
   fps16x16_gteq.c - compare two __fixed16x16 values

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

union u_t {
  long value;
  __fixed16x16 fix;
};

char
__fps16x16_gteq (__fixed16x16 a, __fixed16x16 b)
{
  union u_t u1, u2;

  u1.fix = a;
  u2.fix = b;
  
  return (u1.value >= u2.value);
}
;--------------------------------------------------------------------------
;  ulong2fps16x16.S - convert signed long to fixed16x16
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___ulong2fps16x16

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


S_ulong2fps16x16____ulong2fps16x16	code
___ulong2fps16x16:

	movlw	0x02
	movff	PLUSW1, FSR0L
	movlw	0x01
	movff	PLUSW1, PRODH

	bcf	FSR0L, 7

@1:
	return

	end
;--------------------------------------------------------------------------
;  fps16x162ulong.S - convert fixed16x16 to signed char
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___fps16x162ulong

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW2	equ	0xfdb
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


; Internal registers
.registers	udata_ovr	0x0000
r0x00	res	1
r0x01	res	1
r0x02	res	1
r0x03	res	1


S_fps16x162ulong____fps16x162ulong	code
___fps16x162ulong:

	movlw	0x04
	movff	PLUSW1, PRODL

	movlw	0x7f
	andwf	PRODL, f

	movlw	0x03
	movf	PLUSW1, w

	

	clrf	PRODH
	clrf	FSR0L

	return

	end
;--------------------------------------------------------------------------
;  slong2fps16x16.S - convert signed long to fixed16x16
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___slong2fps16x16

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


S_slong2fps16x16____slong2fps16x16	code
___slong2fps16x16:

	movlw	0x02
	movff	PLUSW1, FSR0L
	movlw	0x01
	movff	PLUSW1, PRODH

	btfss	FSR0L, 7
	bra	@1

	comf	PRODH, f
	comf	FSR0L, f

	infsnz	PRODH, f
	incf	FSR0L, f

	bsf	FSR0L, 7

@1:
	return

	end
/*-------------------------------------------------------------------------
   fps16x16_neq.c - compare two __fixed16x16 values for inequality

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

union u_t {
  long value;
  __fixed16x16 fix;
};

char
__fps16x16_neq (__fixed16x16 a, __fixed16x16 b)
{
  union u_t u1, u2;

  u1.fix = a;
  u2.fix = b;
  
  return (u1.value != u2.value);
}

/*-------------------------------------------------------------------------
   fps16x162sfloat.c

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

float __fps16x162sfloat(__fixed16x16 fixd)
{
  union {
    __fixed16x16 fix;
    unsigned long value;
  } u;
  float tmp=0, exp=2;

    u.fix = fixd;
    tmp = (u.value & 0xffff0000) >> 16;

    while(u.value) {
      u.value &= 0xffff;
      if(u.value & 0x8000)tmp += 1/exp;
      exp *= 2;
      u.value <<= 1;
    }

  return (tmp);
}
/*-------------------------------------------------------------------------
   fps16x16_add.c

   Copyright (C) 2005, Raphael Neider <rneider at web.de> 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

union u_t {
  long value;
  __fixed16x16 fix;
};

__fixed16x16 __fps16x16_add(__fixed16x16 a, __fixed16x16 b)
{
  volatile union u_t u1, u2;

  u1.fix = a;
  u2.fix = b;
  
  u1.value += u2.value;

  return (u1.fix);
}
;--------------------------------------------------------------------------
;  uint2fps16x16.S - convert signed char to fixed16x16
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___uint2fps16x16

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


S_uint2fps16x16____uint2fps16x16	code
___uint2fps16x16:

	movlw	0x02
	movff	PLUSW1, FSR0L
	movlw	0x01
	movff	PLUSW1, PRODH

	clrf	WREG
	clrf	PRODL

	bcf	FSR0L, 7

@1:
	return

	end
;--------------------------------------------------------------------------
;  schar2fps16x16.S - convert signed char to fixed16x16
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___schar2fps16x16

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


S_schar2fps16x16____schar2fps16x16	code
___schar2fps16x16:

	movlw	0x01
	movff	PLUSW1, PRODH

	clrf	WREG
	clrf	PRODL
	clrf	FSR0L

	btfss	PRODH, 7
	bra	@1

	comf	PRODH, f
	comf	FSR0L, f

	infsnz	PRODH, f
	incf	FSR0L, f

	bsf	FSR0L, 7

@1:
	return

	end
;--------------------------------------------------------------------------
;  fps16x162slong.S - convert fixed16x16 to signed char
;
;  Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	radix dec

;--------------------------------------------------------
; public variables in this module
;--------------------------------------------------------
	global ___fps16x162slong

;--------------------------------------------------------
;	Equates to used internal registers
;--------------------------------------------------------
STATUS	equ	0xfd8
WREG	equ	0xfe8
FSR0L	equ	0xfe9
FSR1L	equ	0xfe1
FSR2L	equ	0xfd9
POSTDEC1	equ	0xfe5
PREINC1	equ	0xfe4
PLUSW2	equ	0xfdb
PLUSW1	equ	0xfe3
PRODL	equ	0xff3
PRODH	equ	0xff4


; Internal registers
.registers	udata_ovr	0x0000
r0x00	res	1
r0x01	res	1
r0x02	res	1
r0x03	res	1


S_fps16x162slong____fps16x162slong	code
___fps16x162slong:

	movlw	0x04
	movff	PLUSW1, PRODL

	movlw	0x03
	movf	PLUSW1, w

	clrf	PRODH
	clrf	FSR0L

	btfss	PRODL, 7
	bra	@1

	bcf	PRODL, 7
	comf	WREG, f
	comf	PRODL, f
	comf	PRODH, f
	comf	FSR0L, f
	
	incfsz	WREG, f
	bra	@1
	incfsz	PRODL, f
	bra	@1
	incfsz	PRODH, f
	bra	@1
	incf	FSR0L, f

@1:
	return

	end
/*-------------------------------------------------------------------------
   uchar2fs.c

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

/* convert unsigned char to float */
float
__uchar2fs (unsigned char uc) _FS_REENTRANT
{
  return __ulong2fs (uc);
}
/*-------------------------------------------------------------------------
   sint2fs.c

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

/* convert signed int to float */
float
__sint2fs (signed int si) _FS_REENTRANT
{
  return __slong2fs (si);
}
/*-------------------------------------------------------------------------
   fs2uchar.c

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

/* convert float to unsigned char */
unsigned char
__fs2uchar (float f) _FS_REENTRANT
{
  unsigned long ul = __fs2ulong (f);

  if (ul >= UCHAR_MAX)
    return UCHAR_MAX;
  return ul;
}
/*-------------------------------------------------------------------------
   fs2ulong.c

   Copyright (C) 1991, Pipeline Associates, Inc

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

#include <float.h>

union float_long
{
  float f;
  long l;
};

/* convert float to unsigned long */
unsigned long
__fs2ulong (float a1) _FS_REENTRANT
{
  volatile union float_long fl1;
  int exp;
  unsigned long l;
  
  fl1.f = a1;
  
  if (!fl1.l || SIGN (fl1.l))
    return 0;

  exp = EXP (fl1.l) - EXCESS - 24;
  l = MANT (fl1.l);
  
  l >>= -exp;

  return l;
}
/*-------------------------------------------------------------------------
   fs2sint.c

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

/* convert float to signed int */
signed int
__fs2sint (float f) _FS_REENTRANT
{
  signed long sl = __fs2slong (f);

  if (sl >= INT_MAX)
    return INT_MAX;
  if (sl <= INT_MIN) 
    return -INT_MIN;
  return sl;
}
/*-------------------------------------------------------------------------
   fs2slong.c

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

/* convert float to signed long */
signed long
__fs2slong (float f) _FS_REENTRANT
{
  if (!f)
    return 0;

  if (f < 0)
    {
      return -__fs2ulong (-f);
    }
  else
    {
      return __fs2ulong (f);
    }
}
/*-------------------------------------------------------------------------
   fs2uint.c

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

unsigned long __fs2ulong (float a1);

/* convert float to unsigned int */
unsigned int
__fs2uint (float f) _FS_REENTRANT
{
  unsigned long ul = __fs2ulong(f);

  if (ul >= UINT_MAX)
    return UINT_MAX;
  return ul;
}
/*-------------------------------------------------------------------------
   fseq.c

   Copyright (C) 1991, Pipeline Associates, Inc

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

#include <float.h>

union float_long
  {
    float f;
    long l;
  };

/* compare two floats */
char
__fseq (float a1, float a2) _FS_REENTRANT
{
  volatile union float_long fl1, fl2;

  fl1.f = a1;
  fl2.f = a2;

  if (fl1.l == fl2.l)
    return 1;
  return 0;
}

/*-------------------------------------------------------------------------
   fssub.c

   Copyright (C) 1991, Pipeline Associates, Inc

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

#include <float.h>

union float_long
  {
    float f;
    long l;
  };

/* subtract two floats */
float
__fssub (float a1, float a2) _FS_REENTRANT
{
  volatile union float_long fl1, fl2;

  fl1.f = a1;
  fl2.f = a2;

  /* check for zero args */
  if (!fl2.l)
    return fl1.f;
  if (!fl1.l)
    return -fl2.f;

  /* twiddle sign bit and add */
  fl2.l ^= SIGNBIT;
  return fl1.f + fl2.f; 
}
/*-------------------------------------------------------------------------
   fsneq.c

   Copyright (C) 1991, Pipeline Associates, Inc

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

#include <float.h>

union float_long
  {
    float f;
    long l;
  };

/* compare two floats */
char
__fsneq (float a1, float a2) _FS_REENTRANT
{
  volatile union float_long fl1, fl2;

  fl1.f = a1;
  fl2.f = a2;

#if 0
  if (fl1.l < 0 && fl2.l < 0)
    {
      fl1.l ^= SIGNBIT;
      fl2.l ^= SIGNBIT;
    }
#endif

  if (fl1.l == fl2.l)
    return 0;
  return 1;
}
/*-------------------------------------------------------------------------
   fslt.c

   Copyright (C) 1991, Pipeline Associates, Inc

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

#include <float.h>

union float_long
  {
    float f;
    long l;
  };

/* compare two floats */
char
__fslt (float a1, float a2) _FS_REENTRANT
{
  volatile union float_long fl1, fl2;

  fl1.f = a1;
  fl2.f = a2;

  if (fl1.l < 0 && fl2.l < 0)
    {
      if (fl2.l < fl1.l)
        return 1;
      return 0;
    }

  if (fl1.l < fl2.l)
    return 1;
  return 0;
}
/*-------------------------------------------------------------------------
   ulong2fs.c

   Copyright (C) 1991, Pipeline Associates, Inc

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

#include <float.h>

union float_long
  {
    float f;
    long l;
  };

float
__ulong2fs (unsigned long a ) _FS_REENTRANT
{
  int exp = 24 + EXCESS;
  volatile union float_long fl;

  if (!a)
    {
      return 0.0;
    }

  while (a & NORM) 
    {
      // we lose accuracy here
      a >>= 1;
      ++exp;
    }
  

  if (a < HIDDEN)
    {
      do
        {
          a <<= 1;
          --exp;
  	}
      while (a < HIDDEN);
    }

#if 0
  while (a < HIDDEN) {
      a <<= 1;
      --exp;
    }
#endif

#if 1
  if ((a & 0x7fffff) == 0x7fffff)
    {
      a = 0;
      ++exp;
    }
#endif

  a &= ~HIDDEN;
  /* pack up and go home */
  fl.l = PACK (0, (unsigned long)exp, a);

  return fl.f;
}
/*-------------------------------------------------------------------------
   fsadd.c.c

   Copyright (C) 1991, Pipeline Associates, Inc

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

#include <float.h>

union float_long
  {
    float f;
    unsigned long l;
  };

/* add two floats */
float
__fsadd (float a1, float a2) _FS_REENTRANT
{
  volatile union float_long fl1, fl2;
  long mant1, mant2;
  int exp1, exp2;
  unsigned long sign = 0;

  fl1.f = a1;
  fl2.f = a2;

  /* check for zero args */
  if (!fl1.l)
    return fl2.f;
  if (!fl2.l)
    return fl1.f;

  exp1 = EXP (fl1.l);
  exp2 = EXP (fl2.l);

  if (exp1 > exp2 + 25)
    return fl1.f;
  if (exp2 > exp1 + 25)
    return fl2.f;

  mant1 = MANT (fl1.l);
  mant2 = MANT (fl2.l);

  if (SIGN (fl1.l))
    mant1 = -mant1;
  if (SIGN (fl2.l))
    mant2 = -mant2;

  if (exp1 > exp2)
    {
      mant2 >>= exp1 - exp2;
    }
  else
    {
      mant1 >>= exp2 - exp1;
      exp1 = exp2;
    }
  mant1 += mant2;

  if (mant1 < 0)
    {
      mant1 = -mant1;
      sign = SIGNBIT;
    }
  else if (!mant1)
    return (0);

  /* normalize */
  while (mant1 < HIDDEN)
    {
      mant1 <<= 1;
      --exp1;
    }

  /* round off */
  while (mant1 & 0xff000000)
    {
      if (mant1&1)
        mant1 += 2;
      mant1 >>= 1 ;
      exp1++;
    }

  /* turn off hidden bit */
  mant1 &= ~HIDDEN;

  /* pack up and go home */
  fl1.l = PACK (sign, (unsigned long) exp1, mant1);

  return fl1.f;
}
/*-------------------------------------------------------------------------
   schar2fs.c

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

/* convert signed char to float */
float
__schar2fs (signed char sc) _FS_REENTRANT
{
  return __slong2fs (sc);
}
/*-------------------------------------------------------------------------
   fsdiv.c

   Copyright (C) 1991, Pipeline Associates, Inc

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

#include <float.h>

union float_long
  {
    float f;
    long l;
  };

/* divide two floats */
float
__fsdiv (float a1, float a2) _FS_REENTRANT
{
  volatile union float_long fl1, fl2;
  long result;
  unsigned long mask;
  long mant1, mant2;
  int exp;
  char sign;

  fl1.f = a1;
  fl2.f = a2;

  /* subtract exponents */
  exp = EXP (fl1.l) ;
  exp -= EXP (fl2.l);
  exp += EXCESS;

  /* compute sign */
  sign = SIGN (fl1.l) ^ SIGN (fl2.l);

  /* divide by zero??? */
  if (!fl2.l)
    {/* return NaN or -NaN */
      fl2.l = 0x7FC00000;
      return fl2.f;
    }

  /* numerator zero??? */
  if (!fl1.l)
    return 0;

  /* now get mantissas */
  mant1 = MANT (fl1.l);
  mant2 = MANT (fl2.l);

  /* this assures we have 25 bits of precision in the end */
  if (mant1 < mant2)
    {
      mant1 <<= 1;
      --exp;
    }

  /* now we perform repeated subtraction of fl2.l from fl1.l */
  mask = 0x1000000;
  result = 0;
  while (mask)
    {
      if (mant1 >= mant2)
	{
	  result |= mask;
	  mant1 -= mant2;
	}
      mant1 <<= 1;
      mask >>= 1;
    }

  /* round */
  result += 1;

  /* normalize down */
   ++exp;
  result >>= 1;

  result &= ~HIDDEN;

  /* pack up and go home */
  if (exp >= 0x100)
    fl1.l = (sign ? SIGNBIT : 0) | 0x7F800000;
  else if (exp < 0)
    fl1.l = 0;
  else
    fl1.l = PACK (sign ? SIGNBIT : 0 , exp, result);
  return fl1.f;
}
/*-------------------------------------------------------------------------
   slong2fs.c

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

/* convert signed long to float */
float
__slong2fs (signed long sl) _FS_REENTRANT
{
  if (sl < 0) 
    return -__ulong2fs (-sl);
  else 
    return __ulong2fs (sl);
}
/*-------------------------------------------------------------------------
   fsmul.c

   Copyright (C) 1991, Pipeline Associates, Inc

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

#include <float.h>

union float_long
  {
    float f;
    unsigned long l;
  };

/* multiply two floats */
float
__fsmul (float a1, float a2) _FS_REENTRANT
{
  volatile union float_long fl1, fl2;
  unsigned long result;
  int exp;
  char sign;
  
  fl1.f = a1;
  fl2.f = a2;

  if (!fl1.l || !fl2.l)
    return 0;

  /* compute sign and exponent */
  sign = SIGN (fl1.l) ^ SIGN (fl2.l);
  exp = EXP (fl1.l) - EXCESS;
  exp += EXP (fl2.l);

  fl1.l = MANT (fl1.l);
  fl2.l = MANT (fl2.l);

  /* the multiply is done as one 16x16 multiply and two 16x8 multiples */
  result = (fl1.l >> 8) * (fl2.l >> 8);
  result += ((fl1.l & (unsigned long) 0xFF) * (fl2.l >> 8)) >> 8;
  result += ((fl2.l & (unsigned long) 0xFF) * (fl1.l >> 8)) >> 8;

  /* round, phase 1 */
  result += 0x40;

  if (result & SIGNBIT)
    {
      /* round, phase 2 */
      result += 0x40;
      result >>= 8;
    }
  else
    {
      result >>= 7;
      --exp;
    }

  result &= ~HIDDEN;

  /* pack up and go home */
  if (exp >= 0x100)
    fl1.l = (sign ? SIGNBIT : 0) | 0x7F800000;
  else if (exp < 0)
    fl1.l = 0;
  else
    fl1.l = PACK (sign ? SIGNBIT : 0 , exp, result);
  return fl1.f;
}
/*-------------------------------------------------------------------------
   uint2fs.c

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

/* convert unsigned int to float */
float
__uint2fs (unsigned int ui) _FS_REENTRANT
{
  return __ulong2fs (ui);
}
/*-------------------------------------------------------------------------
   fsgt.c

   Copyright (C) 1991, Pipeline Associates, Inc

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

/* (c)2000/2001: hacked a little by johan.knol@iduna.nl for sdcc */

#include <float.h>

union float_long
  {
    float f;
    long l;
  };

/* compare two floats */
char
__fsgt (float a1, float a2) _FS_REENTRANT
{
  volatile union float_long fl1, fl2;

  fl1.f = a1;
  fl2.f = a2;

  if (fl1.l < 0 && fl2.l < 0)
    {
      if (fl2.l > fl1.l)
        return 1;
      return 0;
    }

  if (fl1.l > fl2.l)
    return 1;
  return 0;
}
/*-------------------------------------------------------------------------
   fs2schar

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <float.h>

/* convert float to signed char */
signed char
__fs2schar (float f) _FS_REENTRANT
{
  signed long sl = __fs2slong (f);

  if (sl >= SCHAR_MAX)
    return SCHAR_MAX;
  if (sl <= SCHAR_MIN)
    return -SCHAR_MIN;
  return sl;
}
/*-------------------------------------------------------------------------
   _modschar.c - routine for signed char (8 bit) modulus

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT usa.net> 
   Adopted for char (8-bit) and pic16 port by
     Vangelis Rokas, <vrokas AT otenet.gr> (2004)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

unsigned char _moduchar (unsigned char a, unsigned char b);

signed char _modschar (signed char a, signed char b) _IL_REENTRANT
{
  register char r;
  char ta, tb;

    if(a<0)ta = -a; else ta = a;
    if(b<0)tb = -b; else tb = b;
    
    r = _moduchar(ta, tb);
    
    if (a < 0) return -r;
    else return r;
}

/*-------------------------------------------------------------------------
   _divuchar.c - routine for unsigned char (8 bit) division

   Copyright (C) 1999, Jean-Louis Vern <jlvern AT gmail.com>
   Adopted for char (8-bit) and pic16 port by
     - Vangelis Rokas, <vrokas AT otenet.gr> (2004)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

//#define MSB_SET(x)	((x >> (8*sizeof(x)-1)) & 1)
#define MSB_SET(x)	(x & 0x80)

unsigned char
_divuchar (unsigned char a, unsigned char b) _IL_REENTRANT
{
  unsigned char reste = 0;
  unsigned char count = 8;
  char c;

  do
  {
    // reste: a <- 0;
    c = MSB_SET(a);
    a <<= 1;
    reste <<= 1;
    if (c)
      reste |= 1;

    if (reste >= b)
    {
      reste -= b;

      // a <- (result = 1)
      a |= 1;
    }
  }
  while (--count);

  return a;
}
/*-------------------------------------------------------------------------
   _divschar.c - routine for signed char (8 bit) division. just calls
                 routine for unsigned division after sign adjustment

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT usa.net> 
   Adopted for char (8-bit) and pic16 port by
     Vangelis Rokas, <vrokas AT otenet.gr> (2004)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

unsigned char _divuchar (unsigned char a, unsigned char b);

int _divschar (signed char a, signed char b) _IL_REENTRANT
{
  register unsigned char r;
  char ta, tb;

    if(a<0)ta = -a; else ta = a;
    if(b<0)tb = -b; else tb = b;
	
    r = _divuchar(ta, tb);
    
    if ((a < 0) ^ (b < 0)) return -r;
    else return r;
}

/*-------------------------------------------------------------------------
   _moduchar.c :- routine for unsigned char (8 bit) modulus

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT usa.net>
   Bug fixes by Martijn van Balen <aed AT >ae.nl
   Adopted for char (8-bit) and pic16 port by
     Vangelis Rokas, <vrokas AT otenet.gr> (2004)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

//#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1) 
#define MSB_SET(x)	(x & 0x80)


unsigned char _moduchar (unsigned char a, unsigned char b) _IL_REENTRANT
{
  unsigned char count = 0;
    
  while (!MSB_SET(b))
  {
    b <<= 1;
    if (b > a)
    {
      b >>=1;
      break;
    }
    count++;
  }

  do
  {
    if (a >= b)
      a -= b;
    b >>= 1;
  }
  while (count--);
  return a;
}
/*-------------------------------------------------------------------------
   moduint.c - routine for unsigned int (16 bit) modulus

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>
   Bug fixes by Martijn van Balen, <aed at iae.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1) 

unsigned int _moduint (unsigned int a, unsigned int b) _IL_REENTRANT
{
  unsigned char count = 0;
    
    
  while (!MSB_SET(b))
  {
    b <<= 1;
    if (b > a)
    {
      b >>=1;
      break;
    }
    count++;
  }
  do
  {
    if (a >= b)
      a -= b;
    b >>= 1;
  }
  while (count--);
  return a;
}
/*-------------------------------------------------------------------------
   divsint.c : routine for signed int (16 bit) division. just calls
               routine for unsigned division after sign adjustment

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

unsigned unsigned _divuint (unsigned a, unsigned b);

int _divsint (int a, int b) _IL_REENTRANT
{
  register int r;

  r = _divuint((a < 0 ? -a : a),
               (b < 0 ? -b : b));
  if ( (a < 0) ^ (b < 0))
    return -r;
  else
    return r;
}
/*-------------------------------------------------------------------------
   divuint.c - routine for unsigned int (16 bit) division

   Copyright (C) 1999, Jean-Louis Vern <jlvern AT gmail.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

#define MSB_SET(x) ((x >> (8*sizeof(x)-1)) & 1)

unsigned int
_divuint (unsigned int a, unsigned int b) _IL_REENTRANT
{
  unsigned int reste = 0;
  unsigned char count = 16;
  unsigned char c;

  do
  {
    // reste: a <- 0;
    c = MSB_SET(a);
    a <<= 1;
    reste <<= 1;
    if (c)
      reste |= 1;

    if (reste >= b)
    {
      reste -= b;
      // a <- (result = 1)
      a |= 1;
    }
  }
  while (--count);
  return a;
}
/*-------------------------------------------------------------------------
   mulint.c - routine for (unsigned) int (16 bit) multiplication

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>
   Modified for pic16 port by - Vangelis Rokas, <vrokas at otenet.gr> (2004)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Signed and unsigned multiplication are the same - as long as the output
   has the same precision as the input.
*/

#include <sdcc-lib.h>

union uu {
	struct { unsigned char lo,hi ;} s;
        unsigned int t;
} ;

int _mulint (int a, int b) _IL_REENTRANT
{
  union uu x;
  union uu y;
  union uu t;

    x.t = a;
    y.t = b;
    t.t = x.s.lo * y.s.lo;
    t.s.hi += (x.s.lo * y.s.hi) + (x.s.hi * y.s.lo);

  return t.t;
}
/*-------------------------------------------------------------------------
   modsint.c - routine for signed int (16 bit) modulus

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta at usa.net>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <sdcc-lib.h>

unsigned unsigned _moduint (unsigned a, unsigned b);

int _modsint (int a, int b) _IL_REENTRANT
{
       register int r;

       r = _moduint((a < 0 ? -a : a),
	            (b < 0 ? -b : b));

       if (a < 0)
	    return -r;
	else
	    return r;
}
/*-------------------------------------------------------------------------
   gstack.c - debug stack tracing support function

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

extern int WREG;
extern int FSR1L;
extern int FSR1H;
extern int FSR0L;
extern int FSR0H;
extern int STATUS;
extern int POSTINC0;
extern int POSTDEC1;
extern int PREINC1;
extern int TOSL;
extern int TOSH;
extern int TOSU;
extern int PCL;
extern int PCLATH;
extern int PCLATU;
extern int stack;
extern int stack_end;

#pragma udata access _wreg_store _status_store _fsr0_store
#pragma udata access _gstack_begin _gstack_end _init_ok

static char _init_ok=0;
static char _wreg_store;
static char _status_store;
static unsigned int _fsr0_store;
static unsigned int _gstack_begin;
static unsigned int _gstack_end;

char _gstack_fail_str[]="Stack overflow\n";
char _gstack_succ_str[]="Stack ok\n";


static
void _gstack_overflow_default(void) __naked
{
  __asm
    lfsr	0, __gstack_fail_str
;    incf	_FSR0L, f

@0:
    movf	_POSTINC0, w
    movff	_WREG, 0xf7f
    bnz		@0
    
;    sleep
@00:
    goto	@00
    
  __endasm ;
}

void (* _gstack_overflow)(void)=_gstack_overflow_default;

    
void _gstack_init(void) __naked
{
  __asm
    
    movlw	LOW(_stack)
    movwf	__gstack_begin
    
    movlw	HIGH(_stack)
    movwf	__gstack_begin+1

    movlw	LOW(_stack_end)
    movwf	__gstack_end
    
    movlw	HIGH(_stack_end)
    movwf	__gstack_end+1

    ; load default handler
;    movlw	LOW(__gstack_overflow_default)
;    movwf	__gstack_overflow
    
;    movlw	HIGH(__gstack_overflow_default)
;    movwf	__gstack_overflow+1
    
;    movlw	UPPER(__gstack_overflow_default)
;    movwf	__gstack_overflow+2
    

    movlw	1
    movwf	__init_ok
    
    return;    
  __endasm ;
}


void _gstack_test(void) __naked
{
  __asm
    movff	_WREG, __wreg_store
    movff	_STATUS, __status_store

    ; if first time, initialize boundary variables
    movf	__init_ok, w
    bnz		@1
    call	__gstack_init
    
@1:
    movf	__gstack_begin, w
    cpfslt	_FSR1L
    bra		@2
    bra		@3

@2:
    movf	__gstack_begin+1, w
    cpfslt	_FSR1H
    bra		@4
    bra		@3

@4:
    movf	__gstack_end, w
    cpfsgt	_FSR1L
    bra		@5
    bra		@3

@5:
    movf	__gstack_end+1, w
    cpfsgt	_FSR1H
    bra		@6

    ; fail

@3:

    push
    movlw	LOW(ret_lab)
    movwf	_TOSL

    movlw	HIGH(ret_lab)
    movwf	_TOSH

    movlw	UPPER(ret_lab)
    movwf	_TOSU

    movff	__gstack_overflow+2, _PCLATU
    movff	__gstack_overflow+1, _PCLATH
    movf	__gstack_overflow, w
    
    ; execute 
    movwf	_PCL
    
ret_lab:
    bra		@10

    ; success
@6:
    movff	_FSR0L, __fsr0_store
    movff	_FSR0H, __fsr0_store+1
    lfsr	0, __gstack_succ_str

    ; print corresponding string
@8:
    movf	_POSTINC0, w
    movff	_WREG, 0xf7f
    bnz		@8

@9:
    movff	__fsr0_store+1, _FSR0H
    movff	__fsr0_store, _FSR0L

@10:
    movff	__status_store, _STATUS
    movff	__wreg_store, _WREG
    
    return
    
    __endasm ;
}
/*-------------------------------------------------------------------------
   tanf.c - Computes tan(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>

float tancotf(float x, int iscot);

float tanf(float x) _MATH_REENTRANT
{
    return tancotf(x, 0);
}
/*-------------------------------------------------------------------------
   errno.c - just declares errno as a variable

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

int errno;
/*-------------------------------------------------------------------------
   expf.c - Computes e**x of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

#include <math.h>
#include <errno.h>

#define P0      0.2499999995E+0
#define P1      0.4160288626E-2
#define Q0      0.5000000000E+0
#define Q1      0.4998717877E-1

#define P(z) ((P1*z)+P0)
#define Q(z) ((Q1*z)+Q0)

#define C1       0.693359375
#define C2      -2.1219444005469058277e-4

#define BIGX    88.72283911  /* ln(XMAX) */
#define EXPEPS  1.0E-7       /* exp(1.0E-7)=0.0000001 */
#define K1      1.4426950409 /* 1/ln(2) */

float expf(float x)
{
    int n;
    float xn, g, r, z, y;
    char sign;

    if(x>=0.0)
        { y=x;  sign=0; }
    else
        { y=-x; sign=1; }

    if(y<EXPEPS) return 1.0;

    if(y>BIGX)
    {
        if(sign)
        {
            errno=ERANGE;
            return XMAX;
        }
        else
        {
            return 0.0;
        }
    }

    z=y*K1;
    n=z;

    if(n<0) --n;
    if(z-n>=0.5) ++n;
    xn=n;
    g=((y-xn*C1))-xn*C2;
    z=g*g;
    r=P(z)*g;
    r=0.5+(r/(Q(z)-r));

    n++;
    z=ldexpf(r, n);
    if(sign)
        return 1.0/z;
    else
        return z;
}
/*-------------------------------------------------------------------------
   ldexpf.c - Build a float from a mantisa and exponent.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>
#include <errno.h>

float ldexpf(float x, int pw2)
{
    union float_long fl;
    long e;

    fl.f = x;

    e=(fl.l >> 23) & 0x000000ff;
    e+=pw2;
    fl.l= ((e & 0xff) << 23) | (fl.l & 0x807fffff);

    return(fl.f);
}
/*-------------------------------------------------------------------------
   cotf.c - Computes cot(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>
#include <errno.h>

float tancotf(float x, int iscot);

float cotf(float x) _MATH_REENTRANT
{
    float y;

    y=fabsf(x);
    if (y<1.0E-30) //This one requires more thinking...
    {
        errno = ERANGE;
        if (x<0.0)
            return -XMAX;
        else
            return XMAX;
    }
    return tancotf(x, 1);
}
/*-------------------------------------------------------------------------
   powf.c - Computes x**y where x and y are 32-bit floats.
            WARNING: less that 6 digits accuracy.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>
#include <errno.h>

float powf(float x, float y)
{
    if(y == 0.0) return 1.0;
    if(y==1.0) return x;
    if(x <= 0.0) return 0.0;
    return expf(logf(x) * y);
}
/*-------------------------------------------------------------------------
   logf.c: Computes the natural log of a 32 bit float as outlined in [1].

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

#include <math.h>
#include <errno.h>

/*Constans for 24 bits or less (8 decimal digits)*/
#define A0 -0.5527074855E+0
#define B0 -0.6632718214E+1
#define A(w) (A0)
#define B(w) (w+B0)

#define C0  0.70710678118654752440
#define C1  0.693359375 /*355.0/512.0*/
#define C2 -2.121944400546905827679E-4

float logf(float x) _MATH_REENTRANT
{
#if     defined(__SDCC_mcs51) && defined(__SDCC_MODEL_SMALL) \
    && !defined(__SDCC_NOOVERLAY)
    volatile
#endif
    float Rz;
    float f, z, w, znum, zden, xn;
    int n;

    if (x<=0.0)
    {
        errno=EDOM;
        return 0.0;
    }
    f=frexpf(x, &n);
    znum=f-0.5;
    if (f>C0)
    {
        znum-=0.5;
        zden=(f*0.5)+0.5;
    }
    else
    {
        n--;
        zden=znum*0.5+0.5;
    }
    z=znum/zden;
    w=z*z;

    Rz=z+z*(w*A(w)/B(w));
    xn=n;
    return ((xn*C2+Rz)+xn*C1);
}
/*-------------------------------------------------------------------------
   cosf.c - Computes cos(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>

float sincosf(float x, int iscos);

float cosf(float x) _MATH_REENTRANT
{
    if (x==0.0) return 1.0;
    return sincosf(x, 1);
}
/*-------------------------------------------------------------------------
   sinf.c - Computes sin(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>

float sincosf(float x, int iscos);

float sinf(float x) _MATH_REENTRANT
{
    if (x==0.0) return 0.0;
    return sincosf(x, 0);
}
/*-------------------------------------------------------------------------
   sincosf.c - Computes sin or cos of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

#include <math.h>
#include <errno.h>

#define r1      (-0.1666665668E+0)
#define r2      (0.8333025139E-2)
#define r3      (-0.1980741872E-3)
#define r4       (0.2601903036E-5)

/* PI=C1+C2 */
#define C1       3.140625
#define C2       9.676535897E-4

/*A reasonable value for YMAX is the int part of PI*B**(t/2)=3.1416*2**(12)*/
#define YMAX     12867.0

float sincosf(float x, int iscos)
{
    float y, f, r, g, XN;
    int N;
    char sign;

    if(iscos)
    {
        y=fabsf(x)+HALF_PI;
        sign=0;
    }
    else
    {
        if(x<0.0)
            { y=-x; sign=1; }
        else
            { y=x; sign=0; }
    }

    if(y>YMAX)
    {
        errno=ERANGE;
        return 0.0;
    }

    /*Round y/PI to the nearest integer*/
    N=((y*iPI)+0.5); /*y is positive*/

    /*If N is odd change sign*/
    if(N&1) sign=!sign;

    XN=N;
    /*Cosine required? (is done here to keep accuracy)*/
    if(iscos) XN-=0.5;

    y=fabsf(x);
    r=(int)y;
    g=y-r;
    f=((r-XN*C1)+g)-XN*C2;

    g=f*f;
    if(g>EPS2) //Used to be if(fabsf(f)>EPS)
    {
        r=(((r4*g+r3)*g+r2)*g+r1)*g;
        f+=f*r;
    }
    return (sign?-f:f);
}
/*-------------------------------------------------------------------------
   atanf.c - Computes arctan of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

#include <math.h>
#include <errno.h>

#define P0 -0.4708325141E+0
#define P1 -0.5090958253E-1
#define Q0  0.1412500740E+1
#define Q1  0.1000000000E+1

#define P(g,f) ((P1*g+P0)*g*f)
#define Q(g) (Q1*g+Q0)

#define K1  0.2679491924 /* 2-sqrt(3) */
#define K2  0.7320508076 /* sqrt(3)-1 */
#define K3  1.7320508076 /* sqrt(3)   */

float atanf(float x) _MATH_REENTRANT
{
    float f, r, g;
    int n=0;
    static const float a[]={  0.0, 0.5235987756, 1.5707963268, 1.0471975512 };

    f=fabsf(x);
    if(f>1.0)
    {
        f=1.0/f;
        n=2;
    }
    if(f>K1)
    {
        f=((K2*f-1.0)+f)/(K3+f);
        // What it is actually wanted is this more accurate formula,
        // but SDCC optimizes it and then it does not work:
        // f=(((K2*f-0.5)-0.5)+f)/(K3+f);
        n++;
    }
    if(fabsf(f)<EPS) r=f;
    else
    {
        g=f*f;
        r=f+P(g,f)/Q(g);
    }
    if(n>1) r=-r;
    r+=a[n];
    if(x<0.0) r=-r;
    return r;
}
/*-------------------------------------------------------------------------
   coshf.c - Computes cosh(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>

float sincoshf(float x, int iscosh);

float coshf(float x) _MATH_REENTRANT
{
    return sincoshf(x, 1);
}
/*-------------------------------------------------------------------------
   asincosf.c - Computes asin or acos of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

#include <math.h>
#include <errno.h>

#define P1  0.933935835E+0
#define P2 -0.504400557E+0
#define Q0  0.560363004E+1
#define Q1 -0.554846723E+1
#define Q2  0.100000000E+1

#define P(g) (P2*g+P1)
#define Q(g) ((Q2*g+Q1)*g+Q0)

float asincosf(float x, int isacos)
{
    float y, g, r;
    int i;

    static const float a[2]={ 0.0, QUART_PI };
    static const float b[2]={ HALF_PI, QUART_PI };

    y=fabsf(x);
    i=isacos;
    if (y < EPS) r=y;
    else
    {
        if (y > 0.5)
        {
            i=1-i;
            if (y > 1.0)
            {
                errno=EDOM;
                return 0.0;
            }
            g=(0.5-y)+0.5;
            g=ldexpf(g,-1);
            y=sqrtf(g);
            y=-(y+y);
        }
        else
        {
            g=y*y;
        }
        r=y+y*((P(g)*g)/Q(g));
    }
    if (isacos)
    {
        if (x < 0.0)
            r=(b[i]+r)+b[i];
        else
            r=(a[i]-r)+a[i];
    }
    else
    {
        r=(a[i]+r)+a[i];
        if (x<0.0) r=-r;
    }
    return r;
}
/*-------------------------------------------------------------------------
   frexpf.c - Returns the exponent and mantisa of a 32 bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>
#include <errno.h>

float frexpf(float x, int *pw2)
{
    union float_long fl;
    long int i;

    fl.f=x;
    /* Find the exponent (power of 2) */
    i  = ( fl.l >> 23) & 0x000000ff;
    i -= 0x7e;
    *pw2 = i;
    fl.l &= 0x807fffff; /* strip all exponent bits */
    fl.l |= 0x3f000000; /* mantissa between 0.5 and 1 */
    return(fl.f);
}
/*-------------------------------------------------------------------------
   atan2f.c - Computes atan2(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>
#include <errno.h>

float atan2f(float x, float y)
{
    float r;

    if ((x==0.0) && (y==0.0))
    {
        errno=EDOM;
        return 0.0;
    }

    if(fabsf(y)>=fabsf(x))
    {
        r=atanf(x/y);
        if(y<0.0) r+=(x>=0?PI:-PI);
    }
    else
    {
        r=-atanf(y/x);
        r+=(x<0.0?-HALF_PI:HALF_PI);
    }
    return r;
}
/*-------------------------------------------------------------------------
   ceilf.c - Returns the integer larger or equal than x

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>

float ceilf(float x) _MATH_REENTRANT
{
    long r;
    r=x;
    if (r<0)
        return r;
    else
        return (r+((r<x)?1:0));
}
/*-------------------------------------------------------------------------
   modff.c - Returns both the integer and fraction of a float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>

float modff(float x, float * y)
{
    *y=((int)x);
    return (x-*y);
}
/*-------------------------------------------------------------------------
   tancotf.c - Computes tan or cot of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

#include <math.h>
#include <errno.h>

#define P0  0.100000000E+1
#define P1 -0.958017723E-1
#define Q0  0.100000000E+1
#define Q1 -0.429135777E+0
#define Q2  0.971685835E-2

#define C1  1.5703125
#define C2  4.83826794897E-4

#define P(f,g) (P1*g*f+f)
#define Q(g) ((Q2*g+Q1)*g+Q0)

//A reasonable choice for YMAX is the integer part of B**(t/2)*PI/2:
#define YMAX 6433.0

float tancotf(float x, int iscotan)
{
    float f, g, xn, xnum, xden;
    int n;

    if (fabsf(x) > YMAX)
    {
        errno = ERANGE;
        return 0.0;
    }

    /*Round x*2*PI to the nearest integer*/
    n=(x*TWO_O_PI+(x>0.0?0.5:-0.5)); /*works for +-x*/
    xn=n;

    xnum=(int)x;
    xden=x-xnum;
    f=((xnum-xn*C1)+xden)-xn*C2;

    if (fabsf(f) < EPS)
    {
        xnum = f;
        xden = 1.0;
    }
    else
    {
        g = f*f;
        xnum = P(f,g);
        xden = Q(g);
    }

    if(n&1)
    //xn is odd
    {
        if(iscotan) return (-xnum/xden);
               else return (-xden/xnum);
    }
    else
    {
        if(iscotan) return (xden/xnum);
               else return (xnum/xden);
    }
}
/*-------------------------------------------------------------------------
   acosf.c - Computes arc cosine of a 32-bit float

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>

float asincosf(float x, int isacos);

float
acosf (float x) _MATH_REENTRANT
{
  if (x == 1.0)
    return 0.0;
  else if (x == -1.0)
    return PI;
  else if (x == 0.0)
    return HALF_PI;
  return asincosf (x, 1);
}
/*-------------------------------------------------------------------------
   floorf.c - Returns the integer smaller or equal than x

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>

float floorf (float x) _MATH_REENTRANT
{
    long r;
    r=x;
    if (r<=0)
        return (r+((r>x)?-1:0));
    else
        return r;
}
/*-------------------------------------------------------------------------
   sincoshf.c - Computes sinh or cosh of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

#include <math.h>
#include <errno.h>

#define P0 -0.713793159E+1
#define P1 -0.190333999E+0
#define Q0 -0.428277109E+2
#define Q1  0.100000000E+1

#define P(z) (P1*z+P0)
#define Q(z) (Q1*z+Q0)

#define K1 0.69316101074218750000E+0 /* ln(v)   */
#define K2 0.24999308500451499336E+0 /* v**(-2) */
#define K3 0.13830277879601902638E-4 /* v/2-1   */

//WMAX is defined as ln(XMAX)-ln(v)+0.69
#define WMAX 44.93535952E+0
//WBAR 0.35*(b+1)
#define WBAR 1.05
#define YBAR 9.0 /*Works for me*/

float sincoshf(float x, int iscosh)
{
    float y, w, z;
    char sign;
    
    if (x<0.0) { y=-x; sign=1; }
          else { y=x;  sign=0; }

    if ((y>1.0) || iscosh)
    {
        if(y>YBAR)
        {
            w=y-K1;
            if (w>WMAX)
            {
                errno=ERANGE;
                z=XMAX;
            }
            else
            {
                z=expf(w);
                z+=K3*z;
            }
        }
        else
        {
            z=expf(y);
            w=1.0/z;
            if(!iscosh) w=-w;
            z=(z+w)*0.5;
        }
        if(sign) z=-z;
    }
    else
    {
        if (y<EPS)
            z=x;
        else
        {
            z=x*x;
            z=x+x*z*P(z)/Q(z);
        }
    }
    return z;
}
/*-------------------------------------------------------------------------
   tanhf.c - Computes tanh(x) where x is a 32-bit float as outlined in [1].

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

#include <math.h>
#include <errno.h>

#define P0 -0.8237728127E+0
#define P1 -0.3831010665E-2
#define Q0  0.2471319654E+1
#define Q1  0.1000000000E+1

/* ln(3)/2 */
#define K1  0.5493061443E+0
/* SBIG=[ln(2)+(t+1)*ln(B)]/2 */
#define SBIG 9.01091

#define P(g) ((P1*g+P0)*g)
#define Q(g) (Q1*g+Q0)

float tanhf(float x) _MATH_REENTRANT
{
    float f, g, r;

    f=fabsf(x);
    if(f>SBIG) r=1.0;
    else if(f>K1)
    {
        r=0.5-1.0/(expf(f+f)+1.0);
        r+=r;
    }
    else if(f<EPS) r=f;
    else
    {
        g=f*f;
        r=f+f*(P(g)/Q(g));
    }
    if(x<0.0) r=-r;
    return r;
}
/*-------------------------------------------------------------------------
   sinhf.c - Computes sinh(x) where x is a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>

float sincoshf(float x, int iscosh);

float sinhf(float x) _MATH_REENTRANT
{
    return sincoshf(x, 0);
}
/*-------------------------------------------------------------------------
   fabsf.c - Returns the absolute value of a 32-bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>
#include <errno.h>

float fabsf(float x) _MATH_REENTRANT
{
    union float_long fl;

    fl.f = x;
    fl.l &= 0x7fffffff;
    return fl.f;
}
/*-------------------------------------------------------------------------
   sqrtf.c - Computes square root of a 32-bit float as outlined in [1]

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* [1] William James Cody and W.  M.  Waite.  _Software manual for the
   elementary functions_, Englewood Cliffs, N.J.:Prentice-Hall, 1980. */

#include <math.h>
#include <errno.h>

float sqrtf(float x) _MATH_REENTRANT
{
    float f, y;
    int n;

    if (x==0.0) return x;
    else if (x==1.0) return 1.0;
    else if (x<0.0)
    {
        errno=EDOM;
        return 0.0;
    }
    f=frexpf(x, &n);
    y=0.41731+0.59016*f; /*Educated guess*/
    /*For a 24 bit mantisa (float), two iterations are sufficient*/
    y+=f/y;
    y=ldexpf(y, -2) + f/y; /*Faster version of 0.25 * y + f/y*/

    if (n&1)
    {
        y*=0.7071067812;
        ++n;
    }
    return ldexpf(y, n/2);
}
/*-------------------------------------------------------------------------
   log10f.c: Computes the base 10 log of a 32 bit float.

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>
#include <errno.h>

float log10f(float x) _MATH_REENTRANT
{
    return logf(x)*0.4342944819;
}
/*-------------------------------------------------------------------------
   asinf.c - Computes asin(x)

   Copyright (C) 2001, 2002, Jesus Calvino-Fraga <jesusc At ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <math.h>

float asincosf(float x, int isacos);

float asinf(float x) _MATH_REENTRANT
{   
         if(x== 1.0) return  HALF_PI;
    else if(x==-1.0) return -HALF_PI;
    else if(x== 0.0) return 0.0;
    else return asincosf(x,0);
}
18f13k22
18f14k22
18f24j11
18f24j50
18f24k50
18f25j11
18f25j50
18f25k50
18f25k80
18f26j11
18f26j13
18f26j50
18f26j53
18f26k80
18f27j13
18f27j53
18f44j11
18f44j50
18f45j11
18f45j50
18f45k50
18f45k80
18f46j11
18f46j13
18f46j50
18f46j53
18f46k80
18f47j13
18f47j53
18f63j11
18f63j90
18f64j11
18f64j90
18f65j10
18f65j11
18f65j15
18f65j90
18f65j94
18f65k22
18f65k80
18f65k90
18f66j10
18f66j11
18f66j15
18f66j16
18f66j90
18f66j93
18f66j94
18f66j99
18f66k22
18f66k80
18f66k90
18f67j10
18f67j11
18f67j90
18f67j93
18f67j94
18f67k22
18f67k90
18f83j11
18f83j90
18f84j11
18f84j90
18f85j10
18f85j11
18f85j15
18f85j90
18f85j94
18f85k22
18f85k90
18f86j10
18f86j11
18f86j15
18f86j16
18f86j72
18f86j90
18f86j93
18f86j94
18f86j99
18f86k22
18f86k90
18f87j10
18f87j11
18f87j72
18f87j90
18f87j93
18f87j94
18f87k22
18f87k90
18f95j94
18f96j94
18f96j99
18f97j94
18f1220
18f1230
18f1320
18f1330
18f2331
18f2431
18f2439
18f2450
18f2455
18f2458
18f2539
18f2550
18f2553
18f4331
18f4431
18f4439
18f4450
18f4455
18f4458
18f4539
18f4550
18f4553
18f6310
18f6390
18f6393
18f6410
18f6490
18f6493
18f6525
18f6621
18f6628
18f6723
18f8310
18f8390
18f8393
18f8410
18f8490
18f8493
18f8525
18f8621
18f8628
18f8723
18lf13k22
18lf14k22
18lf24j11
18lf24j50
18lf24k50
18lf25j11
18lf25j50
18lf25k50
18lf25k80
18lf26j11
18lf26j13
18lf26j50
18lf26j53
18lf26k80
18lf27j13
18lf27j53
18lf44j11
18lf44j50
18lf45j11
18lf45j50
18lf45k50
18lf45k80
18lf46j11
18lf46j13
18lf46j50
18lf46j53
18lf46k80
18lf47j13
18lf47j53
18lf65k80
18lf66k80
18lf1220
18lf1230
18lf1320
18lf1330
18lf2331
18lf2431
18lf2439
18lf2450
18lf2455
18lf2458
18lf2539
18lf2550
18lf2553
18lf4331
18lf4431
18lf4439
18lf4450
18lf4455
18lf4458
18lf4539
18lf4550
18lf4553
18lf6310
18lf6390
18lf6393
18lf6410
18lf6490
18lf6493
18lf6525
18lf6621
18lf6628
18lf6723
18lf8310
18lf8390
18lf8393
18lf8410
18lf8490
18lf8493
18lf8525
18lf8621
18lf8628
18lf8723
18f13k22
18f14k22
18f24j11
18f24k50
18f25j11
18f25k50
18f25k80
18f26j11
18f26j13
18f26j53
18f26k80
18f27j13
18f27j53
18f44j11
18f45j11
18f45k50
18f45k80
18f46j11
18f46j13
18f46j53
18f46k80
18f47j13
18f47j53
18f63j11
18f63j90
18f64j11
18f64j90
18f65j10
18f65j11
18f65j15
18f65j90
18f65j94
18f65k22
18f65k80
18f65k90
18f66j10
18f66j11
18f66j15
18f66j16
18f66j90
18f66j93
18f66j94
18f66j99
18f66k22
18f66k80
18f66k90
18f67j10
18f67j11
18f67j90
18f67j93
18f67j94
18f67k22
18f67k90
18f83j11
18f83j90
18f84j11
18f84j90
18f85j10
18f85j11
18f85j15
18f85j90
18f85j94
18f85k22
18f85k90
18f86j10
18f86j11
18f86j15
18f86j16
18f86j72
18f86j90
18f86j93
18f86j94
18f86j99
18f86k22
18f86k90
18f87j10
18f87j11
18f87j72
18f87j90
18f87j93
18f87j94
18f87k22
18f87k90
18f95j94
18f96j94
18f96j99
18f97j94
18f2439
18f2458
18f2539
18f2553
18f4439
18f4458
18f4539
18f4553
18f6310
18f6390
18f6393
18f6410
18f6490
18f6493
18f6525
18f6621
18f6628
18f6723
18f8310
18f8390
18f8393
18f8410
18f8490
18f8493
18f8525
18f8621
18f8628
18f8723
18lf13k22
18lf14k22
18lf24j11
18lf24k50
18lf25j11
18lf25k50
18lf25k80
18lf26j11
18lf26j13
18lf26j53
18lf26k80
18lf27j13
18lf27j53
18lf44j11
18lf45j11
18lf45k50
18lf45k80
18lf46j11
18lf46j13
18lf46j53
18lf46k80
18lf47j13
18lf47j53
18lf65k80
18lf66k80
18lf2439
18lf2458
18lf2539
18lf2553
18lf4439
18lf4458
18lf4539
18lf4553
18lf6310
18lf6390
18lf6393
18lf6410
18lf6490
18lf6493
18lf6525
18lf6621
18lf6628
18lf6723
18lf8310
18lf8390
18lf8393
18lf8410
18lf8490
18lf8493
18lf8525
18lf8621
18lf8628
18lf8723
static int __foo;

18f13k22
18f14k22
18f24j11
18f24k50
18f25j11
18f25k50
18f25k80
18f26j11
18f26j13
18f26j53
18f26k80
18f27j13
18f27j53
18f44j11
18f45j11
18f45k50
18f45k80
18f46j11
18f46j13
18f46j53
18f46k80
18f47j13
18f47j53
18f63j11
18f63j90
18f64j11
18f64j90
18f65j10
18f65j11
18f65j15
18f65j90
18f65j94
18f65k22
18f65k80
18f65k90
18f66j10
18f66j11
18f66j15
18f66j16
18f66j90
18f66j93
18f66j94
18f66j99
18f66k22
18f66k80
18f66k90
18f67j10
18f67j11
18f67j90
18f67j93
18f67j94
18f67k22
18f67k90
18f83j11
18f83j90
18f84j11
18f84j90
18f85j10
18f85j11
18f85j15
18f85j90
18f85j94
18f85k22
18f85k90
18f86j10
18f86j11
18f86j15
18f86j16
18f86j72
18f86j90
18f86j93
18f86j94
18f86j99
18f86k22
18f86k90
18f87j10
18f87j11
18f87j72
18f87j90
18f87j93
18f87j94
18f87k22
18f87k90
18f95j94
18f96j94
18f96j99
18f97j94
18f2331
18f2431
18f2439
18f2458
18f2539
18f2553
18f4331
18f4431
18f4439
18f4458
18f4539
18f4553
18f6310
18f6390
18f6393
18f6410
18f6490
18f6493
18f6525
18f6621
18f6628
18f6723
18f8310
18f8390
18f8393
18f8410
18f8490
18f8493
18f8525
18f8621
18f8628
18f8723
18lf13k22
18lf14k22
18lf24j11
18lf24k50
18lf25j11
18lf25k50
18lf25k80
18lf26j11
18lf26j13
18lf26j53
18lf26k80
18lf27j13
18lf27j53
18lf44j11
18lf45j11
18lf45k50
18lf45k80
18lf46j11
18lf46j13
18lf46j53
18lf46k80
18lf47j13
18lf47j53
18lf65k80
18lf66k80
18lf2331
18lf2431
18lf2439
18lf2458
18lf2539
18lf2553
18lf4331
18lf4431
18lf4439
18lf4458
18lf4539
18lf4553
18lf6310
18lf6390
18lf6393
18lf6410
18lf6490
18lf6493
18lf6525
18lf6621
18lf6628
18lf6723
18lf8310
18lf8390
18lf8393
18lf8410
18lf8490
18lf8493
18lf8525
18lf8621
18lf8628
18lf8723














18lf13k22
18lf13k50
18lf14k22
18lf14k50
18lf23k22
18lf24j10
18lf24j11
18lf24j50
18lf24k22
18lf24k50
18lf25j10
18lf25j11
18lf25j50
18lf25k22
18lf25k50
18lf25k80
18lf26j11
18lf26j13
18lf26j50
18lf26j53
18lf26k22
18lf26k80
18lf27j13
18lf27j53
18lf43k22
18lf44j10
18lf44j11
18lf44j50
18lf44k22
18lf45j10
18lf45j11
18lf45j50
18lf45k22
18lf45k50
18lf45k80
18lf46j11
18lf46j13
18lf46j50
18lf46j53
18lf46k22
18lf46k80
18lf47j13
18lf47j53
18lf65k80
18lf66k80
18lf242
18lf248
18lf252
18lf258
18lf442
18lf448
18lf452
18lf458
18lf1220
18lf1230
18lf1320
18lf1330
18lf2220
18lf2221
18lf2320
18lf2321
18lf2331
18lf2410
18lf2420
18lf2423
18lf2431
18lf2439
18lf2450
18lf2455
18lf2458
18lf2480
18lf2510
18lf2515
18lf2520
18lf2523
18lf2525
18lf2539
18lf2550
18lf2553
18lf2580
18lf2585
18lf2610
18lf2620
18lf2680
18lf2682
18lf2685
18lf4220
18lf4221
18lf4320
18lf4321
18lf4331
18lf4410
18lf4420
18lf4423
18lf4431
18lf4439
18lf4450
18lf4455
18lf4458
18lf4480
18lf4510
18lf4515
18lf4520
18lf4523
18lf4525
18lf4539
18lf4550
18lf4553
18lf4580
18lf4585
18lf4610
18lf4620
18lf4680
18lf4682
18lf4685
18lf6310
18lf6390
18lf6393
18lf6410
18lf6490
18lf6493
18lf6520
18lf6525
18lf6527
18lf6585
18lf6620
18lf6621
18lf6622
18lf6627
18lf6628
18lf6680
18lf6720
18lf6722
18lf6723
18lf8310
18lf8390
18lf8393
18lf8410
18lf8490
18lf8493
18lf8520
18lf8525
18lf8527
18lf8585
18lf8620
18lf8621
18lf8622
18lf8627
18lf8628
18lf8680
18lf8720
18lf8722
18lf8723
#!/bin/sh

#
# Script to generate Makefile.am,
# execute in device/lib/pic16/libio/ with no arguments.
#
# Written by Raphael Neider <tecodev AT users sourceforge net>
#
# Released under the terms of the GPL v2.
#

cat <<HEREDOC
## Makefile.am -- Process this file with automake to produce Makefile.in
## This file was automatically generated using $0.

lib_LIBRARIES = 

HEREDOC

for f in "../../../non-free/lib/pic16/libdev/pic1"*.c; do
    p="${f##*/pic}";
    p="${p%.c}";
    P=$(echo "$p" | tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ);
    echo "Generating for device >>${p}<<" >&2;
    cat <<HERE
if ENABLE_$P
lib_LIBRARIES += libio${p}.a
endif ENABLE_$P
libio${p}_a_SOURCES = dummy.c
HERE
    sed -e 's/\s*\(#.*\)\{0,1\}$//' adc.ignore | grep -x "$p" > /dev/null 2>&1 && { echo "No adc." >&2 ; } || cat <<HERE
libio${p}_a_SOURCES += adc/adcbusy.c adc/adcclose.c adc/adcconv.c
libio${p}_a_SOURCES += adc/adcopen.c adc/adcread.c adc/adcsetch.c
HERE
    sed -e 's/\s*\(#.*\)\{0,1\}$//' i2c.ignore | grep -x "$p" > /dev/null 2>&1 && { echo "No i2c." >&2 ; } || cat <<HERE
libio${p}_a_SOURCES += i2c/i2cack.c i2c/i2cclose.c i2c/i2cdrdy.c
libio${p}_a_SOURCES += i2c/i2cidle.c i2c/i2cnack.c i2c/i2copen.c
libio${p}_a_SOURCES += i2c/i2creadc.c i2c/i2creads.c i2c/i2crestart.c
libio${p}_a_SOURCES += i2c/i2cstart.c i2c/i2cstop.c i2c/i2cwritec.c
libio${p}_a_SOURCES += i2c/i2cwrites.c
HERE
    sed -e 's/\s*\(#.*\)\{0,1\}$//' usart.ignore | grep -x "$p" > /dev/null 2>&1 && { echo "No usart." >&2 ; } || cat <<HERE
libio${p}_a_SOURCES += usart/ubaud.c usart/ubusy.c usart/uclose.c
libio${p}_a_SOURCES += usart/udrdy.c usart/ugetc.c usart/ugets.c
libio${p}_a_SOURCES += usart/uopen.c usart/uputc.c usart/uputs.c
libio${p}_a_SOURCES += usart/usartd.c
HERE
    cat <<HERE
libio${p}_a_CFLAGS = -p${p} \$(AM_CFLAGS)

HERE
done

cat <<HEREDOC
include \$(top_srcdir)/Makefile.common

HEREDOC

/*-------------------------------------------------------------------------
   adcopen - initialize AD module

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <adc.h>


/*
 * parameters are:
 *   channel: one of ADC_CHN_*
 *   fosc:    one of ADC_FOSC_* | ADC_ACQT_* | ADC_CAL
 *   pcfg:    one of ADC_CFG_* (a bitmask with set bits denoting digital ports for many styles)
 *   config:  ADC_FRM_* | ADC_INT_* | ADC_VCFG_* | ADC_NVCFG_* | ADC_PVCFG_*
 */

void
adc_open(unsigned char channel, unsigned char fosc, sdcc_pcfg_t pcfg, unsigned char config)
{
  /* disable ADC */
#if (__SDCC_ADC_STYLE == 1865501)
  WDTCONbits.ADSHR = 0; /* access ADCON0/1 */
#endif
  ADCON0 = 0;

#if (__SDCC_ADC_STYLE == 1802420)
  ADCON0 = ((channel & 0x07) << 3) | ((fosc & 0x03) << 6);
  ADCON1 = (pcfg & 0x0f) | (config & ADC_FRM_RJUST);
  if (fosc & 0x04) {
    ADCON1bits.ADCS2 = 1;
  }
#elif (__SDCC_ADC_STYLE == 1812200)
  ADCON0 = ((channel & 0x07) | (config & ADC_VCFG_AN3_AN2)) << 2;
  ADCON1 = (pcfg & 0x7f);
  ADCON2 = (ADCON2 & 0x38) | (fosc & 0x07) | (config & ADC_FRM_RJUST);
#elif (__SDCC_ADC_STYLE == 1812300)
  ADCON0 = ((channel & 0x03) << 2);
  ADCON1 = (pcfg & 0x0f) | (config & ADC_VCFG_VREF);
  ADCON2 = (fosc & 0x7f) | (config & ADC_FRM_RJUST);
#elif (__SDCC_ADC_STYLE == 1813502)
  ANSEL = pcfg;
  ANSELH = (pcfg >> 8);
  ADCON0 = ((channel & 0x0f) << 2);
  ADCON1 = (config & 0x0f);
  ADCON2 = (config & ADC_FRM_RJUST) | (fosc & 0x3f);
#elif (__SDCC_ADC_STYLE == 1823222)
  /* use ANSELA, ANSELB, ANSELC, ANSELD, ANSELE registers and
     TRISA, TRISB, TRISC, TRISD, TRISE registers to set
     corresponding port to analog mode */
  /* 46k22 supports up to 28 ADC ports */
  ADCON0 = ((channel & 0x1f) << 2);
  /* TRIGSEL ‚Äî ‚Äî ‚Äî PVCFG<1:0> NVCFG<1:0> */
  ADCON1 = (fosc & ADC_TRIGGER) | (config & 0x0f);
  /* ADFM ‚Äî ACQT<2:0> ADCS<2:0> */
  ADCON2 = (config & ADC_FRM_RJUST) | (fosc & 0x3f);
  (void)pcfg; /* quieten compiler warning */
#elif (__SDCC_ADC_STYLE == 1822200)
  ADCON0 = (channel & 0x0f) << 2;
  /* XXX: Should be (pcfg & 0x0f) as VCFG comes from config,
   * but we retain compatibility for now ... */
  ADCON1 = (pcfg & 0x3f) | (config & ADC_VCFG_AN3_AN2);
  ADCON2 = (config & ADC_FRM_RJUST) | (fosc & 0x3f);
#elif (__SDCC_ADC_STYLE == 1824501)
  ANCON0 = pcfg;
  ANCON1 = (pcfg >> 8);
  ADCON0 = ((channel & 0x0f) << 2) | ((config & ADC_VCFG_AN3_AN2) << 2);
  ADCON1 = (config & ADC_FRM_RJUST) | (fosc & 0x7f);
#elif (__SDCC_ADC_STYLE == 1865501)
  WDTCONbits.ADSHR = 1; /* access ANCON0/1 */
  ANCON0 = pcfg;
  ANCON1 = (pcfg >> 8);
  WDTCONbits.ADSHR = 0; /* access ADCON0/1 */
  ADCON0 = ((channel & 0x0f) << 2) | ((config & ADC_VCFG_AN3_AN2) << 2);
  ADCON1 = (config & ADC_FRM_RJUST) | (fosc & 0x7f);
#else /* unsupported ADC style */
#error Unsupported ADC style.
#endif

  if (config & ADC_INT_ON) {
    PIR1bits.ADIF = 0;
    PIE1bits.ADIE = 1;
    INTCONbits.PEIE = 1;
  }

  /* enable the A/D module */
  ADCON0bits.ADON = 1;
}
/*-------------------------------------------------------------------------
   adcclose - shutdown AD module

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <adc.h>


void adc_close(void)
{
#if (__SDCC_ADC_STYLE == 1865501)
  WDTCONbits.ADSHR = 0; /* access ADCON0/1 */
#endif
  ADCON0bits.ADON = 0;
  PIE1bits.ADIE = 0;
}
/*-------------------------------------------------------------------------
   adcread - read value of convertion

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <adc.h>


int adc_read(void) __naked
{
  __asm
    movff       _ADRESH, _PRODL
    movf        _ADRESL, w
    return
  __endasm;
}
/*-------------------------------------------------------------------------
   adcconv - begin a conversion

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <adc.h>


void adc_conv(void)
{
#if (__SDCC_ADC_STYLE == 1865501)
  WDTCONbits.ADSHR = 0; /* access ADCON0/1 */
#endif
  ADCON0bits.GO = 1;
}
/*-------------------------------------------------------------------------
   adcbusy - check whether the AD module is busy

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <adc.h>


char adc_busy(void) __naked
{
#if (__SDCC_ADC_STYLE == 1865501)
  WDTCONbits.ADSHR = 0; /* access ADCON0/1 */
#endif
#if 0
  return (ADCON0bits.GO);
#else
#if (__SDCC_ADC_STYLE == 1802420)
  __asm
    movlw       0x00
    btfsc       _ADCON0bits, 2
    addlw       0x01
    return
  __endasm;
#elif (__SDCC_ADC_STYLE == 1812200) \
   || (__SDCC_ADC_STYLE == 1812300) \
   || (__SDCC_ADC_STYLE == 1813502) \
   || (__SDCC_ADC_STYLE == 1822200) \
   || (__SDCC_ADC_STYLE == 1823222) \
   || (__SDCC_ADC_STYLE == 1824501) \
   || (__SDCC_ADC_STYLE == 1865501)
  __asm
    movlw       0x00
    btfsc       _ADCON0bits, 1
    addlw       0x01
    return
  __endasm;
#else /* unsupported ADC style */
#error Unsupported ADC style.
#endif
#endif
}
/*-------------------------------------------------------------------------
   adcsetch - select convertion channel

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <adc.h>


void adc_setchannel(unsigned char channel)
{
#if (__SDCC_ADC_STYLE == 1802420)
  ADCON0 = (ADCON0 & ~(0x07 << 3)) | ((channel & 0x07) << 3);
#elif (__SDCC_ADC_STYLE == 1812200)
  ADCON0 = (ADCON0 & ~(0x07 << 2)) | ((channel & 0x07) << 2);
#elif (__SDCC_ADC_STYLE == 1812300)
  ADCON0 = (ADCON0 & ~(0x03 << 2)) | ((channel & 0x03) << 2);
#elif (__SDCC_ADC_STYLE == 1813502)
  ADCON0 = (ADCON0 & ~(0x0f << 2)) | ((channel & 0x0f) << 2);
#elif (__SDCC_ADC_STYLE == 1822200)
  ADCON0 = (ADCON0 & ~(0x0f << 2)) | ((channel & 0x0f) << 2);
#elif (__SDCC_ADC_STYLE == 1823222)
  ADCON0 = (ADCON0 & ~(0x1f << 2)) | ((channel & 0x1f) << 2);
#elif (__SDCC_ADC_STYLE == 1824501)
  ADCON0 = (ADCON0 & ~(0x0f << 2)) | ((channel & 0x0f) << 2);
#elif (__SDCC_ADC_STYLE == 1865501)
  WDTCONbits.ADSHR = 0; /* access ADCON0/1 */
  ADCON0 = (ADCON0 & ~(0x0f << 2)) | ((channel & 0x0f) << 2);
#else /* unsupported ADC style */
#error Unsupported ADC style.
#endif
}
/*-------------------------------------------------------------------------
   ugetc - get received character

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * Devices implemented:
 *	PIC18F[24][45][28]
 */


#include <pic18fregs.h>
#include <usart.h>

extern union USART USART_Status;

unsigned char
usart_getc (void)
{
  USART_Status.val &= 0xf0;

  if (RCSTAbits.RX9)
    {
      USART_Status.RX_NINE = 0;
      if (RCSTAbits.RX9D)
        {
          USART_Status.RX_NINE = 1;
        }
    } // if

  if (RCSTAbits.FERR)
    USART_Status.FRAME_ERROR = 1;

  if (RCSTAbits.OERR)
    USART_Status.OVERRUN_ERROR = 1;

  return (RCREG);
}
/*-------------------------------------------------------------------------
   uopen - initialize USART module

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * Devices implemented:
 *	PIC18F[24][45][28]
 */


#include <pic18fregs.h>
#include <usart.h>

// USART Status Structure
extern union USART USART_Status;

void
usart_open (unsigned char config, sdcc_spbrg_t spbrg) __wparam
{
  TXSTA = 0;           // Reset USART registers to POR state
  RCSTA = 0;

  if (config & 0x01)
    TXSTAbits.SYNC = 1;

  if (config & 0x02)
    {
      TXSTAbits.TX9 = 1;
      RCSTAbits.RX9 = 1;
    }

  if (config & 0x04)
    TXSTAbits.CSRC = 1;

  if (config & 0x08)
    RCSTAbits.CREN = 1;
  else
    RCSTAbits.SREN = 1;

  if (config & 0x10)
    {
      TXSTAbits.BRGH = 1;
#if !__SDCC_NO_SPBRGH
      BAUDCONbits.BRG16 = 1;
    }
  else
    {
      BAUDCONbits.BRG16 = 0;
#endif  /* !__SDCC_NO_SPBRGH */
    }

  /* TX interrupts */

  PIR1bits.TXIF = 0;

  if (config & 0x40)
    PIE1bits.RCIE = 1;
  else
    PIE1bits.RCIE = 0;

  /* RX interrupts */
  PIR1bits.RCIF = 0;

  if (config & 0x80)
    PIE1bits.TXIE = 1;
  else
    PIE1bits.TXIE = 0;

#if !__SDCC_NO_SPBRGH
  SPBRGH = (spbrg >> 8);
#endif  /* !__SDCC_NO_SPBRGH */
  SPBRG = spbrg;

#if (__SDCC_USART_STYLE == 1812200)
  /* Configure RX/TX pins as digital pins. */
  ADCON1bits.PCFG5 = 1;
  ADCON1bits.PCFG6 = 1;

  /* Configure RX/TX pins as inputs. */
  TRISBbits.TRISB1 = 1;
  TRISBbits.TRISB4 = 1;
#elif (__SDCC_USART_STYLE == 1812300)
  /* Configure RX/TX pins as inputs. */
  TRISAbits.TRISA2 = 1;
  TRISAbits.TRISA3 = 1;
#elif (__SDCC_USART_STYLE == 1813502)
  /* Configure RX pin as digital pin. */
  ANSELHbits.ANS11 = 0;

  /* Configure RX/TX pins as inputs. */
  TRISBbits.TRISB5 = 1;
  TRISBbits.TRISB7 = 1;
#elif (__SDCC_USART_STYLE == 1822200)
  /* Configure RX/TX pins. */
  TRISCbits.TRISC6 = 0;
  TRISCbits.TRISC7 = 1;
#elif (__SDCC_USART_STYLE == 1822210) \
   || (__SDCC_USART_STYLE == 1865850)
  /* Configure RX/TX pins. */
  TRISCbits.TRISC6 = 1;
  TRISCbits.TRISC7 = 1;
#elif (__SDCC_USART_STYLE == 1824500)
  /* Configure RX/TX pins. */
  TRISCbits.TRISC6 = 0;
  TRISCbits.TRISC7 = 1;
#elif (__SDCC_USART_STYLE == 1824501) \
   || (__SDCC_USART_STYLE == 1865200)
  /* Configure RX1/TX1 pins. */
  TRISCbits.TRISC6 = 0;
  TRISCbits.TRISC7 = 1;
#else /* other devices */
#error Invalid USART style.
#endif /* other devices */

  TXSTAbits.TXEN = 1;
  RCSTAbits.SPEN = 1;
}
/*-------------------------------------------------------------------------
   ubaud - set baud value

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * Devices implemented:
 *	PIC18F[24][45][28]
 */

#include <pic18fregs.h>
#include <usart.h>

void
usart_baud (sdcc_spbrg_t baudconfig) __wparam
{
#if !__SDCC_NO_SPBRGH
    SPBRGH = (baudconfig >> 8);
#endif  /* !__SDCC_NO_SPBRGH */
    SPBRG = baudconfig;
}
/*-------------------------------------------------------------------------
   usartd - status variable definition

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * Devices implemented:
 *	PIC18F[24][45][28]
 */

#include <pic18fregs.h>
#include <usart.h>

union USART USART_Status;
/*-------------------------------------------------------------------------
   uputc - write a character to USART

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * Devices implemented:
 *	PIC18F[24][45][28]
 */


#include <pic18fregs.h>
#include <usart.h>

extern union USART USART_Status;

void usart_putc(unsigned char dat) __wparam __naked
{
#if 0
  if(TXSTAbits.TX9) {
    TXSTAbits.TX9D = 0;
    if(USART_Status.TX_NINE)TXSTAbits.TX9D = 1;
  }

  TXREG = dat;      // Write the data byte to the USART
#else
  dat;
  __asm
    btfss       _TXSTAbits, 6
    bra         _01_
    
    bcf         _TXSTAbits, 0
    banksel     _USART_Status
    btfsc       _USART_Status, 1, b
    bsf         _TXSTAbits, 0

_01_:
    movwf       _TXREG
    return
  __endasm;
#endif
}
/*-------------------------------------------------------------------------
   ubusy - return USART TX state

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * Devices implemented:
 *	PIC18F[24][45][28]
 */


#include <pic18fregs.h>
#include <usart.h>

unsigned char usart_busy(void) __naked
{
#if 0
  if(!TXSTAbits.TRMT)return 1;
  else return 0;
#else
  __asm
    movlw       0x00
    btfss       _TXSTAbits, 1
    addlw       0x01
    return
  __endasm;
#endif
}
/*-------------------------------------------------------------------------
   uputs - put a string to USART

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * Devices implemented:
 *	PIC18F[24][45][28]
 */


#include <pic18fregs.h>
#include <usart.h>

void usart_puts(char *dat)
{
  do {
    while( usart_busy() );
    usart_putc( *dat );
  } while( *dat++ );
}
/*-------------------------------------------------------------------------
   uclose - shutdown USART module

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * Devices implemented:
 *	PIC18F[24][45][28]
 */


#include <pic18fregs.h>
#include <usart.h>

void usart_close(void)
{
  RCSTA &= 0x4f;
  TXSTAbits.TXEN = 0;
  PIE1 &= 0xcf;
}
/*-------------------------------------------------------------------------
   ugets - read string from USART

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * Devices implemented:
 *	PIC18F[24][45][28]
 */


#include <pic18fregs.h>
#include <usart.h>

void usart_gets(RAM_SCLS char *buffer, unsigned char len)
{
  unsigned char i;
  unsigned char dat;

  for(i=0;i<len;i++)
  {
    while(!usart_drdy());

    dat = usart_getc();
    *buffer = dat;
    buffer++;

    /* read until a \0 is received */
    if(!dat)return;
  }
}
/*-------------------------------------------------------------------------
   udrdy - return 1 is data is received

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * Devices implemented:
 *	PIC18F[24][45][28]
 */

#include <pic18fregs.h>
#include <usart.h>


unsigned char usart_drdy(void) __naked
{
#if 0
  if(PIR1bits.RCIF)return 1;
  else return 0;
#else
  __asm
    movlw       0x00
    btfsc       _PIR1bits, 5
    addlw       0x01
    return
  __endasm;
#endif
}
/*-------------------------------------------------------------------------
   i2cdrdy.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>


unsigned char i2c_drdy(void)
{
  if(SSPSTATbits.BF)return (+1);
  else return (0);
}
/*-------------------------------------------------------------------------
   i2cnack.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>

void i2c_nack(void)
{
  SSPCON2bits.ACKDT = 1;
  SSPCON2bits.ACKEN = 1;
}
/*-------------------------------------------------------------------------
   i2creads.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>


char i2c_readstr(_I2CPARAM_SPEC unsigned char *ptr, unsigned char len)
{
  unsigned char count=0;
  
  while( len-- ) {
    *ptr++ = i2c_readchar();
    
    while(SSPCON2bits.RCEN) {
      if(PIR2bits.BCLIF)return (-1);
      count++;
    
      if(len) {
        I2C_ACK();
        while(SSPCON2bits.ACKEN);
      }
    }
  }
  
  return count;
}
/*-------------------------------------------------------------------------
   i2creadc.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>

unsigned char i2c_readchar(void)
{
  SSPCON2bits.RCEN = 1;
  while( !I2C_DRDY() );
  return ( SSPBUF );
}
/*-------------------------------------------------------------------------
   i2cclose.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>


void i2c_close(void)
{
  SSPCON1 &= 0xdf;
}
/*-------------------------------------------------------------------------
   i2cack.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>


void i2c_ack(void)
{
  SSPCON2bits.ACKDT = 0;
  SSPCON2bits.ACKEN = 1;
}
/*-------------------------------------------------------------------------
   i2cstart.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>

void i2c_start(void)
{
  SSPCON2bits.SEN = 1;
}
/*-------------------------------------------------------------------------
   i2crestart.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>

void i2c_restart(void)
{
  SSPCON2bits.RSEN = 1;
}
/*-------------------------------------------------------------------------
   i2cwritec.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>

char i2c_writechar(unsigned char dat)
{
  SSPCON1bits.WCOL = 0;
  SSPBUF = dat;
  if( SSPCON1bits.WCOL ) {
    return -1;
  } else {
    I2C_IDLE();
    return 0;
  }
}
/*-------------------------------------------------------------------------
   i2cstop.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>

void i2c_stop(void)
{
  SSPCON2bits.PEN = 1;
}
/*-------------------------------------------------------------------------
   i2copen.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>

void i2c_open(unsigned char mode, unsigned char slew, unsigned char addr_brd)
{
  SSPSTAT &= 0x3f;
  SSPCON1 = 0;
  SSPCON2 = 0;
  SSPCON1 |= mode;
  SSPSTAT |= slew;


#if    defined(__SDCC_PIC18F2455)  || defined(__SDCC_PIC18F2550) \
    || defined(__SDCC_PIC18F4455)  || defined(__SDCC_PIC18F4550) \
    || defined(__SDCC_PIC18F66J60) || defined(__SDCC_PIC18F66J65) || defined(__SDCC_PIC18F67J60) \
    || defined(__SDCC_PIC18F86J60) || defined(__SDCC_PIC18F86J65) || defined(__SDCC_PIC18F87J60) \
    || defined(__SDCC_PIC18F96J60) || defined(__SDCC_PIC18F96J65) || defined(__SDCC_PIC18F97J60)

  TRISBbits.TRISB1 = 1;
  TRISBbits.TRISB0 = 1;

#elif  defined(__SDCC_PIC18F24J50) || defined(__SDCC_PIC18F25J50) || defined(__SDCC_PIC18F26J50) \
    || defined(__SDCC_PIC18F44J50) || defined(__SDCC_PIC18F45J50) || defined(__SDCC_PIC18F46J50)

  TRISBbits.TRISB4 = 1;
  TRISBbits.TRISB5 = 1;

#else	/* all other devices */

  TRISCbits.TRISC3 = 1;
  TRISCbits.TRISC4 = 1;

#endif

  SSPADD = addr_brd;

  SSPCON1 |= 0x20;
}
/*-------------------------------------------------------------------------
   i2cidle.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>

void i2c_idle(void)
{
  while((SSPCON2 & 0x1f) | (SSPSTATbits.R_W));
}
/*-------------------------------------------------------------------------
   i2cwrites.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic18fregs.h>
#include <i2c.h>

char i2c_writestr(unsigned char *ptr)
{
  while( *ptr ) {
    if( SSPCON1bits.SSPM3 ) {
      if(i2c_writechar( *ptr )) {
        return (-3);
      }
      I2C_IDLE();
      if( SSPCON2bits.ACKSTAT ) {
        return (-2);
      }
    } else {
      PIR1bits.SSPIF = 0;
      SSPBUF = *ptr;
      SSPCON1bits.CKP = 1;
      while( !PIR1bits.SSPIF );
      
      if((!SSPSTATbits.R_W) && ( !SSPSTATbits.BF )) {
        return (-2);
      }
    }
    
    ptr++;
  }

  return 0;
}
;--------------------------------------------------------------------------
;  modunsigned.s
;
;  Copyright (C) 2009-2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__moduchar
.globl	__moduint

__moduchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __divu8

	ex	de,hl

        ret

__moduint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __divu16

        ex      de,hl

        ret

;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2001, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; Just stubs - not copyrightable

        ;; Stubs that hook the heap in
        .globl  ___sdcc_heap_init

        .area   _GSINIT
        call    ___sdcc_heap_init

        .area   _HEAP
___sdcc_heap::
        ;; For now just allocate 1k of heap.
        .ds     1023

        .area   _HEAP_END
___sdcc_heap_end::
        .ds     1
;--------------------------------------------------------------------------
;  __ltoa.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE
	.ez80

	.globl ___ltoa
	.globl ___ultoa
;
;void __itoa(long value, char *string, unsigned char radix);
;
___ltoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	8(ix) - string
;	10(ix) - radix
;
	ld	de, 4 (ix)
	bit	7, 7 (ix)
	jr	Z, ___ultoa_de
;positive/negative numbers are supported only for radix=10
	ld	a, 10 (ix)
	cp	a, #10
	jr	NZ, ___ultoa_de
;add minus sign to result and inverse value
	ld	hl, #0
	or	a, a
	sbc	hl, de
	ex	de, hl
	ld	hl, #0
	ld	bc, 6 (ix)
	sbc	hl, bc
	ld	6 (ix), hl
	ld	hl, 8 (ix)
	ld	(hl), #0x2D	;minus symbol
	inc	hl
	ld	8 (ix), hl
	jr	___ultoa_dehl
;
;void __uitoa(unsigned int value, char *string, unsigned char radix);
;
___ultoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	8(ix) - string
;	10(ix) - radix
;
	ld	de, 4 (ix)
;
___ultoa_de:
	ld	hl, 8 (ix)
;
___ultoa_dehl:
	ld	a, e
	or	a, d
	or	a, 6 (ix)
	or	a, 7 (ix)
	jr	NZ, 100$
;
	ld	(hl), #0x30
	inc	hl
	jp	190$
100$:
	ld	a, 10 (ix)
	cp	a, #10		;most popular radix
	jr	NZ, 110$
;
;-------- decimal convertion
;this algorithm is 20% faster than generic one
;
	ld	c, l
	ld	b, h
	ld	hl, #-5
	add	hl, sp
	ld	sp, hl
	push	bc
	push	hl
	ld	bc, 6 (ix)
	push	bc
	push	de
	call	___ultobcd
	ld	hl, #6
	add	hl, sp
	ld	sp, hl
	pop	de		;DE - pointer to string
	inc	hl
	inc	hl		;HL - pointer to BCD value
	ld	b, #5		;number of bytes in BCD value
	ld	a, #0x30	;ASCII code of '0'
103$:
	rrd
	ld	(de), a
	inc	de
	rrd
	ld	(de), a
	inc	de
	inc	hl
	djnz	103$
;
;	ld	sp, hl
;skip trailing zeroes
	ld	b, #10		;real decimal number is at most 10 digits
105$:
	dec	de
	ld	a, (de)
	cp	a, #0x30
	jr	NZ, 107$	;break loop if non-zero found
	djnz	105$
107$:
	inc	de		;always point to symbol next to last significant
	ex	de, hl
	jr	190$
;
;---------------------------
;
110$:
	cp	a, #2
	jr	C, 190$		;radix is less than 2
;
	ld	c, a
	dec	c
	and	a, c
	jr	NZ, 150$
;
;-------- radix is power of 2
;
; DE - lower 16 bits of value, HL - pointer to string, C - mask
120$:
	ld	a, e
	ld	b, c
125$:
	srl	7 (ix)
	rr	6 (ix)
	rr	d
	rr	e
	srl	b
	jr	NZ, 125$
;
	and	a, c
	add	a, #0x30
	cp	a, #0x3A ;convert to 0...9A...Z
	jr	C, 130$
	add	a, #7
130$:
	ld	(hl), a
	inc	hl
	ld	a, e
	or	a, d
	or	a, 6 (ix)
	or	a, 7 (ix)
	jr	NZ, 120$
	jr	190$
;
;---------------------------
;
;-------- custom radix (generic algorithm)
;
150$:
	ex	de, hl
	ld	c, e
	ld	b, d
	ld	de, 6 (ix)
160$:
	push	bc
	ld	c, 10 (ix)
	call	___divu32_8
	pop	bc
	add	a, #0x30
	cp	a, #0x3A
	jr	C, 165$
	add	a, #7
165$:
	ld	(bc), a
	inc	bc
	ld	a, l
	or	a, h
	or	a, e
	or	a, d
	jr	NZ, 160$
	ld	l, c
	ld	h, b
;	jr	190$
;
;---------------------------
;
;-------- finish string and reverse order
190$:
	ld	(hl), #0
	ld	de, 8 (ix)
	call	___strreverse_reg
	ld	sp, ix
	pop	ix
	ret
;
;in: DEHL - divident, C - divisor
;out: DEHL - quotient, A - remainder
___divu32_8:
	xor	a, a
	ld	b, #32
100$:
	add	hl, hl
	rl	e
	rl	d
	rla
	jr	c, 110$
	cp	a, c
	jr	c, 120$
110$:
	sub	a, c
	inc	l
120$:
	djnz	100$
	ret

;--------------------------------------------------------------------------
;  memcpy.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memcpy
	.globl ___memcpy

; The Z80 has the ldir instruction, which is perfect for implementing memcpy().
_memcpy:
___memcpy:
	pop	af
	pop	hl	;return value expected to be in HL, so pop dst to HL
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	ex	de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  modmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__modsuchar
.globl	__moduschar

__modsuchar:
	ld      hl,#2+1
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)
	ld      h,#0

	call    __div_signexte

	jp	__get_remainder

__moduschar:
	ld      hl,#2+1
	ld      d, h
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)

	ld      a,l	; Sign extend
	rlca
	sbc     a, a
	ld      h, a

	call	__div16

	jp	__get_remainder

;--------------------------------------------------------------------------
;  strcpy.s
;
;  Copyright (C) 2012, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strcpy

_strcpy:
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
	push	de
	xor	a, a
loop:
	cp	a, (hl)
	ldi
	jr	NZ, loop
	pop	hl
	ret

;--------------------------------------------------------------------------
;  divsigned.s
;
;  Copyright (C) 2000-2010, Michael Hope, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area	_CODE

.globl	__divsint
.globl	__divschar

__divsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jp      __div16

__divschar:
        ld      hl, #2+1
        add     hl, sp

        ld      e, (hl)
        dec     hl
        ld      l, (hl)

__div8::
        ld      a, l            ; Sign extend
        rlca
        sbc     a,a
        ld      h, a
__div_signexte::
        ld      a, e            ; Sign extend
        rlca
        sbc     a,a
        ld      d, a
        ; Fall through to __div16

        ;; signed 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;
        ;; Register used: AF,B,DE,HL
__div16::
        ;; Determine sign of quotient by xor-ing high bytes of dividend
        ;;  and divisor. Quotient is positive if signs are the same, negative
        ;;  if signs are different
        ;; Remainder has same sign as dividend
        ld      a, h            ; Get high byte of dividend
        xor     a, d            ; Xor with high byte of divisor
        rla                     ; Sign of quotient goes into the carry
        ld      a, h            ; Get high byte of dividend
        push    af              ; Save sign of both quotient and reminder

        ; Take absolute value of dividend
        rla
        jr      NC, .chkde      ; Jump if dividend is positive
        sub     a, a            ; Substract dividend from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a

        ; Take absolute value of divisor
.chkde:
        bit     7, d
        jr      Z, .dodiv       ; Jump if divisor is positive
        sub     a, a            ; Subtract divisor from 0
        sub     a, e
        ld      e, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, d
        ld      d, a

        ; Divide absolute values
.dodiv:
        call    __divu16

.fix_quotient:
        ; Negate quotient if it is negative
        pop     af              ; recover sign of quotient
        ret	NC		; Jump if quotient is positive
        ld      b, a
        sub     a, a            ; Subtract quotient from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ld      a, b
	ret

__get_remainder::
        ; Negate remainder if it is negative and move it into hl
        rla
	ex	de, hl
        ret     NC              ; Return if remainder is positive
        sub     a, a            ; Subtract remainder from 0
        sub     a, l
        ld      l, a
        sbc     a, a             ; Propagate remainder (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ret

;--------------------------------------------------------------------------
;  divunsigned.s
;
;  Copyright (C) 2000-2012, Michael Hope, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        ;; Originally from GBDK by Pascal Felber.

.area   _CODE

.globl	__divuint
.globl	__divuchar

__divuint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jr      __divu16

__divuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ;; Fall through
__divu8::
        ld      h,#0x00
        ld      d,h
        ; Fall through to __divu16

        ;; unsigned 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;   carry = 0
        ;;   If divisor is 0, quotient is set to "infinity", i.e HL = 0xFFFF.
        ;;
        ;; Register used: AF,B,DE,HL
__divu16::
        ;; Two algorithms: one assumes divisor <2^7, the second
        ;; assumes divisor >=2^7; choose the applicable one.
        ld      a,e
        and     a,#0x80
        or      a,d
        jr      NZ,.morethan7bits
        ;; Both algorithms "rotate" 24 bits (H,L,A) but roles change.

        ;; unsigned 16/7-bit division
.atmost7bits:
        ld      b,#16           ; bits in dividend and possible quotient
        ;; Carry cleared by AND/OR, this "0" bit will pass trough HL.[*]
        adc     hl,hl
.dvloop7:
        ;; HL holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry.
        ;; A holds remainder.
        rla

        ;; If remainder is >= divisor, next bit of quotient is 1.  We try
        ;;  to compute the difference.
        sub     a,e
        jr      NC,.nodrop7     ; Jump if remainder is >= dividend
        add     a,e             ; Otherwise, restore remainder
        ;; The add above sets the carry, because sbc a,e did set it.
.nodrop7:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        adc     hl,hl
        djnz    .dvloop7
        ;; Carry now contains the same value it contained before
        ;; entering .dvloop7[*]: "0" = valid result.
        ld      e,a             ; DE = remainder, HL = quotient
        ret

.morethan7bits:
        ld      b,#9            ; at most 9 bits in quotient.
        ld      a,l             ; precompute the first 7 shifts, by
        ld      l,h             ;  doing 8
        ld      h,#0
        rr      l               ;  undoing 1
.dvloop:
        ;; Shift next bit of quotient into bit 0 of dividend
        ;; Shift next MSB of dividend into LSB of remainder
        ;; A holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry
        ;; HL holds remainder
        adc     hl,hl           ; HL < 2^(7+9), no carry, ever.

        ;; If remainder is >= divisor, next bit of quotient is 1. We try
        ;;  to compute the difference.
        sbc     hl,de
        jr      NC,.nodrop      ; Jump if remainder is >= dividend
        add     hl,de           ; Otherwise, restore remainder
	;; The add above sets the carry, because sbc hl,de did set it.
.nodrop:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        rla
        djnz    .dvloop
        ;; Take care of the ninth quotient bit! after the loop B=0.
        rl      b               ; BA = quotient
        ;; Carry now contains "0" = valid result.
        ld      d,b
        ld      e,a             ; DE = quotient, HL = remainder
        ex      de,hl           ; HL = quotient, DE = remainder
        ret

;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _atomic_flag_test_and_set

_atomic_flag_test_and_set:
	pop	de
	pop	hl
	push	hl
	push	de
	xor a, a
	srl	(hl)
	ccf
	rla
	ld	l, a
	ret

;--------------------------------------------------------------------------
;  __strreverse.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___strreverse
	.globl ___strreverse_reg
;
;void __reverse(char *beg, char *end);
;
___strreverse::
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
;
;in: HL - pointer to end of string (null symbol), DE - pointer to start of string
;
___strreverse_reg::
	jr	110$
100$:
	add	hl, de
	ld	a, (de)
	ld	c, (hl)
	ld	(hl), a
	ld	a, c
	ld	(de), a
	inc	de
110$:
	dec	hl
	or	a, a
	sbc	hl, de
	jr	NC, 100$
	ret
;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (c) 2017, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

; unsigned char x unsigned char multiplication is done by code generation.

.globl	__mulsuchar
.globl	__muluschar
.globl	__mulschar

; operands have different sign

__mulsuchar:
        ld      hl,#2+1
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        jr      signexte

__muluschar:
        ld      hl,#2
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      c,(hl)
        jr      signexte

__mulschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)

        ;; Need to sign extend before going in.
        ld      a,c
        rla
        sbc     a,a
        ld      b,a
signexte:
        ld      a,e
        rla
        sbc     a,a
        ld      d,a

        jp      __mul16

;--------------------------------------------------------------------------
;  crtenter.s
;
;  Copyright (C) 2015, Alan Cox, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_enter_ix

; Factor out some start of function code to reduce code size

___sdcc_enter_ix:
	pop	hl	; return address
	push	ix	; save frame pointer
	ld	ix, #0
	add	ix, sp	; set ix to the stack frame
	jp	(hl)	; and return

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_iy

; The Z80 has the jp (iy) instruction, which is perfect for implementing function pointers.

___sdcc_call_iy:
	jp	(iy)

;--------------------------------------------------------------------------
;  memmove.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memmove

; The Z80 has the ldir and lddr instructions, which are perfect for implementing memmove().

_memmove:
	pop	af
	pop	hl
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	sbc	hl, de		; or above cleared carry.
	add	hl, de		; same carry as the line before
	jr	C, memmove_up
memmove_down:
	dec	bc
	add	hl, bc
	ex      de, hl
	add	hl, bc
	inc	bc
	lddr
	pop	hl
	ret
memmove_up:
	ex      de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  setjmp.s
;
;  Copyright (C) 2011-2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------
	.ez80

	.area   _CODE

	.globl ___setjmp

___setjmp:
	pop	hl
	pop	iy
	push	af
	push	hl

	; Store return address.
	ld	0(iy), hl

	; Store stack pointer.
	xor	a, a
	ld	l, a
	ld	h, a
	add	hl, sp
	ld	2(iy), hl

	; Store frame pointer.
	push	ix
	pop	hl
	ld	4(iy), hl

	; Return 0.
	ld	l, a
	ld	h, a
	ret

.globl _longjmp

_longjmp:
	pop	af
	pop	iy
	pop	de

	; Ensure that return value is non-zero.
	ld	a, e
	or	a, d
	jr	NZ, jump
	inc	de
jump:

	; Restore frame pointer.
	ld	hl, 4(iy)
	push	hl
	pop	ix

	; Adjust stack pointer.
	ld	hl, 2(iy)
	ld	sp, hl
	pop	hl

	; Move return value into hl.
	ex	de, hl

	; Jump.
	ld	bc, 0(iy)
	push	bc
	ret
;--------------------------------------------------------------------------
;  __uitobcd.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE
	.ez80

	.globl ___uitobcd
;
; void __uitobcd (unsigned int v, unsigned char bcd[3])
; __uitobcd converts v to BCD representation to the bcd.
; bcd[] will contain BCD value.
;
___uitobcd:
	push	ix
	ld	ix, #0
	add	ix, sp
;
	ld	bc, #0x1000
	ld	d, c
	ld	e, c
	ld	hl, 4 (ix)
;
;--- begin speed optimization
;
	ld	a, h
	or	a, a
	jr	NZ, 100$
;
	ld	h, l
	srl	b
;
;--- end speed optimization
;
; HL - binary value
; CDE - future BCD value
; B - bits count (16)
100$:
	add	hl, hl
	ld	a, e
	adc	a, a
	daa
	ld	e, a
	ld	a, d
	adc	a, a
	daa
	ld	d, a
	ld	a, c
	adc	a, a
	daa
	ld	c, a
	djnz	100$
;
	ld	hl, 6 (ix)
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	ld	(hl), c
;
	pop	ix
	ret
;--------------------------------------------------------------------------
;  abs.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _abs

; 12B; 86T for nonnegative arguments, 78T for negative.
_abs:
	pop	hl
	pop	de
	push	de
	push	hl
	xor	a, a
	ld	l, a
	ld	h, a
	sbc	hl, de
	ret	P
	ex	de, hl
	ret

; 14B; 59T for nonegative arguments, 94T for negative:
;_abs:
;	pop	de
;	pop	hl
;	push	hl
;	push	de
;	bit	7, h
;	ret	Z
;	xor	a, a
;	ld	e, a
;	ld	d, a
;	ex	de, hl
;	sbc	hl, de
;	ret

;--------------------------------------------------------------------------
;  strlen.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _strlen

; The Z80 has the cpir instruction, which is perfect for implementing strlen().

_strlen:
	pop	bc
	pop	hl
	push	hl
	push	bc
	xor	a, a
	ld	b, a
	ld	c, a
	cpir
	ld	hl, #-1
	sbc	hl, bc	; C flag still cleared from xor above.
	ret

;--------------------------------------------------------------------------
;  __ultobcd.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE
	.ez80

	.globl ___ultobcd
;
; void __ultobcd (unsigned long v, unsigned char bcd[5])
; __ultobcd converts v to BCD representation to the bcd.
; bcd[] will contain BCD value.
;
___ultobcd:
	push	ix
	ld	ix, #0
	add	ix, sp
	ld	bc, #0x2000
;
;--- begin speed optimization
;
	ld	hl, 4 (ix)
	ld	de, 6 (ix)
	ld	a, e
	or	a, d
	jr	NZ, 101$
;high 2 bytes are zero
	ld	b, #0x10
	ex	de, hl
101$:
	ld	a, d
	or	a, a
	jr	NZ, 102$
;high byte is zero
	ld	d, e
	ld	e, h
	ld	h, l
	ld	a, #-8
	add	a, b
	ld	b, a
102$:
	ld	4 (ix), hl
	ld	6 (ix), de
;
;--- end speed optimization
;
	ld	hl, #0x0000
	ld	e, l
	ld	d, h
; (ix+0)..(ix+3) - binary value
; CDEHL - future BCD value
; B - bits count (32)
103$:
	sla	4 (ix)
	rl	5 (ix)
	rl	6 (ix)
	rl	7 (ix)
	ld	a, l
	adc	a, a
	daa
	ld	l, a
	ld	a, h
	adc	a, a
	daa
	ld	h, a
	ld	a, e
	adc	a, a
	daa
	ld	e, a
	ld	a, d
	adc	a, a
	daa
	ld	d, a
	ld	a, c
	adc	a, a
	daa
	ld	c, a
	djnz	103$
;
	ld	b, l
	ld	a, h
	ld	hl, 8 (ix)
	ld	(hl), b
	inc	hl
	ld	(hl), a
	inc	hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	ld	(hl), c
;
	pop	ix
	ret
;--------------------------------------------------------------------------
;  divmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__divsuchar
.globl	__divuschar

__divsuchar:
	ld	hl, #2+1
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)
	ld	h, #0

	jp	__div_signexte

__divuschar:
	ld	hl, #2+1
	ld	d, h
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)

	ld 	a, l	; Sign extend
	rlca
	sbc	a, a
	ld	h, a

	jp	__div16

;--------------------------------------------------------------------------
;  __itoa.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE
	.ez80

	.globl ___itoa
	.globl ___uitoa
;
;void __itoa(int value, char *string, unsigned char radix);
;
___itoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	6(ix) - string
;	8(ix) - radix
;
	ld	de, 4 (ix)
	bit	7, d
	jr	Z, ___uitoa_de
;positive/negative numbers are supported only for radix=10
	ld	a, 8 (ix)
	cp	a, #10
	jr	NZ, ___uitoa_de
;add minus sign to result and inverse value
	ld	hl, #0
	or	a, a
	sbc	hl, de
	ex	de, hl
	ld	hl, 6 (ix)
	ld	(hl), #0x2D	;minus symbol
	inc	hl
	ld	6 (ix), hl
	jr	___uitoa_dehl
;
;void __uitoa(unsigned int value, char *string, unsigned char radix);
;
___uitoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	6(ix) - string
;	8(ix) - radix
;
	ld	de, 4 (ix)
;
___uitoa_de:
	ld	hl, 6 (ix)
;
___uitoa_dehl:
	ld	a, e
	or	a, d
	jr	NZ, 100$
;
	ld	(hl), #0x30
	inc	hl
	jp	190$
100$:
	ld	a, 8 (ix)
	cp	a, #10		;most popular radix
	jr	NZ, 110$
;
;-------- decimal convertion
; this algorithm up to 2 times faster than generic
;
	ld	c, l
	ld	b, h
	ld	hl, #-4
	add	hl, sp
	ld	sp, hl
	push	bc
	push	hl
	push	de
	call	___uitobcd
	ld	hl, #4
	add	hl, sp
	ld	sp, hl
	pop	de		;DE - pointer to string
	inc	hl
	inc	hl		;HL - pointer to BCD value
	ld	b, #3		;number of bytes in BCD value
	ld	a, #0x30	;ASCII code of '0'
103$:
	rrd
	ld	(de), a
	inc	de
	rrd
	ld	(de), a
	inc	de
	inc	hl
	djnz	103$
;
;	pop	af
;	pop	af
;skip trailing zeroes
	ld	b, #5		;real BCD number is at most 5 digits
	dec	de		;so always skip last zero
105$:
	dec	de
	ld	a, (de)
	cp	a, #0x30
	jr	NZ, 107$	;break loop if non-zero found
	djnz	105$
107$:
	inc	de		;always point to symbol next to last significant
	ex	de, hl
	jr	190$
;
;---------------------------
;
110$:
	cp	a, #2
	jr	C, 190$		;radix is less than 2
;
	ld	c, a
	dec	c
	and	a, c
	jr	NZ, 150$
;
;-------- radix is power of 2
;
; DE - value, HL - pointer to string, C - mask
120$:
	ld	a, e
	ld	b, c
125$:
	srl	d
	rr	e
	srl	b
	jr	NZ, 125$
;
	and	a, c
	add	a, #0x30
	cp	a, #0x3A ;convert to 0...9A...Z
	jr	C, 130$
	add	a, #7
130$:
	ld	(hl), a
	inc	hl
	ld	a, e
	or	a, d
	jr	NZ, 120$
	jr	190$
;
;---------------------------
;
;-------- custom radix (generic algorithm)
;
150$:
	ex	de, hl
160$:
	ld	c, 8 (ix)
	call	___divu16_8
	add	a, #0x30
	cp	a, #0x3A
	jr	C, 165$
	add	a, #7
165$:
	ld	(de), a
	inc	de
	ld	a, l
	or	a, h
	jr	NZ, 160$
	ex	de, hl
;	jr	190$
;
;---------------------------
;
;-------- finish string and reverse order
190$:
	ld	(hl), #0
	ld	de, 6 (ix)
	call	___strreverse_reg
	ld	sp, ix
	pop	ix
	ret
;
;
;in: HL - divident, C - divisor
;out: HL - quotient, A - remainder
___divu16_8:
	xor	a, a
	ld	b, #16
100$:
	add	hl, hl
	rla
	jr	c, 110$
	cp	a, c
	jr	c, 120$
110$:
	sub	a, c
	inc	l
120$:
	djnz	100$
	ret

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_hl

; The Z80 has the jp (hl) instruction, which is perfect for implementing function pointers.

___sdcc_call_hl:
	jp	(hl)

;--------------------------------------------------------------------------
;  __sdcc_bcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; This file contains generic trampolines for banked function calls.
; They are not complete. Programmer must provide set_bank and get_bank
; routines. Or rewrite whole code completely.
;
	.area   _CODE

	.globl ___sdcc_bcall
	.globl ___sdcc_bcall_abc
	.globl ___sdcc_bcall_ehl
;
; trampoline to call banked functions
; used when legacy banking is enabled only
; Usage:
;   call ___sdcc_bcall
;   .dw  <function>
;   .dw  <function_bank>
;
___sdcc_bcall::
	ex	(sp), hl
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	ld	a, (hl)
	inc	hl
	inc	hl
	ex	(sp), hl
;
; trampoline to call banked functions with __z88dk_fastcall calling convention
; Usage:
;  ld   a, #<function_bank>
;  ld   bc, #<function>
;  call ___sdcc_bcall_abc
;
___sdcc_bcall_abc::
	push	hl
	ld	l, a
	call	get_bank	;must return A as current bank number, other registers expected to be unchanged
	ld	h, a
	ld	a, l
	ex	(sp), hl
	inc	sp
	call	___sdcc_bjump_abc
	dec	sp
	pop	af
	jp	set_bank
;
___sdcc_bjump_abc:
	call	set_bank	;set current bank to A, other registers expected to be unchanged
	push	bc
	ret
;
; default trampoline to call banked functions
; Usage:
;  ld   e, #<function_bank>
;  ld   hl, #<function>
;  call ___sdcc_bcall_ehl
;
___sdcc_bcall_ehl::
	call	get_bank
	push	af
	inc	sp
	call	___sdcc_bjump_ehl
	dec	sp
	pop	af
	jp	set_bank
;
___sdcc_bjump_ehl:
	ld	a, e
	call	set_bank
	jp	(hl)
;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (C) 2017, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.hd64
.area   _CODE

; 16 x 16 -> 16 multiplication.

.globl	__mulint

__mulint:
        pop     af
        pop     bc
        pop     de
        push    de
        push    bc
        push    af

	;; 16-bit multiplication
	;;
	;; Entry conditions
	;; bc = multiplicand
	;; de = multiplier
	;;
	;; Exit conditions
	;; hl = less significant word of product
	;;
	;; Register used: AF,BC,DE,HL

__mul16::

	; Swap lower bytes while also copying them into hl
	ld	l, c
	ld	h, e
	ld	e, l
	ld	c, h

	mlt	bc
	mlt	de
	mlt	hl

	ld	a, c
	add	a, e
	add	a, h
	ld	h, a

        ret

;--------------------------------------------------------------------------
;  crt0.s - Generic crt0.s for a Z80
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.module crt0
	.globl	_main

	.area	_HEADER (ABS)
	;; Reset vector
	.org 	0
	jp	init

	.org	0x08
	ei
	reti
	.org	0x10
	ei
	reti
	.org	0x18
	ei
	reti
	.org	0x20
	ei
	reti
	.org	0x28
	ei
	reti
	.org	0x30
	ei
	reti
	.org	0x38
	ei
	reti

	.org	0x100
init:
	;; Set stack pointer directly above top of memory.
	ld	sp,#0x0000

        ;; Initialise global variables
        call    gsinit
	call	_main
	jp	_exit

	;; Ordering of segments for the linker.
	.area	_HOME
	.area	_CODE
	.area	_INITIALIZER
	.area   _GSINIT
	.area   _GSFINAL

	.area	_DATA
	.area	_INITIALIZED
	.area	_BSEG
	.area   _BSS
	.area   _HEAP

	.area   _CODE
__clock::
	ld	a,#2
	rst     0x08
	ret

_exit::
	;; Exit - special code to the emulator
	ld	a,#0
	rst     0x08
1$:
	halt
	jr	1$

	.area   _GSINIT
gsinit::
	ld	bc, #l__INITIALIZER
	ld	a, b
	or	a, c
	jr	Z, gsinit_next
	ld	de, #s__INITIALIZED
	ld	hl, #s__INITIALIZER
	ldir
gsinit_next:

	.area   _GSFINAL
	ret

;--------------------------------------------------------------------------
;  modsigned.s
;
;  Copyright (C) 2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__modschar
.globl	__modsint

__modschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __div8

        jp	__get_remainder

__modsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __div16

        jp	__get_remainder

sdcc/device/lib/ez80-z80
-------------------

eZ80 (z80 mode) specific routines.

Notes:
* Cost of ld r,(ix+n):	4
* Cost of ld rr,(ix+n):	5
* Cost of ld r,(hl); inc hl: 2+1 = 3 and you don't have to pop ix
* Cost of ld rr,(hl); inc hl; inc hl: 4+1+1 = 6
;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2001, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; Just stubs - not copyrightable

        ;; Stubs that hook the heap in
        .globl  ___sdcc_heap_init

        .area   _GSINIT
        call    ___sdcc_heap_init

        .area   _HEAP
___sdcc_heap::
        ;; For now just allocate 1k of heap.
        .ds     1023

        .area   _HEAP_END
___sdcc_heap_end::
        .ds     1
;--------------------------------------------------------------------------
;  memcpy.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl	_memcpy
	.globl	___memcpy

_memcpy::
___memcpy::
	lda	hl, 7(sp)
	ld	a, (hl-)
	ld	d, a
	ld	a, (hl-)
	ld	e, a
	or	a, d
	jr	Z, 190$
	push	bc
	ld	a, (hl-)
	ld	b, a
	ld	a, (hl-)
	ld	c, a
	ld	a, (hl-)
	ld	l, (hl)
	ld	h, a
	inc	d
	inc	e
	jr	110$
100$:
	ld	a, (bc)
	inc	bc
	ld	(hl+), a
110$:
	dec	e
	jr	nz, 100$
	dec	d
	jr	nz, 100$
	pop	bc
190$:
	lda	hl, 2(sp)
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	ret
;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _atomic_flag_test_and_set

_atomic_flag_test_and_set:
	pop	de
	pop	hl
	push	hl
	push	de
	xor a, a
	srl	(hl)
	ccf
	rla
	ld	e, a
	ret

;--------------------------------------------------------------------------
;  setjmp.s
;
;  Copyright (C) 2011-2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___setjmp

___setjmp:
	pop	bc
	pop	de
	push	de
	push	bc

	; Store stack pointer.
	ldhl	sp, #0
	push	de
	push	hl
	pop	de
	pop	hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl

	; Store return address.
	ld	(hl), c
	inc	hl
	ld	(hl), b

	; Return 0.
	xor	a, a
	ld	e, a
	ld	d, a
	ret

.globl _longjmp

_longjmp:
	pop	af
	pop	hl
	pop	de

	; Ensure that return value is non-zero.
	ld	a, e
	or	a, d
	jr	NZ, 0001$
	inc	de
0001$:

	; Get stack pointer.
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl

	; Adjust stack pointer.
	push	hl
	push	bc
	pop	hl
	pop	bc
	ld	sp, hl
	push	bc
	pop	hl

	; Get return address.
	ld	c, (hl)
	inc	hl
	ld	b, (hl)

	; Set return address.
	pop	af
	push	bc

	; Return value is in de.

	; Jump.
	ret

;--------------------------------------------------------------------------
;  abs.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _abs

_abs::
	pop	hl
	pop	de
	push	de
	bit	7, d
	jr	Z, 10$
	ld	a, e
	cpl
	ld	e, a
	ld	a, d
	cpl
	ld	d, a
	inc	de
10$:
	jp	(hl)
;--------------------------------------------------------------------------
;  strlen.s
;
;  Copyright (C) 2020, Tony Pavlov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area	_CODE

	.globl	_strlen

_strlen::
	ldhl	sp, #2
	ld	a, (hl+)
	ld	h, (hl)
	ld	l, a
.strlen::
	ld	de, #0
1$:	ld	a, (hl+)
	or	a
	ret	Z
	inc	de
	jr      1$
;--------------------------------------------------------------------------
;  __initrleblock.s
;
;  Copyright (C) 2001, Michael Hope
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	;; Special RLE decoder used for initing global data
	;; input: DE - destination address
__initrleblock::
	;; Pop the return address
	pop	hl
1$:
	;; Fetch the run
	ld	c, (hl)
	inc	hl
	;; Negative means a run
	bit	7, c
	jr	Z, 2$
	;; Expanding a run
	ld	a, (hl+)
3$:
	ld	(de), a
	inc	de
	inc	c
	jr	NZ, 3$
	jr	1$
2$:
	;; Zero means end of a block
	inc	c
	dec	c
	jr	Z, 4$
	;; Expanding a block
5$:
	ld	a, (hl+)
	ld	(de), a
	inc	de
	dec	c
	jr	NZ, 5$
	jr	1$
4$:
	;; Return back
	jp	(hl)
;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_hl

; The Z80 has the jp (hl) instruction, which is perfect for implementing function pointers.

___sdcc_call_hl:
	jp	(hl)

;--------------------------------------------------------------------------
;  div.s
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        ;; Originally from GBDK by Pascal Felber.
        .area   _CODE

.globl	__divsuchar
.globl	__modsuchar
.globl	__divuschar
.globl	__moduschar
.globl	__divschar
.globl	__modschar
.globl	__divsint
.globl	__modsint
.globl	__divuchar
.globl	__moduchar
.globl	__divuint
.globl	__moduint

__divsuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        ld      b,#0

        call      signexte

	ld	e,c
	ld	d,b

	ret

__modsuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        ld      b,#0

        jp    signexte

__divuschar:
        ld      hl,#2+1
        ld      d, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)

        ld      a,c             ; Sign extend
        rlca
        sbc     a
        ld      b,a

        call      .div16

	ld	e,c
	ld	d,b

	ret

__moduschar:
        ld      hl,#2+1
        ld      d, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)

        ld      a,c             ; Sign extend
        rlca
        sbc     a
        ld      b,a

        call    .div16

        ret

__divschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ld      c,l

        call    .div8

        ld      e,c
        ld      d,b

        ret

__modschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ld      c,l

        call    .div8

        ;; Already in DE

        ret

__divsint:
        ld      hl,#2+3
        add     hl,sp

        ld      d,(hl)
        dec     hl
        ld      e,(hl)
        dec     hl
        ld      a,(hl)
        dec     hl
        ld      l,(hl)
        ld      h,a

        ld      b,h
        ld      c,l

        call    .div16

        ld      e,c
        ld      d,b

        ret

__modsint:
        ld      hl,#2+3
        add     hl,sp

        ld      d,(hl)
        dec     hl
        ld      e,(hl)
        dec     hl
        ld      a,(hl)
        dec     hl
        ld      l,(hl)
        ld      h,a

        ld      b,h
        ld      c,l

        call    .div16

        ;; Already in DE

        ret

        ;; Unsigned
__divuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ld      c,l
        call    .divu8

        ld      e,c
        ld      d,b

        ret

__moduchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ld      c,l
        call    .divu8

        ;; Already in DE

        ret

__divuint:
        ld      hl,#2+3
        add     hl,sp

        ld      d,(hl)
        dec     hl
        ld      e,(hl)
        dec     hl
        ld      a,(hl)
        dec     hl
        ld      l,(hl)
        ld      h,a

        ld      b,h
        ld      c,l
        call    .divu16

        ld      e,c
        ld      d,b

        ret

__moduint:
        ld      hl,#2+3
        add     hl,sp

        ld      d,(hl)
        dec     hl
        ld      e,(hl)
        dec     hl
        ld      a,(hl)
        dec     hl
        ld      l,(hl)
        ld      h,a

        ld      b,h
        ld      c,l

        call    .divu16

        ;; Already in DE

        ret

.div8::
.mod8::
        ld      a,c             ; Sign extend
        rlca
        sbc     a
        ld      b,a
signexte:
        ld      a,e             ; Sign extend
        rlca
        sbc     a
        ld      d,a

        ; Fall through to .div16

        ;; 16-bit division
        ;;
        ;; Entry conditions
        ;;   BC = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   BC = quotient
        ;;   DE = remainder
        ;;   If divisor is non-zero, carry=0
        ;;   If divisor is 0, carry=1 and both quotient and remainder are 0
        ;;
        ;; Register used: AF,BC,DE,HL
.div16::
.mod16::
        ;; Determine sign of quotient by xor-ing high bytes of dividend
        ;;  and divisor. Quotient is positive if signs are the same, negative
        ;;  if signs are different
        ;; Remainder has same sign as dividend
        ld      a,b             ; Get high byte of dividend
        push    af              ; Save as sign of remainder
        xor     d               ; Xor with high byte of divisor
        push    af              ; Save sign of quotient

        ;; Take absolute value of divisor
        bit     7,d
        jr      Z,.chkde        ; Jump if divisor is positive
        sub     a               ; Substract divisor from 0
        sub     e
        ld      e,a
        sbc     a               ; Propagate borrow (A=0xFF if borrow)
        sub     d
        ld      d,a
        ;; Take absolute value of dividend
.chkde:
        bit     7,b
        jr      Z,.dodiv        ; Jump if dividend is positive
        sub     a               ; Substract dividend from 0
        sub     c
        ld      c,a
        sbc     a               ; Propagate borrow (A=0xFF if borrow)
        sub     b
        ld      b,a
        ;; Divide absolute values
.dodiv:
        call    .divu16
        jr      C,.exit         ; Exit if divide by zero
        ;; Negate quotient if it is negative
        pop     af              ; recover sign of quotient
        and     #0x80
        jr      Z,.dorem        ; Jump if quotient is positive
        sub     a               ; Substract quotient from 0
        sub     c
        ld      c,a
        sbc     a               ; Propagate borrow (A=0xFF if borrow)
        sub     b
        ld      b,a
.dorem:
        ;; Negate remainder if it is negative
        pop     af              ; recover sign of remainder
        and     #0x80
        ret     Z               ; Return if remainder is positive
        sub     a               ; Substract remainder from 0
        sub     e
        ld      e,a
        sbc     a               ; Propagate remainder (A=0xFF if borrow)
        sub     d
        ld      d,a
        ret
.exit:
        pop     af
        pop     af
        ret

.divu8::
.modu8::
        ld      b,#0x00
        ld      d,b
        ; Fall through to divu16

.divu16::
.modu16::
        ;; Check for division by zero
        ld      a,e
        or      d
        jr      NZ,.divide      ; Branch if divisor is non-zero
        ld      bc,#0x00        ; Divide by zero error
        ld      d,b
        ld      e,c
        scf                     ; Set carry, invalid result
        ret
.divide:
        ld      l,c             ; L = low byte of dividend/quotient
        ld      h,b             ; H = high byte of dividend/quotient
        ld      bc,#0x00        ; BC = remainder
        or      a               ; Clear carry to start
        ld      a,#16           ; 16 bits in dividend
.dvloop:
        ;; Shift next bit of quotient into bit 0 of dividend
        ;; Shift next MSB of dividend into LSB of remainder
        ;; BC holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry
        ;; HL holds remainder
        ;; Do a 32-bit left shift, shifting carry to L, L to H,
        ;;  H to C, C to B
        push    af              ; save number of bits remaining
        rl      l               ; Carry (next bit of quotient) to bit 0
        rl      h               ; Shift remaining bytes
        rl      c
        rl      b               ; Clears carry since BC was 0
        ;; If remainder is >= divisor, next bit of quotient is 1. This
        ;;  bit goes to carry
        push    bc              ; Save current remainder
        ld      a,c             ; Substract divisor from remainder
        sbc     e
        ld      c,a
        ld      a,b
        sbc     d
        ld      b,a
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        jr      C,.drop         ; Jump if remainder is >= dividend
        pop     bc              ; Otherwise, restore remainder
        pop     af              ; recover # bits remaining, carry flag destroyed
        dec     a
        or      a               ; restore (clear) the carry flag
        jr      NZ,.dvloop
        jr      .nodrop
.drop:
        inc     sp
        inc     sp
        pop     af              ; recover # bits remaining, carry flag destroyed
        dec     a
        scf                     ; restore (set) the carry flag
        jr      NZ,.dvloop
        jr      .nodrop
.nodrop:
        ;; Shift last carry bit into quotient
        ld      d,b             ; DE = remainder
        ld      e,c
        rl      l               ; Carry to L
        ld      c,l             ; C = low byte of quotient
        rl      h
        ld      b,h             ; B = high byte of quotient
        or      a               ; Clear carry, valid result
        ret

;--------------------------------------------------------------------------
;  mul.s
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        ;; Originally from GBDK by Pascal Felber.

        .area   _CODE

.globl	__mulsuchar
.globl	__muluschar
.globl	__mulschar
.globl	__muluchar
.globl	__mulint

; operands have different sign

__mulsuchar:
        ld      hl,#2+1
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        jr      signexte

__muluschar:
        ld      hl,#2
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      c,(hl)
        jr      signexte

__mulschar:
        ld      hl,#2
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      l,(hl)

        ;; Need to sign extend before going in.
        ld      c,l

        ld      a,l
        rla
        sbc     a,a
        ld      b,a
signexte:
        ld      a,e
        rla
        sbc     a,a
        ld      d,a

        jp      .mul16

__muluchar:
        ld      hl,#2
        add     hl,sp

        ld      e,(hl)

        inc     hl
        ld      c,(hl)

        ;; Clear the top
        xor     a
        ld      d,a
        ld      b,a

        jp      .mul16

__mulint:
        ld      hl,#2
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        inc     hl
        ld      a,(hl)
        inc     hl
        ld      h,(hl)
        ld      l,a

        ;; Parameters:
        ;;      HL, DE (left, right irrelivent)
        ld      b,h
        ld      c,l

        ;; 16-bit multiplication
        ;;
        ;; Entry conditions
        ;;   BC = multiplicand
        ;;   DE = multiplier
        ;;
        ;; Exit conditions
        ;;   DE = less significant word of product
        ;;
        ;; Register used: AF,BC,DE,HL
.mul16:
        ld      hl,#0
        ld      a,b
        ; ld c,c
        ld      b,#16

        ;; Optimise for the case when this side has 8 bits of data or
        ;; less.  This is often the case with support address calls.
        or      a
        jp      NZ,1$

        ld      b,#8
        ld      a,c
1$:
        ;; Taken from z88dk, which originally borrowed from the
        ;; Spectrum rom.
        add     hl,hl
        rl      c
        rla                     ;DLE 27/11/98
        jp      NC,2$
        add     hl,de
2$:
        dec     b
        jr      NZ,1$

        ;; Return in DE
        ld      e,l
        ld      d,h

        ret

;--------------------------------------------------------------------------
;  crt0.s -Generic crt0.s for a GBZ80.
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .globl  _main

        .area   _HEADER (ABS)
        ;; Reset vector
        .org    0
        jp      init

        .org    0x08
        reti
        .org    0x10
        reti
        .org    0x18
        reti
        .org    0x20
        reti
        .org    0x28
        reti
        .org    0x30
        reti
        .org    0x38
        reti

        .org    0x100
        jp      0x150

        .org    0x150
init:
        di
        ;; Set stack pointer directly above top of memory.
        ld      sp,#0xe000

        ;; Setup global data
        call    gsinit

        ;; Use _main instead of main to bypass sdcc's intelligence
        call    _main
        jp      _exit

        ;; Ordering of segments for the linker.
        .area   _HOME
        .area   _CODE
        .area   _GSINIT
        .area   _GSFINAL

        .area   _DATA
        .area   _BSS
        .area   _HEAP

        .area   _CODE
__clock::
        ld      a,#2
        rst     0x08
        ret

_exit::
        ;; Exit - special code to the emulator
        ld      a,#0
        rst     0x08
1$:
        halt
        jr      1$

        .area   _GSINIT
gsinit::

        .area   _GSFINAL
        ret
sdcc/device/lib/z80
-------------------

Z80 specific routines.
;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2014, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl ___sdcc_heap_init
	.globl ___sdcc_heap
	.globl ___sdcc_heap_end

	.area GSINIT
	call ___sdcc_heap_init

	.area DATA
	; For now just allocate 64 bytes for the heap.
___sdcc_heap::
	.ds 63
___sdcc_heap_end::
	.ds 1 
;--------------------------------------------------------------------------
;  __gptrget.s - read from pointer
;
;  Copyright (c) 2019, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.module __gptrget
.area CODE

__gptrget::
	sub	a, #0x80
	t1sn	f, c
	goto	code

	; Pointer to RAM
	idxm	a, p
	ret

	; Pointer to ROM
code:
	; Put pointer on stack
	xch	a, p
	push	af	; Put lower byte of pointer on stack.
	mov	a, sp
	add	a, #-1
	xch	a, p
	idxm	p, a	; Put upper byte of pointer on stack.

	; Jump to it. ret there will return from the call to __gprtget
	ret

;--------------------------------------------------------------------------
;  __gptrget.s - read from pointer
;
;  Copyright (c) 2019, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.module __gptrget2
.area CODE

__gptrget2::
	sub	a, #0x80
	t1sn	f, c
	goto	code

	; Pointer to RAM
	idxm	a, p
	push	af
	inc	p
	idxm	a, p
	mov	p, a
	pop	af
	ret

	; Pointer to ROM
code:
	xch	a, p
	push	af	; Put lower byte of pointer to first byte of value on stack.
	call	code2	; Put return value for the ret at second byte of value on stack.

	mov	p, a
	; Jump to lower byte. ret there will return from the call to __gptrget2
	ret

code2:
	add	a, #1
	push	af	; Put lower byte of pointer to second byte of value on stack.
	mov	a, sp
	add	a, #-5
	xch	a, p
	idxm	p, a	; Put upper byte of pointer to first byte of value on stack.
	pop	af
	push	af
	idxm	a, p
	addc	a
	xch	a, p
	add	a, #4
	xch	a, p
	idxm	p, a	; Put lower byte of pointer to second byte of value on stack.

	; Jump to upper byte. ret there will return from the call to code2
	ret

;--------------------------------------------------------------------------
;  __setjmp.s
;
;  Copyright (C) 2019, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area DATA
___setjmp_PARM_1::
        .ds 2
_longjmp_PARM_1::
	.ds 2
_longjmp_PARM_2::
	.ds 2

	.area   CODE

___setjmp::
	mov	a, sp
	add	a, #-1
	mov	p, a
	idxm	a, p
	push	af
	dec	p
	idxm	a, p

	xch	a, p
	mov	a, ___setjmp_PARM_1+0
	xch	a, p

	idxm	p, a
	inc	p
	pop	af
	idxm	p, a

	inc	p
	mov	a, sp
	idxm	p, a
	clear	p
	ret	#0

_longjmp::
	mov	a, _longjmp_PARM_1+0
	add	a, #2
	mov	p, a
	idxm	a, p
	add	a, #-2
	mov	sp, a

	dec	p
	dec	p
	idxm	a, p
	push	af
	inc	p
	idxm	a, p

	xch	a, p
	mov	a, sp
	add	a, #-1
	xch	a, p
	idxm	p, a

	mov	a, _longjmp_PARM_2+1
	mov	p, a
	mov	a, _longjmp_PARM_2+0

	ceqsn	a, p
	ret
	ceqsn	a, #0
	ret
	ret	#1

/*-------------------------------------------------------------------------
;  atomic_flag_clear.c - C run-time: C11 atomic flag
;
;  Copyright (C) 2020, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;------------------------------------------------------------------------*/

#ifdef __SDCC_MODEL_FLAT24

static void dummy(void) __naked
{
	__asm
	.area HOME    (CODE)

_atomic_flag_clear::
	mov  r0,dpl
	clr  a
	mov  @r0,a
	ret

	__endasm;
}

#endif

/*-------------------------------------------------------------------------
   setjmp.c - source file for ANSI routines setjmp & longjmp

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ds80c390.h>
#include <sdcc-lib.h>
#define __SDCC_HIDE_LONGJMP
#include <setjmp.h>

int __setjmp (jmp_buf buf)
{
    unsigned char sp, esp;
    unsigned long lsp;

    /* registers would have been saved on the
       stack anyway so we need to save SP
       and the return address */
    __critical {
        sp = SP;
        esp = ESP;
    }
    lsp = sp;
    lsp |= (unsigned int)(esp << 8);
    lsp |= 0x400000;
    *buf++ = lsp;
    *buf++ = lsp >> 8;
    *buf++ = *((unsigned char __xdata *) lsp - 0);
    *buf++ = *((unsigned char __xdata *) lsp - 1);
    *buf++ = *((unsigned char __xdata *) lsp - 2);
    return 0;
}

int longjmp (jmp_buf buf, int rv)
{
    unsigned long lsp;

    lsp = *buf++;
    lsp |= (unsigned int)(*buf++ << 8);
    lsp |= 0x400000;
    *((unsigned char __xdata *) lsp - 0) = *buf++;
    *((unsigned char __xdata *) lsp - 1) = *buf++;
    *((unsigned char __xdata *) lsp - 2) = *buf++;
    __critical {
        SP = lsp;
        ESP = lsp >> 8;
    }
    return rv ? rv : 1;
}
/*-------------------------------------------------------------------------
;  atomic_flag_test_and_set.c - C run-time: C11 atomic flag
;
;  Copyright (C) 2020, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;------------------------------------------------------------------------*/

#ifdef __SDCC_MODEL_FLAT24

static void dummy(void) __naked
{
	__asm
	.area HOME    (CODE)

_atomic_flag_test_and_set::
	mov  r0,dpl
	mov  a,#0x01
	xch  a,@r0
	mov  dpl,a
	ret

	__endasm;
}

#endif

/*-------------------------------------------------------------------------
   tinibios.c - startup and serial routines for the DS80C390 (tested on TINI)

   Copyright (C) 2001, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <tinibios.h>
#include <stdio.h>

#define TIMED_ACCESS(sfr,value) { TA=0xaa; TA=0x55; sfr=value; }
 
unsigned char _sdcc_external_startup(void)
{
  IE=0; // disable ALL interrupts

  // use A19..16 and !CE3..0, no CAN
  TIMED_ACCESS(P4CNT,0x3f);

  // use !PCE3..0, serial 1 at P5.2/3
  TIMED_ACCESS(P5CNT,0x27);

  // disable watchdog
  EWT=0;

  // watchdog set to 9.1 seconds
  // CKCON|=0xc0;

  // default stretch cycles for MOVX
  //CKCON = (CKCON&0xf8)|(CPU_MOVX_STRETCH&0x07);
  CKCON=0xf9;

  // use internal 4k RAM as data(stack) memory at 0x400000 and
  // move CANx memory access to 0x401000 and upwards
  // use !CE* for program and/or data memory access
  TIMED_ACCESS(MCON,0xaf);

  // select default cpu speed
  CpuSpeed(CPU_SPEED);

  // Copy the Interrupt Vector Table (128 bytes) from 0x10000 to 0x100000
  // This isn't needed for older bootloaders than the 0515, but it won't harm
  __asm
    push dpx
    push dph
    push dpl
    push dps
    push b
    push acc
    mov dps,#0x00 ; make sure no autoincrement in progress
    mov dptr,#0x10000 ; from
    inc dps ; switch to alternate dptr
    mov dptr,#0x100000 ; to
    mov b,#0x80 ; count

_Startup390CopyIVT:
    inc dps
    movx a,@dptr
    inc dptr
    inc dps
    movx @dptr,a
    inc dptr
    djnz b,_Startup390CopyIVT

    pop acc
    pop b
    pop dps
    pop dpl
    pop dph
    pop dpx
  __endasm;

  // global interrupt enable, all masks cleared
  // let the Gods be with us :)
  IE = 0x80; 

  Serial0Init(SERIAL_0_BAUD,1);
  //Serial1Init(SERIAL_1_BAUD,1);
  ClockInit();
  //RtcInit();
  //WatchDogInit();

  // signal _sdcc_gsinit_startup to initialize data (call _sdcc_init_data)
  return 0; 
}

/* Set the cpu speed in clocks per machine cycle, valid values are:
   1024: Power management mode
      4: Divide-by-4 mode
      2: Use frequency multiplier (2x)
      1: Use frequency multiplier (4x) (Don't do this on a TINI at 18.432MHz)

   TODO: TINI seems to support only 2 and 4: write only bits in PMR ?
*/

unsigned int cpuSpeed;

void CpuSpeed(unsigned int speed)
{
#if 0
  while (0 && (EXIF&0x04))
    ; // cpu operates from ring buffer
#endif
  PMR = 0x80; // div4, CTM off, multiplier 2x
  switch (speed) 
    {
    case 1:
      PMR=0x88; // div4, CTM off, multiplier 4x
      PMR=0x98; // div4, CTM on, multiplier 4x
      while ((EXIF&0x08)==0) {
	; // wait for the multiplier to be ready
      }
      PMR = 0x18; // use multiplier
      cpuSpeed=speed;
      break;
    case 2:
      PMR=0x90; // div4, CTM on, multilier 2x
      while ((EXIF&0x08)==0) {
	; // wait for the multiplier to be ready
      }
      PMR = 0x10; // use multiplier
      cpuSpeed=speed;
      break;
    case 4:
      // nothing to do
      cpuSpeed=speed;
      break;
    case 1024:
      PMR = 0xc0; // div1024, CTM off
      cpuSpeed=speed;
      break;
    }
}  

// now the serial0 stuff

// just to make the code more readable 
#define S0RBS SERIAL_0_RECEIVE_BUFFER_SIZE

// this is a ring buffer and can overflow at anytime!
static volatile unsigned char receive0Buffer[S0RBS];
static volatile int receive0BufferHead=0;
static volatile int receive0BufferTail=0;
// no buffering for transmit
static volatile char transmit0IsBusy=0;

static __data unsigned char serial0Buffered;

/* Initialize serial0.

   Available baudrates are from 110 upto 115200 (using 16-bit timer 2)
   If baud==0, the port is disabled.

   If buffered!=0, characters received are buffered using an interrupt
*/

void Serial0Init (unsigned long baud, unsigned char buffered)
{
  if (baud==0) {
    ES0=0; // disable interrupts
    SCON0 &= 0xef; // disable receiver
    return;
  }

  ES0 = 0; // disable serial channel 0 interrupt
  TR2 = 0; // stop timer 2
  
  // set 8 bit uart with variable baud from timer 1/2
  // enable receiver and clear RI and TI
  SCON0 = 0x50;
  
  PCON |= 0x80; // clock is 16x bitrate
  CKCON|=0x20; // timer uses xtal/4
  
  T2MOD=0; // no fancy functions
  T2CON=0x34; // start timer as a baudrate generator for serial0
  
  // set the baud rate
  Serial0Baud(baud);
  
  serial0Buffered=buffered;
 
  if (buffered) {
    RI_0=TI_0=0; // clear "pending" interrupts
    ES0 = 1; // enable serial channel 0 interrupt
  } else {
    RI_0=0; // receive buffer empty
    TI_0=1; // transmit buffer empty
  }
}

void Serial0Baud(unsigned long baud)
{
  TR2=0; // stop timer
  baud=-((long)OSCILLATOR/(32*baud));
  TL2=RCAP2L= baud;
  TH2=RCAP2H= baud>>8;
  TF2=0; // clear overflow flag
  TR2=1; // start timer
}  

void Serial0IrqHandler (void) __interrupt 4
{
  if (RI_0) {
    receive0Buffer[receive0BufferHead]=SBUF0;
    receive0BufferHead=(receive0BufferHead+1)&(S0RBS-1);
    if (receive0BufferHead==receive0BufferTail) {
      /* buffer overrun, sorry :) */
      receive0BufferTail=(receive0BufferTail+1)&(S0RBS-1);
    }
    RI_0=0;
  }
  if (TI_0) {
    TI_0=0;
    transmit0IsBusy=0;
  }
}

char Serial0CharArrived(void)
{
  if (serial0Buffered) {
    if (receive0BufferHead!=receive0BufferTail)
      return receive0Buffer[receive0BufferTail];
  } else {
    if (RI_0)
      return SBUF0;
  }
  return 0;
}

void Serial0PutChar (char c)
{
  if (serial0Buffered) {
    while (transmit0IsBusy)
      ;
    transmit0IsBusy=1;
    SBUF0=c;
  } else {
    while (!TI_0)
      ;
    SBUF0=c;
    TI_0=0;
  }
}

char Serial0GetChar (void)
{
  char c;
  if (serial0Buffered) {
    while (receive0BufferHead==receive0BufferTail)
      ;
    c=receive0Buffer[receive0BufferTail];
    ES0=0; // disable serial interrupts
    receive0BufferTail=(receive0BufferTail+1)&(S0RBS-1);
    ES0=1; // enable serial interrupts
  } else {
    while (!RI_0)
      ;
    c=SBUF0;
    RI_0=0;
  }
  return c;
}

void Serial0SendBreak()
{
  P3 &= ~0x02;
  ClockMilliSecondsDelay(2);
  P3 |= 0x02;
}

void Serial0Flush()
{
  ES0=0; // disable interrupts
  receive0BufferHead=receive0BufferTail=0;
  RI_0=0;
  if (serial0Buffered) {
    TI_0=0;
    ES0=1; // enable interrupts
  } else {
    TI_0=1;
  }
}

/* now let's go for the serial1 stuff, basically it's a replicate of 
   serial0 except it uses timer 1
*/

// just to make the code more readable 
#define S1RBS SERIAL_1_RECEIVE_BUFFER_SIZE

// this is a ring buffer and can overflow at anytime!
static volatile unsigned char receive1Buffer[S1RBS];
static volatile int receive1BufferHead=0;
static volatile int receive1BufferTail=0;
// no buffering for transmit
static volatile char transmit1IsBusy=0;

static __data unsigned char serial1Buffered;

/* Initialize serial1.

   Available baudrates are from 4800 upto 115200 (using 8-bit timer 1)
   If baud==0, the port is disabled.

   If buffered!=0, characters received are buffered using an interrupt
*/

void Serial1Init (unsigned long baud, unsigned char buffered)
{
  if (baud==0) {
    ES1=0; // disable interrupt
    SCON1 &= 0xef; // disable receiver
    return; // and don't touch it
  }

  ES1 = 0; // disable channel 1 interrupt
  TR1 = 0; // stop timer 1
  
  // set 8 bit uart with variable baud from timer 1
  // enable receiver and clear RI and TI
  SCON1 = 0x50;
  
  WDCON |= 0x80; // clock is 16x bitrate
  CKCON|=0x10; // timer uses xtal/4
  
  TMOD = (TMOD&0x0f) | 0x20; // timer 1 is an 8bit auto-reload counter
  
  // set the baud rate
  Serial1Baud(baud);
  
  serial1Buffered=buffered;

  if (buffered) {
    RI_1=TI_1=0; // clear "pending" interrupts
    ES1 = 1; // enable serial channel 1 interrupt
  } else {
    RI_1=0; // receive buffer empty
    TI_1=1; // transmit buffer empty
  }
}

void Serial1Baud(unsigned long baud)
{
  TR1=0; // stop timer
  baud=-((long)OSCILLATOR/(32*baud));
  TL1=TH1 = baud;
  TF1=0; // clear overflow flag
  TR1=1; // start timer
}  

void Serial1IrqHandler (void) __interrupt 7
{
  if (RI_1) {
    receive1Buffer[receive1BufferHead]=SBUF1;
    receive1BufferHead=(receive1BufferHead+1)&(S1RBS-1);
    if (receive1BufferHead==receive1BufferTail) /* buffer overrun, sorry :) */
      receive1BufferTail=(receive1BufferTail+1)&(S1RBS-1);
    RI_1=0;
  }
  if (TI_1) {
    TI_1=0;
    transmit1IsBusy=0;
  }
}

char Serial1CharArrived(void)
{
  if (serial1Buffered) {
    if (receive1BufferHead!=receive1BufferTail)
      return receive1Buffer[receive1BufferTail];
  } else {
    if (RI_1)
      return SBUF1;
  }
  return 0;
}

void Serial1PutChar (char c)
{
  if (serial1Buffered) {
    while (transmit1IsBusy)
      ;
    transmit1IsBusy=1;
    SBUF1=c;
  } else {
    while (!TI_1)
      ;
    SBUF1=c;
    TI_1=0;
  }
}

char Serial1GetChar (void)
{
  char c;
  if (serial1Buffered) {
    while (receive1BufferHead==receive1BufferTail)
      ;
    c=receive1Buffer[receive1BufferTail];
    ES1=0; // disable serial interrupts
    receive1BufferTail=(receive1BufferTail+1)&(S1RBS-1);
    ES1=1; // enable serial interrupts
  } else {
    while (!RI_1)
      ;
    c=SBUF1;
    RI_1=0;
  }
  return c;
}

void Serial1SendBreak()
{
  P5 &= ~0x08;
  ClockMilliSecondsDelay(2);
  P5 |= 0x08;
}

void Serial1Flush()
{
  ES1=0; // disable interrupts
  receive1BufferHead=receive1BufferTail=0;
  RI_1=0;
  if (serial1Buffered) {
    TI_1=0;
    ES1=1; // enable interrupts
  } else {
    TI_1=1;
  }
}

// now let's go for the clock stuff

// these REALLY need to be in data space for the irq routine!
static __data unsigned long milliSeconds=0;
static __data unsigned int timer0ReloadValue;

void ClockInit()
{
  unsigned long timerReloadValue=OSCILLATOR/1000;

  switch (cpuSpeed) {
  case 4: timerReloadValue/=4; break;
  case 1: // not tested yet
  case 2:  // not tested yet
  default: timerReloadValue/=2; break;
  }
  timer0ReloadValue=~timerReloadValue;
  // initialise timer 0
  ET0=0; // disable timer interrupts initially
  TCON = (TCON&0xcc)|0x00; // stop timer, clear overflow
  TMOD = (TMOD&0xf0)|0x01; // 16 bit counter
  CKCON|=0x08; // timer uses xtal/4
  
  TL0=timer0ReloadValue&0xff;
  TH0=timer0ReloadValue>>8;
  
  ET0=1; // enable timer interrupts
  TR0=1; // start timer
}

// This needs to be SUPER fast. What we really want is:

#if 0
void junk_ClockIrqHandler (void) __interrupt 10
{
  TL0 = timer0ReloadValue & 0xff;
  TH0 = timer0ReloadValue >> 8;
  milliSeconds++;
}
#else
// but look at the code, and the pushes and pops, so:
void ClockIrqHandler (void) __interrupt 1 __naked
{
  __asm
    push acc
    push psw
    mov _TL0,_timer0ReloadValue
    mov _TH0,_timer0ReloadValue+1
    clr a
    inc _milliSeconds+0
    cjne a,_milliSeconds+0,_ClockIrqHandlerDone
    inc _milliSeconds+1
    cjne a,_milliSeconds+1,_ClockIrqHandlerDone
    inc _milliSeconds+2
    cjne a,_milliSeconds+2,_ClockIrqHandlerDone
    inc _milliSeconds+3
  _ClockIrqHandlerDone:
    pop psw
    pop acc
    reti
  __endasm;
}
#endif

// we can't just use milliSeconds
unsigned long ClockTicks(void)
{
  unsigned long ms;
  ET0=0;
  ms=milliSeconds;
  ET0=1;
  return ms;
}

void ClockMilliSecondsDelay(unsigned long delay)
{
  long ms=ClockTicks()+delay;

  while (ms>ClockTicks())
    ;
}

// stolen from Kevin Vigor, works only for TINI at default speed
void ClockMicroSecondsDelay(unsigned int delay)
{
  delay; /* shut compiler up. */
   
  __asm
     
    ; delay is in dpl/dph
    mov	r0, dpl
    mov  r1, dph

    mov	a, r0
    orl  a, r1			; quick out for zero case.
    jz   _usDelayDone
   
    inc	r1
    cjne r0, #0, _usDelayLoop
    dec  r1
   
  _usDelayLoop:
    nop
    nop
    nop
    nop
    nop
    nop
    nop				; 7 nops
    djnz r0, _usDelayLoop	; 3 cycles x 1 = 3 cycles
				; 10 cycles per iter
				; we want 9.216, but more is better
				; than less.
    djnz r1, _usDelayLoop	
  _usDelayDone:
   
  __endasm;
}
/*-------------------------------------------------------------------------
   rtc390.c - rtc routines for the DS1315 (tested on TINI)

   Copyright (C) 2001, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <tinibios.h>
#include <stdio.h>
#include <time.h>
#include <ctype.h>

/* this is the address of the ds1315 phantom time chip, although
   it doesn't really matter as long as it's in the 300000-3fffff
   range since the chip only uses CE3*
*/

__xdata __at (0x310000) static volatile unsigned char rtc;

// this is the 64bit pattern that has to be recognized by the ds1315
__code unsigned char rtcMagic[8]={0xc5,0x3a,0xa3,0x5c,0xc5,0x3a,0xa3,0x5c};

#define BCDtoINT(x) (((x)&0x0f)+((x)>>4)*10)
#define INTtoBCD(x) (((x)%10)+(((x)/10)<<4))

static void RtcSync(void) {
  unsigned char dummy, byte,bitMask;

  // reset rtc chip
  dummy=rtc;

  // say the magic word
  for (byte=0; byte<8; byte++) {
    for (bitMask=0x01; bitMask; bitMask<<=1) {
      rtc = (rtcMagic[byte]&bitMask) ? 0xff : 0x00;
    }
  }
}

unsigned char RtcRead(struct tm *rtcDate) {
  unsigned char rtcBytes[8];
  unsigned char byte,bitMask;

  RtcSync();

  for (byte=0; byte<8; byte++) {
    rtcBytes[byte]=0;
    for (bitMask=0x01; bitMask; bitMask<<=1) {
      if (rtc&1) {
	rtcBytes[byte]|=bitMask;
      }
    }
  }
  rtcDate->tm_year=BCDtoINT(rtcBytes[7])+100; // year since 1900
  rtcDate->tm_mon=BCDtoINT(rtcBytes[6])-1; // jan=0
  rtcDate->tm_mday=BCDtoINT(rtcBytes[5]);
  rtcDate->tm_wday=(rtcBytes[4]&0x07)-1; // monday=0?
  rtcDate->tm_hour=BCDtoINT(rtcBytes[3]);
  rtcDate->tm_min=BCDtoINT(rtcBytes[2]);
  rtcDate->tm_sec=BCDtoINT(rtcBytes[1]);
  rtcDate->tm_hundredth=BCDtoINT(rtcBytes[0]);
  if ((rtcBytes[4]&0x30) || (rtcBytes[3]&0x80)) {
    //oscillator not running, reset not active or in 12h mode
    return 0;
  }
  return 1;
}

void RtcWrite(struct tm *rtcDate) {
  unsigned char rtcBytes[8];
  unsigned char byte,bitMask;

  rtcBytes[7]=INTtoBCD(rtcDate->tm_year%100);
  rtcBytes[6]=INTtoBCD(rtcDate->tm_mon)+1;
  rtcBytes[5]=INTtoBCD(rtcDate->tm_mday);
  rtcBytes[4]=(INTtoBCD(rtcDate->tm_wday)+1)&0x07; //set 24h  mode
  rtcBytes[3]=INTtoBCD(rtcDate->tm_hour)&0x3f; // oscilator on, reset on
  rtcBytes[2]=INTtoBCD(rtcDate->tm_min);
  rtcBytes[1]=INTtoBCD(rtcDate->tm_sec);
  //rtcBytes[0]=INTtoBCD(rtcDate->hundredth);
  rtcBytes[0]=0;

  RtcSync();

  for (byte=0; byte<8; byte++) {
    for (bitMask=0x01; bitMask; bitMask<<=1) {
      rtc = (rtcBytes[byte]&bitMask) ? 0xff : 0x00;
    }
  }
}
/*-------------------------------------------------------------------------
;  gptr_cmp.asm - C run-time: compare two generic pointers
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;------------------------------------------------------------------------*/

#ifdef __SDCC_MODEL_FLAT24

static void dummy(void) __naked
{
	__asm
	.area HOME    (CODE)

; compares two generic pointers.
; if p1 < p2  return NZ and C
; if p1 == p2 return  Z and NC
; if p1 > p2  return NZ and NC
; if both are a NULL pointer (yes, we have several) also return Z and NC

___gptr_cmp::
    mov  a,sp
    add  a,#0xFA
    mov  dpl1,a
    mov  a,esp
    anl  a,#0x03
    addc a,#0xFF
    mov  dph1,a
    mov  dpx1,#0x40
    inc  dps        ;select dptr1
    movx a,@dptr
    mov  ap,a
    inc  dptr
    movx a,@dptr
    orl  ap,a
    inc  dptr
    movx a,@dptr
    orl  a,ap
    clr  c
    jnz  00001$
    mov  a,dpl
    orl  a,dph
    orl  a,dpx
; if both are NULL, return Z and NC
    jz   00002$
00001$:
    orl  dps,#0x80  ;decrement dptr1
    inc  dptr
    inc  dptr
    anl  dps,#0x7F  ;increment dptr1
    movx a,@dptr
    subb a,dpl
    mov  ap,a
    inc  dptr
    movx a,@dptr
    subb a,dph
    orl  ap,a
    inc  dptr
    movx a,@dptr
    subb a,dpx
    orl  ap,a
    inc  dptr
    movx a,@dptr
    subb a,b
    orl  a,ap
; p2 < p1, return NZ and C
; p2 = p1, return Z and NC
; p2 > p1, return NZ and NC
00002$:
    dec  dps        ;select dptr0
    ret

	__endasm;
}

#endif

/*-------------------------------------------------------------------------
   memcpyx.c

   Copyright (C) 2000, Kevin Vigor

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

void __xdata * memcpyx (
	void __xdata * dst,
	void __xdata * src,
	int count
	) __naked
{
    /* Shut compiler up about unused parameters. */
    dst; src; count;
    
/* AUTO_TOGGLE uses the '390 DPTS toggle bit. */    
#define AUTO_TOGGLE    
__asm
    ; Destination is in DPTR. Save it on stack so we can return it at end.
    
    push dpx
    push dph
    push dpl
    
    mov  dps, #0x1        ; Alternate DPTR.
    
    ; count  is in _memcpyx_PARM_3
    mov  dptr, #_memcpyx_PARM_3
    movx a, @dptr
    inc dptr
    mov r2, a
    movx a, @dptr
    mov r3, a

    ; src is in _memcpyx_PARM_2
    mov  dptr, #_memcpyx_PARM_2
    movx a, @dptr
    inc  dptr
    push acc
    movx a, @dptr
    inc  dptr
    push acc
    movx a, @dptr
    mov  dpx1, a
    pop  dph1
    pop  dpl1

#ifdef AUTO_TOGGLE
    mov	dps, #0x21	; Current DPTR is alt DPTR, toggle after each op.
#else
    mov dps, #0x0	; Current DPTR is normal DPTR, no toggle.
#endif    
    
    ; src is in alt DPTR, dst is in normal DPTR, count is in r2/r3.
    
    ; If we have zero bytes to copy, quick out.
    mov	 a, r2
    orl  a, r3
    jz   _memcpy_done

    ; increment r3 if r2 != 0 (makes djnz end-of-loop sequence possible).
    inc r3
    cjne r2, #0x0, _memcpyx_loopTop
    dec r3

_memcpyx_loopTop:

#ifdef AUTO_TOGGLE
    movx a, @dptr
    movx @dptr, a
    inc dptr
    inc dptr
#else
    inc dps
    movx a, @dptr
    inc dptr
    dec dps 
    movx @dptr, a
    inc dptr
#endif    

    djnz r2, _memcpyx_loopTop
    djnz r3, _memcpyx_loopTop
    
_memcpy_done:

#ifdef AUTO_TOGGLE
    mov dps, #0x0
#endif    

    pop dpl
    pop dph
    pop dpx
    ret
__endasm;    
    
}
/*-------------------------------------------------------------------------
   i2c390.c

   Copyright (C) 2001, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* This implemenation is based on an example I once grabbed from
   the Philips bbs.
   Don't know who wrote it, but is has been hacked so heavily, he/she wouldn't
   recogize it anyway */

//#define DEBUG_I2C ==> DON'T DO THIS, THIS IS A LIBRARY <==

#ifdef DEBUG_I2C
#include <stdio.h>
#else
#include <tinibios.h>
#endif

// we are (ab)using the CAN CTX and CRX for serial data and serial clock
#define SCL_HIGH (P5 |= 1)
#define SCL_LOW (P5 &= ~1)
#define SDA_HIGH (P5 |= 2)
#define SDA_LOW (P5 &= ~2)

#define SDA_OUT(b) (b ? SDA_HIGH : SDA_LOW)
#define SDA_IN ((P5>>1)&1)
#define SCL_IN (P5&1)

/*
 * I2C error values
 */

#define I2CERR_OK       0       /* No error */
#define I2CERR_NAK      1       /* No ACK from slave */
#define I2CERR_LOST     2       /* Arbitration lost */
#define I2CERR_BUS      3       /* Bus is stuck (not used yet) */
#define I2CERR_TIMEOUT  4       /* Timeout on bus */

char i2cTransmitBuffer[I2C_BUFSIZE];     /* Global transfer buffers */
char i2cReceiveBuffer[I2C_BUFSIZE];

static char i2cError = 0;                 /* Last error */

#define I2CDELAY 1

void I2CDelay(volatile long delay) {
 while (delay--)
   ;
}

void I2CDumpError(char error);

/*
 * Makes sure that the bus is in a known condition. Returns 1 on success,
 * 0 if some other device is pulling on the bus.
 */

char I2CReset(void)
{
  SDA_LOW;
  SCL_LOW;
  SCL_HIGH;
  SDA_HIGH;
  i2cError = 0;
  return (SCL_IN && SDA_IN);
}


/*
 * Generates a start condition on the bus. Returns 0 on success, 1 if some
 * other device is holding the bus.
 */

char I2CStart(void)
{
  SDA_HIGH;
  SCL_HIGH;
  I2CDelay(I2CDELAY);
  SDA_LOW;        /* Pull SDA down... */
  I2CDelay(I2CDELAY);
  SCL_LOW;        /* ...and then SCL -> start condition. */
  I2CDelay(I2CDELAY);
  return 0;
}


/*
 * Generates a stop condition on the bus. Returns 0 on success, 1 if some
 * other device is holding the bus.
 */

char I2CStop(void)
{
  SDA_LOW;
  SCL_HIGH;        /* Let SCL go up */
  I2CDelay(I2CDELAY);
  SDA_HIGH;        /* ...and then SDA up -> stop condition. */
  I2CDelay(I2CDELAY);

  return (SCL_IN && SDA_IN);  /* Both will be up, if everything is fine */
}


/*
 * Clock out one bit.
 * Returns 0 on success, 1 if we lose arbitration.
 */

char BitOutI2C(unsigned char bout)
{
  SDA_OUT(bout);              /* Put data out on SDA */
  I2CDelay(I2CDELAY);
  SCL_HIGH;                   /* Let SCL go up */
  while(!SCL_IN)              /* Wait until all other devices are ready */
    {
      // should do a timeout here
    }

  if (SDA_IN != bout)         /* Arbitration lost, release bus and return */
    {
      SDA_HIGH;               /* Should be up anyway, but make sure */
      i2cError = I2CERR_LOST;
      I2CDumpError(i2cError);
      return 1;
    }
  I2CDelay(I2CDELAY);
  SCL_LOW;                    /* Pull SCL back down */
  I2CDelay(I2CDELAY);
  return 0;                   /* OK */
}


/*
 * Clock in one bit.
 */

char BitInI2C(void)
{
  char bin;

  // SDA is opencollector, so:
  SDA_HIGH;

  SCL_HIGH;                   /* Let SCL go up */
  while(!SCL_IN)              /* Wait for other devices */
    {
      // should do a timeout here
    }
  bin = SDA_IN;               /* Read in data */
  I2CDelay(I2CDELAY);
  SCL_LOW;                    /* Pull SCL back up */
  I2CDelay(I2CDELAY);
  return bin;                 /* Return the sampled bit */
}


/*
 * Send one byte on the bus. No start or stop conditions are generated here,
 * but i2cError will be set according to the result.
 * Returns 0 on success, 1 if we lose arbitration or if the slave doesn't
 * acknowledge the byte. Check i2cError for the actual result on error.
 */

char ByteOutI2C(char dat)
{
  char bit_count;

  bit_count = 8;
  while(bit_count) {
    if (dat & 0x80) {
      if (BitOutI2C(1)) {
	I2CDumpError(i2cError);
	return 1;
      }
    } else {
      if (BitOutI2C(0)) {
	I2CDumpError(i2cError);
	return 1;
      }
    }
    dat <<= 1;
    bit_count--;
  }

  if (BitInI2C()) {
    i2cError = I2CERR_NAK;
    I2CDumpError(i2cError);
    return 1;
  }
  return 0;
}


/*
 * Reads one byte in from the slave. Ack must be 1 if this is the last byte
 * to be read during this transfer, 0 otherwise (as per I2C bus specification,
 * the receiving master must acknowledge all but the last byte during a
 * transfer).
 */

char I2CByteIn(char ack)
{
  char bit_count, byte_in;

  bit_count = 8;
  byte_in = 0;

  while(bit_count)
    {
      byte_in <<= 1;
      if (BitInI2C()) byte_in |= 0x01;
      bit_count--;
    }

  BitOutI2C(ack);
  SDA_HIGH;             /* Added 18-Jul-95 - thanks to Ray Bellis */
 return byte_in;
}


/*
 * Send 'count' bytes to slave 'addr'.
 * Returns 0 on success. Stop condition is sent only when send_stop is true.
 */

char I2CSendStop(char addr, char count, char send_stop)
{
  char byteptr, byte_out;

  if (I2CStart()) return 1;
  i2cError = 0;

  byte_out = addr & 0xfe;     /* Ensure that it's a write address */
  count++;                    /* Include slave address to byte count */
  byteptr = 0;
  while(count)
    {
      if (ByteOutI2C(byte_out))
        {
	  if (i2cError == I2CERR_NAK && send_stop) I2CStop();
	  return i2cError;
        }
      byte_out = i2cTransmitBuffer[byteptr];
      byteptr++;
      count--;
    }

  if (send_stop) I2CStop();
  return 0;
}


/*
 * Read in 'count' bytes from slave 'addr'.
 * Returns 0 on success.
 */

char i2c_recv(char addr, char count)
{
  char byteptr, byte_in;

  if (I2CStart()) return 1;
  i2cError = 0;
  byteptr = 0;

  byte_in = addr | 0x01;

  if (ByteOutI2C(byte_in))
    {
      if (i2cError == I2CERR_NAK) I2CStop();
      return i2cError;
    }

  while(count)
    {
      count-=1;
      if (count) {
	byte_in = I2CByteIn(0);
      } else {
	byte_in = I2CByteIn(1);   /* No ACK during last byte */
      }
      i2cReceiveBuffer[byteptr] = byte_in;
      byteptr++;
    }

  I2CStop();

  return (i2cError ? 1 : 0);
}


/*
 * Write 'tx_count' bytes to slave 'addr', then use a repeated start condition
 * to read 'rx_count' bytes from the same slave during the same transfer.
 * Returns 0 on success, 1 otherwise. On error, check i2cError for the actual
 * error value.
 */

char I2CSendReceive(char addr, char tx_count, char rx_count)
{
  if (I2CSendStop(addr, tx_count, 0))
    {
     /* If send fails, abort but don't send a stop condition if we lost
	 arbitration */

      if (i2cError != I2CERR_LOST) I2CStop();
      return 1;
    }

  SDA_HIGH; /* One of these may be low now, in which case the next */
  SCL_HIGH; /* start condition wouldn't be detected so make */
  I2CDelay(I2CDELAY); /*   sure that they're up and wait for one delay slot */

  if (i2c_recv((char)(addr|0x01), rx_count)) return 1;
  return (i2cError ? 1 : 0);
}

/*
 * Dump an error message.
 */

void I2CDumpError(char error)
{
#ifdef DEBUG_I2C
  switch(error)
    {
    case 0:
      puts("I2C: OK.");
      break;
    case I2CERR_NAK:
      puts("I2C: Slave didn't acknowledge");
      break;
    case I2CERR_LOST:
      puts("I2C: Lost arbitration with another master");
      break;
    case I2CERR_TIMEOUT:
      puts("I2C: Timeout on bus");
      break;
    case I2CERR_BUS:
      puts("I2C: The bus is stuck");
      break;
    default:
      puts("I2C: Unknown error");
      break;
    }
#else
  error; // hush the compiler
#endif
}
/*-------------------------------------------------------------------------
   lcd.c - lcd routines for the DS80C390 (tested on TINI)

   Copyright (C) 2001, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <tinibios.h>
#include <stdio.h>
#include <stdarg.h>

#define LCD_COLLUMNS 20
#define LCD_ROWS 4

/* set the dd ram addresses for the rows
   this one is for a 20x4 LCD
*/
static unsigned char lcdLinesStart[LCD_ROWS]={0, 0x40, 0x14, 0x54};

/* Commercial TINI stick connector boards don't support rw
   control for the lcd-display.
   My own board does, and it makes it much faster.
*/

//#define LCD_RW

__xdata __at (0x380002) static unsigned char lcdIwr;
__xdata __at (0x38000a) static unsigned char lcdDwr;

#ifdef LCD_RW

__xdata __at (0x380003) static unsigned char lcdIrd;
__xdata __at (0x38000b) static unsigned char lcdDrd;

#define LcdWait { while (lcdIrd&0x80) ; }

#else // ifdef LCD_RW

// wait for 100us
#define LcdWait { ClockMicroSecondsDelay(100) ; }

#endif // ifdef LCD_RW

void LcdInit() {
  
  ClockMilliSecondsDelay(16); // >15 ms
  
  lcdIwr=0x38 ;
  ClockMilliSecondsDelay(5); // >4.1 ms
  
  lcdIwr=0x38;
  ClockMicroSecondsDelay(101); // >100 us
  
  lcdIwr=0x38;
  ClockMicroSecondsDelay(101); // >100 us
  
  lcdIwr=0x38; // interface 8 bit
  ClockMicroSecondsDelay(41); // >40 us
  
  lcdIwr=0x0c; // display on
  ClockMicroSecondsDelay(41); // >40 us

  LcdClear();
}

void LcdOn() {
  lcdIwr=0x0c; // display on
  LcdWait;
}

void LcdOff() {
  lcdIwr=0x08; // display off
  LcdWait;
}

void LcdCursorOn() {
  // TODO
}

void LcdCursorOff() {
  // TODO
}

void LcdScrollOn() {
  // TODO
}

void LcdScrollOff() {
  // TODO
}

void LcdCharDefine() {
  // TODO
}

void LcdClear() {
  lcdIwr=0x01; // display clear
  ClockMilliSecondsDelay(6); // > 5ms
}

void LcdHome() {
  lcdIwr=0x80; // set dd ram address 0
  LcdWait;
}

void LcdGoto(unsigned int collumnRow) { // msb=collumn, lsb=row
  lcdIwr=0x80 + \
    lcdLinesStart[collumnRow&0xff] + (collumnRow>>8);
  LcdWait;
}

void LcdPutChar(char c) {
  lcdDwr=c;
  LcdWait;
}

void LcdPutString (char *string) {
  char c;
  while (c=*string++) {
    LcdPutChar (c);
  }
}

void LcdLPutString (unsigned int collumnRow, char *string) {
  LcdGoto(collumnRow);
  LcdPutString(string);
}

// let's hope that no one ever printf's more than the display width,
// however they will :), so to be sure
static char lcdPrintfBuffer[LCD_COLLUMNS*4];

void LcdPrintf (const char *format, ...) __reentrant {
  va_list arg;

  va_start (arg, format);
  vsprintf (lcdPrintfBuffer, format, arg);
  puts (lcdPrintfBuffer);
  LcdPutString(lcdPrintfBuffer);

  va_end (arg);
}

void LcdLPrintf (unsigned int collumnRow, const char *format, ...) __reentrant {
  va_list arg;

  LcdGoto(collumnRow);

  // we can not just call LcdPrintf since we have no idea what is on the stack,
  // so we have to do it all over again
  va_start (arg, format);
  vsprintf (lcdPrintfBuffer, format, arg);

  LcdPutString(lcdPrintfBuffer);

  va_end (arg);
}
/*-------------------------------------------------------------------------
   putchar.c - putchar implementation for DS80C390

   Copyright (C) 2006, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#include <tinibios.h>
#include <stdio.h>

int putchar (int c)
{
	Serial0PutChar(c);
	return(c);
}

extern int getchar(void)
{
	return Serial0GetChar();
}

Moved and unpacked to sdcc/device/examples/ds390
;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2014, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl ___sdcc_heap_init
	.globl ___sdcc_heap
	.globl ___sdcc_heap_end

	.area GSINIT
	call ___sdcc_heap_init

	.area DATA
	; For now just allocate 64 bytes for the heap.
___sdcc_heap::
	.ds 63
___sdcc_heap_end::
	.ds 1 
;--------------------------------------------------------------------------
;  __gptrget.s - read from pointer
;
;  Copyright (c) 2019, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.module __gptrget
.area CODE

__gptrget::
	sub	a, #0x80
	t1sn	f, c
	goto	code

	; Pointer to RAM
	idxm	a, p
	ret

	; Pointer to ROM
code:
	; Put pointer on stack
	xch	a, p
	push	af	; Put lower byte of pointer on stack.
	mov	a, sp
	add	a, #-1
	xch	a, p
	idxm	p, a	; Put upper byte of pointer on stack.

	; Jump to it. ret there will return from the call to __gprtget
	ret

;--------------------------------------------------------------------------
;  __gptrget.s - read from pointer
;
;  Copyright (c) 2019, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.module __gptrget2
.area CODE

__gptrget2::
	sub	a, #0x80
	t1sn	f, c
	goto	code

	; Pointer to RAM
	idxm	a, p
	push	af
	inc	p
	idxm	a, p
	mov	p, a
	pop	af
	ret

	; Pointer to ROM
code:
	xch	a, p
	push	af	; Put lower byte of pointer to first byte of value on stack.
	call	code2	; Put return value for the ret at second byte of value on stack.

	mov	p, a
	; Jump to lower byte. ret there will return from the call to __gptrget2
	ret

code2:
	add	a, #1
	push	af	; Put lower byte of pointer to second byte of value on stack.
	mov	a, sp
	add	a, #-5
	xch	a, p
	idxm	p, a	; Put upper byte of pointer to first byte of value on stack.
	pop	af
	push	af
	idxm	a, p
	addc	a
	xch	a, p
	add	a, #4
	xch	a, p
	idxm	p, a	; Put lower byte of pointer to second byte of value on stack.

	; Jump to upper byte. ret there will return from the call to code2
	ret

;--------------------------------------------------------------------------
;  __setjmp.s
;
;  Copyright (C) 2019, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area DATA
___setjmp_PARM_1::
        .ds 2
_longjmp_PARM_1::
	.ds 2
_longjmp_PARM_2::
	.ds 2

	.area   CODE

___setjmp::
	mov	a, sp
	add	a, #-1
	mov	p, a
	idxm	a, p
	push	af
	dec	p
	idxm	a, p

	xch	a, p
	mov	a, ___setjmp_PARM_1+0
	xch	a, p

	idxm	p, a
	inc	p
	pop	af
	idxm	p, a

	inc	p
	mov	a, sp
	idxm	p, a
	clear	p
	ret	#0

_longjmp::
	mov	a, _longjmp_PARM_1+0
	add	a, #2
	mov	p, a
	idxm	a, p
	add	a, #-2
	mov	sp, a

	dec	p
	dec	p
	idxm	a, p
	push	af
	inc	p
	idxm	a, p

	xch	a, p
	mov	a, sp
	add	a, #-1
	xch	a, p
	idxm	p, a

	mov	a, _longjmp_PARM_2+1
	mov	p, a
	mov	a, _longjmp_PARM_2+0

	ceqsn	a, p
	ret
	ceqsn	a, #0
	ret
	ret	#1

;--------------------------------------------------------------------------
;  modunsigned.s
;
;  Copyright (C) 2009-2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__moduchar
.globl	__moduint

__moduchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __divu8

	ex	de,hl

        ret

__moduint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __divu16

        ex      de,hl

        ret

;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2001, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; Just stubs - not copyrightable

        ;; Stubs that hook the heap in
        .globl  ___sdcc_heap_init

        .area   _GSINIT
        call    ___sdcc_heap_init

        .area   _HEAP
___sdcc_heap::
        ;; For now just allocate 1k of heap.
        .ds     1023

        .area   _HEAP_END
___sdcc_heap_end::
        .ds     1
;--------------------------------------------------------------------------
;  __ltoa.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___ltoa
	.globl ___ultoa
;
;void __itoa(long value, char *string, unsigned char radix);
;
___ltoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	8(ix) - string
;	10(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
	bit	7, 7 (ix)
	jr	Z, ___ultoa_de
;positive/negative numbers are supported only for radix=10
	ld	a, 10 (ix)
	cp	a, #10
	jr	NZ, ___ultoa_de
;add minus sign to result and inverse value
	ld	hl, #0
	or	a, a
	sbc	hl, de
	ex	de, hl
	ld	hl, #0
	ld	c, 6 (ix)
	ld	b, 7 (ix)
	sbc	hl, bc
	ld	6 (ix), l
	ld	7 (ix), h
	ld	l, 8 (ix)
	ld	h, 9 (ix)
	ld	(hl), #0x2D	;minus symbol
	inc	hl
	ld	8 (ix), l
	ld	9 (ix), h
	jr	___ultoa_dehl
;
;void __uitoa(unsigned int value, char *string, unsigned char radix);
;
___ultoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	8(ix) - string
;	10(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
;
___ultoa_de:
	ld	l, 8 (ix)
	ld	h, 9 (ix)
;
___ultoa_dehl:
	ld	a, e
	or	a, d
	or	a, 6 (ix)
	or	a, 7 (ix)
	jr	NZ, 100$
;
	ld	(hl), #0x30
	inc	hl
	jp	190$
100$:
	ld	a, 10 (ix)
	cp	a, #10		;most popular radix
	jr	NZ, 110$
;
;-------- decimal convertion
;this algorithm is 20% faster than generic one
;
	ld	c, l
	ld	b, h
	ld	hl, #-5
	add	hl, sp
	ld	sp, hl
	push	bc
	push	hl
	ld	c, 6 (ix)
	ld	b, 7 (ix)
	push	bc
	push	de
	call	___ultobcd
	ld	hl, #6
	add	hl, sp
	ld	sp, hl
	pop	de		;DE - pointer to string
	inc	hl
	inc	hl		;HL - pointer to BCD value
	ld	b, #5		;number of bytes in BCD value
	ld	a, #0x30	;ASCII code of '0'
103$:
	rrd
	ld	(de), a
	inc	de
	rrd
	ld	(de), a
	inc	de
	inc	hl
	djnz	103$
;
;	ld	sp, hl
;skip trailing zeroes
	ld	b, #10		;real decimal number is at most 10 digits
105$:
	dec	de
	ld	a, (de)
	cp	a, #0x30
	jr	NZ, 107$	;break loop if non-zero found
	djnz	105$
107$:
	inc	de		;always point to symbol next to last significant
	ex	de, hl
	jr	190$
;
;---------------------------
;
110$:
	cp	a, #2
	jr	C, 190$		;radix is less than 2
;
	ld	c, a
	dec	c
	and	a, c
	jr	NZ, 150$
;
;-------- radix is power of 2
;
; DE - lower 16 bits of value, HL - pointer to string, C - mask
120$:
	ld	a, e
	ld	b, c
125$:
	srl	7 (ix)
	rr	6 (ix)
	rr	d
	rr	e
	srl	b
	jr	NZ, 125$
;
	and	a, c
	add	a, #0x30
	cp	a, #0x3A ;convert to 0...9A...Z
	jr	C, 130$
	add	a, #7
130$:
	ld	(hl), a
	inc	hl
	ld	a, e
	or	a, d
	or	a, 6 (ix)
	or	a, 7 (ix)
	jr	NZ, 120$
	jr	190$
;
;---------------------------
;
;-------- custom radix (generic algorithm)
;
150$:
	ex	de, hl
	ld	c, e
	ld	b, d
	ld	e, 6 (ix)
	ld	d, 7 (ix)
160$:
	push	bc
	ld	c, 10 (ix)
	call	___divu32_8
	pop	bc
	add	a, #0x30
	cp	a, #0x3A
	jr	C, 165$
	add	a, #7
165$:
	ld	(bc), a
	inc	bc
	ld	a, l
	or	a, h
	or	a, e
	or	a, d
	jr	NZ, 160$
	ld	l, c
	ld	h, b
;	jr	190$
;
;---------------------------
;
;-------- finish string and reverse order
190$:
	ld	(hl), #0
	ld	e, 8 (ix)
	ld	d, 9 (ix)
	call	___strreverse_reg
	ld	sp, ix
	pop	ix
	ret
;
;in: DEHL - divident, C - divisor
;out: DEHL - quotient, A - remainder
___divu32_8:
	xor	a, a
	ld	b, #32
100$:
	add	hl, hl
	rl	e
	rl	d
	rla
	jr	c, 110$
	cp	a, c
	jr	c, 120$
110$:
	sub	a, c
	inc	l
120$:
	djnz	100$
	ret

;--------------------------------------------------------------------------
;  memcpy.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memcpy
	.globl ___memcpy

; The Z80 has the ldir instruction, which is perfect for implementing memcpy().
_memcpy:
___memcpy:
	pop	af
	pop	hl	;return value expected to be in HL, so pop dst to HL
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	ex	de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  modmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__modsuchar
.globl	__moduschar

__modsuchar:
	ld      hl,#2+1
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)
	ld      h,#0

	call    __div_signexte

	jp	__get_remainder

__moduschar:
	ld      hl,#2+1
	ld      d, h
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)

	ld      a,l	; Sign extend
	rlca
	sbc     a, a
	ld      h, a

	call	__div16

	jp	__get_remainder

;--------------------------------------------------------------------------
;  strcpy.s
;
;  Copyright (C) 2012, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strcpy

_strcpy:
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
	push	de
	xor	a, a
loop:
	cp	a, (hl)
	ldi
	jr	NZ, loop
	pop	hl
	ret

;--------------------------------------------------------------------------
;  divsigned.s
;
;  Copyright (C) 2000-2010, Michael Hope, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area	_CODE

.globl	__divsint
.globl	__divschar

__divsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jp      __div16

__divschar:
        ld      hl, #2+1
        add     hl, sp

        ld      e, (hl)
        dec     hl
        ld      l, (hl)

__div8::
        ld      a, l            ; Sign extend
        rlca
        sbc     a,a
        ld      h, a
__div_signexte::
        ld      a, e            ; Sign extend
        rlca
        sbc     a,a
        ld      d, a
        ; Fall through to __div16

        ;; signed 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;
        ;; Register used: AF,B,DE,HL
__div16::
        ;; Determine sign of quotient by xor-ing high bytes of dividend
        ;;  and divisor. Quotient is positive if signs are the same, negative
        ;;  if signs are different
        ;; Remainder has same sign as dividend
        ld      a, h            ; Get high byte of dividend
        xor     a, d            ; Xor with high byte of divisor
        rla                     ; Sign of quotient goes into the carry
        ld      a, h            ; Get high byte of dividend
        push    af              ; Save sign of both quotient and reminder

        ; Take absolute value of dividend
        rla
        jr      NC, .chkde      ; Jump if dividend is positive
        sub     a, a            ; Substract dividend from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a

        ; Take absolute value of divisor
.chkde:
        bit     7, d
        jr      Z, .dodiv       ; Jump if divisor is positive
        sub     a, a            ; Subtract divisor from 0
        sub     a, e
        ld      e, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, d
        ld      d, a

        ; Divide absolute values
.dodiv:
        call    __divu16

.fix_quotient:
        ; Negate quotient if it is negative
        pop     af              ; recover sign of quotient
        ret	NC		; Jump if quotient is positive
        ld      b, a
        sub     a, a            ; Subtract quotient from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ld      a, b
	ret

__get_remainder::
        ; Negate remainder if it is negative and move it into hl
        rla
	ex	de, hl
        ret     NC              ; Return if remainder is positive
        sub     a, a            ; Subtract remainder from 0
        sub     a, l
        ld      l, a
        sbc     a, a             ; Propagate remainder (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ret

;--------------------------------------------------------------------------
;  divunsigned.s
;
;  Copyright (C) 2000-2012, Michael Hope, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        ;; Originally from GBDK by Pascal Felber.

.area   _CODE

.globl	__divuint
.globl	__divuchar

__divuint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jr      __divu16

__divuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ;; Fall through
__divu8::
        ld      h,#0x00
        ld      d,h
        ; Fall through to __divu16

        ;; unsigned 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;   carry = 0
        ;;   If divisor is 0, quotient is set to "infinity", i.e HL = 0xFFFF.
        ;;
        ;; Register used: AF,B,DE,HL
__divu16::
        ;; Two algorithms: one assumes divisor <2^7, the second
        ;; assumes divisor >=2^7; choose the applicable one.
        ld      a,e
        and     a,#0x80
        or      a,d
        jr      NZ,.morethan7bits
        ;; Both algorithms "rotate" 24 bits (H,L,A) but roles change.

        ;; unsigned 16/7-bit division
.atmost7bits:
        ld      b,#16           ; bits in dividend and possible quotient
        ;; Carry cleared by AND/OR, this "0" bit will pass trough HL.[*]
        adc     hl,hl
.dvloop7:
        ;; HL holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry.
        ;; A holds remainder.
        rla

        ;; If remainder is >= divisor, next bit of quotient is 1.  We try
        ;;  to compute the difference.
        sub     a,e
        jr      NC,.nodrop7     ; Jump if remainder is >= dividend
        add     a,e             ; Otherwise, restore remainder
        ;; The add above sets the carry, because sbc a,e did set it.
.nodrop7:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        adc     hl,hl
        djnz    .dvloop7
        ;; Carry now contains the same value it contained before
        ;; entering .dvloop7[*]: "0" = valid result.
        ld      e,a             ; DE = remainder, HL = quotient
        ret

.morethan7bits:
        ld      b,#9            ; at most 9 bits in quotient.
        ld      a,l             ; precompute the first 7 shifts, by
        ld      l,h             ;  doing 8
        ld      h,#0
        rr      l               ;  undoing 1
.dvloop:
        ;; Shift next bit of quotient into bit 0 of dividend
        ;; Shift next MSB of dividend into LSB of remainder
        ;; A holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry
        ;; HL holds remainder
        adc     hl,hl           ; HL < 2^(7+9), no carry, ever.

        ;; If remainder is >= divisor, next bit of quotient is 1. We try
        ;;  to compute the difference.
        sbc     hl,de
        jr      NC,.nodrop      ; Jump if remainder is >= dividend
        add     hl,de           ; Otherwise, restore remainder
	;; The add above sets the carry, because sbc hl,de did set it.
.nodrop:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        rla
        djnz    .dvloop
        ;; Take care of the ninth quotient bit! after the loop B=0.
        rl      b               ; BA = quotient
        ;; Carry now contains "0" = valid result.
        ld      d,b
        ld      e,a             ; DE = quotient, HL = remainder
        ex      de,hl           ; HL = quotient, DE = remainder
        ret

;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _atomic_flag_test_and_set

_atomic_flag_test_and_set:
	pop	de
	pop	hl
	push	hl
	push	de
	xor a, a
	srl	(hl)
	ccf
	rla
	ld	l, a
	ret

;--------------------------------------------------------------------------
;  __strreverse.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___strreverse
	.globl ___strreverse_reg
;
;void __reverse(char *beg, char *end);
;
___strreverse::
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
;
;in: HL - pointer to end of string (null symbol), DE - pointer to start of string
;
___strreverse_reg::
	jr	110$
100$:
	add	hl, de
	ld	a, (de)
	ld	c, (hl)
	ld	(hl), a
	ld	a, c
	ld	(de), a
	inc	de
110$:
	dec	hl
	or	a, a
	sbc	hl, de
	jr	NC, 100$
	ret
;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (c) 2017, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

; unsigned char x unsigned char multiplication is done by code generation.

.globl	__mulsuchar
.globl	__muluschar
.globl	__mulschar

; operands have different sign

__mulsuchar:
        ld      hl,#2+1
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        jr      signexte

__muluschar:
        ld      hl,#2
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      c,(hl)
        jr      signexte

__mulschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)

        ;; Need to sign extend before going in.
        ld      a,c
        rla
        sbc     a,a
        ld      b,a
signexte:
        ld      a,e
        rla
        sbc     a,a
        ld      d,a

        jp      __mul16

;--------------------------------------------------------------------------
;  crtenter.s
;
;  Copyright (C) 2015, Alan Cox, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_enter_ix

; Factor out some start of function code to reduce code size

___sdcc_enter_ix:
	pop	hl	; return address
	push	ix	; save frame pointer
	ld	ix, #0
	add	ix, sp	; set ix to the stack frame
	jp	(hl)	; and return

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_iy

; The Z80 has the jp (iy) instruction, which is perfect for implementing function pointers.

___sdcc_call_iy:
	jp	(iy)

;--------------------------------------------------------------------------
;  memmove.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memmove

; The Z80 has the ldir and lddr instructions, which are perfect for implementing memmove().

_memmove:
	pop	af
	pop	hl
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	sbc	hl, de		; or above cleared carry.
	add	hl, de		; same carry as the line before
	jr	C, memmove_up
memmove_down:
	dec	bc
	add	hl, bc
	ex      de, hl
	add	hl, bc
	inc	bc
	lddr
	pop	hl
	ret
memmove_up:
	ex      de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  setjmp.s
;
;  Copyright (C) 2011-2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___setjmp

___setjmp:
	pop	hl
	pop	iy
	push	af
	push	hl

	; Store return address.
	ld	0(iy), l
	ld	1(iy), h

	; Store stack pointer.
	xor	a, a
	ld	l, a
	ld	h, a
	add	hl, sp
	ld	2(iy), l
	ld	3(iy), h

	; Store frame pointer.
	push	ix
	pop	hl
	ld	4(iy), l
	ld	5(iy), h

	; Return 0.
	ld	l, a
	ld	h, a
	ret

.globl _longjmp

_longjmp:
	pop	af
	pop	iy
	pop	de

	; Ensure that return value is non-zero.
	ld	a, e
	or	a, d
	jr	NZ, jump
	inc	de
jump:

	; Restore frame pointer.
	ld	l, 4(iy)
	ld	h, 5(iy)
	push	hl
	pop	ix

	; Adjust stack pointer.
	ld	l, 2(iy)
	ld	h, 3(iy)
	ld	sp, hl
	pop	hl

	; Move return value into hl.
	ex	de, hl

	; Jump.
	ld	c, 0(iy)
	ld	b, 1(iy)
	push	bc
	ret
;--------------------------------------------------------------------------
;  __uitobcd.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___uitobcd
;
; void __uitobcd (unsigned int v, unsigned char bcd[3])
; __uitobcd converts v to BCD representation to the bcd.
; bcd[] will contain BCD value.
;
___uitobcd:
	push	ix
	ld	ix, #0
	add	ix, sp
;
	ld	bc, #0x1000
	ld	d, c
	ld	e, c
	ld	l, 4 (ix)
	ld	h, 5 (ix)
;
;--- begin speed optimization
;
	ld	a, h
	or	a, a
	jr	NZ, 100$
;
	ld	h, l
	srl	b
;
;--- end speed optimization
;
; HL - binary value
; CDE - future BCD value
; B - bits count (16)
100$:
	add	hl, hl
	ld	a, e
	adc	a, a
	daa
	ld	e, a
	ld	a, d
	adc	a, a
	daa
	ld	d, a
	ld	a, c
	adc	a, a
	daa
	ld	c, a
	djnz	100$
;
	ld	l, 6 (ix)
	ld	h, 7 (ix)
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	ld	(hl), c
;
	pop	ix
	ret
;--------------------------------------------------------------------------
;  abs.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _abs

; 12B; 86T for nonnegative arguments, 78T for negative.
_abs:
	pop	hl
	pop	de
	push	de
	push	hl
	xor	a, a
	ld	l, a
	ld	h, a
	sbc	hl, de
	ret	P
	ex	de, hl
	ret

; 14B; 59T for nonegative arguments, 94T for negative:
;_abs:
;	pop	de
;	pop	hl
;	push	hl
;	push	de
;	bit	7, h
;	ret	Z
;	xor	a, a
;	ld	e, a
;	ld	d, a
;	ex	de, hl
;	sbc	hl, de
;	ret

;--------------------------------------------------------------------------
;  strlen.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _strlen

; The Z80 has the cpir instruction, which is perfect for implementing strlen().

_strlen:
	pop	bc
	pop	hl
	push	hl
	push	bc
	xor	a, a
	ld	b, a
	ld	c, a
	cpir
	ld	hl, #-1
	sbc	hl, bc	; C flag still cleared from xor above.
	ret

;--------------------------------------------------------------------------
;  __ultobcd.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___ultobcd
;
; void __ultobcd (unsigned long v, unsigned char bcd[5])
; __ultobcd converts v to BCD representation to the bcd.
; bcd[] will contain BCD value.
;
___ultobcd:
	push	ix
	ld	ix, #0
	add	ix, sp
	ld	bc, #0x2000
;
;--- begin speed optimization
;
	ld	l, 4 (ix)
	ld	h, 5 (ix)
	ld	e, 6 (ix)
	ld	d, 7 (ix)
	ld	a, e
	or	a, d
	jr	NZ, 101$
;high 2 bytes are zero
	ld	b, #0x10
	ex	de, hl
101$:
	ld	a, d
	or	a, a
	jr	NZ, 102$
;high byte is zero
	ld	d, e
	ld	e, h
	ld	h, l
	ld	a, #-8
	add	a, b
	ld	b, a
102$:
	ld	4 (ix), l
	ld	5 (ix), h
	ld	6 (ix), e
	ld	7 (ix), d
;
;--- end speed optimization
;
	ld	hl, #0x0000
	ld	e, l
	ld	d, h
; (ix+0)..(ix+3) - binary value
; CDEHL - future BCD value
; B - bits count (32)
103$:
	sla	4 (ix)
	rl	5 (ix)
	rl	6 (ix)
	rl	7 (ix)
	ld	a, l
	adc	a, a
	daa
	ld	l, a
	ld	a, h
	adc	a, a
	daa
	ld	h, a
	ld	a, e
	adc	a, a
	daa
	ld	e, a
	ld	a, d
	adc	a, a
	daa
	ld	d, a
	ld	a, c
	adc	a, a
	daa
	ld	c, a
	djnz	103$
;
	ld	b, l
	ld	a, h
	ld	l, 8 (ix)
	ld	h, 9 (ix)
	ld	(hl), b
	inc	hl
	ld	(hl), a
	inc	hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	ld	(hl), c
;
	pop	ix
	ret
;--------------------------------------------------------------------------
;  divmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__divsuchar
.globl	__divuschar

__divsuchar:
	ld	hl, #2+1
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)
	ld	h, #0

	jp	__div_signexte

__divuschar:
	ld	hl, #2+1
	ld	d, h
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)

	ld 	a, l	; Sign extend
	rlca
	sbc	a, a
	ld	h, a

	jp	__div16

;--------------------------------------------------------------------------
;  __itoa.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___itoa
	.globl ___uitoa
;
;void __itoa(int value, char *string, unsigned char radix);
;
___itoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	6(ix) - string
;	8(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
	bit	7, d
	jr	Z, ___uitoa_de
;positive/negative numbers are supported only for radix=10
	ld	a, 8 (ix)
	cp	a, #10
	jr	NZ, ___uitoa_de
;add minus sign to result and inverse value
	ld	hl, #0
	or	a, a
	sbc	hl, de
	ex	de, hl
	ld	l, 6 (ix)
	ld	h, 7 (ix)
	ld	(hl), #0x2D	;minus symbol
	inc	hl
	ld	6 (ix), l
	ld	7 (ix), h
	jr	___uitoa_dehl
;
;void __uitoa(unsigned int value, char *string, unsigned char radix);
;
___uitoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	6(ix) - string
;	8(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
;
___uitoa_de:
	ld	l, 6 (ix)
	ld	h, 7 (ix)
;
___uitoa_dehl:
	ld	a, e
	or	a, d
	jr	NZ, 100$
;
	ld	(hl), #0x30
	inc	hl
	jp	190$
100$:
	ld	a, 8 (ix)
	cp	a, #10		;most popular radix
	jr	NZ, 110$
;
;-------- decimal convertion
; this algorithm up to 2 times faster than generic
;
	ld	c, l
	ld	b, h
	ld	hl, #-4
	add	hl, sp
	ld	sp, hl
	push	bc
	push	hl
	push	de
	call	___uitobcd
	ld	hl, #4
	add	hl, sp
	ld	sp, hl
	pop	de		;DE - pointer to string
	inc	hl
	inc	hl		;HL - pointer to BCD value
	ld	b, #3		;number of bytes in BCD value
	ld	a, #0x30	;ASCII code of '0'
103$:
	rrd
	ld	(de), a
	inc	de
	rrd
	ld	(de), a
	inc	de
	inc	hl
	djnz	103$
;
;	pop	af
;	pop	af
;skip trailing zeroes
	ld	b, #5		;real BCD number is at most 5 digits
	dec	de		;so always skip last zero
105$:
	dec	de
	ld	a, (de)
	cp	a, #0x30
	jr	NZ, 107$	;break loop if non-zero found
	djnz	105$
107$:
	inc	de		;always point to symbol next to last significant
	ex	de, hl
	jr	190$
;
;---------------------------
;
110$:
	cp	a, #2
	jr	C, 190$		;radix is less than 2
;
	ld	c, a
	dec	c
	and	a, c
	jr	NZ, 150$
;
;-------- radix is power of 2
;
; DE - value, HL - pointer to string, C - mask
120$:
	ld	a, e
	ld	b, c
125$:
	srl	d
	rr	e
	srl	b
	jr	NZ, 125$
;
	and	a, c
	add	a, #0x30
	cp	a, #0x3A ;convert to 0...9A...Z
	jr	C, 130$
	add	a, #7
130$:
	ld	(hl), a
	inc	hl
	ld	a, e
	or	a, d
	jr	NZ, 120$
	jr	190$
;
;---------------------------
;
;-------- custom radix (generic algorithm)
;
150$:
	ex	de, hl
160$:
	ld	c, 8 (ix)
	call	___divu16_8
	add	a, #0x30
	cp	a, #0x3A
	jr	C, 165$
	add	a, #7
165$:
	ld	(de), a
	inc	de
	ld	a, l
	or	h
	jr	NZ, 160$
	ex	de, hl
;	jr	190$
;
;---------------------------
;
;-------- finish string and reverse order
190$:
	ld	(hl), #0
	ld	e, 6 (ix)
	ld	d, 7 (ix)
	call	___strreverse_reg
	ld	sp, ix
	pop	ix
	ret
;
;
;in: HL - divident, C - divisor
;out: HL - quotient, A - remainder
___divu16_8:
	xor	a, a
	ld	b, #16
100$:
	add	hl, hl
	rla
	jr	c, 110$
	cp	a, c
	jr	c, 120$
110$:
	sub	a, c
	inc	l
120$:
	djnz	100$
	ret

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_hl

; The Z80 has the jp (hl) instruction, which is perfect for implementing function pointers.

___sdcc_call_hl:
	jp	(hl)

;--------------------------------------------------------------------------
;  __sdcc_bcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; This file contains generic trampolines for banked function calls.
; They are not complete. Programmer must provide set_bank and get_bank
; routines. Or rewrite whole code completely.
;
	.area   _CODE

	.globl ___sdcc_bcall
	.globl ___sdcc_bcall_abc
	.globl ___sdcc_bcall_ehl
;
; trampoline to call banked functions
; used when legacy banking is enabled only
; Usage:
;   call ___sdcc_bcall
;   .dw  <function>
;   .dw  <function_bank>
;
___sdcc_bcall::
	ex	(sp), hl
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	ld	a, (hl)
	inc	hl
	inc	hl
	ex	(sp), hl
;
; trampoline to call banked functions with __z88dk_fastcall calling convention
; Usage:
;  ld   a, #<function_bank>
;  ld   bc, #<function>
;  call ___sdcc_bcall_abc
;
___sdcc_bcall_abc::
	push	hl
	ld	l, a
	call	get_bank	;must return A as current bank number, other registers expected to be unchanged
	ld	h, a
	ld	a, l
	ex	(sp), hl
	inc	sp
	call	___sdcc_bjump_abc
	dec	sp
	pop	af
	jp	set_bank
;
___sdcc_bjump_abc:
	call	set_bank	;set current bank to A, other registers expected to be unchanged
	push	bc
	ret
;
; default trampoline to call banked functions
; Usage:
;  ld   e, #<function_bank>
;  ld   hl, #<function>
;  call ___sdcc_bcall_ehl
;
___sdcc_bcall_ehl::
	call	get_bank
	push	af
	inc	sp
	call	___sdcc_bjump_ehl
	dec	sp
	pop	af
	jp	set_bank
;
___sdcc_bjump_ehl:
	ld	a, e
	call	set_bank
	jp	(hl)
;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (C) 2017, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.hd64
.area   _CODE

; 16 x 16 -> 16 multiplication.

.globl	__mulint

__mulint:
        pop     af
        pop     bc
        pop     de
        push    de
        push    bc
        push    af

	;; 16-bit multiplication
	;;
	;; Entry conditions
	;; bc = multiplicand
	;; de = multiplier
	;;
	;; Exit conditions
	;; hl = less significant word of product
	;;
	;; Register used: AF,BC,DE,HL

__mul16::

	; Swap lower bytes while also copying them into hl
	ld	l, c
	ld	h, e
	ld	e, l
	ld	c, h

	mlt	bc
	mlt	de
	mlt	hl

	ld	a, c
	add	a, e
	add	a, h
	ld	h, a

        ret

;--------------------------------------------------------------------------
;  crt0.s - Generic crt0.s for a Z80
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.module crt0
	.globl	_main

	.area	_HEADER (ABS)
	;; Reset vector
	.org 	0
	jp	init

	.org	0x08
	ei
	reti
	.org	0x10
	ei
	reti
	.org	0x18
	ei
	reti
	.org	0x20
	ei
	reti
	.org	0x28
	ei
	reti
	.org	0x30
	ei
	reti
	.org	0x38
	ei
	reti

	.org	0x100
init:
	;; Set stack pointer directly above top of memory.
	ld	sp,#0x0000

        ;; Initialise global variables
        call    gsinit
	call	_main
	jp	_exit

	;; Ordering of segments for the linker.
	.area	_HOME
	.area	_CODE
	.area	_INITIALIZER
	.area   _GSINIT
	.area   _GSFINAL

	.area	_DATA
	.area	_INITIALIZED
	.area	_BSEG
	.area   _BSS
	.area   _HEAP

	.area   _CODE
__clock::
	ld	a,#2
	rst     0x08
	ret

_exit::
	;; Exit - special code to the emulator
	ld	a,#0
	rst     0x08
1$:
	halt
	jr	1$

	.area   _GSINIT
gsinit::
	ld	bc, #l__INITIALIZER
	ld	a, b
	or	a, c
	jr	Z, gsinit_next
	ld	de, #s__INITIALIZED
	ld	hl, #s__INITIALIZER
	ldir
gsinit_next:

	.area   _GSFINAL
	ret

;--------------------------------------------------------------------------
;  modsigned.s
;
;  Copyright (C) 2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__modschar
.globl	__modsint

__modschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __div8

        jp	__get_remainder

__modsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __div16

        jp	__get_remainder

sdcc/device/lib/z80
-------------------

Z80 specific routines.

Notes:
* Cost of ld r,(ix+n):	19
* Cost of ld r,(hl); inc hl: 7+6 = 13 and you don't have to pop ix
        ;--------------------------------------------------------------------------
;  modunsigned.s
;
;  Copyright (C) 2009-2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__moduchar
.globl	__moduint

__moduchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __divu8

	ex	de,hl

        ret

__moduint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __divu16

        ex      de,hl

        ret

;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2001, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; Just stubs - not copyrightable

        ;; Stubs that hook the heap in
        .globl  ___sdcc_heap_init

        .area   _GSINIT
        call    ___sdcc_heap_init

        .area   _HEAP
___sdcc_heap::
        ;; For now just allocate 1k of heap.
        .ds     1023

        .area   _HEAP_END
___sdcc_heap_end::
        .ds     1
;--------------------------------------------------------------------------
;  memcpy.s
;
;  Copyright (C) 2020, Sergey Belyashov, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memcpy
	.globl ___memcpy

; The Z80 has the ldir instruction, which is perfect for implementing memcpy(). Unfortunately, it is quite broken on early Rabbits, so we use ldi.
_memcpy:
___memcpy:
	pop	af
	pop	hl	;return value expected to be in HL, so pop dst to HL
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	ex	de, hl
loop:
	ldi
	jp	LO, loop
	pop	hl
	ret

;--------------------------------------------------------------------------
;  modmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__modsuchar
.globl	__moduschar

__modsuchar:
	ld      hl,#2+1
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)
	ld      h,#0

	call    __div_signexte

	jp	__get_remainder

__moduschar:
	ld      hl,#2+1
	ld      d, h
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)

	ld      a,l	; Sign extend
	rlca
	sbc     a, a
	ld      h, a

	call	__div16

	jp	__get_remainder

;--------------------------------------------------------------------------
;  strcpy.s
;
;  Copyright (C) 2012, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strcpy

_strcpy:
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
	push	de
	xor	a, a
loop:
	cp	a, (hl)
	ldi
	jr	NZ, loop
	pop	hl
	ret

;--------------------------------------------------------------------------
;  divsigned.s
;
;  Copyright (C) 2000-2010, Michael Hope, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area	_CODE

.globl	__divsint
.globl	__divschar

__divsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jp      __div16

__divschar:
        ld      hl, #2+1
        add     hl, sp

        ld      e, (hl)
        dec     hl
        ld      l, (hl)

__div8::
        ld      a, l            ; Sign extend
        rlca
        sbc     a,a
        ld      h, a
__div_signexte::
        ld      a, e            ; Sign extend
        rlca
        sbc     a,a
        ld      d, a
        ; Fall through to __div16

        ;; signed 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;
        ;; Register used: AF,B,DE,HL
__div16::
        ;; Determine sign of quotient by xor-ing high bytes of dividend
        ;;  and divisor. Quotient is positive if signs are the same, negative
        ;;  if signs are different
        ;; Remainder has same sign as dividend
        ld      a, h            ; Get high byte of dividend
        xor     a, d            ; Xor with high byte of divisor
        rla                     ; Sign of quotient goes into the carry
        ld      a, h            ; Get high byte of dividend
        push    af              ; Save sign of both quotient and reminder

        ; Take absolute value of dividend
        rla
        jr      NC, .chkde      ; Jump if dividend is positive
        sub     a, a            ; Substract dividend from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a

        ; Take absolute value of divisor
.chkde:
        bit     7, d
        jr      Z, .dodiv       ; Jump if divisor is positive
        sub     a, a            ; Subtract divisor from 0
        sub     a, e
        ld      e, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, d
        ld      d, a

        ; Divide absolute values
.dodiv:
        call    __divu16

.fix_quotient:
        ; Negate quotient if it is negative
        pop     af              ; recover sign of quotient
        ret	NC		; Jump if quotient is positive
        ld      b, a
        sub     a, a            ; Subtract quotient from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ld      a, b
	ret

__get_remainder::
        ; Negate remainder if it is negative and move it into hl
        rla
	ex	de, hl
        ret     NC              ; Return if remainder is positive
        sub     a, a            ; Subtract remainder from 0
        sub     a, l
        ld      l, a
        sbc     a, a             ; Propagate remainder (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ret

;--------------------------------------------------------------------------
;  divunsigned.s
;
;  Copyright (C) 2000-2012, Michael Hope, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        ;; Originally from GBDK by Pascal Felber.

.area   _CODE

.globl	__divuint
.globl	__divuchar

__divuint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jr      __divu16

__divuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ;; Fall through
__divu8::
        ld      h,#0x00
        ld      d,h
        ; Fall through to __divu16

        ;; unsigned 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;   carry = 0
        ;;   If divisor is 0, quotient is set to "infinity", i.e HL = 0xFFFF.
        ;;
        ;; Register used: AF,B,DE,HL
__divu16::
        ;; Two algorithms: one assumes divisor <2^7, the second
        ;; assumes divisor >=2^7; choose the applicable one.
        ld      a,e
        and     a,#0x80
        or      a,d
        jr      NZ,.morethan7bits
        ;; Both algorithms "rotate" 24 bits (H,L,A) but roles change.

        ;; unsigned 16/7-bit division
.atmost7bits:
        ld      b,#16           ; bits in dividend and possible quotient
        ;; Carry cleared by AND/OR, this "0" bit will pass trough HL.[*]
        adc     hl,hl
.dvloop7:
        ;; HL holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry.
        ;; A holds remainder.
        rla

        ;; If remainder is >= divisor, next bit of quotient is 1.  We try
        ;;  to compute the difference.
        sub     a,e
        jr      NC,.nodrop7     ; Jump if remainder is >= dividend
        add     a,e             ; Otherwise, restore remainder
        ;; The add above sets the carry, because sbc a,e did set it.
.nodrop7:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        adc     hl,hl
        djnz    .dvloop7
        ;; Carry now contains the same value it contained before
        ;; entering .dvloop7[*]: "0" = valid result.
        ld      e,a             ; DE = remainder, HL = quotient
        ret

.morethan7bits:
        ld      b,#9            ; at most 9 bits in quotient.
        ld      a,l             ; precompute the first 7 shifts, by
        ld      l,h             ;  doing 8
        ld      h,#0
        rr      l               ;  undoing 1
.dvloop:
        ;; Shift next bit of quotient into bit 0 of dividend
        ;; Shift next MSB of dividend into LSB of remainder
        ;; A holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry
        ;; HL holds remainder
        adc     hl,hl           ; HL < 2^(7+9), no carry, ever.

        ;; If remainder is >= divisor, next bit of quotient is 1. We try
        ;;  to compute the difference.
        sbc     hl,de
        jr      NC,.nodrop      ; Jump if remainder is >= dividend
        add     hl,de           ; Otherwise, restore remainder
	;; The add above sets the carry, because sbc hl,de did set it.
.nodrop:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        rla
        djnz    .dvloop
        ;; Take care of the ninth quotient bit! after the loop B=0.
        rl      b               ; BA = quotient
        ;; Carry now contains "0" = valid result.
        ld      d,b
        ld      e,a             ; DE = quotient, HL = remainder
        ex      de,hl           ; HL = quotient, DE = remainder
        ret

;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _atomic_flag_test_and_set

_atomic_flag_test_and_set:
	ld	hl, 2 (sp)
	xor a, a
	srl	(hl)
	ccf
	rla
	ld	l, a
	ret

;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (c) 2017, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

; unsigned char x unsigned char multiplication is done by code generation.

.globl	__mulsuchar
.globl	__muluschar
.globl	__mulschar

; operands have different sign

__mulsuchar:
        ld      hl,#2+1
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        jr      signexte

__muluschar:
        ld      hl,#2
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      c,(hl)
        jr      signexte

__mulschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)

        ;; Need to sign extend before going in.
        ld      a,c
        rla
        sbc     a,a
        ld      b,a
signexte:
        ld      a,e
        rla
        sbc     a,a
        ld      d,a

        jp      __mul16

;--------------------------------------------------------------------------
;  crtenter.s
;
;  Copyright (C) 2015, Alan Cox, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_enter_ix

; Factor out some start of function code to reduce code size

___sdcc_enter_ix:
	pop	hl	; return address
	push	ix	; save frame pointer
	ld	ix, #0
	add	ix, sp	; set ix to the stack frame
	jp	(hl)	; and return

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_iy

; The Z80 has the jp (iy) instruction, which is perfect for implementing function pointers.

___sdcc_call_iy:
	jp	(iy)

;--------------------------------------------------------------------------
;  memmove.s
;
;  Copyright (C) 2008-2020, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memmove

; The Z80 has the ldir and lddr instructions, which are perfect for implementing memmove(). Unfortunately, it is broken on early Rabbits, so we use ldi and ldd.

_memmove:
	pop	af
	pop	hl
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	sbc	hl, de		; or above cleared carry.
	add	hl, de		; same carry as the line before
	jr	C, memmove_up
memmove_down:
	dec	bc
	add	hl, bc
	ex      de, hl
	add	hl, bc
	inc	bc
loop_down:
	ldd
	jp	LO, loop_down
	pop	hl
	ret
memmove_up:
	ex      de, hl
loop_up:
	ldi
	jp	LO, loop_up
	pop	hl
	ret

;--------------------------------------------------------------------------
;  setjmp.s
;
;  Copyright (C) 2011-2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___setjmp

___setjmp:
	pop	hl
	pop	iy
	push	af
	push	hl

	; Store return address.
	ld	0(iy), l
	ld	1(iy), h

	; Store stack pointer.
	xor	a, a
	ld	l, a
	ld	h, a
	add	hl, sp
	ld	2(iy), l
	ld	3(iy), h

	; Store frame pointer.
	push	ix
	pop	hl
	ld	4(iy), l
	ld	5(iy), h

	; Return 0.
	ld	l, a
	ld	h, a
	ret

.globl _longjmp

_longjmp:
	pop	af
	pop	iy
	pop	de

	; Ensure that return value is non-zero.
	ld	a, e
	or	a, d
	jr	NZ, jump
	inc	de
jump:

	; Restore frame pointer.
	ld	l, 4(iy)
	ld	h, 5(iy)
	push	hl
	pop	ix

	; Adjust stack pointer.
	ld	l, 2(iy)
	ld	h, 3(iy)
	ld	sp, hl
	pop	hl

	; Move return value into hl.
	ex	de, hl

	; Jump.
	ld	c, 0(iy)
	ld	b, 1(iy)
	push	bc
	ret
;--------------------------------------------------------------------------
;  abs.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _abs

; 12B; 86T for nonnegative arguments, 78T for negative.
_abs:
	pop	hl
	pop	de
	push	de
	push	hl
	xor	a, a
	ld	l, a
	ld	h, a
	sbc	hl, de
	ret	P
	ex	de, hl
	ret

; 14B; 59T for nonegative arguments, 94T for negative:
;_abs:
;	pop	de
;	pop	hl
;	push	hl
;	push	de
;	bit	7, h
;	ret	Z
;	xor	a, a
;	ld	e, a
;	ld	d, a
;	ex	de, hl
;	sbc	hl, de
;	ret

;--------------------------------------------------------------------------
;  divmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__divsuchar
.globl	__divuschar

__divsuchar:
	ld	hl, #2+1
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)
	ld	h, #0

	jp	__div_signexte

__divuschar:
	ld	hl, #2+1
	ld	d, h
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)

	ld 	a, l	; Sign extend
	rlca
	sbc	a, a
	ld	h, a

	jp	__div16

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_hl

; The Z80 has the jp (hl) instruction, which is perfect for implementing function pointers.

___sdcc_call_hl:
	jp	(hl)

;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__mulint

__mulint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        ;; Fall through

	;; Parameters:
	;;	hl, de (left, right irrelevant)
	ld	b,h
	ld	c,l

	;; 16-bit multiplication
	;;
	;; Entry conditions
	;; bc = multiplicand
	;; de = multiplier
	;;
	;; Exit conditions
	;; hl = less significant word of product
	;;
	;; Register used: AF,BC,DE,HL
__mul16::
	xor	a,a
	ld	l,a
	or	a,b
	ld	b,#16

        ;; Optimise for the case when this side has 8 bits of data or
        ;; less.  This is often the case with support address calls.
        jr      NZ,2$
        ld      b,#8
        ld      a,c
1$:
        ;; Taken from z88dk, which originally borrowed from the
        ;; Spectrum rom.
        add     hl,hl
2$:
        rl      c
        rla                     ;DLE 27/11/98
        jr      NC,3$
        add     hl,de
3$:
        djnz    1$
        ret

;--------------------------------------------------------------------------
;  crt0.s - Generic crt0.s for a Rabbit 2000
;	derived from "Generic crt0.s for a Z80"
;
;  Copyright (C) 2000, Michael Hope
;  Modified for Rabbit by Leland Morrison 2011
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.module crt0
	.globl	_main
	.globl	__sdcc_external_startup

GCSR		.equ	0x00 ; Global control / status register
MMIDR		.equ	0x10
STACKSEG	.equ	0x11
SEGSIZE		.equ	0x13
MB0CR		.equ	0x14 ; Memory Bank 0 Control Register
MB1CR		.equ	0x15 ; Memory Bank 1 Control Register
MB2CR		.equ	0x16 ; Memory Bank 2 Control Register
MB3CR		.equ	0x17 ; Memory Bank 3 Control Register

	.area	_HEADER (ABS)

	; Reset vector - assuming smode0 and smode1 input pins are grounded
	.org 	0

	; setup internal interrupts
	ld	a, #1
	ld	iir, a

	; Configure physical address space.
	; Leave MB0CR Flash at default slow at /OE0, /CS0
	; Assume slow RAM at /CS1, /OE1, /WE1
	ld	a, #0x05
	ioi
	ld	(MB2CR), a;

	; Configure logical address space. 32 KB root segment followed by 8 KB data segment, 16 KB stack segement, 8 KB xpc segment.
	; By default, SDCC will use the root segment for code and constant data, stack segment for data (including stack). data segment and xpc segement are then unused.
	ld	a, #0xa8	; 16 KB stack segment at 0xa000, 8 KB data segment at 0x8000
	ioi
	ld	(SEGSIZE), a

	; Configure mapping to physical address space.
	ld	a, #0x76
	ioi
	ld	(STACKSEG), a	; stack segment base at 0x76000 + 0xa000 = 0x80000

	; Set stack pointer directly above top of stack segment
	ld	sp, #0xe000

	call __sdcc_external_startup

	; Initialise global variables
	call	gsinit

	call	_main
	jp	_exit

	; Periodic Interrupt
	.org	0x100
	push	af
	ioi
	ld	a, (GCSR) ; clear interrupt
	pop	af
	reti

	; Secondary Watchdog - Rabbit 3000A only
	.org	0x100
	reti

	; rst 0x10
	.org	0x120
	ret

	; rst 0x18
	.org	0x130
	ret

	; rst 0x20
	.org	0x140
	ret

	; rst 0x28
	.org	0x150
	ret

	; Syscall instruction - Rabbit 3000A only
	.org	0x160
	ret

	; rst 0x38
	.org	0x170
	ret

	; Slave Port
	.org	0x180
	reti

	; Timer A
	.org	0x1a0
	reti

	; Timer B
	.org	0x1b0
	reti

	; Serial Port A
	.org	0x1c0
	reti

	; Serial Port B
	.org	0x1d0
	reti

	; Serial Port C
	.org	0x1e0
	reti

	; Serial Port D
	.org	0x1f0
	reti

	.org	0x200

	;; Ordering of segments for the linker.
	.area	_HOME
	.area	_CODE
	.area	_INITIALIZER
	.area   _GSINIT
	.area   _GSFINAL

	.area	_DATA
	.area	_INITIALIZED
	.area	_BSEG
	.area   _BSS
	.area   _HEAP

	.area   _CODE
_exit::
	;; Exit - special code to the emulator
	ld	a,#0
	rst     #0x28
1$:
	;halt		; opcode for halt used for 'altd' on rabbit processors
	jr	1$

	.area   _GSINIT
gsinit::
	ld	bc, #l__DATA
	ld	a, b
	or	a, c
	jr	Z, zeroed_data
	ld	hl,	#s__DATA
	ld	(hl), #0x00
	dec	bc
	ld	a, b
	or	a, c
	jr	Z, zeroed_data
	ld	e, l
	ld	d, h
	inc	de
zero_loop:
	ldi	; Work around new ldir wait state bug.
	jp	LO, zero_loop

zeroed_data:

	ld	bc, #l__INITIALIZER
	ld	a, b
	or	a, c
	jr	Z, gsinit_next
	ld	de, #s__INITIALIZED
	ld	hl, #s__INITIALIZER
copy_loop:
	ldi	; Work around new ldir wait state bug.
	jp	LO, copy_loop
gsinit_next:

	.area   _GSFINAL
	ret

;--------------------------------------------------------------------------
;  modsigned.s
;
;  Copyright (C) 2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__modschar
.globl	__modsint

__modschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __div8

        jp	__get_remainder

__modsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __div16

        jp	__get_remainder

--- 2011-11-01  Raphael Neider

To accomodate for devices with enhanced cores, there are now
two variants of libm and libsdcc:
Applications targetting regular, non-enhanced devices should
link with libm.lib and libsdcc.lib (no change).
Applications that target enhaned devices should link with
libme.lib and libsdcce.lib instead. When the linker is
invoked via sdcc, the proper libsdcc{,e}.lib will be chosen
automatically -- no such mechanism has been established for
libm{,e}.lib!

The build system has also been converted to an Automake-based
one and libdev/ has been moved completely to the non-free
subtree.

--- 2006-03-21  Raphael Neider

Added device specific SFR definitions in libdev/.
From now on all projects should be linked not only with
libsdcc.lib but also with pic$(ARCH).lib where ARCH is
something like p16f877.

--- 2005-10-27  Raphael Neider

Generic pointer support routines and additional arithmetic halpers
have been added to the library.

Although the compiled library should be portable across (all?)
pic14 devices, I recommend selecting the desired target chip
by setting the ARCH variable to the desired target chip in
  - Makefile.common	(AFTER having run ./configure)  OR
  - Makefile.common.in	(BEFORE running ./configure)
in order to maximize performance (smaller devices ignore
BANKSEL directives, i.e. updates to the IRP bit).

--- 2005-09-23  Raphael Neider

The pic14 library is split into several parts:

* common part
  The common part reuses the (hardware independant) sources found 
  under device/lib/ (currently not used).
* pic14 specific part
  The pic14 specific library routines are found in subdirectories of
  device/lib/pic/ and provide specialized implementations better
  suited for the pic14 architecture and additional functions not
  found in (or not reused from) the common sources.
* device specific part
  This part is planned to support specific I/O sub-devices not
  common to all pic14 chips. This part is currently absent...

The SDCC/pic14 library has been created by
	Raphael Neider <rneider AT web.de> (2005)

It is currently maintained by
	Raphael Neider <rneider AT web.de>

The pic14 and the device specific parts (whose sources are found
in device/lib/pic/) are to be licensed nuder the terms of the
GNU Lesser General Public License (LGPL). See COPYING for details.
The sources from the common part are licensed as indicated in each
file.

Requests for enhancements, additions or modifications should be posted
at the SDCC user's or developer's mailing list or directly be sent to
the current maintainer of the library as indicated above.

		  GNU LIBRARY GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1991 Free Software Foundation, Inc.
 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the library GPL.  It is
 numbered 2 because it goes with version 2 of the ordinary GPL.]

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Library General Public License, applies to some
specially designated Free Software Foundation software, and to any
other libraries whose authors decide to use it.  You can use it for
your libraries, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if
you distribute copies of the library, or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link a program with the library, you must provide
complete object files to the recipients so that they can relink them
with the library, after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  Our method of protecting your rights has two steps: (1) copyright
the library, and (2) offer you this license which gives you legal
permission to copy, distribute and/or modify the library.

  Also, for each distributor's protection, we want to make certain
that everyone understands that there is no warranty for this free
library.  If the library is modified by someone else and passed on, we
want its recipients to know that what they have is not the original
version, so that any problems introduced by others will not reflect on
the original authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that companies distributing free
software will individually obtain patent licenses, thus in effect
transforming the program into proprietary software.  To prevent this,
we have made it clear that any patent must be licensed for everyone's
free use or not licensed at all.

  Most GNU software, including some libraries, is covered by the ordinary
GNU General Public License, which was designed for utility programs.  This
license, the GNU Library General Public License, applies to certain
designated libraries.  This license is quite different from the ordinary
one; be sure to read it in full, and don't assume that anything in it is
the same as in the ordinary license.

  The reason we have a separate public license for some libraries is that
they blur the distinction we usually make between modifying or adding to a
program and simply using it.  Linking a program with a library, without
changing the library, is in some sense simply using the library, and is
analogous to running a utility program or application program.  However, in
a textual and legal sense, the linked executable is a combined work, a
derivative of the original library, and the ordinary General Public License
treats it as such.

  Because of this blurred distinction, using the ordinary General
Public License for libraries did not effectively promote software
sharing, because most developers did not use the libraries.  We
concluded that weaker conditions might promote sharing better.

  However, unrestricted linking of non-free programs would deprive the
users of those programs of all benefit from the free status of the
libraries themselves.  This Library General Public License is intended to
permit developers of non-free programs to use free libraries, while
preserving your freedom as a user of such programs to change the free
libraries that are incorporated in them.  (We have not seen how to achieve
this as regards changes in header files, but we have achieved it as regards
changes in the actual functions of the Library.)  The hope is that this
will lead to faster development of free libraries.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, while the latter only
works together with the library.

  Note that it is possible for a library to be covered by the ordinary
General Public License rather than by this special one.

		  GNU LIBRARY GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library which
contains a notice placed by the copyright holder or other authorized
party saying it may be distributed under the terms of this Library
General Public License (also called "this License").  Each licensee is
addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.
  
  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also compile or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    c) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    d) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the source code distributed need not include anything that is normally
distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Library General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

			    NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

		     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the 
    Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
    Boston, MA  02111-1307  USA.

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!
/* ---------------------------------------------------------------------------
   TEMPLATE.c : template for creating library sources

   Copyright (C) 2005, Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	Appendix: How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 19yy  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) 19yy name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
; -------------------------------------------------------------------------
;  TEMPLATE.S : template for creating library assembler sources
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------
# generated automatically by aclocal 1.16.2 -*- Autoconf -*-

# Copyright (C) 1996-2020 Free Software Foundation, Inc.

# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])
m4_ifndef([AC_AUTOCONF_VERSION],
  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,
[m4_warning([this file was generated for autoconf 2.69.
You have another version of autoconf.  It may work, but is not guaranteed to.
If you have problems, you may need to regenerate the build system entirely.
To do so, use the procedure documented by the package, typically 'autoreconf'.])])

# Copyright (C) 2002-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_AUTOMAKE_VERSION(VERSION)
# ----------------------------
# Automake X.Y traces this macro to ensure aclocal.m4 has been
# generated from the m4 files accompanying Automake X.Y.
# (This private macro should not be called outside this file.)
AC_DEFUN([AM_AUTOMAKE_VERSION],
[am__api_version='1.16'
dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
dnl require some minimum version.  Point them to the right macro.
m4_if([$1], [1.16.2], [],
      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
])

# _AM_AUTOCONF_VERSION(VERSION)
# -----------------------------
# aclocal traces this macro to find the Autoconf version.
# This is a private macro too.  Using m4_define simplifies
# the logic in aclocal, which can simply ignore this definition.
m4_define([_AM_AUTOCONF_VERSION], [])

# AM_SET_CURRENT_AUTOMAKE_VERSION
# -------------------------------
# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
[AM_AUTOMAKE_VERSION([1.16.2])dnl
m4_ifndef([AC_AUTOCONF_VERSION],
  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])

# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to
# '$srcdir', '$srcdir/..', or '$srcdir/../..'.
#
# Of course, Automake must honor this variable whenever it calls a
# tool from the auxiliary directory.  The problem is that $srcdir (and
# therefore $ac_aux_dir as well) can be either absolute or relative,
# depending on how configure is run.  This is pretty annoying, since
# it makes $ac_aux_dir quite unusable in subdirectories: in the top
# source directory, any form will work fine, but in subdirectories a
# relative path needs to be adjusted first.
#
# $ac_aux_dir/missing
#    fails when called from a subdirectory if $ac_aux_dir is relative
# $top_srcdir/$ac_aux_dir/missing
#    fails if $ac_aux_dir is absolute,
#    fails when called from a subdirectory in a VPATH build with
#          a relative $ac_aux_dir
#
# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
# are both prefixed by $srcdir.  In an in-source build this is usually
# harmless because $srcdir is '.', but things will broke when you
# start a VPATH build or use an absolute $srcdir.
#
# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
# and then we would define $MISSING as
#   MISSING="\${SHELL} $am_aux_dir/missing"
# This will work as long as MISSING is not called from configure, because
# unfortunately $(top_srcdir) has no meaning in configure.
# However there are other variables, like CC, which are often used in
# configure, and could therefore not use this "fixed" $ac_aux_dir.
#
# Another solution, used here, is to always expand $ac_aux_dir to an
# absolute PATH.  The drawback is that using absolute paths prevent a
# configured tree to be moved without reconfiguration.

AC_DEFUN([AM_AUX_DIR_EXPAND],
[AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl
# Expand $ac_aux_dir to an absolute path.
am_aux_dir=`cd "$ac_aux_dir" && pwd`
])

# AM_CONDITIONAL                                            -*- Autoconf -*-

# Copyright (C) 1997-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_CONDITIONAL(NAME, SHELL-CONDITION)
# -------------------------------------
# Define a conditional.
AC_DEFUN([AM_CONDITIONAL],
[AC_PREREQ([2.52])dnl
 m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
AC_SUBST([$1_TRUE])dnl
AC_SUBST([$1_FALSE])dnl
_AM_SUBST_NOTMAKE([$1_TRUE])dnl
_AM_SUBST_NOTMAKE([$1_FALSE])dnl
m4_define([_AM_COND_VALUE_$1], [$2])dnl
if $2; then
  $1_TRUE=
  $1_FALSE='#'
else
  $1_TRUE='#'
  $1_FALSE=
fi
AC_CONFIG_COMMANDS_PRE(
[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
  AC_MSG_ERROR([[conditional "$1" was never defined.
Usually this means the macro was only invoked conditionally.]])
fi])])

# Copyright (C) 1999-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.


# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be
# written in clear, in which case automake, when reading aclocal.m4,
# will think it sees a *use*, and therefore will trigger all it's
# C support machinery.  Also note that it means that autoscan, seeing
# CC etc. in the Makefile, will ask for an AC_PROG_CC use...


# _AM_DEPENDENCIES(NAME)
# ----------------------
# See how the compiler implements dependency checking.
# NAME is "CC", "CXX", "OBJC", "OBJCXX", "UPC", or "GJC".
# We try a few techniques and use that to set a single cache variable.
#
# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
# dependency, and given that the user is not expected to run this macro,
# just rely on AC_PROG_CC.
AC_DEFUN([_AM_DEPENDENCIES],
[AC_REQUIRE([AM_SET_DEPDIR])dnl
AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
AC_REQUIRE([AM_MAKE_INCLUDE])dnl
AC_REQUIRE([AM_DEP_TRACK])dnl

m4_if([$1], [CC],   [depcc="$CC"   am_compiler_list=],
      [$1], [CXX],  [depcc="$CXX"  am_compiler_list=],
      [$1], [OBJC], [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
      [$1], [OBJCXX], [depcc="$OBJCXX" am_compiler_list='gcc3 gcc'],
      [$1], [UPC],  [depcc="$UPC"  am_compiler_list=],
      [$1], [GCJ],  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
                    [depcc="$$1"   am_compiler_list=])

AC_CACHE_CHECK([dependency style of $depcc],
               [am_cv_$1_dependencies_compiler_type],
[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
  # We make a subdir and do the tests there.  Otherwise we can end up
  # making bogus files that we don't know about and never remove.  For
  # instance it was reported that on HP-UX the gcc test will end up
  # making a dummy file named 'D' -- because '-MD' means "put the output
  # in D".
  rm -rf conftest.dir
  mkdir conftest.dir
  # Copy depcomp to subdir because otherwise we won't find it if we're
  # using a relative directory.
  cp "$am_depcomp" conftest.dir
  cd conftest.dir
  # We will build objects and dependencies in a subdirectory because
  # it helps to detect inapplicable dependency modes.  For instance
  # both Tru64's cc and ICC support -MD to output dependencies as a
  # side effect of compilation, but ICC will put the dependencies in
  # the current directory while Tru64 will put them in the object
  # directory.
  mkdir sub

  am_cv_$1_dependencies_compiler_type=none
  if test "$am_compiler_list" = ""; then
     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
  fi
  am__universal=false
  m4_case([$1], [CC],
    [case " $depcc " in #(
     *\ -arch\ *\ -arch\ *) am__universal=true ;;
     esac],
    [CXX],
    [case " $depcc " in #(
     *\ -arch\ *\ -arch\ *) am__universal=true ;;
     esac])

  for depmode in $am_compiler_list; do
    # Setup a source with many dependencies, because some compilers
    # like to wrap large dependency lists on column 80 (with \), and
    # we should not choose a depcomp mode which is confused by this.
    #
    # We need to recreate these files for each test, as the compiler may
    # overwrite some of them when testing with obscure command lines.
    # This happens at least with the AIX C compiler.
    : > sub/conftest.c
    for i in 1 2 3 4 5 6; do
      echo '#include "conftst'$i'.h"' >> sub/conftest.c
      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
      # Solaris 10 /bin/sh.
      echo '/* dummy */' > sub/conftst$i.h
    done
    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf

    # We check with '-c' and '-o' for the sake of the "dashmstdout"
    # mode.  It turns out that the SunPro C++ compiler does not properly
    # handle '-M -o', and we need to detect this.  Also, some Intel
    # versions had trouble with output in subdirs.
    am__obj=sub/conftest.${OBJEXT-o}
    am__minus_obj="-o $am__obj"
    case $depmode in
    gcc)
      # This depmode causes a compiler race in universal mode.
      test "$am__universal" = false || continue
      ;;
    nosideeffect)
      # After this tag, mechanisms are not by side-effect, so they'll
      # only be used when explicitly requested.
      if test "x$enable_dependency_tracking" = xyes; then
	continue
      else
	break
      fi
      ;;
    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
      # This compiler won't grok '-c -o', but also, the minuso test has
      # not run yet.  These depmodes are late enough in the game, and
      # so weak that their functioning should not be impacted.
      am__obj=conftest.${OBJEXT-o}
      am__minus_obj=
      ;;
    none) break ;;
    esac
    if depmode=$depmode \
       source=sub/conftest.c object=$am__obj \
       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
         >/dev/null 2>conftest.err &&
       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
      # icc doesn't choke on unknown options, it will just issue warnings
      # or remarks (even with -Werror).  So we grep stderr for any message
      # that says an option was ignored or not supported.
      # When given -MP, icc 7.0 and 7.1 complain thusly:
      #   icc: Command line warning: ignoring option '-M'; no argument required
      # The diagnosis changed in icc 8.0:
      #   icc: Command line remark: option '-MP' not supported
      if (grep 'ignoring option' conftest.err ||
          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
        am_cv_$1_dependencies_compiler_type=$depmode
        break
      fi
    fi
  done

  cd ..
  rm -rf conftest.dir
else
  am_cv_$1_dependencies_compiler_type=none
fi
])
AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
AM_CONDITIONAL([am__fastdep$1], [
  test "x$enable_dependency_tracking" != xno \
  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
])


# AM_SET_DEPDIR
# -------------
# Choose a directory name for dependency files.
# This macro is AC_REQUIREd in _AM_DEPENDENCIES.
AC_DEFUN([AM_SET_DEPDIR],
[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
])


# AM_DEP_TRACK
# ------------
AC_DEFUN([AM_DEP_TRACK],
[AC_ARG_ENABLE([dependency-tracking], [dnl
AS_HELP_STRING(
  [--enable-dependency-tracking],
  [do not reject slow dependency extractors])
AS_HELP_STRING(
  [--disable-dependency-tracking],
  [speeds up one-time build])])
if test "x$enable_dependency_tracking" != xno; then
  am_depcomp="$ac_aux_dir/depcomp"
  AMDEPBACKSLASH='\'
  am__nodep='_no'
fi
AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
AC_SUBST([AMDEPBACKSLASH])dnl
_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
AC_SUBST([am__nodep])dnl
_AM_SUBST_NOTMAKE([am__nodep])dnl
])

# Generate code to set up dependency tracking.              -*- Autoconf -*-

# Copyright (C) 1999-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# _AM_OUTPUT_DEPENDENCY_COMMANDS
# ------------------------------
AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
[{
  # Older Autoconf quotes --file arguments for eval, but not when files
  # are listed without --file.  Let's play safe and only enable the eval
  # if we detect the quoting.
  # TODO: see whether this extra hack can be removed once we start
  # requiring Autoconf 2.70 or later.
  AS_CASE([$CONFIG_FILES],
          [*\'*], [eval set x "$CONFIG_FILES"],
          [*], [set x $CONFIG_FILES])
  shift
  # Used to flag and report bootstrapping failures.
  am_rc=0
  for am_mf
  do
    # Strip MF so we end up with the name of the file.
    am_mf=`AS_ECHO(["$am_mf"]) | sed -e 's/:.*$//'`
    # Check whether this is an Automake generated Makefile which includes
    # dependency-tracking related rules and includes.
    # Grep'ing the whole file directly is not great: AIX grep has a line
    # limit of 2048, but all sed's we know have understand at least 4000.
    sed -n 's,^am--depfiles:.*,X,p' "$am_mf" | grep X >/dev/null 2>&1 \
      || continue
    am_dirpart=`AS_DIRNAME(["$am_mf"])`
    am_filepart=`AS_BASENAME(["$am_mf"])`
    AM_RUN_LOG([cd "$am_dirpart" \
      && sed -e '/# am--include-marker/d' "$am_filepart" \
        | $MAKE -f - am--depfiles]) || am_rc=$?
  done
  if test $am_rc -ne 0; then
    AC_MSG_FAILURE([Something went wrong bootstrapping makefile fragments
    for automatic dependency tracking.  If GNU make was not used, consider
    re-running the configure script with MAKE="gmake" (or whatever is
    necessary).  You can also try re-running configure with the
    '--disable-dependency-tracking' option to at least be able to build
    the package (albeit without support for automatic dependency tracking).])
  fi
  AS_UNSET([am_dirpart])
  AS_UNSET([am_filepart])
  AS_UNSET([am_mf])
  AS_UNSET([am_rc])
  rm -f conftest-deps.mk
}
])# _AM_OUTPUT_DEPENDENCY_COMMANDS


# AM_OUTPUT_DEPENDENCY_COMMANDS
# -----------------------------
# This macro should only be invoked once -- use via AC_REQUIRE.
#
# This code is only required when automatic dependency tracking is enabled.
# This creates each '.Po' and '.Plo' makefile fragment that we'll need in
# order to bootstrap the dependency handling code.
AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
[AC_CONFIG_COMMANDS([depfiles],
     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
     [AMDEP_TRUE="$AMDEP_TRUE" MAKE="${MAKE-make}"])])

# Do all the work for Automake.                             -*- Autoconf -*-

# Copyright (C) 1996-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This macro actually does too much.  Some checks are only needed if
# your package does certain things.  But this isn't really a big deal.

dnl Redefine AC_PROG_CC to automatically invoke _AM_PROG_CC_C_O.
m4_define([AC_PROG_CC],
m4_defn([AC_PROG_CC])
[_AM_PROG_CC_C_O
])

# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
# AM_INIT_AUTOMAKE([OPTIONS])
# -----------------------------------------------
# The call with PACKAGE and VERSION arguments is the old style
# call (pre autoconf-2.50), which is being phased out.  PACKAGE
# and VERSION should now be passed to AC_INIT and removed from
# the call to AM_INIT_AUTOMAKE.
# We support both call styles for the transition.  After
# the next Automake release, Autoconf can make the AC_INIT
# arguments mandatory, and then we can depend on a new Autoconf
# release and drop the old call support.
AC_DEFUN([AM_INIT_AUTOMAKE],
[AC_PREREQ([2.65])dnl
dnl Autoconf wants to disallow AM_ names.  We explicitly allow
dnl the ones we care about.
m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
AC_REQUIRE([AC_PROG_INSTALL])dnl
if test "`cd $srcdir && pwd`" != "`pwd`"; then
  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
  # is not polluted with repeated "-I."
  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl
  # test to see if srcdir already configured
  if test -f $srcdir/config.status; then
    AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
  fi
fi

# test whether we have cygpath
if test -z "$CYGPATH_W"; then
  if (cygpath --version) >/dev/null 2>/dev/null; then
    CYGPATH_W='cygpath -w'
  else
    CYGPATH_W=echo
  fi
fi
AC_SUBST([CYGPATH_W])

# Define the identity of the package.
dnl Distinguish between old-style and new-style calls.
m4_ifval([$2],
[AC_DIAGNOSE([obsolete],
             [$0: two- and three-arguments forms are deprecated.])
m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
 AC_SUBST([PACKAGE], [$1])dnl
 AC_SUBST([VERSION], [$2])],
[_AM_SET_OPTIONS([$1])dnl
dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
m4_if(
  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),
  [ok:ok],,
  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
 AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
 AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl

_AM_IF_OPTION([no-define],,
[AC_DEFINE_UNQUOTED([PACKAGE], ["$PACKAGE"], [Name of package])
 AC_DEFINE_UNQUOTED([VERSION], ["$VERSION"], [Version number of package])])dnl

# Some tools Automake needs.
AC_REQUIRE([AM_SANITY_CHECK])dnl
AC_REQUIRE([AC_ARG_PROGRAM])dnl
AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])
AM_MISSING_PROG([AUTOCONF], [autoconf])
AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])
AM_MISSING_PROG([AUTOHEADER], [autoheader])
AM_MISSING_PROG([MAKEINFO], [makeinfo])
AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
AC_REQUIRE([AC_PROG_MKDIR_P])dnl
# For better backward compatibility.  To be removed once Automake 1.9.x
# dies out for good.  For more background, see:
# <https://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
# <https://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
AC_SUBST([mkdir_p], ['$(MKDIR_P)'])
# We need awk for the "check" target (and possibly the TAP driver).  The
# system "awk" is bad on some platforms.
AC_REQUIRE([AC_PROG_AWK])dnl
AC_REQUIRE([AC_PROG_MAKE_SET])dnl
AC_REQUIRE([AM_SET_LEADING_DOT])dnl
_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
	      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
			     [_AM_PROG_TAR([v7])])])
_AM_IF_OPTION([no-dependencies],,
[AC_PROVIDE_IFELSE([AC_PROG_CC],
		  [_AM_DEPENDENCIES([CC])],
		  [m4_define([AC_PROG_CC],
			     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl
AC_PROVIDE_IFELSE([AC_PROG_CXX],
		  [_AM_DEPENDENCIES([CXX])],
		  [m4_define([AC_PROG_CXX],
			     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl
AC_PROVIDE_IFELSE([AC_PROG_OBJC],
		  [_AM_DEPENDENCIES([OBJC])],
		  [m4_define([AC_PROG_OBJC],
			     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl
AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],
		  [_AM_DEPENDENCIES([OBJCXX])],
		  [m4_define([AC_PROG_OBJCXX],
			     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl
])
AC_REQUIRE([AM_SILENT_RULES])dnl
dnl The testsuite driver may need to know about EXEEXT, so add the
dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This
dnl macro is hooked onto _AC_COMPILER_EXEEXT early, see below.
AC_CONFIG_COMMANDS_PRE(dnl
[m4_provide_if([_AM_COMPILER_EXEEXT],
  [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl

# POSIX will say in a future version that running "rm -f" with no argument
# is OK; and we want to be able to make that assumption in our Makefile
# recipes.  So use an aggressive probe to check that the usage we want is
# actually supported "in the wild" to an acceptable degree.
# See automake bug#10828.
# To make any issue more visible, cause the running configure to be aborted
# by default if the 'rm' program in use doesn't match our expectations; the
# user can still override this though.
if rm -f && rm -fr && rm -rf; then : OK; else
  cat >&2 <<'END'
Oops!

Your 'rm' program seems unable to run without file operands specified
on the command line, even when the '-f' option is present.  This is contrary
to the behaviour of most rm programs out there, and not conforming with
the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>

Please tell bug-automake@gnu.org about your system, including the value
of your $PATH and any error possibly output before this message.  This
can help us improve future automake versions.

END
  if test x"$ACCEPT_INFERIOR_RM_PROGRAM" = x"yes"; then
    echo 'Configuration will proceed anyway, since you have set the' >&2
    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to "yes"' >&2
    echo >&2
  else
    cat >&2 <<'END'
Aborting the configuration process, to ensure you take notice of the issue.

You can download and install GNU coreutils to get an 'rm' implementation
that behaves properly: <https://www.gnu.org/software/coreutils/>.

If you want to complete the configuration process using your problematic
'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
to "yes", and re-run configure.

END
    AC_MSG_ERROR([Your 'rm' program is bad, sorry.])
  fi
fi
dnl The trailing newline in this macro's definition is deliberate, for
dnl backward compatibility and to allow trailing 'dnl'-style comments
dnl after the AM_INIT_AUTOMAKE invocation. See automake bug#16841.
])

dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
dnl mangled by Autoconf and run in a shell conditional statement.
m4_define([_AC_COMPILER_EXEEXT],
m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])

# When config.status generates a header, we must update the stamp-h file.
# This file resides in the same directory as the config header
# that is generated.  The stamp files are numbered to have different names.

# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
# loop where config.status creates the headers, so we can generate
# our stamp files there.
AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
[# Compute $1's index in $config_headers.
_am_arg=$1
_am_stamp_count=1
for _am_header in $config_headers :; do
  case $_am_header in
    $_am_arg | $_am_arg:* )
      break ;;
    * )
      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
  esac
done
echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_PROG_INSTALL_SH
# ------------------
# Define $install_sh.
AC_DEFUN([AM_PROG_INSTALL_SH],
[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
if test x"${install_sh+set}" != xset; then
  case $am_aux_dir in
  *\ * | *\	*)
    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
  *)
    install_sh="\${SHELL} $am_aux_dir/install-sh"
  esac
fi
AC_SUBST([install_sh])])

# Copyright (C) 2003-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# Check whether the underlying file-system supports filenames
# with a leading dot.  For instance MS-DOS doesn't.
AC_DEFUN([AM_SET_LEADING_DOT],
[rm -rf .tst 2>/dev/null
mkdir .tst 2>/dev/null
if test -d .tst; then
  am__leading_dot=.
else
  am__leading_dot=_
fi
rmdir .tst 2>/dev/null
AC_SUBST([am__leading_dot])])

# Check to see how 'make' treats includes.	            -*- Autoconf -*-

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_MAKE_INCLUDE()
# -----------------
# Check whether make has an 'include' directive that can support all
# the idioms we need for our automatic dependency tracking code.
AC_DEFUN([AM_MAKE_INCLUDE],
[AC_MSG_CHECKING([whether ${MAKE-make} supports the include directive])
cat > confinc.mk << 'END'
am__doit:
	@echo this is the am__doit target >confinc.out
.PHONY: am__doit
END
am__include="#"
am__quote=
# BSD make does it like this.
echo '.include "confinc.mk" # ignored' > confmf.BSD
# Other make implementations (GNU, Solaris 10, AIX) do it like this.
echo 'include confinc.mk # ignored' > confmf.GNU
_am_result=no
for s in GNU BSD; do
  AM_RUN_LOG([${MAKE-make} -f confmf.$s && cat confinc.out])
  AS_CASE([$?:`cat confinc.out 2>/dev/null`],
      ['0:this is the am__doit target'],
      [AS_CASE([$s],
          [BSD], [am__include='.include' am__quote='"'],
          [am__include='include' am__quote=''])])
  if test "$am__include" != "#"; then
    _am_result="yes ($s style)"
    break
  fi
done
rm -f confinc.* confmf.*
AC_MSG_RESULT([${_am_result}])
AC_SUBST([am__include])])
AC_SUBST([am__quote])])

# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-

# Copyright (C) 1997-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_MISSING_PROG(NAME, PROGRAM)
# ------------------------------
AC_DEFUN([AM_MISSING_PROG],
[AC_REQUIRE([AM_MISSING_HAS_RUN])
$1=${$1-"${am_missing_run}$2"}
AC_SUBST($1)])

# AM_MISSING_HAS_RUN
# ------------------
# Define MISSING if not defined so far and test if it is modern enough.
# If it is, set am_missing_run to use it, otherwise, to nothing.
AC_DEFUN([AM_MISSING_HAS_RUN],
[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
AC_REQUIRE_AUX_FILE([missing])dnl
if test x"${MISSING+set}" != xset; then
  case $am_aux_dir in
  *\ * | *\	*)
    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
  *)
    MISSING="\${SHELL} $am_aux_dir/missing" ;;
  esac
fi
# Use eval to expand $SHELL
if eval "$MISSING --is-lightweight"; then
  am_missing_run="$MISSING "
else
  am_missing_run=
  AC_MSG_WARN(['missing' script is too old or missing])
fi
])

# Helper functions for option handling.                     -*- Autoconf -*-

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# _AM_MANGLE_OPTION(NAME)
# -----------------------
AC_DEFUN([_AM_MANGLE_OPTION],
[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])

# _AM_SET_OPTION(NAME)
# --------------------
# Set option NAME.  Presently that only means defining a flag for this option.
AC_DEFUN([_AM_SET_OPTION],
[m4_define(_AM_MANGLE_OPTION([$1]), [1])])

# _AM_SET_OPTIONS(OPTIONS)
# ------------------------
# OPTIONS is a space-separated list of Automake options.
AC_DEFUN([_AM_SET_OPTIONS],
[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])

# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
# -------------------------------------------
# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
AC_DEFUN([_AM_IF_OPTION],
[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_RUN_LOG(COMMAND)
# -------------------
# Run COMMAND, save the exit status in ac_status, and log it.
# (This has been adapted from Autoconf's _AC_RUN_LOG macro.)
AC_DEFUN([AM_RUN_LOG],
[{ echo "$as_me:$LINENO: $1" >&AS_MESSAGE_LOG_FD
   ($1) >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
   (exit $ac_status); }])

# Check to make sure that the build environment is sane.    -*- Autoconf -*-

# Copyright (C) 1996-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_SANITY_CHECK
# ---------------
AC_DEFUN([AM_SANITY_CHECK],
[AC_MSG_CHECKING([whether build environment is sane])
# Reject unsafe characters in $srcdir or the absolute working directory
# name.  Accept space and tab only in the latter.
am_lf='
'
case `pwd` in
  *[[\\\"\#\$\&\'\`$am_lf]]*)
    AC_MSG_ERROR([unsafe absolute working directory name]);;
esac
case $srcdir in
  *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;
esac

# Do 'set' in a subshell so we don't clobber the current shell's
# arguments.  Must try -L first in case configure is actually a
# symlink; some systems play weird games with the mod time of symlinks
# (eg FreeBSD returns the mod time of the symlink's containing
# directory).
if (
   am_has_slept=no
   for am_try in 1 2; do
     echo "timestamp, slept: $am_has_slept" > conftest.file
     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
     if test "$[*]" = "X"; then
	# -L didn't work.
	set X `ls -t "$srcdir/configure" conftest.file`
     fi
     if test "$[*]" != "X $srcdir/configure conftest.file" \
	&& test "$[*]" != "X conftest.file $srcdir/configure"; then

	# If neither matched, then we have a broken ls.  This can happen
	# if, for instance, CONFIG_SHELL is bash and it inherits a
	# broken ls alias from the environment.  This has actually
	# happened.  Such a system could not be considered "sane".
	AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
  alias in your environment])
     fi
     if test "$[2]" = conftest.file || test $am_try -eq 2; then
       break
     fi
     # Just in case.
     sleep 1
     am_has_slept=yes
   done
   test "$[2]" = conftest.file
   )
then
   # Ok.
   :
else
   AC_MSG_ERROR([newly created file is older than distributed files!
Check your system clock])
fi
AC_MSG_RESULT([yes])
# If we didn't sleep, we still need to ensure time stamps of config.status and
# generated files are strictly newer.
am_sleep_pid=
if grep 'slept: no' conftest.file >/dev/null 2>&1; then
  ( sleep 1 ) &
  am_sleep_pid=$!
fi
AC_CONFIG_COMMANDS_PRE(
  [AC_MSG_CHECKING([that generated files are newer than configure])
   if test -n "$am_sleep_pid"; then
     # Hide warnings about reused PIDs.
     wait $am_sleep_pid 2>/dev/null
   fi
   AC_MSG_RESULT([done])])
rm -f conftest.file
])

# Copyright (C) 2009-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_SILENT_RULES([DEFAULT])
# --------------------------
# Enable less verbose build rules; with the default set to DEFAULT
# ("yes" being less verbose, "no" or empty being verbose).
AC_DEFUN([AM_SILENT_RULES],
[AC_ARG_ENABLE([silent-rules], [dnl
AS_HELP_STRING(
  [--enable-silent-rules],
  [less verbose build output (undo: "make V=1")])
AS_HELP_STRING(
  [--disable-silent-rules],
  [verbose build output (undo: "make V=0")])dnl
])
case $enable_silent_rules in @%:@ (((
  yes) AM_DEFAULT_VERBOSITY=0;;
   no) AM_DEFAULT_VERBOSITY=1;;
    *) AM_DEFAULT_VERBOSITY=m4_if([$1], [yes], [0], [1]);;
esac
dnl
dnl A few 'make' implementations (e.g., NonStop OS and NextStep)
dnl do not support nested variable expansions.
dnl See automake bug#9928 and bug#10237.
am_make=${MAKE-make}
AC_CACHE_CHECK([whether $am_make supports nested variables],
   [am_cv_make_support_nested_variables],
   [if AS_ECHO([['TRUE=$(BAR$(V))
BAR0=false
BAR1=true
V=1
am__doit:
	@$(TRUE)
.PHONY: am__doit']]) | $am_make -f - >/dev/null 2>&1; then
  am_cv_make_support_nested_variables=yes
else
  am_cv_make_support_nested_variables=no
fi])
if test $am_cv_make_support_nested_variables = yes; then
  dnl Using '$V' instead of '$(V)' breaks IRIX make.
  AM_V='$(V)'
  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
else
  AM_V=$AM_DEFAULT_VERBOSITY
  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY
fi
AC_SUBST([AM_V])dnl
AM_SUBST_NOTMAKE([AM_V])dnl
AC_SUBST([AM_DEFAULT_V])dnl
AM_SUBST_NOTMAKE([AM_DEFAULT_V])dnl
AC_SUBST([AM_DEFAULT_VERBOSITY])dnl
AM_BACKSLASH='\'
AC_SUBST([AM_BACKSLASH])dnl
_AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl
])

# Copyright (C) 2001-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# AM_PROG_INSTALL_STRIP
# ---------------------
# One issue with vendor 'install' (even GNU) is that you can't
# specify the program used to strip binaries.  This is especially
# annoying in cross-compiling environments, where the build's strip
# is unlikely to handle the host's binaries.
# Fortunately install-sh will honor a STRIPPROG variable, so we
# always use install-sh in "make install-strip", and initialize
# STRIPPROG with the value of the STRIP variable (set by the user).
AC_DEFUN([AM_PROG_INSTALL_STRIP],
[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
# Installed binaries are usually stripped using 'strip' when the user
# run "make install-strip".  However 'strip' might not be the right
# tool to use in cross-compilation environments, therefore Automake
# will honor the 'STRIP' environment variable to overrule this program.
dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.
if test "$cross_compiling" != no; then
  AC_CHECK_TOOL([STRIP], [strip], :)
fi
INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
AC_SUBST([INSTALL_STRIP_PROGRAM])])

# Copyright (C) 2006-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# _AM_SUBST_NOTMAKE(VARIABLE)
# ---------------------------
# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
# This macro is traced by Automake.
AC_DEFUN([_AM_SUBST_NOTMAKE])

# AM_SUBST_NOTMAKE(VARIABLE)
# --------------------------
# Public sister of _AM_SUBST_NOTMAKE.
AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])

# Check how to create a tarball.                            -*- Autoconf -*-

# Copyright (C) 2004-2020 Free Software Foundation, Inc.
#
# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# _AM_PROG_TAR(FORMAT)
# --------------------
# Check how to create a tarball in format FORMAT.
# FORMAT should be one of 'v7', 'ustar', or 'pax'.
#
# Substitute a variable $(am__tar) that is a command
# writing to stdout a FORMAT-tarball containing the directory
# $tardir.
#     tardir=directory && $(am__tar) > result.tar
#
# Substitute a variable $(am__untar) that extract such
# a tarball read from stdin.
#     $(am__untar) < result.tar
#
AC_DEFUN([_AM_PROG_TAR],
[# Always define AMTAR for backward compatibility.  Yes, it's still used
# in the wild :-(  We should find a proper way to deprecate it ...
AC_SUBST([AMTAR], ['$${TAR-tar}'])

# We'll loop over all known methods to create a tar archive until one works.
_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'

m4_if([$1], [v7],
  [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],

  [m4_case([$1],
    [ustar],
     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.
      # There is notably a 21 bits limit for the UID and the GID.  In fact,
      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343
      # and bug#13588).
      am_max_uid=2097151 # 2^21 - 1
      am_max_gid=$am_max_uid
      # The $UID and $GID variables are not portable, so we need to resort
      # to the POSIX-mandated id(1) utility.  Errors in the 'id' calls
      # below are definitely unexpected, so allow the users to see them
      # (that is, avoid stderr redirection).
      am_uid=`id -u || echo unknown`
      am_gid=`id -g || echo unknown`
      AC_MSG_CHECKING([whether UID '$am_uid' is supported by ustar format])
      if test $am_uid -le $am_max_uid; then
         AC_MSG_RESULT([yes])
      else
         AC_MSG_RESULT([no])
         _am_tools=none
      fi
      AC_MSG_CHECKING([whether GID '$am_gid' is supported by ustar format])
      if test $am_gid -le $am_max_gid; then
         AC_MSG_RESULT([yes])
      else
        AC_MSG_RESULT([no])
        _am_tools=none
      fi],

  [pax],
    [],

  [m4_fatal([Unknown tar format])])

  AC_MSG_CHECKING([how to create a $1 tar archive])

  # Go ahead even if we have the value already cached.  We do so because we
  # need to set the values for the 'am__tar' and 'am__untar' variables.
  _am_tools=${am_cv_prog_tar_$1-$_am_tools}

  for _am_tool in $_am_tools; do
    case $_am_tool in
    gnutar)
      for _am_tar in tar gnutar gtar; do
        AM_RUN_LOG([$_am_tar --version]) && break
      done
      am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
      am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
      am__untar="$_am_tar -xf -"
      ;;
    plaintar)
      # Must skip GNU tar: if it does not support --format= it doesn't create
      # ustar tarball either.
      (tar --version) >/dev/null 2>&1 && continue
      am__tar='tar chf - "$$tardir"'
      am__tar_='tar chf - "$tardir"'
      am__untar='tar xf -'
      ;;
    pax)
      am__tar='pax -L -x $1 -w "$$tardir"'
      am__tar_='pax -L -x $1 -w "$tardir"'
      am__untar='pax -r'
      ;;
    cpio)
      am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
      am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
      am__untar='cpio -i -H $1 -d'
      ;;
    none)
      am__tar=false
      am__tar_=false
      am__untar=false
      ;;
    esac

    # If the value was cached, stop now.  We just wanted to have am__tar
    # and am__untar set.
    test -n "${am_cv_prog_tar_$1}" && break

    # tar/untar a dummy directory, and stop if the command works.
    rm -rf conftest.dir
    mkdir conftest.dir
    echo GrepMe > conftest.dir/file
    AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
    rm -rf conftest.dir
    if test -s conftest.tar; then
      AM_RUN_LOG([$am__untar <conftest.tar])
      AM_RUN_LOG([cat conftest.dir/file])
      grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
    fi
  done
  rm -rf conftest.dir

  AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
  AC_MSG_RESULT([$am_cv_prog_tar_$1])])

AC_SUBST([am__tar])
AC_SUBST([am__untar])
]) # _AM_PROG_TAR

README for the SDCC/pic14 library

Building the library
====================
1. Edit ./Makefile.in and update the ARCH variable to match your
   device. It should be safe to keep the default setting (p18f877),
   but performance improvements might be possible in specifying the
   actual target chip there.
   
2. Run './configure'

3. Run 'make clean'

4. Run 'make all'

Prerequisites
=============
* a recently new GNU Make (tested with 3.80)
* current gputils (tested with 0.13.2)
* SDCC with enabled 14 bit PIC backend (tested with 2.5.4)
/*-------------------------------------------------------------------------
   free.c - dynamic memory allocation

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic14_malloc.h>

void free (void __data *ptr)
{
  /* mark block as deallocated */
  if (ptr)
    PTR2REC(ptr)->bits.alloc = 0;
}
/*-------------------------------------------------------------------------
   realloc.c - dynamic memory allocation

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic14_malloc.h>

void __data *realloc (void __data *ptr, size_t size)
{
    _malloc_rec __data *current_head, *next_head;
    size_t current_size;

    if (ptr)
    {
        current_head = PTR2REC(ptr);
        current_size = current_head->bits.count - 1;
        /* not changing the size */
        if (size == current_size)
            return ptr;
        /* reduce the size of the block */
        if (size < current_size)
        {
            current_head->bits.count = size + 1;
            next_head = NEXTREC(current_head);
            next_head->datum = current_size - size;
            return ptr;
        }
        /* increase the size of the block */
        next_head = NEXTREC(current_head);
        while (next_head->bits.alloc == 0 && next_head->bits.count > 0)
        {
            current_size += next_head->bits.count;
            if (size <= current_size)
            {
                current_head->bits.count = size + 1;
                if (size < current_size)
                {
                    next_head = NEXTREC(current_head);
                    next_head->datum = current_size - size;
                }
                return ptr;
            }
            next_head = NEXTREC(next_head);
        }
    }

    /* reallocation needed */
    return _allocateHeap (ptr, size);
}

/*-------------------------------------------------------------------------
   mbrtowc.c - convert a multibyte sequence to a wide character

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <wchar.h>
#include <errno.h>

size_t mbrtowc(wchar_t *restrict pwc, const char *restrict s, size_t n, mbstate_t *restrict ps)
{
	unsigned char first_byte;
	unsigned char seqlen;
	char mbseq[4];
	wchar_t codepoint;
	unsigned char i, j;
	static mbstate_t sps;

	if(!s)
#if defined(__SDCC_pic14)
		/* try to minimize nested calls */
		{ pwc = 0; s = ""; n = 1; }
#else
		return(mbrtowc(0, "", 1, ps));
#endif
	if(!n)
		goto eilseq;
	if(!ps)
	{
		ps = &sps;
	}

	for(i = 0; ps->c[i] && i < 3; i++)
		mbseq[i] = ps->c[i];

	seqlen = 1;
	first_byte = ps->c[0] ? ps->c[0] : *s;

	if(first_byte & 0x80)
	{
		while (first_byte & (0x80 >> seqlen))
			seqlen++;
		first_byte &= (0xff >> (seqlen + 1));
	}

	if(seqlen > 4)
		goto eilseq;

	if(i + n < seqlen) // Incomplete multibyte character
	{
		for(;n-- ; i++)
			ps->c[i] = *s++;
		return(-2);
	}

	for(j = 0; j < i; j++)
		ps->c[j] = 0;

	for(n = 1, i = i ? i : 1; i < seqlen; i++, n++)
	{
		mbseq[i] = *s++;
		if((mbseq[i] & 0xc0) != 0x80)
			goto eilseq;
	}

	codepoint = first_byte;

	for(s = mbseq + 1, seqlen--; seqlen; seqlen--)
	{
		codepoint <<= 6;
		codepoint |= (*s & 0x3f);
		s++;
	}

	if(codepoint >= 0xd800 && codepoint <= 0xdfff) // UTF-16 surrogate.
		return(-1);

	if(pwc)
		*pwc = codepoint;
	return(n);

eilseq:
	errno = EILSEQ;
	return(-1);
}

/*-------------------------------------------------------------------------
   memfreemax.c - return size of maximum unallocated heap block

   Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic14_malloc.h>

size_t memfreemax (void)
{
    _malloc_rec __data *head;
    size_t size = 1;
    size_t len;
 
    if (_malloc_heap == NULL)
        return 0;
 
      head = _malloc_heap;
      
      while ((len = head->bits.count) != 0)
      {
          if (!head->bits.alloc && (len > size))
                size = len;
          
          head = NEXTREC(head);
      }
 
    /* do not count the block header */
    return size - 1;
}
/*-------------------------------------------------------------------------
   strmusart.c - usart stream putchar

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>
#include <pic16regs.h>

/* note that USART should already been initialized */
static int
__stream_usart_out (char c, FILE *stream)
{
  (void)stream;
  while (!TXIF);
  TXREG = c;
  /* wait until the transmit buffer is empty */
  while (!TRMT);
  return 0;
}

static FILE f = __stream_usart_out;
FILE *usart_out = &f;
/*-------------------------------------------------------------------------
   calloc.c - dynamic memory allocation

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic14_malloc.h>
#include <string.h>

void __data *_calloc (size_t size)
{
    void __data *result;

    result = _allocateHeap (NULL, size);

    if (result != NULL)
        memset (result, 0, size);

    return result;
}
/*-------------------------------------------------------------------------
   vprintf.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

int
vprintf (const char *fmt, va_list ap)
{
  return vfprintf (stdout, fmt, ap);
}
/*-------------------------------------------------------------------------
   memfree.c - return size of all unallocated heap

   Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic14_malloc.h>

size_t memfree (void)
{
    _malloc_rec __data *head;
    size_t size = 0;
    size_t len;
 
    if (_malloc_heap == NULL)
      return 0;
 
    head = _malloc_heap;
 
    while ((len = head->bits.count) != 0)
    {
        if (!head->bits.alloc)
            size += len - 1;
  
        head = NEXTREC(head);
    }
 
    return size;
}
/*-------------------------------------------------------------------------
   strmgpsim.c - gpsim stream putchar

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

/* FIXME: ¬øwhere does this come from?
 *        It doesn't work for me and I see nothing about it in the gpsim sources.
 */

extern __sfr __at(0x0F7F) GPSIM_DEBUG;

static int
__stream_gpsim_out (char c, FILE *stream)
{
  (void)stream;
  GPSIM_DEBUG = c;
  return 0;
}

static FILE f = __stream_gpsim_out;
FILE *gpsim_out = &f;

/*-------------------------------------------------------------------------
   malloc.c - dynamic memory allocation

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic14_malloc.h>

void __data *malloc (size_t size)
{
    return _allocateHeap (NULL, size);
}

/*-------------------------------------------------------------------------
   strmmssp.c - MSSP stream putchar

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>
#include <pic16regs.h>

/* note that MSSP should already been initialized */
static int
__stream_mssp_out (char c, FILE *stream)
{
  (void)stream;
  SSPBUF = c;
  return 0;
}

static FILE f = __stream_mssp_out;
FILE *mssp_out = &f;
/*-------------------------------------------------------------------------
   sprintf.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

#if !(defined(__SDCC_pic14) && !defined(__SDCC_PIC14_HAS_VARARGS))
int
sprintf (char *str, const char *fmt, ...)
{
  int i;
  va_list ap;
  FILE f = str;

  va_start (ap, fmt);
  i = vfprintf (&f, fmt, ap);
  str[i] = '\0';
  va_end (ap);
  return i;
}
#endif
/*-------------------------------------------------------------------------
   printf.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

#if !(defined(__SDCC_pic14) && !defined(__SDCC_PIC14_HAS_VARARGS))
int
printf (const char *fmt, ...)
{
  int i;
  va_list ap;

  va_start (ap, fmt);
  i = vfprintf (stdout, fmt, ap);
  va_end (ap);
  return i;
}
#endif
/*---------------------------------------------------------------------
   qsort() - sort an array

   Copyright (C) 2018, Philipp Klaus Krause . krauseph@informatik.uni-freiburg.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

// Despite the name, this is an insertion sort, since it tends to be smaller in code size.

#if !(defined(__SDCC_pic14) && !defined(__SDCC_PIC14_HAS_PCALL))
static void swap(void *restrict dst, void *restrict src, size_t n)
{
	unsigned char *restrict d = dst;
	unsigned char *restrict s = src;

	while(n--)
	{
		unsigned char tmp = *d;
		*d = *s;
		*s = tmp;
		d++;
		s++;
	}
}

void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *) __reentrant)
{
	unsigned char *b = base;

	if(nmemb <= 1)
		return;

	for(unsigned char *i = base; i < b + nmemb * size; i += size)
	{
		for(unsigned char *j = i; (j > b) && (*compar)(j, j - size) < 0; j -= size)
			swap(j, j - size, size);
	}
}
#endif

/*-------------------------------------------------------------------------
   putchar.c - putchar dummy function

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

/* This is a dummy function so that sources compile,
 * even when user doesn't give a putchar() function. */

int getchar (void)
{
  return EOF;
}
/*-------------------------------------------------------------------------
   vfprintf.c - source file for reduced version of printf

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT ieee.org>
   Modified for pic16 port, by Vangelis Rokas, 2005 <vrokas AT otenet.gr>
   Bug-fixed and feature-enhanced by Mauro Giachero, 2008 <mauro.giachero AT gmail.com>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* following formats are supported :-
   format     output type       argument-type
     %%        -                   -
     %u        unsigned            int
     %u*       unsigned            *
     %b        binary              int
     %lb       binary              long
     %hb       binary              char
     %d        decimal             int
     %lu       unsigned            long
     %hu       unsigned            char
     %l[di]    decimal             long
     %lu[di]   unsigned            long
     %h[di]    decimal             char
     %hu[di]   unsigned            char
     %[xX]     hexadecimal         int
     %l[xX]    hexadecimal         long
     %h[xX]    hexadecimal         char
     %o        octal               int
     %lo       octal               long
     %ho       octal               char
     %c        character           char
     %s        character           generic pointer
   Also supported are:
   - the '0', '-' and ' ' alignment modifiers
   - the '+' and ' ' modifiers
   - the width field for integral types
   - the precision field for strings
*/

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

/***********************************************************
 * The following switches enable some "advanced" features. *
 * With all the switches enabled:                          *
 * ; Statistics:                                           *
 * ; code size:     2062 (0x080e) bytes ( 1.57%)           *
 * ;                1031 (0x0407) words                    *
 * ; udata size:      16 (0x0010) bytes ( 1.25%)           *
 * ; access size:     31 (0x001f) bytes                    *
 * With all the switches disabled:                         *
 * ; Statistics:                                           *
 * ; code size:     1278 (0x04fe) bytes ( 0.98%)           *
 * ;                 639 (0x027f) words                    *
 * ; udata size:      16 (0x0010) bytes ( 1.25%)           *
 * ; access size:     25 (0x0019) bytes                    *
 ***********************************************************/

/*
 * Define this to enable support of the field width, which
 * allows to specify the minimum number of characters an
 * integer must use.
 * Costs ~200 code words and 3 bytes in access RAM.
 */
#define FIELD_WIDTH
/*
 * Define this to enable support of the precision, which
 * allows to specify the maximum number of characters a
 * string can use. Note that this implementation doesn't
 * use this field for integers (as it should).
 * Costs ~85 code words and 1 byte in access RAM.
 */
#define PRECISION
/*
 * Define this to enable support of the '+' and ' ' modifiers,
 * which specify that a positive signed number must be
 * preceded respectively with a '+' or a ' ' character.
 * Costs ~70 code words and 2 words of access RAM
 */
#define SIGN_MODIFIERS
/*
 * With this macro defined, trying to print a float number
 * will generate the "<NO FLOAT>" string.
 * Costs ~25 code words
 */
#define FLOAT_PLACEHOLDER
/*
 * With this macro defined, printing floats will work.
 * This also enables PRECISION and disables FLOAT_PLACEHOLDER.
 */
#define USE_FLOATS
/*
 * This macro enables the use of the 'b' binary specifier and
 * the use of "%b", "%hb" and "%lb"
 */
#define BINARY_SPECIFIER
/*
 * This macro enables the use of the 'i' integer specifier and
 * the use of "%u", "%lu", ... in place of "%ud", "%lud", ... .
 * costs ~10 code words
 */
#define EXTRA_INTEGER
/*
 * Two ways to handle putchar and getchar.
 */
#define _STATIC_PUTCHAR 0
#define _STATIC_GETCHAR 0

/*
 * END OF CONFIGURATION SETTINGS
 */

#if defined(USE_FLOATS)
#define PRECISION
#undef FLOAT_PLACEHOLDER
/* x_ftoa requires up to 8 digits (integral part) + '.' + 24 digits
 * (fractional part). Adding a sign and a NUL byte yields 35 byte. */
# define BUF_SIZE       36
#elif defined(BINARY_SPECIFIER)
/* "%lb" = "0" - "11111111111111111111111111111111" */
# define BUF_SIZE       33
#else
/* "%lo" = "0" - "37777777777" or  "-20000000000" - "17777777777" */
# define BUF_SIZE       13
#endif

/* flags */
#define _LONG       0x0001
#define _STR        0x0002
#define _CHAR       0x0004
#define _PTR        0x0008
#define _FLOAT      0x1000  // only when USE_FLOATS or FLOAT_PLACEHOLDER
#define _UNSIGNED   0x0010
#define _UPCASE     0x0020
#define _LEFTALIGN  0x0100  // only when FIELD_WIDTH
#define _ZEROPAD    0x0200  // only when FIELD_WIDTH
#define _PRINTSIGN  0x0400  // only when SIGN_MODIFIERS
#define _PRINTBLANK 0x0800  // only when SIGN_MODIFIERS

/* precision value meaning unset */
#define _UNSET  ((unsigned char)-1)

#if _STATIC_GETCHAR

static const char *_fmt;
static char ch;
static void _getchar (void)
{
        ch = *_fmt++;
}
#define _GETCHAR()  _getchar()

#else /* _STATIC_GETCHAR */
#define _GETCHAR()  do { ch = *fmt++; } while(0)
#endif

#if _STATIC_PUTCHAR

static FILE *_stream;
static unsigned char count;
static int _putchar (unsigned char c)
{
	if (fputc(c, _stream) < 0)
		return 1;
       	count++;
	return 0;
}
#define _PUTCHAR(c) do { if (_putchar(c)) goto _error; } while(0)

#else /* _STATIC_PUTCHAR */
#define _PUTCHAR(c) do { if (fputc(c, stream) < 0) goto _error; count++; } while(0)
#endif

int
vfprintf (FILE *stream, const char *fmt, va_list ap)
{
  unsigned flags;
  unsigned char radix;      // 2(binary), 8(octal), 10(decimal), 16(hexadecimal) or 0(char)

#if defined(FLOAT_PLACEHOLDER) || defined(USE_FLOATS)
  float f;
#endif

#ifdef FIELD_WIDTH
  unsigned char fieldwidth; // field width in number of characters
#endif

#ifdef PRECISION
  unsigned char precision;  // precission width in number of characters
#endif

  const char *cstr;
  char *str;
  long val;
  char buffer[BUF_SIZE];

#if _STATIC_GETCHAR
  _fmt = fmt;
#else
  char ch;
#endif

#if _STATIC_PUTCHAR
  _stream = stream;
  count = 0;
#else
  unsigned char count = 0;
#endif

  while (1)
    {
      _GETCHAR();
      if (ch == 0)
        return count;
      if (ch != '%')
        {
          _PUTCHAR(ch);
          continue;
        }
      _GETCHAR();
      if (ch == '%')
        {
          _PUTCHAR(ch);
          continue;
        }

      flags = 0;
      radix = 10;

#ifdef FIELD_WIDTH
      fieldwidth = 0;
#endif

#ifdef PRECISION
      // _UNSET is used as an "unlimited" precision marker
      precision = _UNSET;
#endif

#ifdef FIELD_WIDTH
      if (ch == '0')
        {
          flags |= _ZEROPAD;
          _GETCHAR();
        }

      if (ch == '-')
        {
          flags |= _LEFTALIGN;
          _GETCHAR();
        }
#endif

#ifdef SIGN_MODIFIERS
      if (ch == ' ')
        {
          flags |= _PRINTSIGN;
          flags |= _PRINTBLANK;
          _GETCHAR();
        }

      if (ch == '+')
        {
          flags |= _PRINTSIGN;
          _GETCHAR();
        }
#endif

#ifdef FIELD_WIDTH
      if ((ch >= '1') && (ch <= '9'))
        {
          while ((ch >= '0') && (ch <= '9'))
            {
              fieldwidth = 10 * fieldwidth + (ch) - '0';
              _GETCHAR();
            }
        }
#endif

#ifdef PRECISION
      if (ch == '.')
        {
          _GETCHAR();
          precision = 0;
          while ((ch >= '0') && (ch <= '9'))
            {
              precision = 10 * precision + (ch) - '0';
              _GETCHAR();
            }
        }
#endif

      if (ch == 'l')
        {
          flags |= _LONG;
          _GETCHAR();
        }
      else if (ch == 'h')
        {
          flags |= _CHAR;
          _GETCHAR();
        }

      if (ch == 'u')
        {
          flags |= _UNSIGNED;
          _GETCHAR();
        }

      if (ch == 's')
        {
          flags |= _STR;
#ifdef FIELD_WIDTH
          flags &= ~_ZEROPAD;   /* Strings are always space-padded */
#endif
        }
      else if (ch == 'p')
        {
          flags |= _PTR;
          flags |= _UNSIGNED;
          radix = 16;
        }
      else if (ch == 'x')
        radix = 16;
      else if (ch == 'X')
        {
          radix = 16;
          flags |= _UPCASE;
        }
      else if (ch == 'c')
        radix = 0;
      else if (ch == 'o')
        radix = 8;
#ifdef BINARY_SPECIFIER
      else if (ch == 'b')
        radix = 2;
#endif
#if defined(FLOAT_PLACEHOLDER) || defined(USE_FLOATS)
      else if (ch == 'f')
        {
          flags |= _FLOAT;
        }
#endif
#ifdef EXTRA_INTEGER
      else if ((ch == 'd') || (ch == 'i'))  /* This is the default */
            ;
      else if (flags & _UNSIGNED)           /* %u alone is the same as %ud */
#if _STATIC_GETCHAR
        --_fmt;
#else
        --fmt;
#endif
#else
      else if (ch == 'd')
            ;
#endif
      else
        {
          goto _error;
        }

      /* Here starts the formatting code */

      if (flags & _STR)
        {
          str = va_arg (ap, char *);
        }
#if defined(USE_FLOATS)
      else if (flags & _FLOAT)
        {
          f = va_arg (ap, float);
          str = buffer;
          _ftoa (f, buffer, PREC(PREC_F, precision == _UNSET ? PREC_D : precision));
          precision = _UNSET;
        }
#elif defined(FLOAT_PLACEHOLDER)
      else if (flags & _FLOAT)
        {
          /* read but ignore the argument */
          f = va_arg (ap, float);
          str = (char*)"<NO FLOAT>";
#ifdef PRECISION
          precision = _UNSET;
#endif /* PRECISION */
        }
#endif /* FLOAT_PLACEHOLDER */
      else
        {
#ifdef PRECISION
          precision = _UNSET;   //FIXME: No support for the precision field on numerals
#endif
          val = 0;
          if (flags & _LONG)
            {
              val = va_arg (ap, long);
            }
          else if (flags & _PTR)
            {
              str = va_arg (ap, void*);
              val = 0x00ffffffUL & *(unsigned long*)&str;
            }
          else if (flags & _CHAR)
            {
              val = va_arg (ap, char);
              if ((radix != 10) || (flags & _UNSIGNED))
                val = (unsigned char) val;    //Avoid unwanted sign extension
            }
          else
            {
              val = va_arg (ap, int);
              if ((radix != 10) || (flags & _UNSIGNED))
                val = (unsigned int) val;   //Avoid unwanted sign extension
            }

          str = buffer + 1; //Reserve space for a forced '+'
          if (radix)
            {
              if (flags & _UNSIGNED)
                _ultoa (val, buffer + 1, radix);
              else
                _ltoa (val, buffer + 1, radix);
#ifdef SIGN_MODIFIERS
              if ((flags & _PRINTSIGN) && (*str != '-'))
                {
                  --str;
                  *str = (flags & _PRINTBLANK ? ' ' : '+');
                }
#endif
            }
          else
            {
              *str = (unsigned char) val;
              *(str + 1) = '\0';
            }
        }

#ifdef FIELD_WIDTH
      //Count how many pad chars are required in fieldwidth
      cstr = str;
      while (fieldwidth && *cstr)
        {
          ++cstr;
          --fieldwidth;
        }
      //Left padding
      if (!(flags & _LEFTALIGN))
        {
          ch = flags & _ZEROPAD ? '0' : ' ';
          while (fieldwidth)
            {
              _PUTCHAR(ch);
              --fieldwidth;
            }
        }
#endif

#ifdef PRECISION
      while (*str && ((precision == _UNSET) || precision--))
#else
      while (*str)
#endif
        {
          ch = *str++;
          if (radix == 16 && !(flags & _UPCASE))
            {
              ch = tolower (ch);
            }
          _PUTCHAR(ch);
        }

#ifdef FIELD_WIDTH
      //Right padding (with spaces)
      if (flags & _LEFTALIGN)
        {
          while (fieldwidth)
            {
              _PUTCHAR(' ');
              --fieldwidth;
            }
        }
#endif

    }

_error:
  return EOF;
}
/*-------------------------------------------------------------------------
   assert.c

   Copyright (C) 2000, Michael Hope

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

#if !(defined(__SDCC_pic14) && !defined(__SDCC_PIC14_HAS_VARARGS))
void __assert(const char *expression, const char *functionname, const char *filename, unsigned int linenumber)
{
	printf("Assert(%s) failed in function %s at line %u in file %s.\n",
		expression, functionname, linenumber, filename);
	for(;;);
}
#endif

/*---------------------------------------------------------------------
   bsearch() - search a sorted array

   Copyright (C) 2018, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdlib.h>

#if !(defined(__SDCC_pic14) && !defined(__SDCC_PIC14_HAS_PCALL))
void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *) __reentrant)
{
	for(const char *left = base; nmemb;)
	{
		const char *middle = left + nmemb / 2 * size;
		int c = (*compar)(key, middle);

		if(c < 0)
			nmemb = nmemb / 2;	
		else if(c > 0)
		{
			left = middle + size;
			nmemb = (nmemb - 1) / 2;
		}
		else
			return(middle);
	}

	return(0);
}
#endif

/*-------------------------------------------------------------------------
   vsprintf.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

int
vsprintf (char *str, const char *fmt, va_list ap)
{
  int i;
  FILE f = str;

  i = vfprintf (&f, fmt, ap);
  str[i] = '\0';
  return i;
}
/*-------------------------------------------------------------------------
   fprintf.c

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdarg.h>
#include <stdio.h>

#if !(defined(__SDCC_pic14) && !defined(__SDCC_PIC14_HAS_VARARGS))
int
fprintf (FILE *stream, const char *fmt, ...)
{
  int i;
  va_list ap;

  va_start (ap, fmt);
  i = vfprintf (stream, fmt, ap);
  va_end (ap);
  return i;
}
#endif
/*-------------------------------------------------------------------------
   putchar.c - putchar dummy function

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

/* This is a dummy function so that sources compile,
 * even when user doesn't give a putchar() function. */

int putchar (int c)
{
  (void)c;
  return EOF;
}
/*-----------------------------------------------------------------
    printfl.c - source file for reduced version of printf

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   2001060401: Improved by was@icb.snz.chel.su

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* following formats are supported :-
   format     output type       argument-type
     %d        decimal             int
     %ld       decimal             long
     %hd       decimal             char
     %x        hexadecimal         int
     %lx       hexadecimal         long
     %hx       hexadecimal         char
     %o        octal               int
     %lo       octal               long
     %ho       octal               char
     %c        character           char
     %s        character           generic pointer
*/

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#if !(defined(__SDCC_pic14) && !defined(__SDCC_PIC14_HAS_VARARGS))

#if defined(__SDCC_pic14)
#include <stdbool.h>
#define __reentrant
#define __idata      __data
#define __bit        bool
#endif

static __data char radix ;
static __bit  long_flag = 0;
static __bit  string_flag =0;
static __bit  char_flag = 0;
static char * __data str ;
static __data long val;

/* This great loop fails with the ds390 port (2003-01-13).

   At the beginning resp. end of the loop the compiler inserts a "push ar2"
   resp. "pop ar2", which badly interferes with the push/pop in the source.

   Library functions should be rock solid and portable. There's an _ltoa in
   the library, so let's use it and don't reinvent the wheel.

   Bernhard
*/

#if NICE_LIFO_IMPLEMENTATION_BUT_NOT_PORTABLE
/* just for the SP */
#include <8051.h>

static __data volatile char ch;
static __bit sign;

static void pval(void)
{
        volatile char sp;
        unsigned long lval;
        sp = SP;

        if (val < 0 && radix != 16)
        {
           lval = -val;
           sign = 1;
        }
        else { sign = 0; lval = val;}

        if (!long_flag) {
          lval &= 0x0000ffff;
        }
        if (char_flag) {
          lval &= 0x000000ff;
        }

        do
        {

#  if 1
                if(radix != 16)  ch = (lval % radix) + '0';
                else ch = "0123456789ABCDEF"[(unsigned char)lval & 0x0f];
                __asm push _ch __endasm;
                lval /= radix;
#  else
                // This only looks more efficient, but isn't. see the .map
                ch = (lval % radix) + '0';
                if (ch>'9') ch+=7;
                __asm push _ch __endasm;
                lval /= radix;
#  endif
        }
        while (lval);

        if (sign) {
                ch = '-';
                __asm push _ch __endasm;
        }

        while (sp != SP) {
                __asm pop _ch __endasm;
                putchar(ch);
        }
}
#endif

#if defined(__SDCC_pic14)
void printf_small (const char *fmt, ...)
#else
void printf_small (char * fmt, ... ) __reentrant
#endif
{
    va_list ap ;

    va_start(ap,fmt);

    for (; *fmt ; fmt++ ) {
        if (*fmt == '%') {
            long_flag = string_flag = char_flag = 0;
            fmt++ ;
            switch (*fmt) {
            case 'l':
                long_flag = 1;
                fmt++;
                break;
            case 'h':
                char_flag = 1;
                fmt++;
            }

            switch (*fmt) {
            case 's':
                string_flag = 1;
                break;
            case 'd':
                radix = 10;
                break;
            case 'x':
                radix = 16;
                break;
            case 'c':
                radix = 0;
                break;
            case 'o':
                radix = 8;
                break;
            }

            if (string_flag) {
                str = va_arg(ap, char *);
                while (*str) putchar(*str++);
                continue ;
            }

            if (long_flag)
                val = va_arg(ap,long);
            else
                if (char_flag)
                    val = va_arg(ap,char);
                else
                    val = va_arg(ap,int);

#if NICE_LIFO_IMPLEMENTATION_BUT_NOT_PORTABLE
            if (radix) pval();
#else
            if (radix)
            {
              static char __idata buffer[12]; /* 37777777777(oct) */
              char __idata * stri;

              _ltoa (val, buffer, radix);
              stri = buffer;
              while (*stri)
                {
                  putchar (*stri);
                  stri++;
                }
            }
#endif
            else
              putchar((char)val);

        } else
            putchar(*fmt);
    }
}
#endif /* __SDCC_pic14 */
/*-------------------------------------------------------------------------
   aligned_alloc.c

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2015 Goethe-Universit√§t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#pragma std_c11

#include <stddef.h>

/* it is important to declare this function extern before including
   the inline definition to give it external linkage */

#if defined(__SDCC_pic14)
extern void __data *aligned_alloc(size_t alignment, size_t size);
#else
extern void *aligned_alloc(size_t alignment, size_t size);
#endif

#include <stdlib.h>

/*-------------------------------------------------------------------------
   memmisc.c - heap handling functions

   Copyright (C) 2005, Vangelis Rokas <vrokas at otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <pic14_malloc.h>
#include <string.h>

_malloc_rec __data *_malloc_heap = NULL;

void _initHeap (void __data *ptr, size_t size)
{
    _malloc_rec __data *head;
    size_t used_size = 0;
    size_t block_size;

    if (ptr == NULL || size == 0)
    {
        _malloc_heap = NULL;
        return;
    }

    _malloc_heap = (_malloc_rec __data *)ptr;
    head = _malloc_heap;
    /* we need one byte as the end of block list marker */
    size--;

    while (used_size < size) {
        /* a guess of the next block size */
        block_size = (size - used_size); /* thus: block_size > 0 */
        if (block_size > MAX_BLOCK_SIZE)
	    block_size = MAX_BLOCK_SIZE;
 
        /* now we can create the block */
        head->datum = block_size;
        head = NEXTREC(head);
 
        used_size += block_size;
    }

    /* mark end of block list */
    head->datum = 0;
}

/* try to allocate a block from the heap of at least size bytes,
 * merging adjacent blocks if necessary.
 * if ptr is not NULL, it may be included into the merged blocks.
 */
void __data *_allocateHeap (void __data *ptr, size_t size)
{
    _malloc_rec __data *current_head, *next_head, *realloc_head;
    size_t block_size;

    if (_malloc_heap == NULL)
        return ((void __data *)NULL);

    if (size >= MAX_BLOCK_SIZE)
        return ((void __data *)NULL);

    if (ptr)
        realloc_head = PTR2REC(ptr);
    else
        realloc_head = NULL;

    current_head = next_head = _malloc_heap;
    block_size = 0;
    size++;
    while (next_head->datum != 0)
    {
        if (next_head->bits.alloc == 0 || next_head == realloc_head)
        {
            block_size += next_head->bits.count;
            if (block_size >= size)
            {
                /* block found */
                if (realloc_head)
                {
                    memmove (REC2PTR(current_head), ptr, realloc_head->bits.count - 1);
                    if (next_head != realloc_head)
                        realloc_head->bits.alloc = 0;
                }
                current_head->datum = ALLOC_FLAG + size;
                if (block_size > size)
                {
                    next_head = NEXTREC(current_head);
                    next_head->datum = block_size - size;
                }
                return REC2PTR(current_head);
            }
            next_head = NEXTREC(next_head);
        }
        else
        {
            current_head = next_head = NEXTREC(next_head);
            block_size = 0;
        }
    }
    return ((void __data *)NULL);
}
/*-------------------------------------------------------------------------
   streams.c - source file for stream declarations

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

FILE *stdout = NULL;
/*-------------------------------------------------------------------------
   mbrtoc32.c - convert UTF-8 to UTF-16

   Copyright (C) 2016, Philipp Klaus Krause, pkk@spth.de

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <uchar.h>

#include <limits.h>
#include <wchar.h>

size_t mbrtoc16(char16_t *restrict pc16, const char *restrict s, size_t n, mbstate_t *restrict ps)
{
	char32_t codepoint;
	size_t ret;
	static mbstate_t sps;
	char16_t low_surrogate;

	if(!s)
#if defined(__SDCC_pic14)
		/* try to minimize nested calls */
		{ pc16 = 0; s = ""; n = 1; }
#else
		return(mbrtoc16(0, "", 1, ps));
#endif

	if(!ps)
		ps = &sps;

	if(!ps->c[0] && (ps->c[1] || ps->c[2]))
	{
		if(pc16)
			*pc16 = ps->c[1] + (ps->c[2] << 8);
		ps->c[1] = ps->c[2] = 0;
		return(-3);
	}

	ret = mbrtowc(&codepoint, s, n, ps);

	if(ret > MB_LEN_MAX)
		return(ret);

	if (codepoint <= 0xffff) // Basic multilingual plane
	{
		if(pc16)
			*pc16 = codepoint;
		return(ret);
	}

	codepoint -= 0x100000;
	if(pc16)
		*pc16 = ((codepoint >> 10) & 0x3ff) + 0xd800;
	low_surrogate = (codepoint & 0x3ff) + 0xdc00;
	ps->c[0] = 0;
	ps->c[1] = low_surrogate & 0xff;
	ps->c[2] = low_surrogate >> 8;

	return(ret);
}

/*-------------------------------------------------------------------------
   x_ftoa.c - wrapper function to use _convert_float

   Copyright (C) 2004, Vangelis Rokas <vrokas at otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#define __SDCC_FLOAT_LIB
#include <float.h>
#include <stdlib.h>

union {
    unsigned long l;
    float f;
} lf;
int e2;
int e10;

#define M       lf.l    /* mantissa */
#define F       lf.f    /* float */
#define E2      e2      /* exponent base 2 */
#define E10     e10     /* exponent base 10 */

/* While processing decimal output we consider the mantissa as a
 * fixed point number with the integer part in bits 31:28 and the
 * fractional part in bits 27:0.
 */
#define MANT_UNIT       (1UL << 28)

static char *S; /* the output string */

static void _div2 (void)
{
    M = ((M + 1) >> 1);
}

static void _mul2 (void)
{
    M = (M << 1);
}

static void _div5 (void)
{
    M = ((M + 2) / 5);
}

static void _mul5 (void)
{
    M = (M + (M << 2));
}

static void _div10 (void)
{
    M = ((M + 5) / 10);
}

static void _mul10 (void)
{
    M = ((M + (M << 2)) << 1);
}

static void _round (int x)
{
    if (x >= 0)
    {
        unsigned long r = M;
        M = (MANT_UNIT >> 1);
        while (x > 0)
        {
            _div10();
            --x;
        }
        M += r;
        if (M >= 10 * MANT_UNIT)
        {
            _div10();
            ++E10;
        }
    }
}

static void _put_char (char c)
{
    *S++ = c;
}

static void _put_digit (void)
{
    _put_char( '0' + ((M >> 28) & 0x0f));
    M &= 0x0fffffffUL;
    _mul10();
}

void _ftoa (float value, char *str, unsigned char prec)
{
    F = value;
    S = str;
 
    /* output sign */
    if (SIGN(M))
        _put_char('-');
 
    E2 = EXP(M);
    M = MANT(M);
 
    /* infinity or not a number */
    if (E2 == 255)
    {
        if (M == HIDDEN)
        {
            /* infinity */
            _put_char('i');
            _put_char('n');
            _put_char('F');
        }
        else
        {
            /* not a number */
            _put_char('n');
            _put_char('a');
            _put_char('n');
        }
        _put_char('\0');
        return;
    }

    /* zero or denormal number */
    if (E2 == 0)
    {
        if (M == HIDDEN)
        {
            /* zero */
            _put_char('0');
            E10 = prec & PREC_P;
            if (E10)
            {
                _put_char('.');
                while (E10--)
                    _put_char('0');
            }
            if (prec & PREC_E)
            {
                _put_char('E2');
                _put_char('+');
                _put_char('0');
                _put_char('0');
            }
            _put_char('\0');
            return;
        }
        else
        {
            /* denormal number: value = (M - HIDDEN) * pow (2, - 149) */
            M &= ~HIDDEN;
            E2 = 1;
            while (M < HIDDEN)
            {
                 _mul2();
                 --E2;
            }
        }
    }

    /* Now we have a normalized number with value = M * pow (2, E2 - 150)
     * where (1 << 23) <= M < (1 << 24) and -22 <= E2 < 255
     *
     * We adjust it to make M a base2 fixed point value with the implicit
     * decimal point at bit 28 (so bits 31:28 are the integer part and
     * bits 27:0 are the fractional part) and E2 is the unbiased base2
     * exponent.
     *
     * Then we convert it to M * pow (10, E10)
     */
    M <<= (28-23);      /* now MANT_UNIT <= M < 2 * MANT_UNIT */
    E2 -= EXCESS + 1;       /* now -149 <= E2 < 128 */
    E10 = 0;        /* base 10 exponent */
    while (E2 > 0)
    {
        if (M < 5 * MANT_UNIT)
        {
            _mul2();
        }
        else
        {
            _div5();
            ++E10;
        }
        --E2;
    }
    while (E2 < 0)
    {
        if (M < 2 * MANT_UNIT)
        {
            _mul5();
            --E10;
        }
        else
        {
            _div2();
        }
        ++E2;
    }
    while (M < MANT_UNIT)
    {
        _mul10();
        --E10;
    }
    /* Now we have a number with value = M * pow (10, E10)
     * where 1 <= M < 10 with fixed point after bit 28.
     */
    /* Format G: use format E10 if exp < -4 or exp >= prec; format F otherwise. */
    if ((prec & (PREC_E|PREC_F)) == 0)
    {
        if (E10 < -4 || E10 >= prec)
            prec |= PREC_E;
        else
            prec |= PREC_F;
    }
    /* Format E: [-]d.dddE+-dd rounded to 'prec' fractional digits (prec >= 0) */
    if (prec & PREC_E)
    {
        _round(prec & PREC_P);
        _put_digit();
        E2 = prec & PREC_P;
        if (E2 > 0)
        {
            _put_char('.');
            while (E2 > 0)
            {
                _put_digit();
                --E2;
            }
        }
        _put_char('E');
        if (E10 < 0)
        {
            _put_char('-');
            E10 = - E10;
        }
        else
        {
            _put_char('+');
        }
        _uitoa (E10, S, 10);
    }
    /* Format F: [-]ddd.ddd rounded to 'prec' fractional digits (prec >= 0) */
    else
    {
        _round(E10 + (prec & PREC_P));
        /* Print the integer part */
        if (E10 >= 0)
        {
            while (E10 >= 0)
            {
                _put_digit();
                --E10;
            }
        }
        else
        {
            _put_char('0');
        }
        E2 = prec & PREC_P;
        if (E2 > 0)
        {
            /* Print the fractional part */
            _put_char('.');
            while (E2 > 0)
            {
                if (E10 < -1)
                {
                    _put_char('0');
                    ++E10;
                }
                else
                {
                    _put_digit();
                }
                --E2;
            }
        }
        _put_char('\0');
    }
}
/*-------------------------------------------------------------------------
   fputc.c - write a character to a stream

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

int fputc (char c, FILE *stream)
{
  char *p;
  unsigned char tag;

  /* if stream is NULL use putchar */
  if (!stream)
  	return putchar (c);

  p = *stream;
  tag = ((char*)&p)[2];

  /* this is a __code pointer */
  if (tag)
#if !(defined(__SDCC_pic14) && !defined(__SDCC_PIC14_HAS_PCALL))
  	return ((_stream_out_handler*)p) (c, stream);
#else
	return EOF;
#endif

  /* this is a __data pointer */
  *p = c;
  *(char **)stream = p+1;

  return (unsigned char)c;
}
/*-------------------------------------------------------------------------
   fputs.c - write a string, without the terminating null byte, to a stream

   Copyright (C) 2005, Vangelis Rokas <vrokas AT otenet.gr>

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <stdio.h>

/* Must return a non-negative number on success, or EOF on error.
 * Just for convenience, in case of success returns the number of
 * characters written.
 */
int fputs (const char *s, FILE *stream)
{
  int ret = 0;
  while (*s)
    {
      if (fputc (*s++, stream) < 0)
        return EOF;
      ret++;
    }
  return ret;
}
/*-------------------------------------------------------------------------
   _mulint.c - routine for (unsigned) int (16 bit) multiplication

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Signed and unsigned multiplication are the same - as long as the output
   has the same precision as the input.

   Assembler-functions are provided for:
     ds390
     mcs51 small
     mcs51 small stack-auto
     mcs51 large
*/

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_ds390)
#    if !defined(__SDCC_STACK_AUTO)
#      define _MULINT_ASM_LARGE
#    endif
#  elif defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO) && !defined(__SDCC_PARMS_IN_BANK1)
#        define _MULINT_ASM_SMALL_AUTO
#      else
#        define _MULINT_ASM_SMALL
#      endif
#    else // must be __SDCC_MODEL_LARGE
#      if !defined(__SDCC_STACK_AUTO)
#        define _MULINT_ASM_LARGE
#     endif
#   endif
#  endif
#endif

#if defined(_MULINT_ASM_LARGE)

#pragma save
#pragma less_pedantic
int
_mulint (int a, int b)
{
  a*b; // hush the compiler

  /* mulint=
      (int)(lsb_a*lsb_b) +
      (char)(msb_a*lsb_b)<<8 +
      (char)(lsb_a*msb_b)<<8
  */

  __asm
    mov r2,dph ; msb_a
    mov r3,dpl ; lsb_a

    mov b,r3 ; lsb_a
#if defined(__SDCC_PARMS_IN_BANK1)
    mov a,b1_0
#else
    mov dptr,#__mulint_PARM_2
    movx a,@dptr ; lsb_b
#endif
    mul ab ; lsb_a*lsb_b
    mov r0,a
    mov r1,b

    mov b,r2 ; msb_a
#if defined(__SDCC_PARMS_IN_BANK1)
    mov a,b1_0
#else
    movx a,@dptr ; lsb_b
#endif
    mul ab ; msb_a*lsb_b
    add a,r1
    mov r1,a

    mov b,r3 ; lsb_a
#if defined(__SDCC_PARMS_IN_BANK1)
    mov a,b1_1
#else
    inc dptr
    movx a,@dptr ; msb_b
#endif
    mul ab ; lsb_a*msb_b
    add a,r1

    mov dph,a
    mov dpl,r0
    ret
  __endasm;
}
#pragma restore

#elif defined(_MULINT_ASM_SMALL) || defined(_MULINT_ASM_SMALL_AUTO)

#pragma save
#pragma less_pedantic
int
_mulint_dummy (void) __naked
{
	__asm

__mulint:

	.globl __mulint

#if !defined(__SDCC_STACK_AUTO) || defined(__SDCC_PARMS_IN_BANK1)

#if defined(__SDCC_NOOVERLAY)
	.area DSEG    (DATA)
#else
	.area OSEG    (OVR,DATA)
#endif
#if defined(__SDCC_PARMS_IN_BANK1)
	#define bl 	(b1_0)
	#define bh 	(b1_1)
#else
	#define bl 	(__mulint_PARM_2)
	#define bh 	(__mulint_PARM_2 + 1)
__mulint_PARM_2:

	.globl __mulint_PARM_2

	.ds	2
#endif

	.area CSEG    (CODE)

	; globbered registers none

	mov	a,dpl			;  1  al
	mov	b,bl			;  2  bl
	mul	ab			;  4  al * bl
	xch	a,dpl			;  1  store low-byte of return value, fetch al
	push	b			;  2

	mov	b,bh			;  2  bh
	mul	ab			;  4  al * bh
	pop	b			;  2
	add	a,b			;  1
	xch	a,dph			;  1  ah -> acc

	mov	b,bl			;  2  bl
	mul	ab			;  4  ah * bl
	add	a,dph			;  1
	mov	dph,a			;  1
	ret				;  2
					; 30

#else // __SDCC_STACK_AUTO

	; globbered registers r0

	mov	a,#-2			;  1  return address 2 bytes
	add	a,sp			;  1
	mov	r0,a			;  1  r0 points to bh

	mov	a,@r0			;  1  bh
	mov	b,dpl			;  2  al
	mul	ab			;  4  al * bh
	push	acc			;  2

	mov	b,dpl			;  2  al
	dec	r0			;  1
	mov	a,@r0			;  1  bl
	mul	ab			;  4  al * bl

	mov	dpl,a			;  1  low-byte of return-value

	pop	acc			;  2
	add	a,b			;  1
	xch	a,dph			;  1  ah -> acc

	mov	b,@r0			;  2  bl
	mul	ab			;  4  ah * bl
	add	a,dph			;  1
	mov	dph,a			;  1

	ret

#endif // __SDCC_STACK_AUTO

	__endasm;
}
#pragma restore

#else

#if defined(__SDCC_hc08) || defined(__SDCC_s08) || defined(__SDCC_stm8)
// Big-endian
union uu {
	struct { unsigned char hi, lo ;} s;
        unsigned int t;
};
#else
// Little-endian
union uu {
	struct { unsigned char lo,hi ;} s;
        unsigned int t;
};
#endif

int
_mulint (int a, int b)
{
#if !defined(__SDCC_STACK_AUTO) && (defined(__SDCC_MODEL_LARGE) || defined(__SDCC_ds390))	// still needed for large
	union uu __xdata *x;
	union uu __xdata *y;
	union uu t;
        x = (union uu __xdata *)&a;
        y = (union uu __xdata *)&b;
#elif defined(__SDCC_pic14)
	union uu x;
	union uu y;
	union uu t;
        x.t = a;
        y.t = b;
#else
	register union uu *x;
	register union uu *y;
	union uu t;
        x = (union uu *)&a;
        y = (union uu *)&b;
#endif

  // sdcc is bad at handling union accesses. So we use (unsigned char)a instead of x->s.lo here.
#if defined(__SDCC_pic14)
  t.t = x.s.lo * y.s.lo;
  t.s.hi += (x.s.lo * y.s.hi) + (x.s.hi * y.s.lo);
#else
  t.t = (unsigned char)a * (unsigned char)b;
  t.s.hi += ((unsigned char)a * y->s.hi) + (x->s.hi * (unsigned char)b);
#endif

  return t.t;
}

#endif

#undef _MULINT_ASM
/*-------------------------------------------------------------------------
   idata.c - startup code evaluating gputils' cinit structure

   Copyright (C) 2007, Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * This code fragment copies initialized data from ROM to their
 * assigned RAM locations. The required cinit structure is created
 * by gputils' linker and comprises initial values of all linked in
 * modules.
 */

/*
 * We call the user's main() after initialization is done.
 */
extern void main(void);

/*
 * Force generation of _cinit symbol.
 */
static char force_cinit = 0;

/*
 * This struct describes one initialized variable.
 */
typedef struct {
    unsigned src;   // source address of data in CODE space
    unsigned dst;   // destination address of values in DATA space
    unsigned size;  // number of bytes to copy from `src' to `dst'
} cinit_t;

/*
 * This structure provides the number and position of the above
 * structs. to initialize all variables in the .hex file.
 */
extern __code struct {
    unsigned	records;    // number of entries in this file
    cinit_t	entry[];    // intialization descriptor
} cinit;

/*
 * Iterate over all records and copy values from ROM to RAM.
 */
void
_sdcc_gsinit_startup(void)
{
    unsigned num, size;
    __code cinit_t *cptr;
    __code char *src;
    __data char *dst;

    num = cinit.records;
    cptr = &cinit.entry[0];

    // iterate over all cinit entries
    while (num--) {
	size = cptr->size;
	src = (__code char *) cptr->src;
	dst = (__data char *) cptr->dst;

	// copy data byte-wise from ROM to RAM
	while (size--) {
	    *dst = *src;
	    src++;
	    dst++;
	} // while

	// XXX: might need to clear the watchdog timer here...
	cptr++;
    } // while

    // call main after initialization
    __asm
        EXTERN _main
	PAGESEL _main
	GOTO _main
    __endasm;
}
/*-------------------------------------------------------------------------
   _mullong.c - routine for multiplication of 32 bit (unsigned) long

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net
   Copyright (C) 1999, Jean Louis VERN jlvern@writeme.com

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Signed and unsigned multiplication are the same - as long as the output
   has the same precision as the input.

   Assembler-functions are provided for:
     mcs51 small
     mcs51 small stack-auto
*/

#if !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
#  if defined(__SDCC_mcs51)
#    if defined(__SDCC_MODEL_SMALL)
#      if defined(__SDCC_STACK_AUTO) && !defined(__SDCC_PARMS_IN_BANK1)
#        define _MULLONG_ASM_SMALL_AUTO
#      else
#        define _MULLONG_ASM_SMALL
#      endif
#    elif defined(__SDCC_MODEL_LARGE)
#      if !defined(__SDCC_STACK_AUTO)
#        define _MULLONG_ASM_LARGE
#      endif
#    endif
#  endif
#endif

#if defined(_MULLONG_ASM_SMALL) || defined(_MULLONG_ASM_SMALL_AUTO)

void
_mullong_dummy (void) __naked
{
	__asm

__mullong:

	.globl __mullong

				; the result c will be stored in r4...r7
	#define c0 r4
	#define c1 r5
	#define c2 r6
	#define c3 r7

	#define a0 dpl
	#define a1 dph
	#define a2 r2
	#define a3 r3

	; c0  a0 * b0
	; c1  a1 * b0 + a0 * b1
	; c2  a2 * b0 + a1 * b1 + a0 * b2
	; c3  a3 * b0 + a2 * b1 + a1 * b2 + a0 * b3

#if !defined(__SDCC_STACK_AUTO) || defined(__SDCC_PARMS_IN_BANK1)
#if defined(__SDCC_PARMS_IN_BANK1)
	#define b0  (b1_0)
	#define b1  (b1_1)
	#define b2  (b1_2)
	#define b3  (b1_3)
#else
#if defined(__SDCC_NOOVERLAY)
	.area DSEG    (DATA)
#else
	.area OSEG    (OVR,DATA)
#endif

__mullong_PARM_2:

	.globl __mullong_PARM_2

	.ds	4

	b0 =  __mullong_PARM_2
	b1 = (__mullong_PARM_2+1)
	b2 = (__mullong_PARM_2+2)
	b3 = (__mullong_PARM_2+3)

#endif
	.area CSEG    (CODE)

				; parameter a comes in a, b, dph, dpl
	mov	r2,b		; save parameter a
	mov	r3,a

				;	Byte 0
	mov	a,a0
	mov	b,b0
	mul	ab		; a0 * b0
	mov	c0,a
	mov	c1,b

				;	Byte 1
	mov	a,a1
	mov	b,b0
	mul	ab		; a1 * b0
	add	a,c1
	mov	c1,a
	clr	a
	addc	a,b
	mov	c2,a

	mov	a,a0
	mov	b,b1
	mul	ab		; a0 * b1
	add	a,c1
	mov	c1,a
	mov	a,b
	addc	a,c2
	mov	c2,a
	clr	a
	rlc	a
	mov	c3,a

				;	Byte 2
	mov	a,a2
	mov	b,b0
	mul	ab		; a2 * b0
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	a,a1
	mov	b,b1
	mul	ab		; a1 * b1
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	a,a0
	mov	b,b2
	mul	ab		; a0 * b2
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

				;	Byte 3
	mov	a,a3
	mov	b,b0
	mul	ab		; a3 * b0
	add	a,c3
	mov	c3,a

	mov	a,a2
	mov	b,b1
	mul	ab		; a2 * b1
	add	a,c3
	mov	c3,a

	mov	a,a1
	mov	b,b2
	mul	ab		; a1 * b2
	add	a,c3
	mov	c3,a

	mov	a,a0
	mov	b,b3
	mul	ab		; a0 * b3
	add	a,c3

	mov	b,c2
	mov	dph,c1
	mov	dpl,c0
	ret

#else // __SDCC_STACK_AUTO

				; parameter a comes in a, b, dph, dpl
	mov	r2,b		; save parameter a
	mov	r3,a

	#define a0 dpl
	#define a1 dph
	#define a2 r2
	#define a3 r3

	#define b0 r1

	mov	a,#-2-3		;  1  return address 2 bytes, b 4 bytes
	add	a,sp		;  1
	mov	r0,a		;  1  r0 points to b0

				;	Byte 0
	mov	a,a0
	mov	b,@r0		; b0
	mov	b0,b		; we need b0 several times
	inc	r0		; r0 points to b1
	mul	ab		; a0 * b0
	mov	c0,a
	mov	c1,b

				;	Byte 1
	mov	a,a1
	mov	b,b0
	mul	ab		; a1 * b0
	add	a,c1
	mov	c1,a
	clr	a
	addc	a,b
	mov	c2,a

	mov	a,a0
	mov	b,@r0		; b1
	mul	ab		; a0 * b1
	add	a,c1
	mov	c1,a
	mov	a,b
	addc	a,c2
	mov	c2,a
	clr	a
	rlc	a
	mov	c3,a

				;	Byte 2
	mov	a,a2
	mov	b,b0
	mul	ab		; a2 * b0
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	a,a1
	mov	b,@r0		; b1
	mul	ab		; a1 * b1
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	a,a0
	inc	r0
	mov	b,@r0		; b2
	mul	ab		; a0 * b2
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

				;	Byte 3
	mov	a,a3
	mov	b,b0
	mul	ab		; a3 * b0
	add	a,c3
	mov	c3,a

	mov	a,a1
	mov	b,@r0		; b2
	mul	ab		; a1 * b2
	add	a,c3
	mov	c3,a

	mov	a,a2
	dec	r0
	mov	b,@r0		; b1
	mul	ab		; a2 * b1
	add	a,c3
	mov	c3,a

	mov	a,a0
	inc	r0
	inc	r0
	mov	b,@r0		; b3
	mul	ab		; a0 * b3
	add	a,c3

	mov	b,c2
	mov	dph,c1
	mov	dpl,c0

	ret

#endif // __SDCC_STACK_AUTO

	__endasm;
}

#elif defined(_MULLONG_ASM_LARGE)

void
_mullong_dummy (void) __naked
{
	__asm

__mullong:

	.globl __mullong

				; the result c will be stored in r4...r7
	#define c0 r4
	#define c1 r5
	#define c2 r6
	#define c3 r7

	; c0  a0 * b0
	; c1  a1 * b0 + a0 * b1
	; c2  a2 * b0 + a1 * b1 + a0 * b2
	; c3  a3 * b0 + a2 * b1 + a1 * b2 + a0 * b3

#if !defined(__SDCC_PARMS_IN_BANK1)
	.area XSEG    (XDATA)

__mullong_PARM_2:

	.globl __mullong_PARM_2

	.ds	4
#endif
	.area CSEG    (CODE)

				; parameter a comes in a, b, dph, dpl
	mov	r0,dpl		; save parameter a
	mov	r1,dph
	mov	r2,b
	mov	r3,a

	#define a0 r0
	#define a1 r1
	#define a2 r2
	#define a3 r3

				;	Byte 0
	mov	b,a0
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_0		; b0
#else
	mov	dptr,#__mullong_PARM_2
	movx	a,@dptr		; b0
#endif
	mul	ab		; a0 * b0
	mov	c0,a
	mov	c1,b

				;	Byte 1
	mov	b,a1
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_0		; b0
#else
	movx	a,@dptr		; b0
#endif
	mul	ab		; a1 * b0
	add	a,c1
	mov	c1,a
	clr	a
	addc	a,b
	mov	c2,a

	mov	b,a0
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_1		; b1
#else
	inc	dptr		; b1
	movx	a,@dptr
#endif
	mul	ab		; a0 * b1
	add	a,c1
	mov	c1,a
	mov	a,b
	addc	a,c2
	mov	c2,a
	clr	a
	rlc	a
	mov	c3,a

				;	Byte 2
	mov	b,a1
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_1		; b1
#else
	movx	a,@dptr		; b1
#endif
	mul	ab		; a1 * b1
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	b,a0
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_2		; b2
#else
	inc	dptr		; b2
	movx	a,@dptr
#endif
	mul	ab		; a0 * b2
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	b,a2
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_0		; b0
#else
	mov	dptr,#__mullong_PARM_2
	movx	a,@dptr		; b0
#endif
	mul	ab		; a2 * b0
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

				;	Byte 3
	mov	b,a3
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_0		; b0
#else
	movx	a,@dptr		; b0
#endif
	mul	ab		; a3 * b0
	add	a,c3
	mov	c3,a

	mov	b,a2
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_1		; b1
#else
	inc	dptr		; b1
	movx	a,@dptr
#endif
	mul	ab		; a2 * b1
	add	a,c3
	mov	c3,a

	mov	b,a1
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_2		; b2
#else
	inc	dptr		; b2
	movx	a,@dptr
#endif
	mul	ab		; a1 * b2
	add	a,c3
	mov	c3,a

	mov	b,a0
#if defined(__SDCC_PARMS_IN_BANK1)
	mov	a,b1_3		; b3
#else
	inc	dptr		; b3
	movx	a,@dptr
#endif
	mul	ab		; a0 * b3
	add	a,c3

	mov	b,c2
	mov	dph,c1
	mov	dpl,c0
	ret

	__endasm;
}

#elif defined(__SDCC_USE_XSTACK) && defined(__SDCC_STACK_AUTO)

void
_mullong_dummy (void) __naked
{
	__asm

__mullong:

	.globl __mullong

				; the result c will be stored in r4...r7
	#define c0 r4
	#define c1 r5
	#define c2 r6
	#define c3 r7

	#define a0 dpl
	#define a1 dph
	#define a2 r2
	#define a3 r3

	#define b0 r1

	; c0  a0 * b0
	; c1  a1 * b0 + a0 * b1
	; c2  a2 * b0 + a1 * b1 + a0 * b2
	; c3  a3 * b0 + a2 * b1 + a1 * b2 + a0 * b3

				; parameter a comes in a, b, dph, dpl
	mov	r2,b		; save parameter a
	mov	r3,a

	mov	a,#-4		;  1  b 4 bytes
	add	a,_spx		;  1
	mov	r0,a		;  1  r0 points to b0

				;	Byte 0
	movx	a,@r0		; b0
	mov	b0,a		; we need b0 several times
	inc	r0		; r0 points to b1
	mov	b,a0
	mul	ab		; a0 * b0
	mov	c0,a
	mov	c1,b

				;	Byte 1
	mov	a,a1
	mov	b,b0
	mul	ab		; a1 * b0
	add	a,c1
	mov	c1,a
	clr	a
	addc	a,b
	mov	c2,a

	mov	b,a0
	movx	a,@r0		; b1
	mul	ab		; a0 * b1
	add	a,c1
	mov	c1,a
	mov	a,b
	addc	a,c2
	mov	c2,a
	clr	a
	rlc	a
	mov	c3,a

				;	Byte 2
	mov	a,a2
	mov	b,b0
	mul	ab		; a2 * b0
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	b,a1
	movx	a,@r0		; b1
	mul	ab		; a1 * b1
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

	mov	b,a0
	inc	r0
	movx	a,@r0		; b2
	mul	ab		; a0 * b2
	add	a,c2
	mov	c2,a
	mov	a,b
	addc	a,c3
	mov	c3,a

				;	Byte 3
	mov	a,a3
	mov	b,b0
	mul	ab		; a3 * b0
	add	a,c3
	mov	c3,a

	mov	b,a1
	movx	a,@r0		; b2
	mul	ab		; a1 * b2
	add	a,c3
	mov	c3,a

	mov	b,a2
	dec	r0
	movx	a,@r0		; b1
	mul	ab		; a2 * b1
	add	a,c3
	mov	c3,a

	mov	b,a0
	inc	r0
	inc	r0
	movx	a,@r0		; b3
	mul	ab		; a0 * b3
	add	a,c3

	mov	b,c2
	mov	dph,c1
	mov	dpl,c0

	ret

	__endasm;
}

#else // _MULLONG_ASM

struct some_struct {
	short a ;
	char b;
	long c ;};
#if defined(__SDCC_hc08) || defined(__SDCC_s08) || defined(__SDCC_stm8)
/* big endian order */
union bil {
        struct {unsigned char b3,b2,b1,b0 ;} b;
        struct {unsigned short hi,lo ;} i;
        unsigned long l;
        struct { unsigned char b3; unsigned short i12; unsigned char b0;} bi;
} ;
#else
/* little endian order */
union bil {
        struct {unsigned char b0,b1,b2,b3 ;} b;
        struct {unsigned short lo,hi ;} i;
        unsigned long l;
        struct { unsigned char b0; unsigned short i12; unsigned char b3;} bi;
} ;
#endif

#if defined(__SDCC)
 #include <sdcc-lib.h>
#endif

#define bcast(x) ((union bil _AUTOMEM *)&(x))

/*
                     3   2   1   0
       X             3   2   1   0
       ----------------------------
                   0.3 0.2 0.1 0.0
               1.3 1.2 1.1 1.0
           2.3 2.2 2.1 2.0
       3.3 3.2 3.1 3.0
       ----------------------------
                  |3.3|1.3|0.2|0.0|   A
                    |2.3|0.3|0.1|     B
                    |3.2|1.2|1.0|     C
                      |2.2|1.1|       D
                      |3.1|2.0|       E
                        |2.1|         F
                        |3.0|         G
                          |-------> only this side 32 x 32 -> 32
*/
#if defined(__SDCC_USE_XSTACK)
// currently the original code without u fails with --xstack
// it runs out of pointer registers
long
_mullong (long a, long b)
{
        union bil t, u;

        t.i.hi   = bcast(a)->b.b0 * bcast(b)->b.b2;          // A
        t.i.lo   = bcast(a)->b.b0 * bcast(b)->b.b0;          // A
        u.bi.b3  = bcast(a)->b.b0 * bcast(b)->b.b3;          // B
        u.bi.i12 = bcast(a)->b.b0 * bcast(b)->b.b1;          // B
        u.bi.b0  = 0;                                        // B
        t.l += u.l;

        t.b.b3  += bcast(a)->b.b3 * bcast(b)->b.b0;          // G
        t.b.b3  += bcast(a)->b.b2 * bcast(b)->b.b1;          // F
        t.i.hi  += bcast(a)->b.b2 * bcast(b)->b.b0;          // E
        t.i.hi  += bcast(a)->b.b1 * bcast(b)->b.b1;          // D

        u.bi.b3  = bcast(a)->b.b1 * bcast(b)->b.b2;          // C
        u.bi.i12 = bcast(a)->b.b1 * bcast(b)->b.b0;          // C
        u.bi.b0  = 0;                                        // C
        t.l += u.l;

        return t.l;
}
#elif defined(__SDCC_z80) || defined(__SDCC_gbz80) || defined(__SDCC_r2k) || defined(__SDCC_r3k)
/* 32x32->32 multiplication to be used
   if 16x16->16 is faster than three 8x8->16.
   2009, by M.Bodrato ( http://bodrato.it/ )

   z80 and gbz80 don't have any hardware multiplication.
   r2k and r3k have 16x16 hardware multiplication.
 */
long
_mullong (long a, long b)
{
  unsigned short i12;

  bcast(a)->i.hi *= bcast(b)->i.lo;
  bcast(a)->i.hi += bcast(b)->i.hi * bcast(a)->i.lo;

  /* only (a->i.lo * b->i.lo) 16x16->32 to do. asm? */
  bcast(a)->i.hi += bcast(a)->b.b1 * bcast(b)->b.b1;

  i12 = bcast(b)->b.b0 * bcast(a)->b.b1;
  bcast(b)->bi.i12 = bcast(a)->b.b0 * bcast(b)->b.b1;

  /* add up the two partial result, store carry in b3 */
  bcast(b)->b.b3 = ((bcast(b)->bi.i12 += i12) < i12);

  bcast(a)->i.lo  = bcast(a)->b.b0 * bcast(b)->b.b0;

  bcast(b)->bi.b0 = 0;

  return a + b;
}
#elif defined(__SDCC_pic14)
long
_mullong (long a, long b)
{
        union bil x;
        union bil y;
        union bil t;
	x.l = a;
	y.l = b;

        t.i.hi = x.b.b0 * y.b.b2;           // A
        t.i.lo = x.b.b0 * y.b.b0;           // A
        t.b.b3 += x.b.b3 * y.b.b0;          // G
        t.b.b3 += x.b.b2 * y.b.b1;          // F
        t.i.hi += x.b.b2 * y.b.b0;          // E <- b lost in .lst
        // x.i.hi is free !
        t.i.hi += x.b.b1 * y.b.b1;          // D <- b lost in .lst

        x.bi.b3 = x.b.b1 * y.b.b2;  // C
        x.bi.i12 = x.b.b1 * y.b.b0; // C

        y.bi.b3 = x.b.b0 * y.b.b3;  // B
        y.bi.i12 = x.b.b0 * y.b.b1; // B

        y.bi.b0 = 0;                                // B
        x.bi.b0 = 0;                                // C
        t.l += (long)x.l;

        return t.l + (long)y.l;
}
#else
long
_mullong (long a, long b)
{
        union bil t;

        t.i.hi = bcast(a)->b.b0 * bcast(b)->b.b2;           // A
        t.i.lo = bcast(a)->b.b0 * bcast(b)->b.b0;           // A
        t.b.b3 += bcast(a)->b.b3 * bcast(b)->b.b0;          // G
        t.b.b3 += bcast(a)->b.b2 * bcast(b)->b.b1;          // F
        t.i.hi += bcast(a)->b.b2 * bcast(b)->b.b0;          // E <- b lost in .lst
        // bcast(a)->i.hi is free !
        t.i.hi += bcast(a)->b.b1 * bcast(b)->b.b1;          // D <- b lost in .lst

        bcast(a)->bi.b3 = bcast(a)->b.b1 * bcast(b)->b.b2;  // C
        bcast(a)->bi.i12 = bcast(a)->b.b1 * bcast(b)->b.b0; // C

        bcast(b)->bi.b3 = bcast(a)->b.b0 * bcast(b)->b.b3;  // B
        bcast(b)->bi.i12 = bcast(a)->b.b0 * bcast(b)->b.b1; // B

        bcast(b)->bi.b0 = 0;                                // B
        bcast(a)->bi.b0 = 0;                                // C
        t.l += a;

        return t.l + b;
}
#endif

#endif // _MULLONG_ASM
/*-------------------------------------------------------------------------
   _fsadd.c - Floating point library in optimized assembly for 8051

   Copyright (c) 2004, Paul Stoffregen, paul@pjrc.com

   Modifications for PIC14 by
   Copyright (C) 2019 Gonzalo P√©rez de Olaguer C√≥rdoba <salo@gpoc.es>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#define __SDCC_FLOAT_LIB
#include <float.h>
#include <stdbool.h>
#include <sdcc-lib.h>

#ifdef FLOAT_ASM_MCS51

// float __fsadd (float a, float b) __reentrant
static void dummy(void) __naked
{
	__asm

	// extract the two inputs, placing them into:
	//      sign     exponent   mantissa
	//      ----     --------   --------
	//  a:  sign_a   exp_a      r4/r3/r2
	//  b:  sign_b   exp_b      r7/r6/r5
	//
	// r1: used to extend precision of a's mantissa
	// r0: general purpose loop counter

	.globl	___fsadd
___fsadd:
	lcall	fsgetargs

	.globl	fsadd_direct_entry
fsadd_direct_entry:
	// we're going to extend mantissa to 32 bits temporarily
	mov	r1, #0

	// which exponent is greater?
	mov	a, exp_b
	cjne	a, exp_a, 00005$
	sjmp	00011$
00005$:	jnc	00010$

	// a's exponent was greater, so shift b's mantissa
	lcall	fs_swap_a_b

00010$:
	// b's exponent was greater, so shift a's mantissa
	mov	a, exp_b
	clr	c
	subb	a, exp_a
	lcall	fs_rshift_a	// acc has # of shifts to do

00011$:
	// decide if we need to add or subtract
	// sign_a and sign_b are stored in the flag bits of psw,
	// so this little trick checks if the arguements have the
	// same sign.
	mov	a, psw
	swap	a
	xrl	a, psw
	jb	acc.1, 00022$

00020$:
	// add the mantissas (both positive or both negative)
	mov	a, r2
	add	a, r5
	mov	r2, a
	mov	a, r3
	addc	a, r6
	mov	r3, a
	mov	a, r4
	addc	a, r7
	mov	r4, a
	// check for overflow past 24 bits
	jnc	00021$
	mov	a, #1
	lcall	fs_rshift_a
	mov	a, r4
	orl	a, #0x80
	mov	r4, a
00021$:
	ljmp	fs_round_and_return



00022$:
	// subtract the mantissas (one of them is negative)
	clr	c
	mov	a, r2
	subb	a, r5
	mov	r2, a
	mov	a, r3
	subb	a, r6
	mov	r3, a
	mov	a, r4
	subb	a, r7
	mov	r4, a
	jnc	00025$
	// if we get a negative result, turn it positive and
	// flip the sign bit
	clr	c
	clr	a
	subb	a, r1
	mov	r1, a
	clr	a
	subb	a, r2
	mov	r2, a
	clr	a
	subb	a, r3
	mov	r3, a
	clr	a
	subb	a, r4
	mov	r4, a
	cpl	sign_a
00025$:
	lcall	fs_normalize_a
	ljmp	fs_round_and_return

	__endasm;
}

#else

/*
** libgcc support for software floating point.
** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
** Permission is granted to do *anything* you want with this file,
** commercial or otherwise, provided this message remains intact.  So there!
** I would appreciate receiving any updates/patches/changes that anyone
** makes, and am willing to be the repository for said changes (am I
** making a big mistake?).
**
** Pat Wood
** Pipeline Associates, Inc.
** pipeline!phw@motown.com or
** sun!pipeline!phw or
** uunet!motown!pipeline!phw
*/

union float_long
  {
    float f;
    unsigned long l;
  };

/* add two floats */
float __fsadd (float a1, float a2)
{
  long mant1, mant2;
#if defined(__SDCC_pic14)
#define _INPUT(pflN,aN)   pflN.f = aN
#define _OUTPUT(aN,pflN)  pflN.f
#define _LONG(pflN)       pflN.l
  union float_long pfl1, pfl2;
#else
#define _INPUT(pflN,aN)   pflN = (long _AUTOMEM *)&aN
#define _OUTPUT(aN,pflN)  aN
#define _LONG(pflN)       *pflN
  long _AUTOMEM *pfl1;
  long _AUTOMEM *pfl2;
#endif
  int exp1, exp2, expd;
  bool sign = false;

  _INPUT(pfl2,a2);
  exp2 = EXP (_LONG(pfl2));
  mant2 = MANT (_LONG(pfl2)) << 4;
  if (SIGN (_LONG(pfl2)))
    mant2 = -mant2;
  /* check for zero args */
  if (!_LONG(pfl2))
    return (a1);

  _INPUT(pfl1,a1);
  exp1 = EXP (_LONG(pfl1));
  mant1 = MANT (_LONG(pfl1)) << 4;
  if (SIGN(_LONG(pfl1)))
  if (_LONG(pfl1) & 0x80000000)
    mant1 = -mant1;
  /* check for zero args */
  if (!_LONG(pfl1))
    return (a2);

  expd = exp1 - exp2;
  if (expd > 25)
    return (a1);
  if (expd < -25)
    return (a2);

  if (expd < 0)
    {
      expd = -expd;
      exp1 += expd;
      mant1 >>= expd;
    }
  else
    {
      mant2 >>= expd;
    }
  mant1 += mant2;

  sign = false;

  if (mant1 < 0)
    {
      mant1 = -mant1;
      sign = true;
    }
  else if (!mant1)
    return (0);

  /* normalize */
  while (mant1 < (HIDDEN<<4)) {
    mant1 <<= 1;
    exp1--;
  }

  /* round off */
  while (mant1 & 0xf0000000) {
    if (mant1&1)
      mant1 += 2;
    mant1 >>= 1;
    exp1++;
  }

  /* turn off hidden bit */
  mant1 &= ~(HIDDEN<<4);

  /* pack up and go home */
  if (exp1 >= 0x100)
    _LONG(pfl1) = (sign ? (SIGNBIT | __INFINITY) : __INFINITY);
  else if (exp1 < 0)
    _LONG(pfl1) = 0;
  else
    _LONG(pfl1) = PACK (sign ? SIGNBIT : 0 , exp1, mant1>>4);
  return (_OUTPUT(a1,pfl1));
}

#endif
; -------------------------------------------------------------------------
;  _gptrget1.S - read one byte pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget
	global	__gptrget1
	global	__codeptrget1
	
	CODE

__gptrget:
__gptrget1:
	select_routine __dataptrget1, __codeptrget1
	; invalid tag -- return 0x00
	retlw	0x00

__dataptrget1:
	setup_fsr
	movf	_INDF0, W
	return

__codeptrget1:
	; call the RETLW instruction at the given address
	movf	STK00, W
	movwf	_PCLATH
	movf	STK01, W
	movwf	_PCL
	return	; should never be executed...

	END
; -------------------------------------------------------------------------
;  _gptrget4.S - read four bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
; 
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
; 
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget4
	extern	__codeptrget1
	
	CODE

__gptrget4:
	select_routine __dataptrget4, __codeptrget4
	; invalid tag -- return 0x00000000
	clrf	STK02
	clrf	STK01
	clrf	STK00
	retlw	0x00

__dataptrget4:
	setup_fsr
        get_indf0_postinc
	movwf	STK02		; LSB in STK02
        get_indf0_postinc
	movwf	STK01		; 2nd byte in STK01
        get_indf0_postinc
	movwf	STK00		; 3rd byte in STK00
	movf	_INDF0, W	; MSB in WREG
	return

__codeptrget4:
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK02		; temporarily store LSB
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK03		; temporarily store 2nd byte
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK04		; temporarily store 3rd byte
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK05		; temporarily store MSB
	movf	STK02, W
	movwf	STK02		; LSB in STK02
	movf	STK03, W
	movwf	STK01		; 2nd byte in STK01
	movf	STK04, W
	movwf	STK00		; 3rd byte in STK00
	movf	STK05, W	; MSB in WREG
	return

	END
; -----------------------------------------------
; --- extern declared SFRs
; -----------------------------------------------
	extern _STATUS
	extern _FSR0L
	extern _FSR0H
	extern _INDF0
	extern _PCLATH
	extern _PCL

C	EQU	0
DC	EQU	1
Z	EQU	2
FSR0    EQU     0x04 ; for MOVWI FSR0++
FSR1    EQU     0x06
	
; -----------------------------------------------
; --- generic pointer access helpers
; -----------------------------------------------

GPTRTAG_DATA	EQU	0x00
GPTRTAG_CODE	EQU	0x80

; setup FSR0 to point to (STK00:STK01)
setup_fsr	macro
	movf	STK01, W
	movwf	_FSR0L
	movf	STK00, W
	movwf	_FSR0H
	endm

; dispatch according to gptr type
select_routine	macro	dataptr, codeptr
	; __data pointer tag: 0x00
	xorlw	GPTRTAG_DATA
	btfsc	_STATUS, Z
	goto	dataptr
	; __code pointer tag: 0x80
	xorlw	(GPTRTAG_DATA ^ GPTRTAG_CODE)
	btfsc	_STATUS, Z
	goto	codeptr
	endm

check_data	macro	dataptr
	; __data pointer tag: 0x00
	xorlw	GPTRTAG_DATA
	btfsc	_STATUS, Z
	goto	dataptr
	endm

get_indf0_postinc   macro
        movf    _INDF0, W
        incfsz  _FSR0L, F
        decf    _FSR0H, F
        incf    _FSR0H, F
        endm

put_indf0_postinc   macro
        movwf   _INDF0
        incfsz  _FSR0L, F
        decf    _FSR0H, F
        incf    _FSR0H, F
        endm
; -------------------------------------------------------------------------
;  _gptrget3.S - read three bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
; 
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
; 
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget3
	extern	__codeptrget1
	
	CODE

__gptrget3:
	select_routine __dataptrget3, __codeptrget3
	; invalid tag -- return 0x000000
	clrf	STK01
	clrf	STK00
	retlw	0x00

__dataptrget3:
	setup_fsr
        get_indf0_postinc
	movwf	STK01		; LSB in STK01
        get_indf0_postinc
	movwf	STK00		; 2nd byte in STK00
	movf	_INDF0, W	; MSB in WREG
	return

__codeptrget3:
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK02		; temporarily store LSB
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK03		; temporarily store 2nd byte
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK04		; temporarily store MSB
	movf	STK02, W
	movwf	STK01		; LSB in STK01
	movf	STK03, W
	movwf	STK00		; 2nd byte in STK00
	movf	STK04, W	; MSB in WREG
	return

	END
; -------------------------------------------------------------------------
;  _gptrput3.S : write three bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput3
	
	CODE

__gptrput3:
	check_data	__dataptrput3
	; cannot write to __code space
	return

__dataptrput3:
	setup_fsr
	movf	STK04, W	; get LSB(val)
        put_indf0_postinc
	movf	STK03, W	; get 2nd byte of val
        put_indf0_postinc
	movf	STK02, W	; get MSB(val)
	movwf	_INDF0
	return

	END
; -------------------------------------------------------------------------
;  _gptrget2.S - read two bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget2
	extern	__codeptrget1
	
	CODE

__gptrget2:
	select_routine __dataptrget2, __codeptrget2
	; invalid tag -- return 0x0000
	clrf	STK00
	retlw	0x00

__dataptrget2:
	setup_fsr
        get_indf0_postinc
	movwf	STK00		; low byte in STK00
	movf	_INDF0, W	; high byte in WREG
	return

__codeptrget2:
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK02		; temporarily store LSB
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK03		; temporarily store MSB
	movf	STK02, W
	movwf	STK00		; LSB in STK00
	movf	STK03, W	; MSB in WREG
	return
	
	END
; -------------------------------------------------------------------------
;  _gptrput2.S : write two bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput2
	
	CODE

__gptrput2:
	check_data	__dataptrput2
	; cannot write to __code space
	return

__dataptrput2:
	setup_fsr
	movf	STK03, W	; get LSB(val)
        put_indf0_postinc
	movf	STK02, W	; get MSB(val)
	movwf	_INDF0
	return

	END
; -------------------------------------------------------------------------
;  _gptrput1.S : write one byte pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput
	global	__gptrput1
	
	CODE

__gptrput:
__gptrput1:
	check_data	__dataptrput1
	; cannot write to __code space
	return

__dataptrput1:
	setup_fsr
	movf	STK02, W	; get LSB(val)
	movwf	_INDF0		; store LSB
	return

	END
; -------------------------------------------------------------------------
;  _gptrput4.S : write four bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput4
	
	CODE

__gptrput4:
	check_data	__dataptrput4
	; cannot write to __code space
	return

__dataptrput4:
	setup_fsr
	movf	STK05, W	; get LSB(val)
        put_indf0_postinc
	movf	STK04, W	; get 2nd byte of val
        put_indf0_postinc
	movf	STK03, W	; get 3rd byte of val
        put_indf0_postinc
	movf	STK02, W	; get MSB(val)
	movwf	_INDF0
	return

	END
; -------------------------------------------------------------------------
;  _gptrget1.S - read one byte pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget
	global	__gptrget1
	global	__codeptrget1
	
	CODE

__gptrget:
__gptrget1:
	select_routine __dataptrget1, __codeptrget1
	; invalid tag -- return 0x00
	retlw	0x00

__dataptrget1:
	setup_fsr
	movf	_INDF, W
	return

__codeptrget1:
	; call the RETLW instruction at the given address
	movf	STK00, W
	movwf	_PCLATH
	movf	STK01, W
	movwf	_PCL
	return	; should never be executed...

	END
/*-------------------------------------------------------------------------
   shadowregs.c - provide shadow register for use during interrupts

   Copyright (C) 2007, Raphael Neider <rneider AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
 * This file is part of SDCC's pic14 library and distributed under
 * the terms of the GPLv2 with linking exception; see COPYING in some
 * parent directory for details.
 */

/* 
 * We should make sure these always reside in the same bank,
 * so that we can save two BANKSELs in the interrupt entry code.
 */

unsigned char __sdcc_saved_fsr;
//unsigned char __sdcc_saved_pclath;
//unsigned char __sdcc_saved_status;

; -------------------------------------------------------------------------
;  _gptrget4.S - read four bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
; 
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
; 
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget4
	extern	__codeptrget1
	
	CODE

__gptrget4:
	select_routine __dataptrget4, __codeptrget4
	; invalid tag -- return 0x00000000
	clrf	STK02
	clrf	STK01
	clrf	STK00
	retlw	0x00

__dataptrget4:
	setup_fsr
	movf	_INDF, W
	movwf	STK02		; LSB in STK02
	inc_fsr
	movf	_INDF, W
	movwf	STK01		; 2nd byte in STK01
	inc_fsr
	movf	_INDF, W
	movwf	STK00		; 3rd byte in STK00
	inc_fsr
	movf	_INDF, W	; MSB in WREG
	return

__codeptrget4:
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK02		; temporarily store LSB
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK03		; temporarily store 2nd byte
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK04		; temporarily store 3rd byte
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK05		; temporarily store MSB
	movf	STK02, W
	movwf	STK02		; LSB in STK02
	movf	STK03, W
	movwf	STK01		; 2nd byte in STK01
	movf	STK04, W
	movwf	STK00		; 3rd byte in STK00
	movf	STK05, W	; MSB in WREG
	return

	END
; -----------------------------------------------
; --- extern declared SFRs
; -----------------------------------------------
	extern _STATUS
	extern _FSR
	extern _INDF
	extern _PCLATH
	extern _PCL

C	EQU	0
DC	EQU	1
Z	EQU	2
IRP	EQU	7
	
; -----------------------------------------------
; --- generic pointer access helpers
; -----------------------------------------------

GPTRTAG_DATA	EQU	0x00
GPTRTAG_CODE	EQU	0x80

; setup FSR to point to (STK00:STK01)
setup_fsr	macro
	movf	STK01, W
	movwf	_FSR
	; select indirectly addressed bank
	bcf	_STATUS, IRP
	btfsc	STK00, 0
	bsf	_STATUS, IRP
	endm

; increment FSR, update IRP on bank crossings
; FIXME: update IRP if FSR is reset to 0...
inc_fsr		macro
	incf	_FSR, F
	endm

; dispatch according to gptr type
select_routine	macro	dataptr, codeptr
	; __data pointer tag: 0x00
	xorlw	GPTRTAG_DATA
	btfsc	_STATUS, Z
	goto	dataptr
	; __code pointer tag: 0x80
	xorlw	(GPTRTAG_DATA ^ GPTRTAG_CODE)
	btfsc	_STATUS, Z
	goto	codeptr
	endm

check_data	macro	dataptr
	; __data pointer tag: 0x00
	xorlw	GPTRTAG_DATA
	btfsc	_STATUS, Z
	goto	dataptr
	endm

; -------------------------------------------------------------------------
;  _gptrget3.S - read three bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
; 
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
; 
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget3
	extern	__codeptrget1
	
	CODE

__gptrget3:
	select_routine __dataptrget3, __codeptrget3
	; invalid tag -- return 0x000000
	clrf	STK01
	clrf	STK00
	retlw	0x00

__dataptrget3:
	setup_fsr
	movf	_INDF, W
	movwf	STK01		; LSB in STK01
	inc_fsr
	movf	_INDF, W
	movwf	STK00		; 2nd byte in STK00
	inc_fsr
	movf	_INDF, W	; MSB in WREG
	return

__codeptrget3:
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK02		; temporarily store LSB
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK03		; temporarily store 2nd byte
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK04		; temporarily store MSB
	movf	STK02, W
	movwf	STK01		; LSB in STK01
	movf	STK03, W
	movwf	STK00		; 2nd byte in STK00
	movf	STK04, W	; MSB in WREG
	return

	END
; -------------------------------------------------------------------------
;  _gptrput3.S : write three bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput3
	
	CODE

__gptrput3:
	check_data	__dataptrput3
	; cannot write to __code space
	return

__dataptrput3:
	setup_fsr
	movf	STK04, W	; get LSB(val)
	movwf	_INDF
	inc_fsr
	movf	STK03, W	; get 2nd byte of val
	movwf	_INDF
	inc_fsr
	movf	STK02, W	; get MSB(val)
	movwf	_INDF
	return

	END
; -------------------------------------------------------------------------
;  _gptrget2.S - read two bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget2
	extern	__codeptrget1
	
	CODE

__gptrget2:
	select_routine __dataptrget2, __codeptrget2
	; invalid tag -- return 0x0000
	clrf	STK00
	retlw	0x00

__dataptrget2:
	setup_fsr
	movf	_INDF, W
	movwf	STK00		; low byte in STK00
	inc_fsr
	movf	_INDF, W	; high byte in WREG
	return

__codeptrget2:
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK02		; temporarily store LSB
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK03		; temporarily store MSB
	movf	STK02, W
	movwf	STK00		; LSB in STK00
	movf	STK03, W	; MSB in WREG
	return
	
	END
; -------------------------------------------------------------------------
;  _gptrput2.S : write two bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput2
	
	CODE

__gptrput2:
	check_data	__dataptrput2
	; cannot write to __code space
	return

__dataptrput2:
	setup_fsr
	movf	STK03, W	; get LSB(val)
	movwf	_INDF
	inc_fsr
	movf	STK02, W	; get MSB(val)
	movwf	_INDF
	return

	END
; -------------------------------------------------------------------------
;  _gptrput1.S : write one byte pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput
	global	__gptrput1
	
	CODE

__gptrput:
__gptrput1:
	check_data	__dataptrput1
	; cannot write to __code space
	return

__dataptrput1:
	setup_fsr
	movf	STK02, W	; get LSB(val)
	movwf	_INDF		; store LSB
	return

	END
; -------------------------------------------------------------------------
;  _gptrput4.S : write four bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput4
	
	CODE

__gptrput4:
	check_data	__dataptrput4
	; cannot write to __code space
	return

__dataptrput4:
	setup_fsr
	movf	STK05, W	; get LSB(val)
	movwf	_INDF
	inc_fsr
	movf	STK04, W	; get 2nd byte of val
	movwf	_INDF
	inc_fsr
	movf	STK03, W	; get 3rd byte of val
	movwf	_INDF
	inc_fsr
	movf	STK02, W	; get MSB(val)
	movwf	_INDF
	return

	END
; -------------------------------------------------------------------------
;  _gptrget1.S - read one byte pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget
	global	__gptrget1
	global	__codeptrget1
	
	CODE

__gptrget:
__gptrget1:
	select_routine __dataptrget1, __codeptrget1
	; invalid tag -- return 0x00
	retlw	0x00

__dataptrget1:
	setup_fsr
	movf	_INDF0, W
	return

__codeptrget1:
	; call the RETLW instruction at the given address
	movf	STK00, W
	movwf	_PCLATH
	movf	STK01, W
	movwf	_PCL
	return	; should never be executed...

	END
; -------------------------------------------------------------------------
;  _gptrget4.S - read four bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
; 
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
; 
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget4
	extern	__codeptrget1
	
	CODE

__gptrget4:
	select_routine __dataptrget4, __codeptrget4
	; invalid tag -- return 0x00000000
	clrf	STK02
	clrf	STK01
	clrf	STK00
	retlw	0x00

__dataptrget4:
	setup_fsr
	moviw	FSR0++
	movwf	STK02		; LSB in STK02
	moviw	FSR0++
	movwf	STK01		; 2nd byte in STK01
	moviw	FSR0++
	movwf	STK00		; 3rd byte in STK00
	movf	_INDF0, W	; MSB in WREG
	return

__codeptrget4:
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK02		; temporarily store LSB
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK03		; temporarily store 2nd byte
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK04		; temporarily store 3rd byte
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK05		; temporarily store MSB
	movf	STK02, W
	movwf	STK02		; LSB in STK02
	movf	STK03, W
	movwf	STK01		; 2nd byte in STK01
	movf	STK04, W
	movwf	STK00		; 3rd byte in STK00
	movf	STK05, W	; MSB in WREG
	return

	END
; -----------------------------------------------
; --- extern declared SFRs
; -----------------------------------------------
	extern _STATUS
	extern _FSR0L
	extern _FSR0H
	extern _INDF0
	extern _PCLATH
	extern _PCL

C	EQU	0
DC	EQU	1
Z	EQU	2
FSR0    EQU     0x04 ; for MOVWI FSR0++
FSR1    EQU     0x06
	
; -----------------------------------------------
; --- generic pointer access helpers
; -----------------------------------------------

GPTRTAG_DATA	EQU	0x00
GPTRTAG_CODE	EQU	0x80

; setup FSR0 to point to (STK00:STK01)
setup_fsr	macro
	movf	STK01, W
	movwf	_FSR0L
	movf	STK00, W
	movwf	_FSR0H
	endm

; dispatch according to gptr type
select_routine	macro	dataptr, codeptr
	; __data pointer tag: 0x00
	xorlw	GPTRTAG_DATA
	btfsc	_STATUS, Z
	goto	dataptr
	; __code pointer tag: 0x80
	xorlw	(GPTRTAG_DATA ^ GPTRTAG_CODE)
	btfsc	_STATUS, Z
	goto	codeptr
	endm

check_data	macro	dataptr
	; __data pointer tag: 0x00
	xorlw	GPTRTAG_DATA
	btfsc	_STATUS, Z
	goto	dataptr
	endm

; -------------------------------------------------------------------------
;  _gptrget3.S - read three bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
; 
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
; 
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget3
	extern	__codeptrget1
	
	CODE

__gptrget3:
	select_routine __dataptrget3, __codeptrget3
	; invalid tag -- return 0x000000
	clrf	STK01
	clrf	STK00
	retlw	0x00

__dataptrget3:
	setup_fsr
	moviw	FSR0++
	movwf	STK01		; LSB in STK01
	moviw	FSR0++
	movwf	STK00		; 2nd byte in STK00
	movf	_INDF0, W	; MSB in WREG
	return

__codeptrget3:
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK02		; temporarily store LSB
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK03		; temporarily store 2nd byte
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK04		; temporarily store MSB
	movf	STK02, W
	movwf	STK01		; LSB in STK01
	movf	STK03, W
	movwf	STK00		; 2nd byte in STK00
	movf	STK04, W	; MSB in WREG
	return

	END
; -------------------------------------------------------------------------
;  _gptrput3.S : write three bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput3
	
	CODE

__gptrput3:
	check_data	__dataptrput3
	; cannot write to __code space
	return

__dataptrput3:
	setup_fsr
	movf	STK04, W	; get LSB(val)
	movwi	FSR0++
	movf	STK03, W	; get 2nd byte of val
	movwi	FSR0++
	movf	STK02, W	; get MSB(val)
	movwf	_INDF0
	return

	END
; -------------------------------------------------------------------------
;  _gptrget2.S - read two bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrget2
	extern	__codeptrget1
	
	CODE

__gptrget2:
	select_routine __dataptrget2, __codeptrget2
	; invalid tag -- return 0x0000
	clrf	STK00
	retlw	0x00

__dataptrget2:
	setup_fsr
        moviw   FSR0++
	movwf	STK00		; low byte in STK00
	movf	_INDF0, W	; high byte in WREG
	return

__codeptrget2:
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK02		; temporarily store LSB
	incfsz	STK01,F	; increment low address byte
	decf	STK00,F	; undo increment of high address byte if low byte did not overflow
	incf	STK00,F	; increment high address byte
	pagesel	__codeptrget1	; might reside in different page
	call	__codeptrget1
	movwf	STK03		; temporarily store MSB
	movf	STK02, W
	movwf	STK00		; LSB in STK00
	movf	STK03, W	; MSB in WREG
	return
	
	END
; -------------------------------------------------------------------------
;  _gptrput2.S : write two bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput2
	
	CODE

__gptrput2:
	check_data	__dataptrput2
	; cannot write to __code space
	return

__dataptrput2:
	setup_fsr
	movf	STK03, W	; get LSB(val)
	movwi	FSR0++
	movf	STK02, W	; get MSB(val)
	movwf	_INDF0
	return

	END
; -------------------------------------------------------------------------
;  _gptrput1.S : write one byte pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput
	global	__gptrput1
	
	CODE

__gptrput:
__gptrput1:
	check_data	__dataptrput1
	; cannot write to __code space
	return

__dataptrput1:
	setup_fsr
	movf	STK02, W	; get LSB(val)
	movwf	_INDF0		; store LSB
	return

	END
; -------------------------------------------------------------------------
;  _gptrput4.S : write four bytes pointed to by a generic pointer
;
;  Copyright (C) 2005, Raphael Neider <rneider AT web.de>
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; calling conventions:
;   3 byte generic pointer is passed in via (WREG STK00 STK01).
;   The result is returned in (WREG (STK00 (STK01 (STK02)))).
;
;   unsigned char _gptrget  (void *gptr);
;   unsigned char _gptrget1 (void *gptr);
;   unsigned int  _gptrget2 (void *gptr);
;   void *        _gptrget3 (void *gptr);
;   unsigned long _gptrget4 (void *gptr);
;
;   void _gptrput  (void *ptr, unsigned char val);
;   void _gptrput1 (void *ptr, unsigned char val);
;   void _gptrput2 (void *ptr, unsigned int  val);
;   void _gptrput3 (void *ptr, unsigned int  val);
;   void _gptrput4 (void *ptr, unsigned long val);

include macros.inc
include p16f_common.inc

	global	__gptrput4
	
	CODE

__gptrput4:
	check_data	__dataptrput4
	; cannot write to __code space
	return

__dataptrput4:
	setup_fsr
	movf	STK05, W	; get LSB(val)
	movwi	FSR0++
	movf	STK04, W	; get 2nd byte of val
	movwi	FSR0++
	movf	STK03, W	; get 3rd byte of val
	movwi	FSR0++
	movf	STK02, W	; get MSB(val)
	movwf	_INDF0
	return

	END
/*-------------------------------------------------------------------------
   tinibios.c - startup and serial routines for the DS80C400 (tested on TINIM400)

   Copyright (C) 2003, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <tinibios.h>
#include <ds400rom.h>

#include <stdio.h>

#define TIMED_ACCESS(sfr,value) { TA=0xaa; TA=0x55; sfr=value; }

unsigned char _sdcc_external_startup(void)
{
  IE = 0; // Disable all interrupts.

  PSW = 0;
  
  __asm
  ; save the 24-bit return address
  pop ar2; msb
  pop ar1
  pop ar0; lsb


  mov _ESP,#0x00; reinitialize the stack
  mov _SP,#0x00

  ; restore the 24-bit return address
  push ar0; lsb
  push ar1
  push ar2; msb
  __endasm;    
  
  // Stub: call rom_init here, then fixup IVT.
  // 
  
  Serial0Init(1, 0); // baud argument ignored.
  
  IE = 0x80; // Enable interrupts.
  
  return 0;
}

// now the serial0 stuff

// just to make the code more readable 
#define S0RBS SERIAL_0_RECEIVE_BUFFER_SIZE

// this is a ring buffer and can overflow at anytime!
static volatile unsigned char receive0Buffer[S0RBS];
static volatile int receive0BufferHead=0;
static volatile int receive0BufferTail=0;
// no buffering for transmit
static volatile char transmit0IsBusy=0;

static __data unsigned char serial0Buffered;

/* Initialize serial0.

   Available baudrates are from 110 upto 115200 (using 16-bit timer 2)
   If baud==0, the port is disabled.

   If buffered!=0, characters received are buffered using an interrupt
*/


#define TIMER_RELOAD (65536 - ((OSCILLATOR) / (32 * SERIAL_0_BAUD)))

void Serial0Init (unsigned long baud, unsigned char buffered)
{
  ES0 = 0; // disable serial channel 0 interrupt

#if 0
  // Need no port setup, done by boot rom.
  baud;
#else
  SCON0 = 0x5A; // 10 bit serial 0, use timer baud rate, enable recieving
  RCAP2H = (TIMER_RELOAD >> 8) & 0xff;
  RCAP2L = TIMER_RELOAD & 0xff;
  T2CON = 0x30; // Enable timer 2 for serial port
  TR2 = 1; // Set timer 2 to run

  baud;
#endif

  serial0Buffered=buffered;
 
 if (buffered) {
    installInterrupt(Serial0IrqHandler, 0x23);
    RI_0=TI_0=0; // clear "pending" interrupts
    ES0 = 1; // enable serial channel 0 interrupt
  } else {
    RI_0=0; // receive buffer empty
    TI_0=1; // transmit buffer empty
  }
}

void Serial0SwitchToBuffered(void)
{
  IE &= ~0x80;
  
  serial0Buffered = 1;
  installInterrupt(Serial0IrqHandler, 0x23);
  RI_0=TI_0=0; // clear "pending" interrupts
  ES0 = 1; // enable serial channel 0 interrupt
  
  IE |= 0x80;
}

void Serial0IrqHandler (void) __interrupt 4
{
  if (RI_0) {
    receive0Buffer[receive0BufferHead]=SBUF0;
    receive0BufferHead=(receive0BufferHead+1)&(S0RBS-1);
    if (receive0BufferHead==receive0BufferTail) {
      /* buffer overrun, sorry :) */
      receive0BufferTail=(receive0BufferTail+1)&(S0RBS-1);
    }
    RI_0=0;
  }
  if (TI_0) {
    TI_0=0;
    transmit0IsBusy=0;
  }
}

char Serial0CharArrived(void)
{
  if (serial0Buffered) {
    if (receive0BufferHead!=receive0BufferTail)
      return receive0Buffer[receive0BufferTail];
  } else {
    if (RI_0)
      return SBUF0;
  }
  return 0;
}

void Serial0PutChar (char c)
{
  if (serial0Buffered) {
    while (transmit0IsBusy)
      ;
    transmit0IsBusy=1;
    SBUF0=c;
  } else {
    while (!TI_0)
      ;
    TI_0 = 0;
    SBUF0=c;
  }
}

char Serial0GetChar (void)
{
  char c;
  if (serial0Buffered) {
    while (receive0BufferHead==receive0BufferTail)
      ;
    c=receive0Buffer[receive0BufferTail];
    ES0=0; // disable serial interrupts
    receive0BufferTail=(receive0BufferTail+1)&(S0RBS-1);
    ES0=1; // enable serial interrupts
  } else {
    while (!RI_0)
      ;
    c=SBUF0;
    RI_0=0;
  }
  return c;
}

void Serial0SendBreak()
{
  P3 &= ~0x02;
  ClockMilliSecondsDelay(2);
  P3 |= 0x02;
}

void Serial0Flush()
{
  ES0=0; // disable interrupts
  receive0BufferHead=receive0BufferTail=0;
  RI_0=0;
  if (serial0Buffered) {
    TI_0=0;
    ES0=1; // enable interrupts
  } else {
    TI_0=1;
  }
}

// now let's go for the clock stuff - on the DS400, we can just
// use the ROM's millisecond timer, running off timer 0.
// 
// for now, this timer runs too fast by about 20%. We need an implementation of
// task_settickreload to fix this.

void ClockInit()
{
  // nada, all done by DSS_rom_init
}

// we can't just use milliSeconds
unsigned long ClockTicks(void)
{
  return task_gettimemillis_long();
}

void ClockMilliSecondsDelay(unsigned long delay)
{
  unsigned long ms = task_gettimemillis_long() + delay;

  while (ms > task_gettimemillis_long())
    ;
}

// Return the start of the XI_SEG. Really just a workaround for the
// fact that the linker defined symbol (s_XISEG) isn't directly accessible
// from C due to the lack of a leading underscore, and I'm too lazy to hack 
// the linker.
static void __xdata *_xisegStart(void) __naked
{
  __asm    
  mov dptr, #(s_XISEG)
  ret
  __endasm;
}

// Return the length of the XI_SEG. Really just a workaround for the
// fact that the linker defined symbol (l_XISEG) isn't directly accessible
// from C due to the lack of a leading underscore, and I'm too lazy to hack 
// the linker.
static unsigned  _xisegLen(void) __naked
{
  __asm
  mov dptr, #(l_XISEG)
  ret
  __endasm;
}

// Returns the address of the first byte available for heap memory, 
// i.e. the first byte following the XI_SEG.
static void __xdata *_firstHeapByte(void)
{
  unsigned char __xdata *start;
  
  start = (unsigned char __xdata *) _xisegStart();
  start += _xisegLen();

  return (void __xdata *)start;
}

// TINIm400 specific startup.

// The last addressible byte of the CE0 area. 
#define CE0_END 0xfffff

unsigned char romInit(unsigned char noisy, char speed)
{
  void __xdata *heapStart;
  void __xdata *heapEnd;
  unsigned long heapLen; 
  unsigned char rc;

  if (speed == SPEED_2X)
  {
    PMR = 0x82;
    PMR = 0x92;

    while (!(EXIF & 8))
      ;

    PMR = 0x12;
  }
  else if (speed == SPEED_4X)
  {
    // Hangs on TINIm400!
    PMR = 0x82;
    PMR = 0x8a;
    PMR = 0x9a;

    while (!(EXIF & 8))
      ;

    PMR = 0x1a;
  }

  heapStart = _firstHeapByte();
  heapEnd = (void __xdata *)CE0_END;

  rc = init_rom(heapStart, heapEnd);

  if (noisy)
  {
    if (rc)
    {
      printf("error: rom_init returns %d\n", (int)rc);
      return rc;
    }
    else
    {
      heapLen = CE0_END - (unsigned long)heapStart;
      printf("Heap starts at %p, length %luK\n", heapStart, heapLen / 1024);
    }
  }

  task_settickreload(RELOAD_14_746);

  // Switch to interrupt driven serial I/O now that the rom is initialized.
  Serial0SwitchToBuffered();

  P5 &= ~4; // LED on.

  return 0;
}

// Install an interrupt handler.
void installInterrupt(void (*isrPtr)(void), unsigned char offset)
{
  unsigned char __xdata * vectPtr = (unsigned char __xdata *) offset;
  unsigned long isr = (unsigned long)isrPtr;

  *vectPtr++ = 0x02;
  *vectPtr++ = (unsigned char)(isr >> 16);
  *vectPtr++ = (unsigned char)(isr >> 8);
  *vectPtr = (unsigned char)isr;
}
/*-------------------------------------------------------------------------
   memcpyx.c

   Copyright (C) 2003, Kevin Vigor

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#include <string.h>

// FIXME: can optimize even further on '400 with auto-increment/auto-toggle.

void __xdata * memcpyx (
	void __xdata * dst,
	void __xdata * src,
	int count
	) __naked
{
    /* Shut compiler up about unused parameters. */
    dst; src; count;
    
__asm
    ; Destination is in DPTR. Save it on stack so we can return it at end.
    
    push dpx
    push dph
    push dpl
    
    mov  dps, #0x1        ; Alternate DPTR.
    
    ; count  is in _memcpyx_PARM_3
    mov  dptr, #_memcpyx_PARM_3
    movx a, @dptr
    inc dptr
    mov r2, a
    movx a, @dptr
    mov r3, a

    ; src is in _memcpyx_PARM_2
    mov  dptr, #_memcpyx_PARM_2
    movx a, @dptr
    inc  dptr
    push acc
    movx a, @dptr
    inc  dptr
    push acc
    movx a, @dptr
    mov  dpx1, a
    pop  dph1
    pop  dpl1

    mov	dps, #0x21	; Current DPTR is alt DPTR, toggle after each op.
    
    ; src is in alt DPTR, dst is in normal DPTR, count is in r2/r3.
    
    ; If we have zero bytes to copy, quick out.
    mov	 a, r2
    orl  a, r3
    jz   _memcpy_done

    ; increment r3 if r2 != 0 (makes djnz end-of-loop sequence possible).
    inc r3
    cjne r2, #0x0, _memcpyx_loopTop
    dec r3

_memcpyx_loopTop:

    movx a, @dptr
    movx @dptr, a
    inc dptr
    inc dptr

    djnz r2, _memcpyx_loopTop
    djnz r3, _memcpyx_loopTop
    
_memcpy_done:

    mov dps, #0x0

    pop dpl
    pop dph
    pop dpx
    ret
__endasm;    
    
}
/*-------------------------------------------------------------------------
   ds400rom.c

   Copyright (C) 2003, Dallas Semiconductor Corporation

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
// Interface to the DS80C400 ROM functions. Largely based on code released
// by Dallas, hence the following copyright.

// ---------------------------------------------------------------------------
//  Copyright (C) 2003 Dallas Semiconductor Corporation, All Rights Reserved.
//
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included
//  in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//  MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
//  IN NO EVENT SHALL DALLAS SEMICONDUCTOR BE LIABLE FOR ANY CLAIM, DAMAGES
//  OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//  OTHER DEALINGS IN THE SOFTWARE.
//
//  Except as contained in this notice, the name of Dallas Semiconductor
//  shall not be used except as stated in the Dallas Semiconductor
//  Branding Policy.
// ---------------------------------------------------------------------------

#include <stdio.h>
#include <ds400rom.h>

// ROM globals, taken from startup400.a51
__data unsigned char __at (0x68) DSS_wos_crit_count;
__data unsigned int  __at (0x6b) DSS_timerReload;
__data unsigned char __at (0x6d) DSS_curr_pc[3];
__data unsigned char __at (0x72) DSS_sched[3];
__data unsigned char __at (0x74) DSS_ms_count[5];
__data unsigned char __at (0x7b) DSS_hb_chandle[5];

// Register bank 3 equates.
#define R0_B3     0x18
#define R1_B3     0x19
#define R2_B3     0x1A
#define R3_B3     0x1B
#define R4_B3     0x1C
#define R5_B3     0x1D
#define R6_B3     0x1E
#define R7_B3     0x1F


// The top of the redirect function table in RAM.
#define CALL_TABLE_TOP  256

// The bank the ROM is stored in.  Should be 0FFh for production
// 400's.  Change this value when running with a debug ROM.

#define ROM_BANK        0xFF

// The address of the ROM export table is stored
// at (ROM_BANK << 16) | ROM_EXPORTTABLE_OFFS

#define ROM_EXPORTTABLE_OFFS    2

//
// Each entry in the ROM export table is 3 bytes.
//
#define ROMXT_ENTRYSIZE      3

//
// The number of functions in the ROM export table is stored
// first in the export table.
//
#define ROMXT_NUMFUNCTIONS     (0 * ROMXT_ENTRYSIZE)

//
// ROM EXPORT TABLE FUNCTIONS (denoted with ROMXT)
//

// UTILITY functions
#define ROMXT_CRC16                     (1 * ROMXT_ENTRYSIZE) //
#define ROMXT_MEM_CLEAR_16              (2 * ROMXT_ENTRYSIZE) //
#define ROMXT_MEM_COPY_16               (3 * ROMXT_ENTRYSIZE) //
#define ROMXT_MEM_COMPARE               (4 * ROMXT_ENTRYSIZE) //
#define ROMXT_ADD_DPTR1_16              (5 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_ADD_DPTR2_16              (6 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_SUB_DPTR1_16              (7 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_SUB_DPTR2_16              (8 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_GETPSEUDORANDOM           (9 * ROMXT_ENTRYSIZE) //

// MEMORY MGR
#define ROMXT_KERNELMALLOC              (10 * ROMXT_ENTRYSIZE) // not exposed
#define ROMXT_KERNELFREE                (11 * ROMXT_ENTRYSIZE) // not exposed
#define ROMXT_MM_MALLOC                 (12 * ROMXT_ENTRYSIZE) // exposed as redirected function
#define ROMXT_MM_MALLOC_DIRTY           (13 * ROMXT_ENTRYSIZE) // exposed as redirected function
#define ROMXT_MM_FREE                   (14 * ROMXT_ENTRYSIZE) // exposed as redirected function
#define ROMXT_MM_DEREF                  (15 * ROMXT_ENTRYSIZE) // exposed as redirected function
#define ROMXT_GETFREERAM                (16 * ROMXT_ENTRYSIZE) // exposed as redirected function

// SOCKET functions
#define ROMXT_ROM_SOCKET                (17 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_CLOSESOCKET           (18 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_SENDTO                (19 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_RECVFROM              (20 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_CONNECT               (21 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_BIND                  (22 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_LISTEN                (23 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_ACCEPT                (24 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_RECV                  (25 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_SEND                  (26 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_GETSOCKOPT            (27 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_SETSOCKOPT            (28 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_GETSOCKNAME           (29 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_GETPEERNAME           (30 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_CLEANUP               (31 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_AVAIL                 (32 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_JOIN                  (33 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_LEAVE                 (34 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_PING                  (35 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_GETNETWORKPARAMS      (36 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_SETNETWORKPARAMS      (37 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_GETIPV6PARAMS         (38 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_GETETHERNETSTATUS     (39 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_GETTFTPSERVER         (40 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_SETTFTPSERVER         (41 * ROMXT_ENTRYSIZE) //
#define ROMXT_ETH_PROCESSINTERRUPT      (42 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_ARP_GENERATEREQUEST       (43 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_NET_ETH0_MAC_ID           (44 * ROMXT_ENTRYSIZE) //

// DHCP functions
#define ROMXT_DHCP_INIT                 (45 * ROMXT_ENTRYSIZE) //
#define ROMXT_DHCP_SETUP                (46 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_DHCP_STARTUP              (47 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_DHCP_RUN                  (48 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_DHCP_STATUS               (49 * ROMXT_ENTRYSIZE) //
#define ROMXT_DHCP_STOP                 (50 * ROMXT_ENTRYSIZE) //
#define ROMXT_DHCPNOTIFY                (51 * ROMXT_ENTRYSIZE) // empty redirect stub, not implemented

// TFTP functions
#define ROMXT_TFTP_INIT                 (52 * ROMXT_ENTRYSIZE) //
#define ROMXT_TFTP_FIRST                (53 * ROMXT_ENTRYSIZE) //
#define ROMXT_TFTP_NEXT                 (54 * ROMXT_ENTRYSIZE) //
#define ROMXT_TFTP_MSG                  (55 * ROMXT_ENTRYSIZE) //

// SCHEDULER functions
#define ROMXT_TASK_GENESIS              (56 * ROMXT_ENTRYSIZE) //
#define ROMXT_TASK_GETCURRENT           (57 * ROMXT_ENTRYSIZE) //
#define ROMXT_TASK_GETPRIORITY          (58 * ROMXT_ENTRYSIZE) //
#define ROMXT_TASK_SETPRIORITY          (59 * ROMXT_ENTRYSIZE) //
#define ROMXT_TASK_FORK                 (60 * ROMXT_ENTRYSIZE) //
#define ROMXT_TASK_KILL                 (61 * ROMXT_ENTRYSIZE) //
#define ROMXT_TASK_SUSPEND              (62 * ROMXT_ENTRYSIZE) //
#define ROMXT_TASK_SLEEP                (63 * ROMXT_ENTRYSIZE) //
#define ROMXT_TASK_SIGNAL               (64 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_TASK_SWITCH_IN        (65 * ROMXT_ENTRYSIZE) // empty redirect stub, not implemented
#define ROMXT_ROM_TASK_SWITCH_OUT       (66 * ROMXT_ENTRYSIZE) // empty redirect stub, not implemented
#define ROMXT_ENTERCRITSECTION          (67 * ROMXT_ENTRYSIZE) //
#define ROMXT_LEAVECRITSECTION          (68 * ROMXT_ENTRYSIZE) //

// INIT functions
#define ROMXT_ROM_INIT                  (69 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_COPYIVT               (70 * ROMXT_ENTRYSIZE) //
#define ROMXT_ROM_REDIRECT_INIT         (71 * ROMXT_ENTRYSIZE) //
#define ROMXT_MM_INIT                   (72 * ROMXT_ENTRYSIZE) //
#define ROMXT_KM_INIT                   (73 * ROMXT_ENTRYSIZE) //
#define ROMXT_OW_INIT                   (74 * ROMXT_ENTRYSIZE) //
#define ROMXT_NETWORK_INIT              (75 * ROMXT_ENTRYSIZE) //
#define ROMXT_ETH_INIT                  (76 * ROMXT_ENTRYSIZE) //
#define ROMXT_INIT_SOCKETS              (77 * ROMXT_ENTRYSIZE) //
#define ROMXT_TICK_INIT                 (78 * ROMXT_ENTRYSIZE) //

// Timer Interrupt vectors
#define ROMXT_WOS_TICK                  (79 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_BLOB                      (80 * ROMXT_ENTRYSIZE) // not implemented for C compiler

// Maintenance functions
#define ROMXT_WOS_IOPOLL                (81 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_IP_PROCESSRECEIVEQUEUES   (82 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_IP_PROCESSOUTPUT          (83 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_TCP_RETRYTOP              (84 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_ETH_PROCESSOUTPUT         (85 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_IGMP_GROUPMAINTAINENCE    (86 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_IP6_PROCESSRECEIVEQUEUES  (87 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_IP6_PROCESSOUTPUT         (88 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_PARAMBUFFER               (89 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_RAM_TOP                   (90 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_BOOT_MEMBEGIN             (91 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_BOOT_MEMEND               (92 * ROMXT_ENTRYSIZE) // not implemented for C compiler

// 1-Wire
#define ROMXT_OWM_FIRST                 (93 * ROMXT_ENTRYSIZE) //
#define ROMXT_OWM_NEXT                  (94 * ROMXT_ENTRYSIZE) //
#define ROMXT_OWM_RESET                 (95 * ROMXT_ENTRYSIZE) //
#define ROMXT_OWM_BYTE                  (96 * ROMXT_ENTRYSIZE) //
#define ROMXT_OWM_SEARCH                (97 * ROMXT_ENTRYSIZE) // not implemented for C compiler
#define ROMXT_OW_ROMID                  (98 * ROMXT_ENTRYSIZE) //

// Misc, extras, late additions
#define ROMXT_AUTOBAUD                  (99 * ROMXT_ENTRYSIZE)
#define ROMXT_TFTP_CLOSE                (100 * ROMXT_ENTRYSIZE)


#define ROMRT_ENTRYSIZE  3

//
// ROM REDIRECT TABLE FUNCTIONS (denoted with ROMRT)
//
#define ROMRT_KERNELMALLOC                  ( 1 * ROMRT_ENTRYSIZE)
#define ROMRT_KERNELFREE                    ( 2 * ROMRT_ENTRYSIZE)
#define ROMRT_MALLOC                        ( 3 * ROMRT_ENTRYSIZE)
#define ROMRT_FREE                          ( 4 * ROMRT_ENTRYSIZE)
#define ROMRT_MALLOCDIRTY                   ( 5 * ROMRT_ENTRYSIZE)
#define ROMRT_DEREF                         ( 6 * ROMRT_ENTRYSIZE)
#define ROMRT_GETFREERAM                    ( 7 * ROMRT_ENTRYSIZE)
#define ROMRT_GETTIMEMILLIS                 ( 8 * ROMRT_ENTRYSIZE)
#define ROMRT_GETTHREADID                   ( 9 * ROMRT_ENTRYSIZE)
#define ROMRT_THREADRESUME                  (10 * ROMRT_ENTRYSIZE)
#define ROMRT_THREADIOSLEEP                 (11 * ROMRT_ENTRYSIZE)
#define ROMRT_THREADIOSLEEPNC               (12 * ROMRT_ENTRYSIZE)
#define ROMRT_THREADSAVE                    (13 * ROMRT_ENTRYSIZE)
#define ROMRT_THREADRESTORE                 (14 * ROMRT_ENTRYSIZE)
#define ROMRT_SLEEP                         (15 * ROMRT_ENTRYSIZE)
#define ROMRT_GETTASKID                     (16 * ROMRT_ENTRYSIZE)
#define ROMRT_INFOSENDCHAR                  (17 * ROMRT_ENTRYSIZE)
#define ROMRT_IP_COMPUTECHECKSUM_SOFTWARE   (18 * ROMRT_ENTRYSIZE)
#define ROMRT_0                             (19 * ROMRT_ENTRYSIZE) // undefined
#define ROMRT_DHCPNOTIFY                    (20 * ROMRT_ENTRYSIZE)
#define ROMRT_ROM_TASK_CREATE               (21 * ROMRT_ENTRYSIZE)
#define ROMRT_ROM_TASK_DUPLICATE            (22 * ROMRT_ENTRYSIZE)
#define ROMRT_ROM_TASK_DESTROY              (23 * ROMRT_ENTRYSIZE)
#define ROMRT_ROM_TASK_SWITCH_IN            (24 * ROMRT_ENTRYSIZE)
#define ROMRT_ROM_TASK_SWITCH_OUT           (25 * ROMRT_ENTRYSIZE)
#define ROMRT_OWIP_READCONFIG               (26 * ROMRT_ENTRYSIZE)
#define ROMRT_SETMACID                      (27 * ROMRT_ENTRYSIZE)
#define ROMRT_UNDEREF                       (28 * ROMRT_ENTRYSIZE)


#define GETC            \
    clr  a              \
    movc a, @a+dptr


// expects function number in R6_B3 (low byte) & R7_B3 (high byte)
void _romcall(void) __naked
{
__asm
      push  dpx                               ; dptr0 preserved here
      push  dph
      push  dpl

      ; point to the address of the table
      mov   dptr, #(ROM_BANK << 16 | ROM_EXPORTTABLE_OFFS)

      push  acc                               ; acc preserved here
      push  b                                 ; b preserved here
      inc   dptr
      GETC                                    ; get the address of the table
      push  acc
      inc   dptr
      GETC
      add   a, R6_B3                          ; add function offset to the table
      mov   dpl, a
      pop   acc
      addc  a, R7_B3
      mov   dph, a

      ;
      ; dpx is the same, all in the same bank
      ;
      inc   dptr                              ; get the target address of the function we want
      GETC
      mov   b, a
      inc   dptr
      GETC
      mov   R3_B3, a
      mov   R4_B3, b
      mov   R5_B3, dpx                        ; high byte does not change
      pop   b                                 ; b restored here
      pop   acc                               ; acc restored here
      pop   dpl                               ; dptr0 preserved here
      pop   dph
      pop   dpx
      push  R3_B3                             ; push the target address
      push  R4_B3
      push  R5_B3
      ret                                     ; this is not a ret, it is a call!

      ; the called function ends with a ret which will return to our original caller.
__endasm ;
}

// expects function number in R6_B3 (low byte) & R7_B3 (high byte)
void _romredirect(void) __naked
{
__asm
      push  dpx
      push  dph
      push  dpl
      push  acc
      ; dptr = CALL_TABLE_TOP + function offset.
      mov   a, #(CALL_TABLE_TOP & 0xff)
      add   a, R6_B3                          ; add function offset to the table
      mov   dpl, a
      mov   a, #((CALL_TABLE_TOP >> 8) & 0xff)
      addc  a, R7_B3
      mov   dph, a
      mov   dpx, #((CALL_TABLE_TOP >> 16) & 0xff)
      movx  a, @dptr                      ; read high byte
      mov   R5_B3, a
      inc   dptr
      movx  a, @dptr                      ; read mid byte
      mov   R4_B3, a
      inc   dptr
      movx  a, @dptr                      ; read low byte
      mov   R3_B3, a
      pop   acc                 ; restore acc and dptr
      pop   dpl
      pop   dph
      pop   dpx
      push  R3_B3               ; push low byte of target address
      push  R4_B3
      push  R5_B3               ; push high byte of target address
      ret                       ; this is not a ret, it is a call!

      ; the called function ends with a ret which will return to our original caller.
__endasm;
}


// This macro is invalid for the standard C preprocessor, since it
// includes a hash character in the expansion, hence the SDCC specific
// pragma.
#pragma sdcc_hash +
#define ROMCALL(x) \
        mov     R6_B3, #(x & 0xff)              \
        mov     R7_B3, #((x >> 8) & 0xff)       \
        lcall   __romcall

#define ROMREDIRECT(x) \
        mov     R6_B3, #(x & 0xff)              \
        mov     R7_B3, #((x >> 8) & 0xff)       \
        lcall   __romredirect


// init_rom: the ds400 ROM_INIT ROM function.
unsigned char init_rom(void __xdata *loMem,
                       void __xdata *hiMem) __naked
{
    // shut compiler up about unused parameters.
    loMem;
    hiMem;

__asm
        ; load params.
        ; loMem is already in DPTR.
        mov     r2, dpx
        mov     r1, dph
        mov     r0, dpl
        ; hiMem is in _init_rom_PARM_2
        mov     dptr, #_init_rom_PARM_2
        mov     r5, dpx
        mov     r4, dph
        mov     r3, dpl

        ROMCALL(ROMXT_ROM_INIT)

        ; result is in acc, move to dpl for C convention.
        mov     dpl, a
        ret
__endasm        ;
}

// DSS_gettimemillis: note that the ROM actually returns 5 bytes of time,
// we're discarding the high byte here.
unsigned long task_gettimemillis_long(void) __naked
{
__asm
   ; no parameters to load.
   ROMREDIRECT(ROMRT_GETTIMEMILLIS)
   ; results in r4 - r0, return in DPTR/B
   mov dpl, r0
   mov dph, r1
   mov dpx, r2
   mov b, r3
   ret
__endasm;
}

unsigned char task_getthreadID(void) __naked
{
__asm
   ; no parameters to load.
   ROMREDIRECT(ROMRT_GETTHREADID)
   ; results in acc, return in dpl
   mov dpl, a
   ret
__endasm;
}

unsigned int task_gettickreload(void)
{
  return DSS_timerReload;
}

void task_settickreload(unsigned int rl)
{
  DSS_timerReload = rl;
}
;--------------------------------------------------------------------------
;  modunsigned.s
;
;  Copyright (C) 2009-2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__moduchar
.globl	__moduint

__moduchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __divu8

	ex	de,hl

        ret

__moduint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __divu16

        ex      de,hl

        ret

;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2001, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; Just stubs - not copyrightable

        ;; Stubs that hook the heap in
        .globl  ___sdcc_heap_init

        .area   _GSINIT
        call    ___sdcc_heap_init

        .area   _HEAP
___sdcc_heap::
        ;; For now just allocate 1k of heap.
        .ds     1023

        .area   _HEAP_END
___sdcc_heap_end::
        .ds     1
;--------------------------------------------------------------------------
;  memcpy.s
;
;  Copyright (C) 2020, Sergey Belyashov, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memcpy
	.globl ___memcpy

; The Z80 has the ldir instruction, which is perfect for implementing memcpy(). Unfortunately, it is quite broken on early Rabbits, so we use ldi.
_memcpy:
___memcpy:
	pop	af
	pop	hl	;return value expected to be in HL, so pop dst to HL
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	ex	de, hl
loop:
	ldi
	jp	LO, loop
	pop	hl
	ret

;--------------------------------------------------------------------------
;  modmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__modsuchar
.globl	__moduschar

__modsuchar:
	ld      hl,#2+1
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)
	ld      h,#0

	call    __div_signexte

	jp	__get_remainder

__moduschar:
	ld      hl,#2+1
	ld      d, h
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)

	ld      a,l	; Sign extend
	rlca
	sbc     a, a
	ld      h, a

	call	__div16

	jp	__get_remainder

;--------------------------------------------------------------------------
;  strcpy.s
;
;  Copyright (C) 2012, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strcpy

_strcpy:
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
	push	de
	xor	a, a
loop:
	cp	a, (hl)
	ldi
	jr	NZ, loop
	pop	hl
	ret

;--------------------------------------------------------------------------
;  divsigned.s
;
;  Copyright (C) 2000-2010, Michael Hope, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area	_CODE

.globl	__divsint
.globl	__divschar

__divsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jp      __div16

__divschar:
        ld      hl, #2+1
        add     hl, sp

        ld      e, (hl)
        dec     hl
        ld      l, (hl)

__div8::
        ld      a, l            ; Sign extend
        rlca
        sbc     a,a
        ld      h, a
__div_signexte::
        ld      a, e            ; Sign extend
        rlca
        sbc     a,a
        ld      d, a
        ; Fall through to __div16

        ;; signed 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;
        ;; Register used: AF,B,DE,HL
__div16::
        ;; Determine sign of quotient by xor-ing high bytes of dividend
        ;;  and divisor. Quotient is positive if signs are the same, negative
        ;;  if signs are different
        ;; Remainder has same sign as dividend
        ld      a, h            ; Get high byte of dividend
        xor     a, d            ; Xor with high byte of divisor
        rla                     ; Sign of quotient goes into the carry
        ld      a, h            ; Get high byte of dividend
        push    af              ; Save sign of both quotient and reminder

        ; Take absolute value of dividend
        rla
        jr      NC, .chkde      ; Jump if dividend is positive
        sub     a, a            ; Substract dividend from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a

        ; Take absolute value of divisor
.chkde:
        bit     7, d
        jr      Z, .dodiv       ; Jump if divisor is positive
        sub     a, a            ; Subtract divisor from 0
        sub     a, e
        ld      e, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, d
        ld      d, a

        ; Divide absolute values
.dodiv:
        call    __divu16

.fix_quotient:
        ; Negate quotient if it is negative
        pop     af              ; recover sign of quotient
        ret	NC		; Jump if quotient is positive
        ld      b, a
        sub     a, a            ; Subtract quotient from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ld      a, b
	ret

__get_remainder::
        ; Negate remainder if it is negative and move it into hl
        rla
	ex	de, hl
        ret     NC              ; Return if remainder is positive
        sub     a, a            ; Subtract remainder from 0
        sub     a, l
        ld      l, a
        sbc     a, a             ; Propagate remainder (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ret

;--------------------------------------------------------------------------
;  divunsigned.s
;
;  Copyright (C) 2000-2012, Michael Hope, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        ;; Originally from GBDK by Pascal Felber.

.area   _CODE

.globl	__divuint
.globl	__divuchar

__divuint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jr      __divu16

__divuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ;; Fall through
__divu8::
        ld      h,#0x00
        ld      d,h
        ; Fall through to __divu16

        ;; unsigned 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;   carry = 0
        ;;   If divisor is 0, quotient is set to "infinity", i.e HL = 0xFFFF.
        ;;
        ;; Register used: AF,B,DE,HL
__divu16::
        ;; Two algorithms: one assumes divisor <2^7, the second
        ;; assumes divisor >=2^7; choose the applicable one.
        ld      a,e
        and     a,#0x80
        or      a,d
        jr      NZ,.morethan7bits
        ;; Both algorithms "rotate" 24 bits (H,L,A) but roles change.

        ;; unsigned 16/7-bit division
.atmost7bits:
        ld      b,#16           ; bits in dividend and possible quotient
        ;; Carry cleared by AND/OR, this "0" bit will pass trough HL.[*]
        adc     hl,hl
.dvloop7:
        ;; HL holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry.
        ;; A holds remainder.
        rla

        ;; If remainder is >= divisor, next bit of quotient is 1.  We try
        ;;  to compute the difference.
        sub     a,e
        jr      NC,.nodrop7     ; Jump if remainder is >= dividend
        add     a,e             ; Otherwise, restore remainder
        ;; The add above sets the carry, because sbc a,e did set it.
.nodrop7:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        adc     hl,hl
        djnz    .dvloop7
        ;; Carry now contains the same value it contained before
        ;; entering .dvloop7[*]: "0" = valid result.
        ld      e,a             ; DE = remainder, HL = quotient
        ret

.morethan7bits:
        ld      b,#9            ; at most 9 bits in quotient.
        ld      a,l             ; precompute the first 7 shifts, by
        ld      l,h             ;  doing 8
        ld      h,#0
        rr      l               ;  undoing 1
.dvloop:
        ;; Shift next bit of quotient into bit 0 of dividend
        ;; Shift next MSB of dividend into LSB of remainder
        ;; A holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry
        ;; HL holds remainder
        adc     hl,hl           ; HL < 2^(7+9), no carry, ever.

        ;; If remainder is >= divisor, next bit of quotient is 1. We try
        ;;  to compute the difference.
        sbc     hl,de
        jr      NC,.nodrop      ; Jump if remainder is >= dividend
        add     hl,de           ; Otherwise, restore remainder
	;; The add above sets the carry, because sbc hl,de did set it.
.nodrop:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        rla
        djnz    .dvloop
        ;; Take care of the ninth quotient bit! after the loop B=0.
        rl      b               ; BA = quotient
        ;; Carry now contains "0" = valid result.
        ld      d,b
        ld      e,a             ; DE = quotient, HL = remainder
        ex      de,hl           ; HL = quotient, DE = remainder
        ret

;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _atomic_flag_test_and_set

_atomic_flag_test_and_set:
	ld	hl, 2 (sp)
	xor a, a
	srl	(hl)
	ccf
	rla
	ld	l, a
	ret

;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (c) 2017-2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

; unsigned char x unsigned char multiplication is done by code generation.

.globl	__mulsuchar
.globl	__muluschar
.globl	__mulschar

; operands have different sign

__mulsuchar:
        ld      hl,#2+1
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        jr      signexte

__muluschar:
        ld      hl,#2
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      c,(hl)
        jr      signexte

__mulschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)

        ;; Need to sign extend before going in.
        ld      a,c
        rla
        sbc     a,a
        ld      b,a
signexte:
        ld      a,e
        rla
        sbc     a,a
        ld      d,a

        mul

	ld	l, c
	ld	h, b

	ret

;--------------------------------------------------------------------------
;  crtenter.s
;
;  Copyright (C) 2015, Alan Cox, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_enter_ix

; Factor out some start of function code to reduce code size

___sdcc_enter_ix:
	pop	hl	; return address
	push	ix	; save frame pointer
	ld	ix, #0
	add	ix, sp	; set ix to the stack frame
	jp	(hl)	; and return

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_iy

; The Z80 has the jp (iy) instruction, which is perfect for implementing function pointers.

___sdcc_call_iy:
	jp	(iy)

;--------------------------------------------------------------------------
;  memmove.s
;
;  Copyright (C) 2008-2020, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memmove

; The Z80 has the ldir and lddr instructions, which are perfect for implementing memmove(). Unfortunately, it is broken on early Rabbits, so we use ldi and ldd.

_memmove:
	pop	af
	pop	hl
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	sbc	hl, de		; or above cleared carry.
	add	hl, de		; same carry as the line before
	jr	C, memmove_up
memmove_down:
	dec	bc
	add	hl, bc
	ex      de, hl
	add	hl, bc
	inc	bc
loop_down:
	ldd
	jp	LO, loop_down
	pop	hl
	ret
memmove_up:
	ex      de, hl
loop_up:
	ldi
	jp	LO, loop_up
	pop	hl
	ret

;--------------------------------------------------------------------------
;  setjmp.s
;
;  Copyright (C) 2011-2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___setjmp

___setjmp:
	pop	hl
	pop	iy
	push	af
	push	hl

	; Store return address.
	ld	0(iy), l
	ld	1(iy), h

	; Store stack pointer.
	xor	a, a
	ld	l, a
	ld	h, a
	add	hl, sp
	ld	2(iy), l
	ld	3(iy), h

	; Store frame pointer.
	push	ix
	pop	hl
	ld	4(iy), l
	ld	5(iy), h

	; Return 0.
	ld	l, a
	ld	h, a
	ret

.globl _longjmp

_longjmp:
	pop	af
	pop	iy
	pop	de

	; Ensure that return value is non-zero.
	ld	a, e
	or	a, d
	jr	NZ, jump
	inc	de
jump:

	; Restore frame pointer.
	ld	l, 4(iy)
	ld	h, 5(iy)
	push	hl
	pop	ix

	; Adjust stack pointer.
	ld	l, 2(iy)
	ld	h, 3(iy)
	ld	sp, hl
	pop	hl

	; Move return value into hl.
	ex	de, hl

	; Jump.
	ld	c, 0(iy)
	ld	b, 1(iy)
	push	bc
	ret
;--------------------------------------------------------------------------
;  abs.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _abs

; 12B; 86T for nonnegative arguments, 78T for negative.
_abs:
	pop	hl
	pop	de
	push	de
	push	hl
	xor	a, a
	ld	l, a
	ld	h, a
	sbc	hl, de
	ret	P
	ex	de, hl
	ret

; 14B; 59T for nonegative arguments, 94T for negative:
;_abs:
;	pop	de
;	pop	hl
;	push	hl
;	push	de
;	bit	7, h
;	ret	Z
;	xor	a, a
;	ld	e, a
;	ld	d, a
;	ex	de, hl
;	sbc	hl, de
;	ret

;--------------------------------------------------------------------------
;  divmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__divsuchar
.globl	__divuschar

__divsuchar:
	ld	hl, #2+1
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)
	ld	h, #0

	jp	__div_signexte

__divuschar:
	ld	hl, #2+1
	ld	d, h
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)

	ld 	a, l	; Sign extend
	rlca
	sbc	a, a
	ld	h, a

	jp	__div16

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_hl

; The Z80 has the jp (hl) instruction, which is perfect for implementing function pointers.

___sdcc_call_hl:
	jp	(hl)

;--------------------------------------------------------------------------
;  crt0.s - Generic crt0.s for a Rabbit 2000
;	derived from "Generic crt0.s for a Z80"
;
;  Copyright (C) 2000, Michael Hope
;  Modified for Rabbit by Leland Morrison 2011
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.module crt0
	.globl	_main
	.globl	__sdcc_external_startup

GCSR		.equ	0x00 ; Global control / status register
MMIDR		.equ	0x10
STACKSEG	.equ	0x11
SEGSIZE		.equ	0x13
MB0CR		.equ	0x14 ; Memory Bank 0 Control Register
MB1CR		.equ	0x15 ; Memory Bank 1 Control Register
MB2CR		.equ	0x16 ; Memory Bank 2 Control Register
MB3CR		.equ	0x17 ; Memory Bank 3 Control Register

	.area	_HEADER (ABS)

	; Reset vector - assuming smode0 and smode1 input pins are grounded
	.org 	0

	; setup internal interrupts
	ld	a, #1
	ld	iir, a

	; Configure physical address space.
	; Leave MB0CR Flash at default slow at /OE0, /CS0
	; Assume slow RAM at /CS1, /OE1, /WE1
	ld	a, #0x05
	ioi
	ld	(MB2CR), a;

	; Configure logical address space. 32 KB root segment followed by 8 KB data segment, 16 KB stack segement, 8 KB xpc segment.
	; By default, SDCC will use the root segment for code and constant data, stack segment for data (including stack). data segment and xpc segement are then unused.
	ld	a, #0xa8	; 16 KB stack segment at 0xa000, 8 KB data segment at 0x8000
	ioi
	ld	(SEGSIZE), a

	; Configure mapping to physical address space.
	ld	a, #0x76
	ioi
	ld	(STACKSEG), a	; stack segment base at 0x76000 + 0xa000 = 0x80000

	; Set stack pointer directly above top of stack segment
	ld	sp, #0xe000

	call __sdcc_external_startup

	; Initialise global variables
	call	gsinit

	call	_main
	jp	_exit

	; Periodic Interrupt
	.org	0x100
	push	af
	ioi
	ld	a, (GCSR) ; clear interrupt
	pop	af
	reti

	; Secondary Watchdog - Rabbit 3000A only
	.org	0x100
	reti

	; rst 0x10
	.org	0x120
	ret

	; rst 0x18
	.org	0x130
	ret

	; rst 0x20
	.org	0x140
	ret

	; rst 0x28
	.org	0x150
	ret

	; Syscall instruction - Rabbit 3000A only
	.org	0x160
	ret

	; rst 0x38
	.org	0x170
	ret

	; Slave Port
	.org	0x180
	reti

	; Timer A
	.org	0x1a0
	reti

	; Timer B
	.org	0x1b0
	reti

	; Serial Port A
	.org	0x1c0
	reti

	; Serial Port B
	.org	0x1d0
	reti

	; Serial Port C
	.org	0x1e0
	reti

	; Serial Port D
	.org	0x1f0
	reti

	.org	0x200

	;; Ordering of segments for the linker.
	.area	_HOME
	.area	_CODE
	.area	_INITIALIZER
	.area   _GSINIT
	.area   _GSFINAL

	.area	_DATA
	.area	_INITIALIZED
	.area	_BSEG
	.area   _BSS
	.area   _HEAP

	.area   _CODE
_exit::
	;; Exit - special code to the emulator
	ld	a,#0
	rst     #0x28
1$:
	;halt		; opcode for halt used for 'altd' on rabbit processors
	jr	1$

	.area   _GSINIT
gsinit::
	ld	bc, #l__DATA
	ld	a, b
	or	a, c
	jr	Z, zeroed_data
	ld	hl,	#s__DATA
	ld	(hl), #0x00
	dec	bc
	ld	a, b
	or	a, c
	jr	Z, zeroed_data
	ld	e, l
	ld	d, h
	inc	de
zero_loop:
	ldi	; Work around new ldir wait state bug.
	jp	LO, zero_loop

zeroed_data:

	ld	bc, #l__INITIALIZER
	ld	a, b
	or	a, c
	jr	Z, gsinit_next
	ld	de, #s__INITIALIZED
	ld	hl, #s__INITIALIZER
copy_loop:
	ldi	; Work around new ldir wait state bug.
	jp	LO, copy_loop
gsinit_next:

	.area   _GSFINAL
	ret

;--------------------------------------------------------------------------
;  modsigned.s
;
;  Copyright (C) 2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__modschar
.globl	__modsint

__modschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __div8

        jp	__get_remainder

__modsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __div16

        jp	__get_remainder

;--------------------------------------------------------------------------
;  crtxpop.asm - C run-time: pop registers (not bits) from xstack
;
;  Copyright (C) 2009, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

;--------------------------------------------------------
; overlayable bit register bank
;--------------------------------------------------------
	.area BIT_BANK	(REL,OVR,DATA)
bits:
	.ds 1

	ar0 = 0x00
	ar1 = 0x01

	.area HOME    (CODE)

; Pop registers r1..r7 & bits from xstack
; Expect mask in B
___sdcc_xpop_regs::
	mov	a,r0
	mov	r0,_spx
___sdcc_xpop::
	push acc
	jbc	B.0,00100$	;if B(0)=0 then
	dec	r0
	movx	a,@r0		;pop bits
	mov	bits,a
00100$:
	jbc	B.1,00101$	;if B(1)=0 then
	dec	r0
	movx	a,@r0		;pop R1
	mov	r1,a
00101$:
	jbc	B.2,00102$	;if B(2)=0 then
	dec	r0
	movx	a,@r0		;pop R2
	mov	r2,a
00102$:
	jbc	B.3,00103$	;if B(3)=0 then
	dec	r0
	movx	a,@r0		;pop R3
	mov	r3,a
00103$:
	jbc	B.4,00104$	;if B(4)=0 then
	dec	r0
	movx	a,@r0		;pop R4
	mov	r4,a
00104$:
	jbc	B.5,00105$	;if B(5)=0 then
	dec	r0
	movx	a,@r0		;pop R5
	mov	r5,a
00105$:
	jbc	B.6,00106$	;if B(6)=0 then
	dec	r0
	movx	a,@r0		;pop R6
	mov	r6,a
00106$:
	jbc	B.7,00107$	;if B(7)=0 then
	dec	r0
	movx	a,@r0		;pop R7
	mov	r7,a
00107$:
	mov	_spx,r0
	pop	ar0
	ret
;--------------------------------------------------------------------------
;  crtpagesfr.asm - C run-time: define page sfr for movx @r0/r1 instructions
;
;  Copyright (C) 2004, Erik Petrich
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

__XPAGE == 0xa0	; 0xa0 is P2 on the original 8051
;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.asm - C run-time: C11 atomic flag
;
;  Copyright (C) 2020, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area HOME    (CODE)
	.area GSINIT0 (CODE)
	.area GSINIT1 (CODE)
	.area GSINIT2 (CODE)
	.area GSINIT3 (CODE)
	.area GSINIT4 (CODE)
	.area GSINIT5 (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)
	.area CSEG    (CODE)

	.area HOME    (CODE)

_atomic_flag_test_and_set::
	mov  r0,dpl
	mov  a,#0x01
	xch  a,@r0
	mov  dpl,a
	ret
;--------------------------------------------------------------------------
;  crtcall.asm - C run-time: indirect function call
;
;  Copyright (C) 2007, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area HOME    (CODE)
	.area GSINIT0 (CODE)
	.area GSINIT1 (CODE)
	.area GSINIT2 (CODE)
	.area GSINIT3 (CODE)
	.area GSINIT4 (CODE)
	.area GSINIT5 (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)
	.area CSEG    (CODE)

	.area HOME    (CODE)

__sdcc_call_dptr::
	clr	a
	jmp	@a+dptr
;--------------------------------------------------------------------------
;  atomic_flag_clear.asm - C run-time: C11 atomic flag
;
;  Copyright (C) 2020, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area HOME    (CODE)
	.area GSINIT0 (CODE)
	.area GSINIT1 (CODE)
	.area GSINIT2 (CODE)
	.area GSINIT3 (CODE)
	.area GSINIT4 (CODE)
	.area GSINIT5 (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)
	.area CSEG    (CODE)

	.area HOME    (CODE)

_atomic_flag_clear::
	mov  r0,dpl
	clr  a
	mov  @r0,a
	ret
;--------------------------------------------------------------------------
;  crtxpopbits.asm - C run-time: pop bits and other registers from xstack
;
;  Copyright (C) 2009, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

;--------------------------------------------------------
; overlayable bit register bank
;--------------------------------------------------------
	.area BIT_BANK	(REL,OVR,DATA)
bits:
	.ds 1

	ar0 = 0x00
	ar1 = 0x01

	.area HOME    (CODE)

; Pop registers r0..r7 & bits from xstack (r0 always)
; Expect mask in B
___sdcc_xpop_regs_r0::
	mov	r0,_spx
	dec	r0
	movx	a,@r0		;pop R0
	ljmp	___sdcc_xpop
;--------------------------------------------------------------------------
;  crtclear.asm - C run-time: clear DATA/IDATA
;
;  Copyright (C) 2004, Erik Petrich
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area CSEG    (CODE)
	.area GSINIT0 (CODE)
	.area GSINIT1 (CODE)
	.area GSINIT2 (CODE)
	.area GSINIT3 (CODE)
	.area GSINIT4 (CODE)
	.area GSINIT5 (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)

	.area GSINIT4 (CODE)

__mcs51_genRAMCLEAR::
	clr	a
	mov	r0,#(l_IRAM-1)	; mov r0,a will do for most devices
00004$:	mov	@r0,a
	djnz	r0,00004$
;	_mcs51_genRAMCLEAR() end
;--------------------------------------------------------------------------
;  gptr_cmp.asm - C run-time: compare two generic pointers
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area HOME    (CODE)
	.area GSINIT0 (CODE)
	.area GSINIT1 (CODE)
	.area GSINIT2 (CODE)
	.area GSINIT3 (CODE)
	.area GSINIT4 (CODE)
	.area GSINIT5 (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)
	.area CSEG    (CODE)

	.area HOME    (CODE)

; compares two generic pointers.
; if p1 < p2  return NZ and C
; if p1 == p2 return  Z and NC
; if p1 > p2  return NZ and NC
; if both are a NULL pointer (yes, we have several) also return Z and NC
; assumes that banks never map to address 0x0000
; so it suffices to check dptr part only and ignore b

___gptr_cmp::
	mov  a,sp
	add  a,#0xfc
	clr  c
	xch  a,r0
	push acc
	push dpl
	mov  a,@r0
	inc  r0
	orl  a,@r0
	jnz  00001$
	mov  a,dpl
	orl  a,dph
; if both are NULL, return Z and NC
	jz   00002$
00001$:
	dec  r0
	mov  a,dpl
	subb a,@r0
	mov  dpl,a
	inc  r0
	mov  a,dph
	subb a,@r0
	orl  dpl,a
	inc  r0
	mov  a,b
	subb a,@r0
	orl  a,dpl
; p2 < p1, return NZ and C
; p2 = p1, return Z and NC
; p2 > p1, return NZ and NC
00002$:
	pop  dpl
	xch  a,r0
	pop  acc
	xch  a,r0
	ret
;--------------------------------------------------------------------------
;  crtbank.asm - C run-time: bank switching
;
;  Copyright (C) 2005, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------


	.area HOME    (CODE)
	.area GSINIT0 (CODE)
	.area GSINIT1 (CODE)
	.area GSINIT2 (CODE)
	.area GSINIT3 (CODE)
	.area GSINIT4 (CODE)
	.area GSINIT5 (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)
	.area CSEG    (CODE)

; /*-------------------------------------------------------------------------
;   Example for SiLabs C8051F12x / C8051F13x with 128kB code memory
;   divided into 4 banks of 32kB
;   These devices have an sfr called PSBANK containing two parts:
;   COBANK (bit 5:4): Constant Operations Bank
;   IFBANK (bit 1:0): Instruction Fetch Bank
;   From 0x0000 to 0x7FFF bank 0 is always accessed
;   From 0x8000 to 0xFFFF bank COBANK is accessed for reading with movc
;   From 0x8000 to 0xFFFF bank IFBANK is accessed for executing instructions
;
;   Make your own copy of this file,
;   adapt it to your situation,
;   and compile/link it in your project
; -------------------------------------------------------------------------*/

	.globl _PSBANK

	.area HOME    (CODE)

__sdcc_banked_call::
	push	_PSBANK		;save return bank
	xch	a,r0		;save Acc in r0, do not assume any register bank
	push	acc		;push LSB address
	mov	a,r1
	push	acc		;push MSB address
	mov	a,r2		;get new bank
	anl	a,#0x0F		;remove storage class indicator
	anl	_PSBANK,#0xF0
	orl	_PSBANK,a	;select bank
	xch	a,r0		;restore Acc
	ret			;make the call

__sdcc_banked_ret::
	pop	_PSBANK		;restore bank
	ret			;return to caller
;--------------------------------------------------------------------------
;  crtxpush.asm :- C run-time: push registers (not R0) to xstack
;
;  Copyright (C) 2009, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

;--------------------------------------------------------
; overlayable bit register bank
;--------------------------------------------------------
	.area BIT_BANK	(REL,OVR,DATA)
bits:
	.ds 1

	ar0 = 0x00
	ar1 = 0x01

	.area HOME    (CODE)

; Push registers r1..r7 & bits on xstack
; Expect allocation size in ACC and mask in B
___sdcc_xpush_regs::
	add	a,_spx
	mov	_spx,a
	xch	a,r0
___sdcc_xpush::
	push	acc
	jbc	B.0,00100$	;if B(0)=0 then
	mov	a,bits		;push bits
	dec	r0
	movx	@r0,a
00100$:
	jbc	B.1,00101$	;if B(1)=0 then
	mov	a,r1		;push R1
	dec	r0
	movx	@r0,a
00101$:
	jbc	B.2,00102$	;if B(2)=0 then
	mov	a,r2		;push R2
	dec	r0
	movx	@r0,a
00102$:
	jbc	B.3,00103$	;if B(3)=0 then
	mov	a,r3		;push R3
	dec	r0
	movx	@r0,a
00103$:
	jbc	B.4,00104$	;if B(4)=0 then
	mov	a,r4		;push R4
	dec	r0
	movx	@r0,a
00104$:
	jbc	B.5,00105$	;if B(5)=0 then
	mov	a,r5		;push R5
	dec	r0
	movx	@r0,a
00105$:
	jbc	B.6,00106$	;if B(6)=0 then
	mov	a,r6		;push R6
	dec	r0
	movx	@r0,a
00106$:
	jbc	B.7,00107$	;if B(7)=0 then
	mov	a,r7		;push R7
	dec	r0
	movx	@r0,a
00107$:
	pop	ar0
	ret
;--------------------------------------------------------------------------
;  crtstart.asm - C run-time: startup
;
;  Copyright (C) 2004, Erik Petrich
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area CSEG    (CODE)
	.area GSINIT0 (CODE)
	.area GSINIT1 (CODE)
	.area GSINIT2 (CODE)
	.area GSINIT3 (CODE)
	.area GSINIT4 (CODE)
	.area GSINIT5 (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)

	.globl __start__stack
	
	.area GSINIT0 (CODE)

__sdcc_gsinit_startup::
        mov     sp,#__start__stack - 1

	.area GSINIT2 (CODE)
	
        lcall   __sdcc_external_startup
        mov     a,dpl
        jz      __sdcc_init_data
        ljmp    __sdcc_program_startup
__sdcc_init_data:
;--------------------------------------------------------------------------
;  crtxinit.asm :- C run-time: copy XINIT to XISEG
;
;  Copyright (C) 2004, Erik Petrich
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; Set DUAL_DPTR to 1 and reassemble if your derivative has dual data pointers
; Especially useful if movx @Ri cannot go beyond the first 256 bytes of xdata
; due to lack of P2 or _XPAGE
; If the derivative has auto-toggle or auto-increment it can be further optimized
	DUAL_DPTR = 0

	.area CSEG    (CODE)
	.area GSINIT0 (CODE)
	.area GSINIT1 (CODE)
	.area GSINIT2 (CODE)
	.area GSINIT3 (CODE)
	.area GSINIT4 (CODE)
	.area GSINIT5 (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)

	.area GSINIT3 (CODE)

	.if DUAL_DPTR

	.globl _DPS			; assume DPSEL is in DPS bit0

__mcs51_genXINIT::
	mov	r1,#l_XINIT
	mov	a,r1
	orl	a,#(l_XINIT >> 8)
	jz	00003$
	mov	r2,#((l_XINIT+255) >> 8)
	orl	_DPS,#0x01		; set DPSEL, select DPTR1
	mov	dptr,#s_XINIT		; DPTR1 for code
	dec	_DPS			; clear DPSEL, select DPTR0
	mov	dptr,#s_XISEG		; DPTR0 for xdata
00001$:	clr	a
	inc	_DPS			; set DPSEL, select DPTR1
	movc	a,@a+dptr
	inc	dptr
	dec	_DPS			; clear DPSEL, select DPTR0
	movx	@dptr,a
	inc	dptr
	djnz	r1,00001$
	djnz	r2,00001$
00003$:

	.else

	.globl __XPAGE

__mcs51_genXINIT::
	mov	r1,#l_XINIT
	mov	a,r1
	orl	a,#(l_XINIT >> 8)
	jz	00003$
	mov	r2,#((l_XINIT+255) >> 8)
	mov	dptr,#s_XINIT
	mov	r0,#s_XISEG
	mov	__XPAGE,#(s_XISEG >> 8)
00001$:	clr	a
	movc	a,@a+dptr
	movx	@r0,a
	inc	dptr
	inc	r0
	cjne	r0,#0,00002$
	inc	__XPAGE
00002$:	djnz	r1,00001$
	djnz	r2,00001$
	mov	__XPAGE,#0xFF
00003$:

	.endif
;--------------------------------------------------------------------------
;  crtxclear.asm - C run-time: clear XSEG
;
;  Copyright (C) 2004, Erik Petrich
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area CSEG    (CODE)
	.area GSINIT0 (CODE)
	.area GSINIT1 (CODE)
	.area GSINIT2 (CODE)
	.area GSINIT3 (CODE)
	.area GSINIT4 (CODE)
	.area GSINIT5 (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)

	.area GSINIT4 (CODE)

__mcs51_genXRAMCLEAR::
	mov	r0,#l_PSEG
	mov	a,r0
	orl	a,#(l_PSEG >> 8)
	jz	00006$
	mov	r1,#s_PSEG
	mov	__XPAGE,#(s_PSEG >> 8)
	clr     a
00005$:	movx	@r1,a
	inc	r1
	djnz	r0,00005$

00006$:
	mov	r0,#l_XSEG
	mov	a,r0
	orl	a,#(l_XSEG >> 8)
	jz	00008$
	mov	r1,#((l_XSEG + 255) >> 8)
	mov	dptr,#s_XSEG
	clr     a
00007$:	movx	@dptr,a
	inc	dptr
	djnz	r0,00007$
	djnz	r1,00007$
00008$:

;--------------------------------------------------------------------------
;  crtxstack.asm - C run-time: setup xstack
;
;  Copyright (C) 2004, Erik Petrich
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area CSEG    (CODE)
	.area GSINIT0 (CODE)
	.area GSINIT1 (CODE)
	.area GSINIT2 (CODE)
	.area GSINIT3 (CODE)
	.area GSINIT4 (CODE)
	.area GSINIT5 (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)

	.globl __start__xstack
	.globl __XPAGE

	.area GSINIT1 (CODE)

__sdcc_init_xstack::

; Need to initialize in GSINIT1 in case the user's __sdcc_external_startup
; uses the xstack.
	
	mov	__XPAGE,#(__start__xstack >> 8)
	mov	_spx,#__start__xstack

	.area GSINIT5 (CODE)

; Need to initialize in GSINIT5 because __mcs51_genXINIT modifies __XPAGE
; and __mcs51_genRAMCLEAR modifies _spx.
	
	mov	__XPAGE,#(__start__xstack >> 8)
	mov	_spx,#__start__xstack
;--------------------------------------------------------------------------
;  crtxpush0.asm - C run-time: push R0 and other registers to xstack
;
;  Copyright (C) 2009, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

;--------------------------------------------------------
; overlayable bit register bank
;--------------------------------------------------------
	.area BIT_BANK	(REL,OVR,DATA)
bits:
	.ds 1

	ar0 = 0x00
	ar1 = 0x01

	.area HOME    (CODE)

; Push registers r0..r7 & bits on xstack (r0 always)
; Expect allocation size in ACC and mask in B
___sdcc_xpush_regs_r0::
	add	a,_spx
	mov	_spx,a
	xch	a,r0		;push R0
	dec	r0
	movx	@r0,a
	ljmp	___sdcc_xpush
sdcc/device/lib/mcs51
-------------------

mcs51 specific routines.
;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2014, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl ___sdcc_heap_init
	.globl ___sdcc_heap
	.globl ___sdcc_heap_end

	.area GSINIT
	call ___sdcc_heap_init

	.area DATA
	; For now just allocate 1024 bytes for the heap.
___sdcc_heap::
	.ds 1023
___sdcc_heap_end::
	.ds 1

;--------------------------------------------------------------------------
;  memcpy.s
;
;  Copyright (C) 2018, Benedikt Freisen
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; This memcpy() implementation has been optimized for speed using 4x loop
; unrolling and index relative addressing.

; void *memcpy(void *dest, const void *src, size_t n);

	.globl ___memcpy
	.globl _memcpy

	.area CODE

___memcpy:
_memcpy:
	ldw	y, (3, sp)
	ldw	x, (5, sp)

	srl	(7, sp)
	rrc	(8, sp)
	jrnc	n_x0
	ld	a, (x)
	ld	(y), a
	incw	x
	incw	y
n_x0:
	srl	(7, sp)
	rrc	(8, sp)
	jrnc	n_00
	ld	a, (x)
	ld	(y), a
	incw	x
	incw	y
	ld	a, (x)
	ld	(y), a
	incw	x
	incw	y
n_00:
	tnz	(8, sp)
	jrne	loop_ent
	dec	(7, sp)
	jrmi	end
	jra	loop_ent

loop:
	addw	x, #4
	addw	y, #4
loop_ent:
	ld	a, (x)
	ld	(y), a
	ld	a, (1, x)
	ld	(1, y), a
	ld	a, (2, x)
	ld	(2, y), a
	ld	a, (3, x)
	ld	(3, y), a

	dec	(8, sp)
	jrne	loop
	dec	(7, sp)
	jrpl	loop

end:
	ldw	x, (3, sp)
	ret

;--------------------------------------------------------------------------
;  strcpy.s
;
;  Copyright (C) 2016, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl _strcpy

	.area CODE

_strcpy:

	ldw	y, (0x03, sp)
	ldw	x, (0x05, sp)

loop:
	ld	a, (x)
	ld	(y), a
	jreq	end
	ld	a, (1, x)
	ld	(1, y), a
	jreq	end
	ld	a, (2, x)
	ld	(2, y), a
	jreq	end
	addw	x, #3
	addw	y, #3
	jra	loop

end:
	ldw	x, (0x03, sp)
	ret

;--------------------------------------------------------------------------
;  _mullong.s
;
;  Copyright (C) 2014, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl __mullong

	.area CODE
__mullong:
	clrw	x
	pushw	x
	pushw	x
__mullong_0:
	ld	a, (#10, sp)
	ld	xl, a
	ld	a, (#14, sp)
	mul	x, a
	ldw	(#3, sp), x
__mullong_1:
	ld	a, (#9, sp)
	ld	xl, a
	ld	a, (#14, sp)
	mul	x, a
	addw	x, (#2, sp)
	ldw	(#2, sp), x
	clr	a
	adc	a, #0
	ld	(#1, sp), a

	ld	a, (#10, sp)
	ld	xl, a
	ld	a, (#13, sp)
	mul	x, a
	addw	x, (#2, sp)
	ldw	(#2, sp), x
	clr	a
	adc	a, (#1, sp)
	ld	(#1, sp), a
__mullong_2:
	ld	a, (#10, sp)
	ld	xl, a
	ld	a, (#12, sp)
	mul	x, a
	addw	x, (#1, sp)
	ldw	(#1, sp), x

	ld	a, (#9, sp)
	ld	xl, a
	ld	a, (#13, sp)
	mul	x, a
	addw	x, (#1, sp)
	ldw	(#1, sp), x

	ld	a, (#8, sp)
	ld	xl, a
	ld	a, (#14, sp)
	mul	x, a
	addw	x, (#1, sp)
	ldw	(#1, sp), x
__mullong_3:
	ld	a, (#7, sp)
	ld	xl, a
	ld	a, (#14, sp)
	mul	x, a
	ld	a, xl
	add	a, (#1, sp)
	ld	(#1, sp), a

	ld	a, (#10, sp)
	ld	xl, a
	ld	a, (#11, sp)
	mul	x, a
	ld	a, xl
	add	a, (#1, sp)
	ld	(#1, sp), a

	ld	a, (#9, sp)
	ld	xl, a
	ld	a, (#12, sp)
	mul	x, a
	ld	a, xl
	add	a, (#1, sp)
	ld	(#1, sp), a

	ld	a, (#8, sp)
	ld	xl, a
	ld	a, (#13, sp)
	mul	x, a
	ld	a, xl
	add	a, (#1, sp)
	ld	(#1, sp), a
__mullong_4:
	popw	y
	popw	x
	ret
;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   CODE

	.globl _atomic_flag_test_and_set

_atomic_flag_test_and_set:
	ldw	x, (0x03, sp)
	clr	a
	srl	(x)
	ccf
	rlc	a
	ret

;--------------------------------------------------------------------------
;  _fast_long_neg.s
;
;  Copyright (C) 2014, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl __fast_long_neg

	.area CODE
__fast_long_neg:
	cplw y
	tnzw x
	jreq __fast_long_neg_0
	cplw x
	incw x
	ret
__fast_long_neg_0:
	incw y
	ret;--------------------------------------------------------------------------
;  _modulong.s
;
;  Copyright (C) 2014, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl __modulong

	.area CODE
__modulong:
	sub	sp, #3
;	device/lib/_modulong.c: 342: unsigned char count = 0;
	clr	(0x03, sp)
;	device/lib/_modulong.c: 344: while (!MSB_SET(b))
	clr	(0x01, sp)
__modulong_00103:
	ld	a, (0x0a, sp)
	sll	a
	clr	a
	rlc	a
	tnz	a
	jrne	__modulong_00117
;	device/lib/_modulong.c: 346: b <<= 1;
	ldw	y, (0x0c, sp)
	ldw	x, (0x0a, sp)
	sllw	y
	rlcw	x
	ldw	(0x0c, sp), y
	ldw	(0x0a, sp), x
;	device/lib/_modulong.c: 347: if (b > a)
	ldw	x, (0x08, sp)
	cpw	x, (0x0c, sp)
	ld	a, (0x07, sp)
	sbc	a, (0x0b, sp)
	ld	a, (0x06, sp)
	sbc	a, (0x0a, sp)
	jrnc	__modulong_00102
;	device/lib/_modulong.c: 349: b >>=1;
	ldw	y, (0x0c, sp)
	ldw	x, (0x0a, sp)
	srlw	x
	rrcw	y
	ldw	(0x0c, sp), y
	ldw	(0x0a, sp), x
;	device/lib/_modulong.c: 350: break;
	jra	__modulong_00117
__modulong_00102:
;	device/lib/_modulong.c: 352: count++;
	inc	(0x01, sp)
	ld	a, (0x01, sp)
	ld	(0x03, sp), a
	jra	__modulong_00103
;	device/lib/_modulong.c: 354: do
__modulong_00117:
	ld	a, (0x03, sp)
	ld	(0x02, sp), a
__modulong_00108:
;	device/lib/_modulong.c: 356: if (a >= b)
	ldw	x, (0x08, sp)
	subw	x, (0x0c, sp)
	ld	a, (0x07, sp)
	sbc	a, (0x0b, sp)
	ld	yl, a
	ld	a, (0x06, sp)
	sbc	a, (0x0a, sp)
	jrc	__modulong_00107
;	device/lib/_modulong.c: 357: a -= b;
	ldw	(0x08, sp), x
	ld	yh, a
	ldw	(0x06, sp), y
__modulong_00107:
;	device/lib/_modulong.c: 358: b >>= 1;
	ldw	y, (0x0c, sp)
	ldw	x, (0x0a, sp)
	srlw	x
	rrcw	y
	ldw	(0x0c, sp), y
	ldw	(0x0a, sp), x
;	device/lib/_modulong.c: 360: while (count--);
	ld	a, (0x02, sp)
	dec	(0x02, sp)
	tnz	a
	jrne	__modulong_00108
;	device/lib/_modulong.c: 362: return a;
	ldw	x, (0x08, sp)
	ldw	y, (0x06, sp)
	addw	sp, #3
	ret
;--------------------------------------------------------------------------
;  _divulong.s
;
;  Copyright (C) 2014, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl __divulong

	.area CODE
__divulong:
	sub	sp, #6
;	device/lib/_divulong.c: 333: unsigned long reste = 0L;
	clrw	x
	ldw	(0x05, sp), x
	ldw	(0x03, sp), x
;	device/lib/_divulong.c: 334: unsigned char count = 32;
	ld	a, #0x20
	ld	(0x02, sp), a
;	device/lib/_divulong.c: 337: do
__divulong_00105:
;	device/lib/_divulong.c: 340: c = MSB_SET(x);
	ld	a, (0x09, sp)
	sll	a
	clr	a
	rlc	a
	ld	(0x01, sp), a
;	device/lib/_divulong.c: 341: x <<= 1;
	ldw	y, (0x0b, sp)
	ldw	x, (0x09, sp)
	sllw	y
	rlcw	x
	ldw	(0x0b, sp), y
	ldw	(0x09, sp), x
;	device/lib/_divulong.c: 342: reste <<= 1;
	ldw	y, (0x05, sp)
	ldw	x, (0x03, sp)
	sllw	y
	rlcw	x
	ldw	(0x05, sp), y
	ldw	(0x03, sp), x
;	device/lib/_divulong.c: 343: if (c)
	tnz	(0x01, sp)
	jreq	__divulong_00102
;	device/lib/_divulong.c: 344: reste |= 1L;
	ld	a, (0x06, sp)
	or	a, #0x01
	ld	(0x06, sp), a
__divulong_00102:
;	device/lib/_divulong.c: 346: if (reste >= y)
	ldw	x, (0x05, sp)
	subw	x, (0x0f, sp)
	ld	a, (0x04, sp)
	sbc	a, (0x0e, sp)
	ld	yl, a
	ld	a, (0x03, sp)
	sbc	a, (0x0d, sp)
	jrc	__divulong_00106
;	device/lib/_divulong.c: 348: reste -= y;
	ldw	(0x05, sp), x
	ld	yh, a
	ldw	(0x03, sp), y
;	device/lib/_divulong.c: 350: x |= 1L;
	ld	a, (0x0c, sp)
	or	a, #0x01
	ld	(0x0c, sp), a
__divulong_00106:
;	device/lib/_divulong.c: 353: while (--count);
	dec	(0x02, sp)
	jrne	__divulong_00105
;	device/lib/_divulong.c: 354: return x;
	ldw	x, (0x0b, sp)
	ldw	y, (0x09, sp)
	addw	sp, #6
	ret
;--------------------------------------------------------------------------
;  setjmp.s
;
;  Copyright (C) 2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   CODE

	.globl ___setjmp

___setjmp:
	ldw	y, (3, sp)

	; store return address
	ldw	x, (1, sp)
	ldw	(y), x

	; store stack pointer
	ldw	x, sp
	ldw	(2, y), x

	; return 0
	clrw	x

	ret

	.globl _longjmp

_longjmp:
	ldw	x, (3, sp)
	ldw	y, (5, sp)

	; Restore stack pointer
	pushw	x
	ldw	x, (2, x)
	ldw	(1, x), y
	popw	y
	ldw	sp, x

	; Calculate return value
	popw	x
	tnzw	x
	jrne	jump
	incw	x
jump:
	; Return
	ldw	y, (y)
	jp	(y)

;--------------------------------------------------------------------------
;  _mulint.s
;
;  Copyright (C) 2014-2015, Krzysztof Nikiel, Ben Shi, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl __mulint

.area CODE

__mulint:

	ldw	x, (#3, sp)
	ld	a, (#6, sp)
	mul	x, a
	pushw	x

	ldw	x, (#4, sp)
	mul	x, a
	ld	a, xl
	add	a, (#1, sp)
	ld	(#1, sp), a

	ldw	x, (#5, sp)
	ld	a, (#7, sp)
	mul	x, a
	ld	a, xl
	add	a, (#1, sp)
	popw	x
	ld	xh, a
	
	ret

;--------------------------------------------------------------------------
;  _modsint.s
;
;  Copyright (C) 2014, Krzysztof Nikiel, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl __modsint

	.area CODE
__modsint:
	ldw	y, (#5, sp)
	ldw	x, (#3, sp)
	ld	a, xh
	jrpl	__modsint_1
	negw	x
__modsint_1:
	tnzw	y
	jrpl	__modsint_2
	negw	y
__modsint_2:
	divw	x, y
	tnz	a
	jrpl	__modsint_3
	negw	y
__modsint_3:
	ldw	x, y
	ret
;--------------------------------------------------------------------------
;  _divsint.s
;
;  Copyright (C) 2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl __divsint

	.area CODE

__divsint:
	ldw	x, (#3, sp)
	ld	a, xh
	ldw	y, (#5, sp)
	jrpl	y_nonnegative
	cpl	a
	negw	y
y_nonnegative:
	tnzw	x
	jrpl	x_nonnegative
	negw	x
x_nonnegative:
	divw	x, y
	tnz	a
	jrpl	return_nonnegative
	negw	x
return_nonnegative:
	ret

;--------------------------------------------------------------------------
;  strcmp.s
;
;  Copyright (C) 2016, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl _strcmp

	.area CODE

_strcmp:

	ldw	y, (3, sp)
	ldw	x, (5, sp)

loop:
	ld	a, (y)
	jreq	null
	cp	a, (x)
	jrne	diff

	ld	a, (1, y)
	jreq	null_1
	cp	a, (1, x)
	jrne	diff

	ld	a, (2, y)
	jreq	null_2
	cp	a, (2, x)
	jrne	diff

	addw	y, #3
	addw	x, #3

	jra	loop

null_2:
	incw	x
null_1:
	incw	x
null:
	tnz	(x)
	jrne	less
	clrw	x
	ret

diff:
	jrult less
	ldw	x, #1
	ret

less:
	ldw	x, #-1
	ret

;--------------------------------------------------------------------------
;  _divslong.s
;
;  Copyright (C) 2014, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl __divslong

	.area CODE
__divslong:
	ldw x, (#0x09, sp)
	ldw y, (#0x07, sp)
	jrpl __divslong_0
	call __fast_long_neg
__divslong_0:
	pushw x
	pushw y
__divslong_1:
	ldw x, (#0x09, sp)
	ldw y, (#0x07, sp)
	jrpl __divslong_2
	call __fast_long_neg
__divslong_2:
	pushw x
	pushw y
__divslong_3:
	call __divulong
	addw sp, #0x08
__divslong_4:
	ld a, (#0x03, sp)
	xor a, (#0x07, sp)
	jrpl __divslong_5
	call __fast_long_neg
__divslong_5:
	ret
;--------------------------------------------------------------------------
;  _modslong.s
;
;  Copyright (C) 2014, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl __modslong

	.area CODE
__modslong:
	ldw x, (#0x09, sp)
	ldw y, (#0x07, sp)
	jrpl __modslong_0
	call __fast_long_neg
__modslong_0:
	pushw x
	pushw y
__modslong_1:
	ldw x, (#0x09, sp)
	ldw y, (#0x07, sp)
	jrpl __modslong_2
	call __fast_long_neg
__modslong_2:
	pushw x
	pushw y
__modslong_3:
	call __modulong
	addw sp, #0x08
__modslong_4:
	ld a, (#0x03, sp)
	jrpl __modslong_5
	call __fast_long_neg
__modslong_5:
	ret
;--------------------------------------------------------------------------
;  __mulsint2slong.s
;
;  Copyright (C) 2016, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl ___mulsint2slong
.globl ___muluint2ulong

.area CODE

___muluint2ulong:
    clr a
    ldw x, (5, sp)
    jra right_nonneg

___mulsint2slong:
	
	; Handle signed operands
	clr	a
	ldw	x, (3, sp)
	jrpl	left_nonneg
	cpl	a
	negw	x
	ldw	(3, sp), x
left_nonneg:
	ldw	x, (5, sp)
	jrpl	right_nonneg
	cpl	a
	negw	x
	ldw	(5, sp), x
right_nonneg:

	sub	sp, #4
	push	a

	; Multiply lower bytes
	ld	a, (5+4, sp)
	mul	x, a
	ldw	(4, sp), x

	; Multiply upper bytes
	ldw	x, (5+2, sp)
	ld	a, (5+5, sp)
	mul	x, a
	ldw	(2, sp), x

	; Multiply middle bytes
	ld	a, (5+5, sp)
	jreq	skip_m1
	ldw	x, (5+3, sp)
	mul	x, a
	addw	x, (3, sp)
	ldw	(3, sp), x
	ld	a, (2, sp)
	adc	a, #0
	ld	(2, sp), a
skip_m1:

	ld	a, (5+3, sp)
	jreq	skip_m2
	ldw	x, (5+5, sp)
	mul	x, a
	addw	x, (3, sp)
	ldw	(3, sp), x
	ld	a, (2, sp)
	adc	a, #0
	ld	(2, sp), a
skip_m2:

	; Handle signed result
	pop	a
	popw	y
	popw	x
	tnz	a
jrpl	end
	negw	x
jrnc	neg_y
	incw	y
neg_y:
	negw	y
end:
	ret

;--------------------------------------------------------------------------
;  modunsigned.s
;
;  Copyright (C) 2009-2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__moduchar
.globl	__moduint

__moduchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __divu8

	ex	de,hl

        ret

__moduint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __divu16

        ex      de,hl

        ret

;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2001, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; Just stubs - not copyrightable

        ;; Stubs that hook the heap in
        .globl  ___sdcc_heap_init

        .area   _GSINIT
        call    ___sdcc_heap_init

        .area   _HEAP
___sdcc_heap::
        ;; For now just allocate 1k of heap.
        .ds     1023

        .area   _HEAP_END
___sdcc_heap_end::
        .ds     1
;--------------------------------------------------------------------------
;  __ltoa.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___ltoa
	.globl ___ultoa
;
;void __itoa(long value, char *string, unsigned char radix);
;
___ltoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	8(ix) - string
;	10(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
	bit	7, 7 (ix)
	jr	Z, ___ultoa_de
;positive/negative numbers are supported only for radix=10
	ld	a, 10 (ix)
	cp	a, #10
	jr	NZ, ___ultoa_de
;add minus sign to result and inverse value
	ld	hl, #0
	or	a, a
	sbc	hl, de
	ex	de, hl
	ld	hl, #0
	ld	c, 6 (ix)
	ld	b, 7 (ix)
	sbc	hl, bc
	ld	6 (ix), l
	ld	7 (ix), h
	ld	l, 8 (ix)
	ld	h, 9 (ix)
	ld	(hl), #0x2D	;minus symbol
	inc	hl
	ld	8 (ix), l
	ld	9 (ix), h
	jr	___ultoa_dehl
;
;void __uitoa(unsigned int value, char *string, unsigned char radix);
;
___ultoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	8(ix) - string
;	10(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
;
___ultoa_de:
	ld	l, 8 (ix)
	ld	h, 9 (ix)
;
___ultoa_dehl:
	ld	a, e
	or	a, d
	or	a, 6 (ix)
	or	a, 7 (ix)
	jr	NZ, 100$
;
	ld	(hl), #0x30
	inc	hl
	jp	190$
100$:
	ld	a, 10 (ix)
	cp	a, #10		;most popular radix
	jr	NZ, 110$
;
;-------- decimal convertion
;this algorithm is 20% faster than generic one
;
	ld	c, l
	ld	b, h
	ld	hl, #-5
	add	hl, sp
	ld	sp, hl
	push	bc
	push	hl
	ld	c, 6 (ix)
	ld	b, 7 (ix)
	push	bc
	push	de
	call	___ultobcd
	ld	hl, #6
	add	hl, sp
	ld	sp, hl
	pop	de		;DE - pointer to string
	inc	hl
	inc	hl		;HL - pointer to BCD value
	ld	b, #5		;number of bytes in BCD value
	ld	a, #0x30	;ASCII code of '0'
103$:
	rrd
	ld	(de), a
	inc	de
	rrd
	ld	(de), a
	inc	de
	inc	hl
	djnz	103$
;
;	ld	sp, hl
;skip trailing zeroes
	ld	b, #10		;real decimal number is at most 10 digits
105$:
	dec	de
	ld	a, (de)
	cp	a, #0x30
	jr	NZ, 107$	;break loop if non-zero found
	djnz	105$
107$:
	inc	de		;always point to symbol next to last significant
	ex	de, hl
	jr	190$
;
;---------------------------
;
110$:
	cp	a, #2
	jr	C, 190$		;radix is less than 2
;
	ld	c, a
	dec	c
	and	a, c
	jr	NZ, 150$
;
;-------- radix is power of 2
;
; DE - lower 16 bits of value, HL - pointer to string, C - mask
120$:
	ld	a, e
	ld	b, c
125$:
	srl	7 (ix)
	rr	6 (ix)
	rr	d
	rr	e
	srl	b
	jr	NZ, 125$
;
	and	a, c
	add	a, #0x30
	cp	a, #0x3A ;convert to 0...9A...Z
	jr	C, 130$
	add	a, #7
130$:
	ld	(hl), a
	inc	hl
	ld	a, e
	or	a, d
	or	a, 6 (ix)
	or	a, 7 (ix)
	jr	NZ, 120$
	jr	190$
;
;---------------------------
;
;-------- custom radix (generic algorithm)
;
150$:
	ex	de, hl
	ld	c, e
	ld	b, d
	ld	e, 6 (ix)
	ld	d, 7 (ix)
160$:
	push	bc
	ld	c, 10 (ix)
	call	___divu32_8
	pop	bc
	add	a, #0x30
	cp	a, #0x3A
	jr	C, 165$
	add	a, #7
165$:
	ld	(bc), a
	inc	bc
	ld	a, l
	or	a, h
	or	a, e
	or	a, d
	jr	NZ, 160$
	ld	l, c
	ld	h, b
;	jr	190$
;
;---------------------------
;
;-------- finish string and reverse order
190$:
	ld	(hl), #0
	ld	e, 8 (ix)
	ld	d, 9 (ix)
	call	___strreverse_reg
	ld	sp, ix
	pop	ix
	ret
;
;in: DEHL - divident, C - divisor
;out: DEHL - quotient, A - remainder
___divu32_8:
	xor	a, a
	ld	b, #32
100$:
	add	hl, hl
	rl	e
	rl	d
	rla
	jr	c, 110$
	cp	a, c
	jr	c, 120$
110$:
	sub	a, c
	inc	l
120$:
	djnz	100$
	ret

;--------------------------------------------------------------------------
;  memcpy.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memcpy
	.globl ___memcpy

; The Z80 has the ldir instruction, which is perfect for implementing memcpy().
_memcpy:
___memcpy:
	pop	af
	pop	hl	;return value expected to be in HL, so pop dst to HL
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	ex	de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  modmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__modsuchar
.globl	__moduschar

__modsuchar:
	ld      hl,#2+1
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)
	ld      h,#0

	call    __div_signexte

	jp	__get_remainder

__moduschar:
	ld      hl,#2+1
	ld      d, h
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)

	ld      a,l	; Sign extend
	rlca
	sbc     a, a
	ld      h, a

	call	__div16

	jp	__get_remainder

;--------------------------------------------------------------------------
;  strcpy.s
;
;  Copyright (C) 2012, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strcpy

_strcpy:
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
	push	de
	xor	a, a
loop:
	cp	a, (hl)
	ldi
	jr	NZ, loop
	pop	hl
	ret

;--------------------------------------------------------------------------
;  divsigned.s
;
;  Copyright (C) 2000-2010, Michael Hope, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area	_CODE

.globl	__divsint
.globl	__divschar

__divsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jp      __div16

__divschar:
        ld      hl, #2+1
        add     hl, sp

        ld      e, (hl)
        dec     hl
        ld      l, (hl)

__div8::
        ld      a, l            ; Sign extend
        rlca
        sbc     a,a
        ld      h, a
__div_signexte::
        ld      a, e            ; Sign extend
        rlca
        sbc     a,a
        ld      d, a
        ; Fall through to __div16

        ;; signed 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;
        ;; Register used: AF,B,DE,HL
__div16::
        ;; Determine sign of quotient by xor-ing high bytes of dividend
        ;;  and divisor. Quotient is positive if signs are the same, negative
        ;;  if signs are different
        ;; Remainder has same sign as dividend
        ld      a, h            ; Get high byte of dividend
        xor     a, d            ; Xor with high byte of divisor
        rla                     ; Sign of quotient goes into the carry
        ld      a, h            ; Get high byte of dividend
        push    af              ; Save sign of both quotient and reminder

        ; Take absolute value of dividend
        rla
        jr      NC, .chkde      ; Jump if dividend is positive
        sub     a, a            ; Substract dividend from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a

        ; Take absolute value of divisor
.chkde:
        bit     7, d
        jr      Z, .dodiv       ; Jump if divisor is positive
        sub     a, a            ; Subtract divisor from 0
        sub     a, e
        ld      e, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, d
        ld      d, a

        ; Divide absolute values
.dodiv:
        call    __divu16

.fix_quotient:
        ; Negate quotient if it is negative
        pop     af              ; recover sign of quotient
        ret	NC		; Jump if quotient is positive
        ld      b, a
        sub     a, a            ; Subtract quotient from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ld      a, b
	ret

__get_remainder::
        ; Negate remainder if it is negative and move it into hl
        rla
	ex	de, hl
        ret     NC              ; Return if remainder is positive
        sub     a, a            ; Subtract remainder from 0
        sub     a, l
        ld      l, a
        sbc     a, a             ; Propagate remainder (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ret

;--------------------------------------------------------------------------
;  divunsigned.s
;
;  Copyright (C) 2000-2012, Michael Hope, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        ;; Originally from GBDK by Pascal Felber.

.area   _CODE

.globl	__divuint
.globl	__divuchar

__divuint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jr      __divu16

__divuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ;; Fall through
__divu8::
        ld      h,#0x00
        ld      d,h
        ; Fall through to __divu16

        ;; unsigned 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;   carry = 0
        ;;   If divisor is 0, quotient is set to "infinity", i.e HL = 0xFFFF.
        ;;
        ;; Register used: AF,B,DE,HL
__divu16::
        ;; Two algorithms: one assumes divisor <2^7, the second
        ;; assumes divisor >=2^7; choose the applicable one.
        ld      a,e
        and     a,#0x80
        or      a,d
        jr      NZ,.morethan7bits
        ;; Both algorithms "rotate" 24 bits (H,L,A) but roles change.

        ;; unsigned 16/7-bit division
.atmost7bits:
        ld      b,#16           ; bits in dividend and possible quotient
        ;; Carry cleared by AND/OR, this "0" bit will pass trough HL.[*]
        adc     hl,hl
.dvloop7:
        ;; HL holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry.
        ;; A holds remainder.
        rla

        ;; If remainder is >= divisor, next bit of quotient is 1.  We try
        ;;  to compute the difference.
        sub     a,e
        jr      NC,.nodrop7     ; Jump if remainder is >= dividend
        add     a,e             ; Otherwise, restore remainder
        ;; The add above sets the carry, because sbc a,e did set it.
.nodrop7:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        adc     hl,hl
        djnz    .dvloop7
        ;; Carry now contains the same value it contained before
        ;; entering .dvloop7[*]: "0" = valid result.
        ld      e,a             ; DE = remainder, HL = quotient
        ret

.morethan7bits:
        ld      b,#9            ; at most 9 bits in quotient.
        ld      a,l             ; precompute the first 7 shifts, by
        ld      l,h             ;  doing 8
        ld      h,#0
        rr      l               ;  undoing 1
.dvloop:
        ;; Shift next bit of quotient into bit 0 of dividend
        ;; Shift next MSB of dividend into LSB of remainder
        ;; A holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry
        ;; HL holds remainder
        adc     hl,hl           ; HL < 2^(7+9), no carry, ever.

        ;; If remainder is >= divisor, next bit of quotient is 1. We try
        ;;  to compute the difference.
        sbc     hl,de
        jr      NC,.nodrop      ; Jump if remainder is >= dividend
        add     hl,de           ; Otherwise, restore remainder
	;; The add above sets the carry, because sbc hl,de did set it.
.nodrop:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        rla
        djnz    .dvloop
        ;; Take care of the ninth quotient bit! after the loop B=0.
        rl      b               ; BA = quotient
        ;; Carry now contains "0" = valid result.
        ld      d,b
        ld      e,a             ; DE = quotient, HL = remainder
        ex      de,hl           ; HL = quotient, DE = remainder
        ret

;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _atomic_flag_test_and_set

_atomic_flag_test_and_set:
	pop	de
	pop	hl
	push	hl
	push	de
	xor a, a
	srl	(hl)
	ccf
	rla
	ld	l, a
	ret

;--------------------------------------------------------------------------
;  __strreverse.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___strreverse
	.globl ___strreverse_reg
;
;void __reverse(char *beg, char *end);
;
___strreverse::
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
;
;in: HL - pointer to end of string (null symbol), DE - pointer to start of string
;
___strreverse_reg::
	jr	110$
100$:
	add	hl, de
	ld	a, (de)
	ld	c, (hl)
	ld	(hl), a
	ld	a, c
	ld	(de), a
	inc	de
110$:
	dec	hl
	or	a, a
	sbc	hl, de
	jr	NC, 100$
	ret
;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (c) 2017, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

; unsigned char x unsigned char multiplication is done by code generation.

.globl	__mulsuchar
.globl	__muluschar
.globl	__mulschar

; operands have different sign

__mulsuchar:
        ld      hl,#2+1
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        jr      signexte

__muluschar:
        ld      hl,#2
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      c,(hl)
        jr      signexte

__mulschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)

        ;; Need to sign extend before going in.
        ld      a,c
        rla
        sbc     a,a
        ld      b,a
signexte:
        ld      a,e
        rla
        sbc     a,a
        ld      d,a

        jp      __mul16

;--------------------------------------------------------------------------
;  crtenter.s
;
;  Copyright (C) 2015, Alan Cox, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_enter_ix

; Factor out some start of function code to reduce code size

___sdcc_enter_ix:
	pop	hl	; return address
	push	ix	; save frame pointer
	ld	ix, #0
	add	ix, sp	; set ix to the stack frame
	jp	(hl)	; and return

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_iy

; The Z80 has the jp (iy) instruction, which is perfect for implementing function pointers.

___sdcc_call_iy:
	jp	(iy)

;--------------------------------------------------------------------------
;  memmove.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memmove

; The Z80 has the ldir and lddr instructions, which are perfect for implementing memmove().

_memmove:
	pop	af
	pop	hl
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	sbc	hl, de		; or above cleared carry.
	add	hl, de		; same carry as the line before
	jr	C, memmove_up
memmove_down:
	dec	bc
	add	hl, bc
	ex      de, hl
	add	hl, bc
	inc	bc
	lddr
	pop	hl
	ret
memmove_up:
	ex      de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  setjmp.s
;
;  Copyright (C) 2011-2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___setjmp

___setjmp:
	pop	hl
	pop	iy
	push	af
	push	hl

	; Store return address.
	ld	0(iy), l
	ld	1(iy), h

	; Store stack pointer.
	xor	a, a
	ld	l, a
	ld	h, a
	add	hl, sp
	ld	2(iy), l
	ld	3(iy), h

	; Store frame pointer.
	push	ix
	pop	hl
	ld	4(iy), l
	ld	5(iy), h

	; Return 0.
	ld	l, a
	ld	h, a
	ret

.globl _longjmp

_longjmp:
	pop	af
	pop	iy
	pop	de

	; Ensure that return value is non-zero.
	ld	a, e
	or	a, d
	jr	NZ, jump
	inc	de
jump:

	; Restore frame pointer.
	ld	l, 4(iy)
	ld	h, 5(iy)
	push	hl
	pop	ix

	; Adjust stack pointer.
	ld	l, 2(iy)
	ld	h, 3(iy)
	ld	sp, hl
	pop	hl

	; Move return value into hl.
	ex	de, hl

	; Jump.
	ld	c, 0(iy)
	ld	b, 1(iy)
	push	bc
	ret
;--------------------------------------------------------------------------
;  __uitobcd.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___uitobcd
;
; void __uitobcd (unsigned int v, unsigned char bcd[3])
; __uitobcd converts v to BCD representation to the bcd.
; bcd[] will contain BCD value.
;
___uitobcd:
	push	ix
	ld	ix, #0
	add	ix, sp
;
	ld	bc, #0x1000
	ld	d, c
	ld	e, c
	ld	l, 4 (ix)
	ld	h, 5 (ix)
;
;--- begin speed optimization
;
	ld	a, h
	or	a, a
	jr	NZ, 100$
;
	ld	h, l
	srl	b
;
;--- end speed optimization
;
; HL - binary value
; CDE - future BCD value
; B - bits count (16)
100$:
	add	hl, hl
	ld	a, e
	adc	a, a
	daa
	ld	e, a
	ld	a, d
	adc	a, a
	daa
	ld	d, a
	ld	a, c
	adc	a, a
	daa
	ld	c, a
	djnz	100$
;
	ld	l, 6 (ix)
	ld	h, 7 (ix)
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	ld	(hl), c
;
	pop	ix
	ret
;--------------------------------------------------------------------------
;  abs.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _abs

; 12B; 86T for nonnegative arguments, 78T for negative.
_abs:
	pop	hl
	pop	de
	push	de
	push	hl
	xor	a, a
	ld	l, a
	ld	h, a
	sbc	hl, de
	ret	P
	ex	de, hl
	ret

; 14B; 59T for nonegative arguments, 94T for negative:
;_abs:
;	pop	de
;	pop	hl
;	push	hl
;	push	de
;	bit	7, h
;	ret	Z
;	xor	a, a
;	ld	e, a
;	ld	d, a
;	ex	de, hl
;	sbc	hl, de
;	ret

;--------------------------------------------------------------------------
;  strlen.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strlen

; The Z80 has the cpir instruction, which is perfect for implementing strlen().

_strlen:
	pop	bc
	pop	hl
	push	hl
	push	bc
	xor	a, a
	ld	b, a
	ld	c, a
	cpir
	ld	hl, #-1
	sbc	hl, bc	; C flag still cleared from xor above.
	ret

;--------------------------------------------------------------------------
;  __ultobcd.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___ultobcd
;
; void __ultobcd (unsigned long v, unsigned char bcd[5])
; __ultobcd converts v to BCD representation to the bcd.
; bcd[] will contain BCD value.
;
___ultobcd:
	push	ix
	ld	ix, #0
	add	ix, sp
	ld	bc, #0x2000
;
;--- begin speed optimization
;
	ld	l, 4 (ix)
	ld	h, 5 (ix)
	ld	e, 6 (ix)
	ld	d, 7 (ix)
	ld	a, e
	or	a, d
	jr	NZ, 101$
;high 2 bytes are zero
	ld	b, #0x10
	ex	de, hl
101$:
	ld	a, d
	or	a, a
	jr	NZ, 102$
;high byte is zero
	ld	d, e
	ld	e, h
	ld	h, l
	ld	a, #-8
	add	a, b
	ld	b, a
102$:
	ld	4 (ix), l
	ld	5 (ix), h
	ld	6 (ix), e
	ld	7 (ix), d
;
;--- end speed optimization
;
	ld	hl, #0x0000
	ld	e, l
	ld	d, h
; (ix+0)..(ix+3) - binary value
; CDEHL - future BCD value
; B - bits count (32)
103$:
	sla	4 (ix)
	rl	5 (ix)
	rl	6 (ix)
	rl	7 (ix)
	ld	a, l
	adc	a, a
	daa
	ld	l, a
	ld	a, h
	adc	a, a
	daa
	ld	h, a
	ld	a, e
	adc	a, a
	daa
	ld	e, a
	ld	a, d
	adc	a, a
	daa
	ld	d, a
	ld	a, c
	adc	a, a
	daa
	ld	c, a
	djnz	103$
;
	ld	b, l
	ld	a, h
	ld	l, 8 (ix)
	ld	h, 9 (ix)
	ld	(hl), b
	inc	hl
	ld	(hl), a
	inc	hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	ld	(hl), c
;
	pop	ix
	ret
;--------------------------------------------------------------------------
;  divmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__divsuchar
.globl	__divuschar

__divsuchar:
	ld	hl, #2+1
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)
	ld	h, #0

	jp	__div_signexte

__divuschar:
	ld	hl, #2+1
	ld	d, h
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)

	ld 	a, l	; Sign extend
	rlca
	sbc	a, a
	ld	h, a

	jp	__div16

;--------------------------------------------------------------------------
;  __itoa.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___itoa
	.globl ___uitoa
;
;void __itoa(int value, char *string, unsigned char radix);
;
___itoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	6(ix) - string
;	8(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
	bit	7, d
	jr	Z, ___uitoa_de
;positive/negative numbers are supported only for radix=10
	ld	a, 8 (ix)
	cp	a, #10
	jr	NZ, ___uitoa_de
;add minus sign to result and inverse value
	ld	hl, #0
	or	a, a
	sbc	hl, de
	ex	de, hl
	ld	l, 6 (ix)
	ld	h, 7 (ix)
	ld	(hl), #0x2D	;minus symbol
	inc	hl
	ld	6 (ix), l
	ld	7 (ix), h
	jr	___uitoa_dehl
;
;void __uitoa(unsigned int value, char *string, unsigned char radix);
;
___uitoa::
	push	ix
	ld	ix, #0
	add	ix, sp
;
;	4(ix) - value
;	6(ix) - string
;	8(ix) - radix
;
	ld	e, 4 (ix)
	ld	d, 5 (ix)
;
___uitoa_de:
	ld	l, 6 (ix)
	ld	h, 7 (ix)
;
___uitoa_dehl:
	ld	a, e
	or	a, d
	jr	NZ, 100$
;
	ld	(hl), #0x30
	inc	hl
	jp	190$
100$:
	ld	a, 8 (ix)
	cp	a, #10		;most popular radix
	jr	NZ, 110$
;
;-------- decimal convertion
; this algorithm up to 2 times faster than generic
;
	ld	c, l
	ld	b, h
	ld	hl, #-4
	add	hl, sp
	ld	sp, hl
	push	bc
	push	hl
	push	de
	call	___uitobcd
	ld	hl, #4
	add	hl, sp
	ld	sp, hl
	pop	de		;DE - pointer to string
	inc	hl
	inc	hl		;HL - pointer to BCD value
	ld	b, #3		;number of bytes in BCD value
	ld	a, #0x30	;ASCII code of '0'
103$:
	rrd
	ld	(de), a
	inc	de
	rrd
	ld	(de), a
	inc	de
	inc	hl
	djnz	103$
;
;	pop	af
;	pop	af
;skip trailing zeroes
	ld	b, #5		;real BCD number is at most 5 digits
	dec	de		;so always skip last zero
105$:
	dec	de
	ld	a, (de)
	cp	a, #0x30
	jr	NZ, 107$	;break loop if non-zero found
	djnz	105$
107$:
	inc	de		;always point to symbol next to last significant
	ex	de, hl
	jr	190$
;
;---------------------------
;
110$:
	cp	a, #2
	jr	C, 190$		;radix is less than 2
;
	ld	c, a
	dec	c
	and	a, c
	jr	NZ, 150$
;
;-------- radix is power of 2
;
; DE - value, HL - pointer to string, C - mask
120$:
	ld	a, e
	ld	b, c
125$:
	srl	d
	rr	e
	srl	b
	jr	NZ, 125$
;
	and	a, c
	add	a, #0x30
	cp	a, #0x3A ;convert to 0...9A...Z
	jr	C, 130$
	add	a, #7
130$:
	ld	(hl), a
	inc	hl
	ld	a, e
	or	a, d
	jr	NZ, 120$
	jr	190$
;
;---------------------------
;
;-------- custom radix (generic algorithm)
;
150$:
	ex	de, hl
160$:
	ld	c, 8 (ix)
	call	___divu16_8
	add	a, #0x30
	cp	a, #0x3A
	jr	C, 165$
	add	a, #7
165$:
	ld	(de), a
	inc	de
	ld	a, l
	or	h
	jr	NZ, 160$
	ex	de, hl
;	jr	190$
;
;---------------------------
;
;-------- finish string and reverse order
190$:
	ld	(hl), #0
	ld	e, 6 (ix)
	ld	d, 7 (ix)
	call	___strreverse_reg
	ld	sp, ix
	pop	ix
	ret
;
;
;in: HL - divident, C - divisor
;out: HL - quotient, A - remainder
___divu16_8:
	xor	a, a
	ld	b, #16
100$:
	add	hl, hl
	rla
	jr	c, 110$
	cp	a, c
	jr	c, 120$
110$:
	sub	a, c
	inc	l
120$:
	djnz	100$
	ret

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_hl

; The Z80 has the jp (hl) instruction, which is perfect for implementing function pointers.

___sdcc_call_hl:
	jp	(hl)

;--------------------------------------------------------------------------
;  __sdcc_bcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; This file contains generic trampolines for banked function calls.
; They are not complete. Programmer must provide set_bank and get_bank
; routines. Or rewrite whole code completely.
;
	.area   _CODE

	.globl ___sdcc_bcall
	.globl ___sdcc_bcall_abc
	.globl ___sdcc_bcall_ehl
;
; trampoline to call banked functions
; used when legacy banking is enabled only
; Usage:
;   call ___sdcc_bcall
;   .dw  <function>
;   .dw  <function_bank>
;
___sdcc_bcall::
	ex	(sp), hl
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	ld	a, (hl)
	inc	hl
	inc	hl
	ex	(sp), hl
;
; trampoline to call banked functions with __z88dk_fastcall calling convention
; Usage:
;  ld   a, #<function_bank>
;  ld   bc, #<function>
;  call ___sdcc_bcall_abc
;
___sdcc_bcall_abc::
	push	hl
	ld	l, a
	call	get_bank	;must return A as current bank number, other registers expected to be unchanged
	ld	h, a
	ld	a, l
	ex	(sp), hl
	inc	sp
	call	___sdcc_bjump_abc
	dec	sp
	pop	af
	jp	set_bank
;
___sdcc_bjump_abc:
	call	set_bank	;set current bank to A, other registers expected to be unchanged
	push	bc
	ret
;
; default trampoline to call banked functions
; Usage:
;  ld   e, #<function_bank>
;  ld   hl, #<function>
;  call ___sdcc_bcall_ehl
;
___sdcc_bcall_ehl::
	call	get_bank
	push	af
	inc	sp
	call	___sdcc_bjump_ehl
	dec	sp
	pop	af
	jp	set_bank
;
___sdcc_bjump_ehl:
	ld	a, e
	call	set_bank
	jp	(hl)
;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__mulint

__mulint:
        pop     af
        pop     bc
        pop     de
        push    de
        push    bc
        push    af

	;; 16-bit multiplication
	;;
	;; Entry conditions
	;; bc = multiplicand
	;; de = multiplier
	;;
	;; Exit conditions
	;; hl = less significant word of product
	;;
	;; Register used: AF,BC,DE,HL
__mul16::
	xor	a,a
	ld	l,a
	or	a,b
	ld	b,#16

        ;; Optimise for the case when this side has 8 bits of data or
        ;; less.  This is often the case with support address calls.
        jr      NZ,2$
        ld      b,#8
        ld      a,c
1$:
        ;; Taken from z88dk, which originally borrowed from the
        ;; Spectrum rom.
        add     hl,hl
2$:
        rl      c
        rla                     ;DLE 27/11/98
        jr      NC,3$
        add     hl,de
3$:
        djnz    1$
        ret

;--------------------------------------------------------------------------
;  crt0.s - Generic crt0.s for a Z80
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.module crt0
	.globl	_main

	.area	_HEADER (ABS)
	;; Reset vector
	.org 	0
	jp	init

	.org	0x08
	ei
	reti
	ei
	.org	0x10
	ei
	reti
	.org	0x18
	ei
	reti
	.org	0x20
	ei
	reti
	.org	0x28
	ei
	reti
	.org	0x30
	ei
	reti
	.org	0x38
	ei
	reti

	.org	0x100
init:
	;; Set stack pointer directly above top of memory.
	ld	sp,#0x0000

	;; Initialise global variables
	call	gsinit
	call	_main
	jp	_exit

	;; Ordering of segments for the linker.
	.area	_HOME
	.area	_CODE
	.area	_INITIALIZER
	.area   _GSINIT
	.area   _GSFINAL

	.area	_DATA
	.area	_INITIALIZED
	.area	_BSEG
	.area   _BSS
	.area   _HEAP

	.area   _CODE
__clock::
	ld	a,#2
	rst	0x08
	ret

_exit::
	;; Exit - special code to the emulator
	ld	a,#0
	rst	0x08
1$:
	halt
	jr	1$

	.area   _GSINIT
gsinit::
	ld	bc, #l__INITIALIZER
	ld	a, b
	or	a, c
	jr	Z, gsinit_next
	ld	de, #s__INITIALIZED
	ld	hl, #s__INITIALIZER
	ldir
gsinit_next:

	.area   _GSFINAL
	ret

;--------------------------------------------------------------------------
;  modsigned.s
;
;  Copyright (C) 2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__modschar
.globl	__modsint

__modschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __div8

        jp	__get_remainder

__modsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __div16

        jp	__get_remainder

sdcc/device/lib/z80
-------------------

Z80 specific routines.

Notes:
* Cost of ld r,(ix+n):	19
* Cost of ld r,(hl); inc hl: 7+6 = 13 and you don't have to pop ix
        ;--------------------------------------------------------------------------
;  modunsigned.s
;
;  Copyright (C) 2009-2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__moduchar
.globl	__moduint

__moduchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __divu8

	ex	de,hl

        ret

__moduint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __divu16

        ex      de,hl

        ret

;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2001, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; Just stubs - not copyrightable

        ;; Stubs that hook the heap in
        .globl  ___sdcc_heap_init

        .area   _GSINIT
        call    ___sdcc_heap_init

        .area   _HEAP
___sdcc_heap::
        ;; For now just allocate 1k of heap.
        .ds     1023

        .area   _HEAP_END
___sdcc_heap_end::
        .ds     1
;--------------------------------------------------------------------------
;  memcpy.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memcpy
	.globl ___memcpy

; The Z80 has the ldir instruction, which is perfect for implementing memcpy().
_memcpy:
___memcpy:
	pop	af
	pop	hl	;return value expected to be in HL, so pop dst to HL
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	ex	de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  modmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__modsuchar
.globl	__moduschar

__modsuchar:
	ld      hl,#2+1
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)
	ld      h,#0

	call    __div_signexte

	jp	__get_remainder

__moduschar:
	ld      hl,#2+1
	ld      d, h
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)

	ld      a,l	; Sign extend
	rlca
	sbc     a, a
	ld      h, a

	call	__div16

	jp	__get_remainder

;--------------------------------------------------------------------------
;  strcpy.s
;
;  Copyright (C) 2012, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strcpy

_strcpy:
	pop	bc
	pop	de
	pop	hl
	push	hl
	push	de
	push	bc
	push	de
	xor	a, a
loop:
	cp	a, (hl)
	ldi
	jr	NZ, loop
	pop	hl
	ret

;--------------------------------------------------------------------------
;  divsigned.s
;
;  Copyright (C) 2000-2010, Michael Hope, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area	_CODE

.globl	__divsint
.globl	__divschar

__divsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jp      __div16

__divschar:
        ld      hl, #2+1
        add     hl, sp

        ld      e, (hl)
        dec     hl
        ld      l, (hl)

__div8::
        ld      a, l            ; Sign extend
        rlca
        sbc     a,a
        ld      h, a
__div_signexte::
        ld      a, e            ; Sign extend
        rlca
        sbc     a,a
        ld      d, a
        ; Fall through to __div16

        ;; signed 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;
        ;; Register used: AF,B,DE,HL
__div16::
        ;; Determine sign of quotient by xor-ing high bytes of dividend
        ;;  and divisor. Quotient is positive if signs are the same, negative
        ;;  if signs are different
        ;; Remainder has same sign as dividend
        ld      a, h            ; Get high byte of dividend
        xor     a, d            ; Xor with high byte of divisor
        rla                     ; Sign of quotient goes into the carry
        ld      a, h            ; Get high byte of dividend
        push    af              ; Save sign of both quotient and reminder

        ; Take absolute value of dividend
        rla
        jr      NC, .chkde      ; Jump if dividend is positive
        sub     a, a            ; Substract dividend from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a

        ; Take absolute value of divisor
.chkde:
        bit     7, d
        jr      Z, .dodiv       ; Jump if divisor is positive
        sub     a, a            ; Subtract divisor from 0
        sub     a, e
        ld      e, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, d
        ld      d, a

        ; Divide absolute values
.dodiv:
        call    __divu16

.fix_quotient:
        ; Negate quotient if it is negative
        pop     af              ; recover sign of quotient
        ret	NC		; Jump if quotient is positive
        ld      b, a
        sub     a, a            ; Subtract quotient from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ld      a, b
	ret

__get_remainder::
        ; Negate remainder if it is negative and move it into hl
        rla
	ex	de, hl
        ret     NC              ; Return if remainder is positive
        sub     a, a            ; Subtract remainder from 0
        sub     a, l
        ld      l, a
        sbc     a, a             ; Propagate remainder (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ret

;--------------------------------------------------------------------------
;  divunsigned.s
;
;  Copyright (C) 2000-2012, Michael Hope, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        ;; Originally from GBDK by Pascal Felber.

.area   _CODE

.globl	__divuint
.globl	__divuchar

__divuint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        jr      __divu16

__divuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        ;; Fall through
__divu8::
        ld      h,#0x00
        ld      d,h
        ; Fall through to __divu16

        ;; unsigned 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;   carry = 0
        ;;   If divisor is 0, quotient is set to "infinity", i.e HL = 0xFFFF.
        ;;
        ;; Register used: AF,B,DE,HL
__divu16::
        ;; Two algorithms: one assumes divisor <2^7, the second
        ;; assumes divisor >=2^7; choose the applicable one.
        ld      a,e
        and     a,#0x80
        or      a,d
        jr      NZ,.morethan7bits
        ;; Both algorithms "rotate" 24 bits (H,L,A) but roles change.

        ;; unsigned 16/7-bit division
.atmost7bits:
        ld      b,#16           ; bits in dividend and possible quotient
        ;; Carry cleared by AND/OR, this "0" bit will pass trough HL.[*]
        adc     hl,hl
.dvloop7:
        ;; HL holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry.
        ;; A holds remainder.
        rla

        ;; If remainder is >= divisor, next bit of quotient is 1.  We try
        ;;  to compute the difference.
        sub     a,e
        jr      NC,.nodrop7     ; Jump if remainder is >= dividend
        add     a,e             ; Otherwise, restore remainder
        ;; The add above sets the carry, because sbc a,e did set it.
.nodrop7:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        adc     hl,hl
        djnz    .dvloop7
        ;; Carry now contains the same value it contained before
        ;; entering .dvloop7[*]: "0" = valid result.
        ld      e,a             ; DE = remainder, HL = quotient
        ret

.morethan7bits:
        ld      b,#9            ; at most 9 bits in quotient.
        ld      a,l             ; precompute the first 7 shifts, by
        ld      l,h             ;  doing 8
        ld      h,#0
        rr      l               ;  undoing 1
.dvloop:
        ;; Shift next bit of quotient into bit 0 of dividend
        ;; Shift next MSB of dividend into LSB of remainder
        ;; A holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry
        ;; HL holds remainder
        adc     hl,hl           ; HL < 2^(7+9), no carry, ever.

        ;; If remainder is >= divisor, next bit of quotient is 1. We try
        ;;  to compute the difference.
        sbc     hl,de
        jr      NC,.nodrop      ; Jump if remainder is >= dividend
        add     hl,de           ; Otherwise, restore remainder
	;; The add above sets the carry, because sbc hl,de did set it.
.nodrop:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        rla
        djnz    .dvloop
        ;; Take care of the ninth quotient bit! after the loop B=0.
        rl      b               ; BA = quotient
        ;; Carry now contains "0" = valid result.
        ld      d,b
        ld      e,a             ; DE = quotient, HL = remainder
        ex      de,hl           ; HL = quotient, DE = remainder
        ret

;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _atomic_flag_test_and_set

_atomic_flag_test_and_set:
	ld	hl, 2 (sp)
	xor a, a
	srl	(hl)
	ccf
	rla
	ld	l, a
	ret

;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (c) 2017-2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

; unsigned char x unsigned char multiplication is done by code generation.

.globl	__mulsuchar
.globl	__muluschar
.globl	__mulschar

; operands have different sign

__mulsuchar:
        ld      hl,#2+1
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        jr      signexte

__muluschar:
        ld      hl,#2
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      c,(hl)
        jr      signexte

__mulschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)

        ;; Need to sign extend before going in.
        ld      a,c
        rla
        sbc     a,a
        ld      b,a
signexte:
        ld      a,e
        rla
        sbc     a,a
        ld      d,a

        mul

	ld	l, c
	ld	h, b

	ret

;--------------------------------------------------------------------------
;  crtenter.s
;
;  Copyright (C) 2015, Alan Cox, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_enter_ix

; Factor out some start of function code to reduce code size

___sdcc_enter_ix:
	pop	hl	; return address
	push	ix	; save frame pointer
	ld	ix, #0
	add	ix, sp	; set ix to the stack frame
	jp	(hl)	; and return

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_iy

; The Z80 has the jp (iy) instruction, which is perfect for implementing function pointers.

___sdcc_call_iy:
	jp	(iy)

;--------------------------------------------------------------------------
;  memmove.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memmove

; The Z80 has the ldir and lddr instructions, which are perfect for implementing memmove().

_memmove:
	pop	af
	pop	hl
	pop	de
	pop	bc
	push	bc
	push	de
	push	hl
	push	af
	ld	a, c
	or	a, b
	ret	Z
	push	hl
	sbc	hl, de		; or above cleared carry.
	add	hl, de		; same carry as the line before
	jr	C, memmove_up
memmove_down:
	dec	bc
	add	hl, bc
	ex      de, hl
	add	hl, bc
	inc	bc
	lddr
	pop	hl
	ret
memmove_up:
	ex      de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  setjmp.s
;
;  Copyright (C) 2011-2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___setjmp

___setjmp:
	pop	hl
	pop	iy
	push	af
	push	hl

	; Store return address.
	ld	0(iy), l
	ld	1(iy), h

	; Store stack pointer.
	xor	a, a
	ld	l, a
	ld	h, a
	add	hl, sp
	ld	2(iy), l
	ld	3(iy), h

	; Store frame pointer.
	push	ix
	pop	hl
	ld	4(iy), l
	ld	5(iy), h

	; Return 0.
	ld	l, a
	ld	h, a
	ret

.globl _longjmp

_longjmp:
	pop	af
	pop	iy
	pop	de

	; Ensure that return value is non-zero.
	ld	a, e
	or	a, d
	jr	NZ, jump
	inc	de
jump:

	; Restore frame pointer.
	ld	l, 4(iy)
	ld	h, 5(iy)
	push	hl
	pop	ix

	; Adjust stack pointer.
	ld	l, 2(iy)
	ld	h, 3(iy)
	ld	sp, hl
	pop	hl

	; Move return value into hl.
	ex	de, hl

	; Jump.
	ld	c, 0(iy)
	ld	b, 1(iy)
	push	bc
	ret
;--------------------------------------------------------------------------
;  abs.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _abs

; 12B; 86T for nonnegative arguments, 78T for negative.
_abs:
	pop	hl
	pop	de
	push	de
	push	hl
	xor	a, a
	ld	l, a
	ld	h, a
	sbc	hl, de
	ret	P
	ex	de, hl
	ret

; 14B; 59T for nonegative arguments, 94T for negative:
;_abs:
;	pop	de
;	pop	hl
;	push	hl
;	push	de
;	bit	7, h
;	ret	Z
;	xor	a, a
;	ld	e, a
;	ld	d, a
;	ex	de, hl
;	sbc	hl, de
;	ret

;--------------------------------------------------------------------------
;  divmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__divsuchar
.globl	__divuschar

__divsuchar:
	ld	hl, #2+1
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)
	ld	h, #0

	jp	__div_signexte

__divuschar:
	ld	hl, #2+1
	ld	d, h
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)

	ld 	a, l	; Sign extend
	rlca
	sbc	a, a
	ld	h, a

	jp	__div16

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_hl

; The Z80 has the jp (hl) instruction, which is perfect for implementing function pointers.

___sdcc_call_hl:
	jp	(hl)

;--------------------------------------------------------------------------
;  crt0.s - Generic crt0.s for a Rabbit 3000A
;	derived from "Generic crt0.s for a Z80"
;
;  Copyright (C) 2000, Michael Hope
;  Modified for Rabbit by Leland Morrison 2011
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.module crt0
	.globl	_main
	.globl	__sdcc_external_startup

GCSR		.equ	0x00 ; Global control / status register
MMIDR		.equ	0x10
STACKSEG	.equ	0x11
SEGSIZE		.equ	0x13
MB0CR		.equ	0x14 ; Memory Bank 0 Control Register
MB1CR		.equ	0x15 ; Memory Bank 1 Control Register
MB2CR		.equ	0x16 ; Memory Bank 2 Control Register
MB3CR		.equ	0x17 ; Memory Bank 3 Control Register

	.area	_HEADER (ABS)

	; Reset vector - assuming smode0 and smode1 input pins are grounded
	.org 	0

	; setup internal interrupts
	ld	a, #1
	ld	iir, a

	; Configure physical address space.
	; Leave MB0CR Flash at default slow at /OE0, /CS0
	; Assume slow RAM at /CS1, /OE1, /WE1
	ld	a, #0x05
	ioi
	ld	(MB2CR), a;

	; Configure logical address space. 32 KB root segment followed by 8 KB data segment, 16 KB stack segement, 8 KB xpc segment.
	; By default, SDCC will use the root segment for code and constant data, stack segment for data (including stack). data segment and xpc segement are then unused.
	ld	a, #0xa8	; 16 KB stack segment at 0xa000, 8 KB data segment at 0x8000
	ioi
	ld	(SEGSIZE), a

	; Configure mapping to physical address space.
	ld	a, #0x76
	ioi
	ld	(STACKSEG), a	; stack segment base at 0x76000 + 0xa000 = 0x80000

	; Set stack pointer directly above top of stack segment
	ld	sp, #0xe000

	call __sdcc_external_startup

	; Initialise global variables
	call	gsinit

	call	_main
	jp	_exit

	; Periodic Interrupt
	.org	0x100
	push	af
	ioi
	ld	a, (GCSR) ; clear interrupt
	pop	af
	reti

	; Secondary Watchdog - Rabbit 3000A only
	.org	0x100
	reti

	; rst 0x10
	.org	0x120
	ret

	; rst 0x18
	.org	0x130
	ret

	; rst 0x20
	.org	0x140
	ret

	; rst 0x28
	.org	0x150
	ret

	; Syscall instruction - Rabbit 3000A only
	.org	0x160
	ret

	; rst 0x38
	.org	0x170
	ret

	; Slave Port
	.org	0x180
	reti

	; Timer A
	.org	0x1a0
	reti

	; Timer B
	.org	0x1b0
	reti

	; Serial Port A
	.org	0x1c0
	reti

	; Serial Port B
	.org	0x1d0
	reti

	; Serial Port C
	.org	0x1e0
	reti

	; Serial Port D
	.org	0x1f0
	reti

	.org	0x200

	;; Ordering of segments for the linker.
	.area	_HOME
	.area	_CODE
	.area	_INITIALIZER
	.area   _GSINIT
	.area   _GSFINAL

	.area	_DATA
	.area	_INITIALIZED
	.area	_BSEG
	.area   _BSS
	.area   _HEAP

	.area   _CODE
_exit::
	;; Exit - special code to the emulator
	ld	a,#0
	rst     #0x28
1$:
	;halt		; opcode for halt used for 'altd' on rabbit processors
	jr	1$

	.area   _GSINIT
gsinit::
	ld	bc, #l__DATA
	ld	a, b
	or	a, c
	jr	Z, zeroed_data
	ld	hl,	#s__DATA
	ld	(hl), #0x00
	dec	bc
	ld	a, b
	or	a, c
	jr	Z, zeroed_data
	ld	e, l
	ld	d, h
	inc	de
	ldir

zeroed_data:

	ld	bc, #l__INITIALIZER
	ld	a, b
	or	a, c
	jr	Z, gsinit_next
	ld	de, #s__INITIALIZED
	ld	hl, #s__INITIALIZER
	ldir
	
gsinit_next:

	.area   _GSFINAL
	ret

;--------------------------------------------------------------------------
;  modsigned.s
;
;  Copyright (C) 2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__modschar
.globl	__modsint

__modschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __div8

        jp	__get_remainder

__modsint:
        pop     af
        pop     hl
        pop     de
        push    de
        push    hl
        push    af

        call    __div16

        jp	__get_remainder

;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2014, Ben Shi
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.globl ___sdcc_heap_init
	.globl ___sdcc_heap
	.globl ___sdcc_heap_end

	.area GSINIT
	call ___sdcc_heap_init

	.area DATA
	; For now just allocate 64 bytes for the heap.
___sdcc_heap::
	.ds 63
___sdcc_heap_end::
	.ds 1 
;--------------------------------------------------------------------------
;  __gptrget.s - read from pointer
;
;  Copyright (c) 2019, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.module __gptrget
.area CODE

__gptrget::
	sub	a, #0x80
	t1sn	f, c
	goto	code

	; Pointer to RAM
	idxm	a, p
	ret

	; Pointer to ROM
code:
	; Put pointer on stack
	xch	a, p
	push	af	; Put lower byte of pointer on stack.
	mov	a, sp
	add	a, #-1
	xch	a, p
	idxm	p, a	; Put upper byte of pointer on stack.

	; Jump to it. ret there will return from the call to __gprtget
	ret

;--------------------------------------------------------------------------
;  __gptrget.s - read from pointer
;
;  Copyright (c) 2019, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;  might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.module __gptrget2
.area CODE

__gptrget2::
	sub	a, #0x80
	t1sn	f, c
	goto	code

	; Pointer to RAM
	idxm	a, p
	push	af
	inc	p
	idxm	a, p
	mov	p, a
	pop	af
	ret

	; Pointer to ROM
code:
	xch	a, p
	push	af	; Put lower byte of pointer to first byte of value on stack.
	call	code2	; Put return value for the ret at second byte of value on stack.

	mov	p, a
	; Jump to lower byte. ret there will return from the call to __gptrget2
	ret

code2:
	add	a, #1
	push	af	; Put lower byte of pointer to second byte of value on stack.
	mov	a, sp
	add	a, #-5
	xch	a, p
	idxm	p, a	; Put upper byte of pointer to first byte of value on stack.
	pop	af
	push	af
	idxm	a, p
	addc	a
	xch	a, p
	add	a, #4
	xch	a, p
	idxm	p, a	; Put lower byte of pointer to second byte of value on stack.

	; Jump to upper byte. ret there will return from the call to code2
	ret

;--------------------------------------------------------------------------
;  __setjmp.s
;
;  Copyright (C) 2019, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area DATA
___setjmp_PARM_1::
        .ds 2
_longjmp_PARM_1::
	.ds 2
_longjmp_PARM_2::
	.ds 2

	.area   CODE

___setjmp::
	mov	a, sp
	add	a, #-1
	mov	p, a
	idxm	a, p
	push	af
	dec	p
	idxm	a, p

	xch	a, p
	mov	a, ___setjmp_PARM_1+0
	xch	a, p

	idxm	p, a
	inc	p
	pop	af
	idxm	p, a

	inc	p
	mov	a, sp
	idxm	p, a
	clear	p
	ret	#0

_longjmp::
	mov	a, _longjmp_PARM_1+0
	add	a, #2
	mov	p, a
	idxm	a, p
	add	a, #-2
	mov	sp, a

	dec	p
	dec	p
	idxm	a, p
	push	af
	inc	p
	idxm	a, p

	xch	a, p
	mov	a, sp
	add	a, #-1
	xch	a, p
	idxm	p, a

	mov	a, _longjmp_PARM_2+1
	mov	p, a
	mov	a, _longjmp_PARM_2+0

	ceqsn	a, p
	ret
	ceqsn	a, #0
	ret
	ret	#1

;--------------------------------------------------------------------------
;  modunsigned.s
;
;  Copyright (C) 2009-2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__moduchar
.globl	__moduint

__moduchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __divu8

	ex	de,hl

        ret

__moduint:
        ld	hl, 2 (sp)
        ld	de, 4 (sp)

        call    __divu16

        ex      de,hl

        ret

;--------------------------------------------------------------------------
;  heap.s
;
;  Copyright (C) 2001, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

; Just stubs - not copyrightable

        ;; Stubs that hook the heap in
        .globl  ___sdcc_heap_init

        .area   _GSINIT
        call    ___sdcc_heap_init

        .area   _HEAP
___sdcc_heap::
        ;; For now just allocate 1k of heap.
        .ds     1023

        .area   _HEAP_END
___sdcc_heap_end::
        .ds     1
;--------------------------------------------------------------------------
;  memcpy.s
;
;  Copyright (C) 2020, Sergey Belyashov
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memcpy
	.globl ___memcpy

; The Z80 has the ldir instruction, which is perfect for implementing memcpy().
_memcpy:
___memcpy:
	ld	hl, 2 (sp)	;return value expected to be in HL, so pop dst to HL
	ld	bc, 6 (sp)
	ld	a, c
	or	a, b
	ret	Z
	ld	de, 4 (sp)
	push	hl
	ex	de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  modmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__modsuchar
.globl	__moduschar

__modsuchar:
	ld      hl,#2+1
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)
	ld      h,#0

	call    __div_signexte

	jp	__get_remainder

__moduschar:
	ld      hl,#2+1
	ld      d, h
	add     hl,sp

	ld      e,(hl)
	dec     hl
	ld      l,(hl)

	ld      a,l	; Sign extend
	rlca
	sbc     a, a
	ld      h, a

	call	__div16

	jp	__get_remainder

;--------------------------------------------------------------------------
;  strcpy.s
;
;  Copyright (C) 2012, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strcpy

_strcpy:
	ld	de, 2 (sp)
	ld	hl, 4 (sp)
	push	de
	xor	a, a
loop:
	cp	a, (hl)
	ldi
	jr	NZ, loop
	pop	hl
	ret

;--------------------------------------------------------------------------
;  divsigned.s
;
;  Copyright (C) 2000-2010, Michael Hope, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area	_CODE

.globl	__divsint
.globl	__divschar

__divsint:
        ld	hl, 2 (sp)
        ld	de, 4 (sp)

        jp      __div16

__divschar:
        ld      hl, #2+1
        add     hl, sp

        ld      e, (hl)
        dec     hl
        ld      l, (hl)

__div8::
        ld      a, l            ; Sign extend
        rlca
        sbc     a, a
        ld      h, a
__div_signexte::
        ld      a, e            ; Sign extend
        rlca
        sbc     a, a
        ld      d, a
        ; Fall through to __div16

        ;; signed 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;
        ;; Register used: AF,B,DE,HL
__div16::
        ;; Determine sign of quotient by xor-ing high bytes of dividend
        ;;  and divisor. Quotient is positive if signs are the same, negative
        ;;  if signs are different
        ;; Remainder has same sign as dividend
        ld      a, h            ; Get high byte of dividend
        xor     a, d            ; Xor with high byte of divisor
        rla                     ; Sign of quotient goes into the carry
        ld      a, h            ; Get high byte of dividend
        push    af              ; Save sign of both quotient and reminder

        ; Take absolute value of dividend
        rla
        jr      NC, .chkde      ; Jump if dividend is positive
        sub     a, a            ; Substract dividend from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a

        ; Take absolute value of divisor
.chkde:
        bit     7, d
        jr      Z, .dodiv       ; Jump if divisor is positive
        sub     a, a            ; Subtract divisor from 0
        sub     a, e
        ld      e, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, d
        ld      d, a

        ; Divide absolute values
.dodiv:
        call    __divu16

.fix_quotient:
        ; Negate quotient if it is negative
        pop     af              ; recover sign of quotient
        ret	NC		; Jump if quotient is positive
        ld      b, a
        sub     a, a            ; Subtract quotient from 0
        sub     a, l
        ld      l, a
        sbc     a, a            ; Propagate borrow (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ld      a, b
	ret

__get_remainder::
        ; Negate remainder if it is negative and move it into hl
        rla
	ex	de, hl
        ret     NC              ; Return if remainder is positive
        sub     a, a            ; Subtract remainder from 0
        sub     a, l
        ld      l, a
        sbc     a, a             ; Propagate remainder (A=0xFF if borrow)
        sub     a, h
        ld      h, a
        ret

;--------------------------------------------------------------------------
;  divunsigned.s
;
;  Copyright (C) 2000-2012, Michael Hope, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        ;; Originally from GBDK by Pascal Felber.

.area   _CODE

.globl	__divuint
.globl	__divuchar

__divuint:
        ld	hl, 2 (sp)
        ld	de, 4 (sp)

        jr      __divu16

__divuchar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

__divu8::
        ld      h,#0x00
        ld      d,h
        ; Fall through to __divu16

        ;; unsigned 16-bit division
        ;;
        ;; Entry conditions
        ;;   HL = dividend
        ;;   DE = divisor
        ;;
        ;; Exit conditions
        ;;   HL = quotient
        ;;   DE = remainder
        ;;   carry = 0
        ;;   If divisor is 0, quotient is set to "infinity", i.e HL = 0xFFFF.
        ;;
        ;; Register used: AF,B,DE,HL
__divu16::
        ;; Two algorithms: one assumes divisor <2^7, the second
        ;; assumes divisor >=2^7; choose the applicable one.
        ld      a,e
        and     a,#0x80
        or      a,d
        jr      NZ,.morethan7bits
        ;; Both algorithms "rotate" 24 bits (H,L,A) but roles change.

        ;; unsigned 16/7-bit division
.atmost7bits:
        ld      b,#16           ; bits in dividend and possible quotient
        ;; Carry cleared by AND/OR, this "0" bit will pass trough HL.[*]
        adc     hl,hl
.dvloop7:
        ;; HL holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry.
        ;; A holds remainder.
        rla

        ;; If remainder is >= divisor, next bit of quotient is 1.  We try
        ;;  to compute the difference.
        sub     a,e
        jr      NC,.nodrop7     ; Jump if remainder is >= dividend
        add     a,e             ; Otherwise, restore remainder
        ;; The add above sets the carry, because sbc a,e did set it.
.nodrop7:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        adc     hl,hl
        djnz    .dvloop7
        ;; Carry now contains the same value it contained before
        ;; entering .dvloop7[*]: "0" = valid result.
        ld      e,a             ; DE = remainder, HL = quotient
        ret

.morethan7bits:
        ld      b,#9            ; at most 9 bits in quotient.
        ld      a,l             ; precompute the first 7 shifts, by
        ld      l,h             ;  doing 8
        ld      h,#0
        rr      l               ;  undoing 1
.dvloop:
        ;; Shift next bit of quotient into bit 0 of dividend
        ;; Shift next MSB of dividend into LSB of remainder
        ;; A holds both dividend and quotient. While we shift a bit from
        ;;  MSB of dividend, we shift next bit of quotient in from carry
        ;; HL holds remainder
        adc     hl,hl           ; HL < 2^(7+9), no carry, ever.

        ;; If remainder is >= divisor, next bit of quotient is 1. We try
        ;;  to compute the difference.
        sbc     hl,de
        jr      NC,.nodrop      ; Jump if remainder is >= dividend
        add     hl,de           ; Otherwise, restore remainder
	;; The add above sets the carry, because sbc hl,de did set it.
.nodrop:
        ccf                     ; Complement borrow so 1 indicates a
                                ;  successful substraction (this is the
                                ;  next bit of quotient)
        rla
        djnz    .dvloop
        ;; Take care of the ninth quotient bit! after the loop B=0.
        rl      b               ; BA = quotient
        ;; Carry now contains "0" = valid result.
        ld      d,b
        ld      e,a             ; DE = quotient, HL = remainder
        ex      de,hl           ; HL = quotient, DE = remainder
        ret

;--------------------------------------------------------------------------
;  atomic_flag_test_and_set.s
;
;  Copyright (C) 2020, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _atomic_flag_test_and_set

_atomic_flag_test_and_set:
	ld	hl, 2 (sp)
	xor a, a
	srl	(hl)
	ccf
	rla
	ld	l, a
	ret

;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (c) 2017, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

; unsigned char x unsigned char multiplication is done by code generation.

.globl	__mulsuchar
.globl	__muluschar
.globl	__mulschar

; operands have different sign

__mulsuchar:
        ld      hl,#2+1
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)
        jr      signexte

__muluschar:
        ld      hl,#2
        ld      b, h
        add     hl,sp

        ld      e,(hl)
        inc     hl
        ld      c,(hl)
        jr      signexte

__mulschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      c,(hl)

        ;; Need to sign extend before going in.
        ld      a,c
        rla
        sbc     a,a
        ld      b,a
signexte:
        ld      a,e
        rla
        sbc     a,a
        ld      d,a

        jp      __mul16

;--------------------------------------------------------------------------
;  crtenter.s
;
;  Copyright (C) 2015, Alan Cox, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_enter_ix

; Factor out some start of function code to reduce code size

___sdcc_enter_ix:
	pop	hl	; return address
	push	ix	; save frame pointer
	ld	ix, #0
	add	ix, sp	; set ix to the stack frame
	jp	(hl)	; and return

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock, 2015 Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_iy

; The Z80 has the jp (iy) instruction, which is perfect for implementing function pointers.

___sdcc_call_iy:
	jp	(iy)

;--------------------------------------------------------------------------
;  memmove.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause, Marco Bodrato
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

        .area   _CODE

	.globl _memmove

; The Z80 has the ldir and lddr instructions, which are perfect for implementing memmove().

_memmove:
	ld	hl, 2 (sp)
	ld	bc, 6 (sp)
	ld	a, c
	or	a, b
	ret	Z
	ld	de, 4 (sp)
	push	hl
	sbc	hl, de		; or above cleared carry.
	add	hl, de		; same carry as the line before
	jr	C, memmove_up
memmove_down:
	dec	bc
	add	hl, bc
	ex      de, hl
	add	hl, bc
	inc	bc
	lddr
	pop	hl
	ret
memmove_up:
	ex      de, hl
	ldir
	pop	hl
	ret

;--------------------------------------------------------------------------
;  setjmp.s
;
;  Copyright (C) 2011-2014, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___setjmp

___setjmp:
	ld	hl, 0 (sp)
	ld	iy, 2 (sp)

	; Store return address.
	ld	0 (iy), hl

	; Store stack pointer.
	ld	2 (iy), sp

	; Store frame pointer.
	ld	4 (iy), ix

	; Return 0.
	sub	hl, hl
	ret

.globl _longjmp

_longjmp:
	pop	hl
	pop	iy
	pop	hl

	; Ensure that return value is non-zero.
	or	hl, hl
	jr	NZ, jump
	inc	hl
jump:

	; Restore frame pointer.
	ld	ix, 4 (iy)

	; Adjust stack pointer.
	ld	sp, 2 (iy)
	add	sp, #2

	; Jump.
	ld	bc, 0 (iy)
	jp	(bc)
;--------------------------------------------------------------------------
;  abs.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _abs

; 12B; 86T for nonnegative arguments, 78T for negative.
_abs:
	ld	de, 2 (sp)
	xor	a, a
	ld	l, a
	ld	h, a
	sbc	hl, de
	ret	P
	ex	de, hl
	ret

; 14B; 59T for nonegative arguments, 94T for negative:
;_abs:
;	pop	de
;	pop	hl
;	push	hl
;	push	de
;	bit	7, h
;	ret	Z
;	xor	a, a
;	ld	e, a
;	ld	d, a
;	ex	de, hl
;	sbc	hl, de
;	ret

;--------------------------------------------------------------------------
;  strlen.s
;
;  Copyright (C) 2008-2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl _strlen

; The Z80 has the cpir instruction, which is perfect for implementing strlen().

_strlen:
	ld	hl, 2 (sp)
	xor	a, a
	ld	b, a
	ld	c, a
	cpir
	ld	hl, #-1
	sbc	hl, bc	; C flag still cleared from xor above.
	ret

;--------------------------------------------------------------------------
;  divmixed.s
;
;  Copyright (C) 2010, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.globl	__divsuchar
.globl	__divuschar

__divsuchar:
	ld	hl, #2+1
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)
	ld	h, #0

	jp	__div_signexte

__divuschar:
	ld	hl, #2+1
	ld	d, h
	add	hl, sp

	ld	e, (hl)
	dec	hl
	ld	l, (hl)

	ld 	a, l	; Sign extend
	rlca
	sbc	a, a
	ld	h, a

	jp	__div16

;--------------------------------------------------------------------------
;  crtcall.s
;
;  Copyright (C) 2011, Maarten Brock
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

	.area   _CODE

	.globl ___sdcc_call_hl

; The Z80 has the jp (hl) instruction, which is perfect for implementing function pointers.

___sdcc_call_hl:
	jp	(hl)

;; crt0_asm.s - tlcs90
	
	.t90
	
	.module crt0

	.globl _meminit
	.globl _main
	.globl _xxaddr
	.globl _xxby
	.globl _xxdata

	.globl _ser_putchar_irq
	.globl _ser_puts
	
	;; put as abs in dat at end of file..
	;.globl _ser_irq_flags
	;.globl _ser_char
	
	.globl _xget_byte_asm
	.globl _xset_byte_asm


	 ;; for interrupts the pc and af are pushed on the stack
	
	.globl _irq_info_swi
	.globl _irq_info_intwd
	.globl _irq_info_intt0
	.globl _irq_info_intt1
	.globl _timer1_irq
	.globl _irq_info_intt3
	.globl _irq_info_intt4
	.globl _irq_info_int1
	.globl _irq_info_intt5

	.globl _ticks16
	.globl _xflag
	
	;; NOTE: header might get trashed by linker when code loc ist not used!?
	.area	_HEADER (ABS)
	
	.org 	0

	.include "t90regs.s"

	;; _ser_irq_flags
TX_ACTIVE	.equ 0
RX_READY        .equ 1
	
L0:
	;halt
	;jr    L0
	jp    _astart
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop
L10:	
	; SWI
	jp    _swi_irq
	nop  
	nop  
	nop  
	nop  
	nop  

L18:	
	nop  ; NMI
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  

L20:
	; INTWD
	jp    _intwd_irq
	nop  
	nop  
	nop  
	nop  
	nop
L28:	
	reti ; INT0
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
L30:	
	; INTT0
	jp    _intt0_irq
	nop  
	nop  
	nop  
	nop  
	nop
L38:	
	; INTT1
	jp    _intt1_irq
	nop  
	nop  
	nop  
	nop  
	nop
L40:
	; INTAD 
	reti 
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop
L48:	
	; INTT3
	jp    _intt3_irq
	nop  
	nop  
	nop  
	nop  
	nop
L50:	
	; INTT4
	jp    _intt4_irq
	nop  
	nop  
	nop  
	nop  
	nop
L58:	
	; INT1
	jp    _int1_irq
	nop  
	nop  
	nop  
	nop  
	nop
L60:	
	; INTT5
	jp    _intt5_irq
	nop  
	nop  
	nop  
	nop  
	nop
L68:	
	reti ; INT2
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop
L70:	
	jp _serial_rx_irq
	nop  
	nop  
	nop  
	nop  
	nop
L78:	
	jp _serial_tx_irq
	nop  
	nop  
	nop  
	nop  
	nop
L80:	
	nop  

	.org 0x100
	
_astart:
	ld    sp, #0x0FFA0	; stack
	
	;halt
	;swi
	
	or    (P01CR), #0x04
	
	ld    (P3), #0xF7	
	ld    (P3CR), #0xA5	; P30 = RXD, P31 = IN:PaperOut CN3, P32 = TXD, P33 = OUT:CN2.LF P34:IN, P37:IN
	
	ld    (P4), #0x00
	ld    (P4CR), #0x03	; address output
	ld    (P7), #0x03
	ld    (P67CR), #0xF0
	ld    (SMMOD), #0xA0
	ld    (SMCR), #0x00
	ld    (T4MOD), #0x35
	ld    (P8), #0x08
	ld    (P8CR), #0x08
	ld    (T4FFCR), #0x01
	
	ld    (TMOD), #0x40
	
	;ld    (SCMOD), #0x03	; 9600
	ld    (SCMOD), #0x01	; 19200
	or    (SCMOD), #0x08	; 8-bit data
	or    (SCMOD), #0x20	; receiver enable

	ld    (SCCR), #0x00
	
	ld    (WDMOD), #0xC0
	ld    (TRUN), #0x20	; PRRUN, start prescaler
	or    (TRUN), #0xE0	; BRATE, 19200 baud

	;; enable rx/tx irqs
	set   0,(INTEL)		; tx
	set   1,(INTEL)		; rx

	;call _boot1
	
	ld    hl, #0xFF20	; data start
	ld    a, #0x00
	
clear_ram:
	call  _wd_reset_asm
	
	ld    (hl),a
	inc   hl
	cp    hl, #0xFFC0	; io start, 160 bytes data
	jr    nz, clear_ram
	
	call  _wd_reset_asm

	res   TX_ACTIVE,(_ser_irq_flags)
	
	;call _boot2
	call _meminit
	
	call  _wd_reset_asm
	
        ;; Initialise global variables

	;call _boot3
	
        call gsinit

	;call _boot4
	
	call _main
	halt
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	.area _CODE
	
	;; get far byte using by
	
_xget_byte_asm:
	push bc
	ld	iy, (_xxaddr)
	ld	b, (BY)
	ld	a, (_xxby)
	ld	(BY), a
	ld	a,(iy)
	ld	(BY), b
	ld	(_xxdata), a
	pop	bc
	ret

_xset_byte_asm:
	push bc
	ld	iy, (_xxaddr)
	ld	b, (BY)
	ld	a, (_xxby)
	ld	(BY), a
	ld 	a, (_xxdata)
	ld	(iy), a
	ld	(BY), b
	pop	bc
	ret
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_serial_rx_irq:
	ld a, (SCBUF)
	ld (_ser_char), a
	set RX_READY, (_ser_irq_flags)
	reti 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
_serial_tx_irq:
	res TX_ACTIVE,(_ser_irq_flags)
	ld (IRFH), #0x0F ; clear tx request flag (vector 0x78/8 = 0x0F)
	reti 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_swi_irq:
	push hl
	ld hl, 4(sp)
	ld (_swi_pc), hl	; pc
	ld hl, 2(sp)
	ld (_swi_af), hl	; af
	call _irq_info_swi
	pop hl
	reti
_intwd_irq:	
	call _irq_info_intwd
	reti
_intt0_irq:	
	call _irq_info_intt0
	reti
_intt1_irq:	
	;call _irq_info_intt1
	;exx

	; hangs when exx is used?
	incw (_ticks16) 

	; hangs when exx is used?
	;; ld hl, (_ticks16)
	;; inc hl
	;; ld (_ticks16), hl
	
	ld (WDCR), #0x4E
	ld (IRFL), #0x10;
	;call _timer1_irq
	;exx
	reti
_intt3_irq:	
	call _irq_info_intt3
	reti
_intt4_irq:	
	call _irq_info_intt4
	reti
_int1_irq:	
	call _irq_info_int1
	reti
_intt5_irq:	
	call _irq_info_intt5
	reti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
_ser_putchar_irq:
	ld    a, 2(sp)

_ser_putchar_asm:
	
loop1:

	;; check tx active flag
	bit   TX_ACTIVE,(_ser_irq_flags)
	jr    z, send1

	di
	bit   0,(IRFH) ; check irq
	jr    nz, send1
	ei
	
	nop
	nop
	call  _wd_reset_asm
	jr    loop1 ; loop, wait for irq

send1:	
	di
	ld    (IRFH),#0x0F ; clear tx request flag (vector 0x78/8 = 0x0F)
	ld    (SCBUF),a ; send
	set   TX_ACTIVE,(_ser_irq_flags) ; tx active..
	ei
	ret
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
_ser_puts:
	ld hl, 2(sp)
	
ser_puts1:
	ld a,(hl)
	or a, a
	ret z
	
	call _ser_putchar_asm
	inc hl
	jr ser_puts1
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_WatchDogDisable:
	ld    (WDMOD), #0x00 	; wd disable code
	ld    (WDCR), #0xB1 	; wd disable code
	ret
	
_wd_reset_asm:
	ld    (WDCR), #0x4E 	; wd clear code

.if 0
	; STAR ASIC? Not needed..
	push  bc
	push  iy
	
	ld    b,(BY)
	ld    (BY), #0x01
	ld    iy, #0x4001		
	set   1,(iy)
	nop  
	nop  
	res   1,(iy)
	ld    (BY),b
	
	pop   iy
	pop   bc

.endif
	
	ret
	
	;; Ordering of segments for the linker.
	.area	_HOME
	.area	_CODE
	.area	_INITIALIZER
	.area   _GSINIT
	.area   _GSFINAL

	.area	_DATA
	.area	_INITIALIZED
	.area	_BSEG
	.area   _BSS
	.area   _HEAP

	.area   _CODE

	.area   _GSINIT
gsinit::
	ld	bc, #l__INITIALIZER
	ld	a, b
	or	a, c
	jr	Z, gsinit_next
	ld	de, #s__INITIALIZED
	ld	hl, #s__INITIALIZER
	ldir
gsinit_next:

	.area   _GSFINAL
	ret
	
	.area _DATA
; __sfr __at	
_ser_irq_flags	=	0xffbf
_ser_char	=	0xffbe
_swi_pc		=       0xffbc
_swi_af         =       0xffba
_ticks16	=	0xffb8
_xflag		=	0xffb7
	
P0	.equ 0x0ffc0
P1	.equ 0x0ffc1
P01CR	.equ 0x0ffc2
IRFL	.equ 0x0ffc2
IRFH	.equ 0x0ffc3
P2	.equ 0x0ffc4
P2CR	.equ 0x0ffc5
P3	.equ 0x0ffc6
P3CR	.equ 0x0ffc7
P4	.equ 0x0ffc8
P4CR	.equ 0x0ffc9
P5	.equ 0x0ffca
SMMOD	.equ 0x0ffcb
P6	.equ 0x0ffcc
P7	.equ 0x0ffcd
P67CR	.equ 0x0ffce
SMCR	.equ 0x0ffcf
P8	.equ 0x0ffd0
P8CR	.equ 0x0ffd1
WDMOD	.equ 0x0ffd2
WDCR	.equ 0x0ffd3
TREG0	.equ 0x0ffd4
TREG1	.equ 0x0ffd5
TREG2	.equ 0x0ffd6
TREG3	.equ 0x0ffd7
TCLK	.equ 0x0ffd8
TFFCR	.equ 0x0ffd9
TMOD	.equ 0x0ffda
TRUN	.equ 0x0ffdb
CAP1L	.equ 0x0ffdc
CAP1H	.equ 0x0ffdd
CAP2L	.equ 0x0ffde
CAL2H	.equ 0x0ffdf
TREG4L	.equ 0x0ffe0
TREG4H	.equ 0x0ffe1
TREG5L	.equ 0x0ffe2
TREG5H	.equ 0x0ffe3
T4MOD	.equ 0x0ffe4
T4FFCR	.equ 0x0ffe5
INTEL	.equ 0x0ffe6
INTEH	.equ 0x0ffe7
DMAEH	.equ 0x0ffe8
SCMOD	.equ 0x0ffe9
SCCR	.equ 0x0ffea
SCBUF	.equ 0x0ffeb
BX	.equ 0x0ffec
BY	.equ 0x0ffed
ADREG	.equ 0x0ffee
ADMOD	.equ 0x0ffef
;--------------------------------------------------------------------------
;  mulchar.s
;
;  Copyright (C) 2000, Michael Hope
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__mulint

__mulint:
	ld	bc, 2 (sp)
	ld	de, 4 (sp)

	;; 16-bit multiplication
	;;
	;; Entry conditions
	;; bc = multiplicand
	;; de = multiplier
	;;
	;; Exit conditions
	;; hl = less significant word of product
	;;
	;; Register used: AF,BC,DE,HL
__mul16::
	xor	a,a
	ld	l,a
	or	a,b
	ld	b,#16

        ;; Optimise for the case when this side has 8 bits of data or
        ;; less.  This is often the case with support address calls.
        jr      NZ,2$
        ld      b,#8
        ld      a,c
1$:
        ;; Taken from z88dk, which originally borrowed from the
        ;; Spectrum rom.
        add     hl,hl
2$:
        rl      c
        rla                     ;DLE 27/11/98
        jr      NC,3$
        add     hl,de
3$:
        djnz    1$
        ret

;; crt0_asm.s - tlcs90
	
	.t90
	
	.module crt0

;	.globl _meminit
	.globl _main
	;; .globl _xxaddr
	;; .globl _xxby
	;; .globl _xxdata

;	.globl _ser_putchar_irq
;	.globl _ser_puts
	
	;; put as abs in dat at end of file..
	;.globl _ser_irq_flags
	;.globl _ser_char
	
;	.globl _xget_byte_asm
;	.globl _xset_byte_asm


	 ;; for interrupts the pc and af are pushed on the stack
	
;	.globl _irq_info_swi
;	.globl _irq_info_intwd
;	.globl _irq_info_intt0
;	.globl _irq_info_intt1
;	.globl _timer1_irq
;	.globl _irq_info_intt3
;	.globl _irq_info_intt4
;	.globl _irq_info_int1
;	.globl _irq_info_intt5

	.globl _ticks16
	.globl _xflag
	
	;; NOTE: header might get trashed by linker when code loc ist not used!?
	.area	_HEADER (ABS)
	
	.org 	0

	.include "t90regs.s"

	;; _ser_irq_flags
TX_ACTIVE	.equ 0
RX_READY        .equ 1
	
L0:
	;halt
	;jr    L0
	jp    _astart
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop
L10:	
	; SWI
				;jp    _swi_irq
	nop
	nop
	nop
	
	nop  
	nop  
	nop  
	nop  
	nop  

L18:	
	nop  ; NMI
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  

L20:
	; INTWD
				;jp    _intwd_irq
	nop
	nop
	nop
	
	nop  
	nop  
	nop  
	nop  
	nop
L28:	
	reti ; INT0
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
L30:	
	; INTT0
				;jp    _intt0_irq
	nop
	nop
	nop
	
	nop  
	nop  
	nop  
	nop  
	nop
L38:	
	; INTT1
				;jp    _intt1_irq
	nop
	nop
	nop
	
	nop  
	nop  
	nop  
	nop  
	nop
L40:
	; INTAD 
	reti 
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop
L48:	
	; INTT3
				;jp    _intt3_irq
	nop
	nop
	nop
	
	nop  
	nop  
	nop  
	nop  
	nop
L50:	
	; INTT4
				;jp    _intt4_irq
	nop
	nop
	nop
	
	nop  
	nop  
	nop  
	nop  
	nop
L58:	
	; INT1
				;jp    _int1_irq
	nop
	nop
	nop
	
	nop  
	nop  
	nop  
	nop  
	nop
L60:	
	; INTT5
				;jp    _intt5_irq
	nop
	nop
	nop
	
	nop  
	nop  
	nop  
	nop  
	nop
L68:	
	reti ; INT2
	nop  
	nop  
	nop  
	nop  
	nop  
	nop  
	nop
L70:	
				;jp _serial_rx_irq
	nop
	nop
	nop
	
	nop  
	nop  
	nop  
	nop  
	nop
L78:	
				;jp _serial_tx_irq
	nop
	nop
	nop
	
	nop  
	nop  
	nop  
	nop  
	nop
L80:	
	nop  

	.org 0x100
	
_astart:
	ld    sp, #0x0FFA0	; stack
	
	;halt
	;swi
	
;	or    (P01CR), #0x04	;
	
;	ld    (P3), #0xF7	
;	ld    (P3CR), #0xA5	; P30 = RXD, P31 = IN:PaperOut CN3, P32 = TXD, P33 = OUT:CN2.LF P34:IN, P37:IN
	
;	ld    (P4), #0x00
;	ld    (P4CR), #0x03	; address output
;	ld    (P7), #0x03
;	ld    (P67CR), #0xF0
;	ld    (SMMOD), #0xA0
;	ld    (SMCR), #0x00
;	ld    (T4MOD), #0x35
;	ld    (P8), #0x08
;	ld    (P8CR), #0x08
;	ld    (T4FFCR), #0x01
	
;	ld    (TMOD), #0x40
	
	;ld    (SCMOD), #0x03	; 9600
;	ld    (SCMOD), #0x01	; 19200
;	or    (SCMOD), #0x08	; 8-bit data
;	or    (SCMOD), #0x20	; receiver enable

;	ld    (SCCR), #0x00
	
;	ld    (WDMOD), #0xC0
;	ld    (TRUN), #0x20	; PRRUN, start prescaler
;	or    (TRUN), #0xE0	; BRATE, 19200 baud

	;; enable rx/tx irqs
;	set   0,(INTEL)		; tx
;	set   1,(INTEL)		; rx

	;call _boot1
	
	ld    hl, #s__DATA	; data start
	ld    a, #0x00
	
clear_ram:
	call  _wd_reset_asm

	cp    hl, #0xFFC0	; io start, 160 bytes data
	jr    z, zeroed_data
	
	ld    (hl),a
	inc   hl

	jr	clear_ram
zeroed_data:

	call  _wd_reset_asm

;	res   TX_ACTIVE,(_ser_irq_flags)
	
	;call _boot2
;	call _meminit
	
	call  _wd_reset_asm
	
        ;; Initialise global variables

	;call _boot3
	
        call gsinit

	;call _boot4
	
	call _main
	halt
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	.area _CODE
	
	;; get far byte using by
	
;; _xget_byte_asm:
;; 	push bc
;; 	ld	iy, (_xxaddr)
;; 	ld	b, (BY)
;; 	ld	a, (_xxby)
;; 	ld	(BY), a
;; 	ld	a,(iy)
;; 	ld	(BY), b
;; 	ld	(_xxdata), a
;; 	pop	bc
;; 	ret

;; _xset_byte_asm:
;; 	push bc
;; 	ld	iy, (_xxaddr)
;; 	ld	b, (BY)
;; 	ld	a, (_xxby)
;; 	ld	(BY), a
;; 	ld 	a, (_xxdata)
;; 	ld	(iy), a
;; 	ld	(BY), b
;; 	pop	bc
;; 	ret
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; _serial_rx_irq:
;; 	ld a, (SCBUF)
;; 	ld (_ser_char), a
;; 	set RX_READY, (_ser_irq_flags)
;; 	reti 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
;; _serial_tx_irq:
;; 	res TX_ACTIVE,(_ser_irq_flags)
;; 	ld (IRFH), #0x0F ; clear tx request flag (vector 0x78/8 = 0x0F)
;; 	reti 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; _swi_irq:
;; 	push hl
;; 	ld hl, 4(sp)
;; 	ld (_swi_pc), hl	; pc
;; 	ld hl, 2(sp)
;; 	ld (_swi_af), hl	; af
;; 	call _irq_info_swi
;; 	pop hl
;; 	reti
;; _intwd_irq:	
;; 	call _irq_info_intwd
;; 	reti
;; _intt0_irq:	
;; 	call _irq_info_intt0
;; 	reti
;; _intt1_irq:	
;; 	;call _irq_info_intt1
;; 	;exx

;; 	; hangs when exx is used?
;; 	incw (_ticks16) 

;; 	; hangs when exx is used?
;; 	;; ld hl, (_ticks16)
;; 	;; inc hl
;; 	;; ld (_ticks16), hl
	
;; 	ld (WDCR), #0x4E
;; 	ld (IRFL), #0x10;
;; 	;call _timer1_irq
;; 	;exx
;; 	reti
;; _intt3_irq:	
;; 	call _irq_info_intt3
;; 	reti
;; _intt4_irq:	
;; 	call _irq_info_intt4
;; 	reti
;; _int1_irq:	
;; 	call _irq_info_int1
;; 	reti
;; _intt5_irq:	
;; 	call _irq_info_intt5
;; 	reti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
;; _ser_putchar_irq:
;; 	ld    a, 2(sp)

;; _ser_putchar_asm:
	
;; loop1:

;; 	;; check tx active flag
;; 	bit   TX_ACTIVE,(_ser_irq_flags)
;; 	jr    z, send1

;; 	di
;; 	bit   0,(IRFH) ; check irq
;; 	jr    nz, send1
;; 	ei
	
;; 	nop
;; 	nop
;; 	call  _wd_reset_asm
;; 	jr    loop1 ; loop, wait for irq

;; send1:	
;; 	di
;; 	ld    (IRFH),#0x0F ; clear tx request flag (vector 0x78/8 = 0x0F)
;; 	ld    (SCBUF),a ; send
;; 	set   TX_ACTIVE,(_ser_irq_flags) ; tx active..
;; 	ei
;; 	ret
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
;; _ser_puts:
;; 	ld hl, 2(sp)
	
;; ser_puts1:
;; 	ld a,(hl)
;; 	or a, a
;; 	ret z
	
;; 	call _ser_putchar_asm
;; 	inc hl
;; 	jr ser_puts1
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_WatchDogDisable:
	ld    (WDMOD), #0x00 	; wd disable code
	ld    (WDCR), #0xB1 	; wd disable code
	ret
	
_wd_reset_asm:
	ld    (WDCR), #0x4E 	; wd clear code

.if 0
	; STAR ASIC? Not needed..
	push  bc
	push  iy
	
	ld    b,(BY)
	ld    (BY), #0x01
	ld    iy, #0x4001		
	set   1,(iy)
	nop  
	nop  
	res   1,(iy)
	ld    (BY),b
	
	pop   iy
	pop   bc

.endif
	
	ret
	
	;; Ordering of segments for the linker.
	.area	_HOME
	.area	_CODE
	.area	_INITIALIZER
	.area   _GSINIT
	.area   _GSFINAL

	.area	_DATA
	.area	_INITIALIZED
	.area	_BSEG
	.area   _BSS
	.area   _HEAP

	.area   _CODE

	.area   _GSINIT
gsinit::
	ld	bc, #l__INITIALIZER
	ld	a, b
	or	a, c
	jr	Z, gsinit_next
	ld	de, #s__INITIALIZED
	ld	hl, #s__INITIALIZER
	ldir
gsinit_next:

	.area   _GSFINAL
	ret
	
	.area _DATA
; __sfr __at	
_ser_irq_flags	=	0xffbf
_ser_char	=	0xffbe
_swi_pc		=       0xffbc
_swi_af         =       0xffba
_ticks16	=	0xffb8
_xflag		=	0xffb7
	
;--------------------------------------------------------------------------
;  modsigned.s
;
;  Copyright (C) 2009, Philipp Klaus Krause
;
;  This library is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundation; either version 2, or (at your option) any
;  later version.
;
;  This library is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License 
;  along with this library; see the file COPYING. If not, write to the
;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
;
;  As a special exception, if you link this library with other files,
;  some of which are compiled with SDCC, to produce an executable,
;  this library does not by itself cause the resulting executable to
;  be covered by the GNU General Public License. This exception does
;  not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;--------------------------------------------------------------------------

.area   _CODE

.globl	__modschar
.globl	__modsint

__modschar:
        ld      hl,#2+1
        add     hl,sp

        ld      e,(hl)
        dec     hl
        ld      l,(hl)

        call    __div8

        jp	__get_remainder

__modsint:
        ld	hl, 2 (sp)
        ld	de, 4 (sp)

        call    __div16

        jp	__get_remainder

sdcc/device/lib/z80
-------------------

Z80 specific routines.

Notes:
* Cost of ld r,(ix+n):	19
* Cost of ld r,(hl); inc hl: 7+6 = 13 and you don't have to pop ix
        !<arch>
/               0           0     0     0       3462      `
    Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê  Ê               ,   ,   ,  "N  "N  #ò  #ò  %¬  %¬  %¬  'ò  'ò  (x  (x  (x  *Ñ  *Ñ  +å  +å  +å  ,–  ,–  =‹  =‹  ?Ù  ?Ù  B  B  GÜ  GÜ  Iú  Iú  K∞  Ré  Ré  Vt  Vt  Z^  Z^  `  `  b§  b§  e8  jx  àH  àH  £ú  ¿H  ƒ   …^  “é  ÿv  €ÿ  ‚d  Ë‘  Ë‘  ˛ò  ˛ò ÿ ÿ ‰ ‰ Ç Ç !" !" 0N 0N 2ƒ 2ƒ >t >t T8 T8 VN VN Z÷ Z÷ t0 t0 xú xú } } éÓ éÓ õ õ ¥í ∂¨ ∏» ∏» »ƒ »ƒ œÊ œÊ ÷Ï ÷Ï ⁄“ ‹p ﬂ~ ·† Î  Ù2 ˘t ˛  ˛  Ï ˆ ˆ !  ( ( 6* > > A D F@ IN K  OÃ RH VJ VJ Y  \Ï _h g, i$ k qÜ {ÿ {ÿ á4 á4 ôÚ ôÚ ° ° ©∞ ©∞ ™˙ Ø Ø ¥í ∑" ∫Ü Ω∏ Ω∏ ¿T ¿T ƒB …2 Õ^ œ‡ ”˙ ◊x €N ﬁ~ ‰¢ Íú Ó≤ Ú4 ˆ ¯~ ¯~ ˙p ˙p ˛‰ ˛‰ ˛‰ ˛‰ 	 	 º "ò 'Ä 3≤ =˛ C< J^ J^ V¥ V¥ `Ú `Ú e¥ g⁄ rD F Ö à* äJ å¿ èò èò íÑ íÑ ßp ßp © Û$ Û$ ı‰ ı‰ ˚h ˇB ˇB ˇB ˇB ˇB ˇB ˇB ˇB ˇB 2X 2X 2X ; ; C> D˙ D˙ D˙ I* I* I* L† Oº Q“ Wh.__.ABS. __divuint __moduschar __modsuchar __divuschar __divsuchar .modu16 .divu16 __modschar __moduchar __divschar __divuchar .mod16 .div16 .modu8 .divu8 .mod8 .div8 __modsint __moduint __divsint .__.ABS. __muluschar __mulsuchar __mulint __mulschar __muluchar .__.ABS. ___memcpy _memcpy .__.ABS. _abs .__.ABS. __initrleblock .__.ABS. ___sdcc_heap ___sdcc_heap_end .__.ABS. ___sdcc_call_hl .__.ABS. _longjmp ___setjmp .__.ABS. _atomic_flag_test_and_set .__.ABS. .strlen _strlen .__.ABS. _atof .__.ABS. ___schar2fs .__.ABS. ___sint2fs .__.ABS. ___slong2fs .__.ABS. ___uchar2fs .__.ABS. ___uint2fs ___ulong2fs .__.ABS. ___fs2schar .__.ABS. ___fs2sint .__.ABS. ___fs2slong .__.ABS. ___fs2uchar .__.ABS. ___fs2uint ___fs2ulong ___fsadd .__.ABS. ___fsdiv ___fsmul ___fssub ___fseq ___fslt ___fsneq _fabsf _frexpf _ldexpf .__.ABS. _expf .__.ABS. _powf .__.ABS. _sincosf .__.ABS. _sinf .__.ABS. _cosf .__.ABS. _logf .__.ABS. _log10f .__.ABS. _sqrtf .__.ABS. _tancotf .__.ABS. _tanf .__.ABS. _cotf .__.ABS. _asincosf .__.ABS. _asinf .__.ABS. _acosf .__.ABS. _atanf .__.ABS. _atan2f .__.ABS. _sincoshf _sinhf _coshf .__.ABS. _tanhf .__.ABS. _floorf .__.ABS. _ceilf .__.ABS. _modff _errno _isinf _isnan __divslong __modslong __modulong __divulong .__.ABS. __mullong __mullonglong .__.ABS. __divslonglong __divulonglong .__.ABS. __modslonglong __modulonglong .__.ABS. _isalnum _isalpha _isblank _iscntrl _isdigit _isgraph _islower _isprint .__.ABS. _ispunct _isspace _isupper _isxdigit _tolower _toupper _atoi _atol .__.ABS. _strtol .__.ABS. _strtoul .__.ABS. _bsearch .__.ABS. _qsort .__.ABS. _abs _labs _rand _srand _strcat _strchr _strcspn .__.ABS. _strdup .__.ABS. _strndup _strncat _strncmp _strxfrm _strncpy _strpbrk _strrchr _strspn _strstr _strtok _memccpy _memchr _memcmp _memset .__.ABS. _aligned_alloc .__.ABS. _calloc .__.ABS. ___sdcc_heap_init _malloc ___sdcc_heap_free .__.ABS. _realloc _free _mblen _mbtowc _wctomb _mbstowcs _wcstombs .__.ABS. _mbrtoc16 .__.ABS. _c16rtomb .__.ABS. _mbrtoc32 _c32rtomb ___mbstoc16s ___c16stombs _wcscmp _wcslen _btowc _wctob _mbsinit .__.ABS. _mbrlen .__.ABS. _mbrtowc .__.ABS. _wcrtomb __print_format .__.ABS. _puts .__.ABS. _gets ___assert ___month _RtcRead _asctime _time _localtime ___day _gmtime _mktime _ctime .__.ABS. ___itoa ___uitoa ___ultoa ___ltoa __sdcc_external_startup .__.ABS. _vsprintf _sprintf .__.ABS. _vprintf _printf _strcmp _strcpy _memmove _atomic_flag_clear //                                              224       `
__initrleblock.rel/
__sdcc_call_hl.rel/
atomic_flag_test_and_set.rel/
_mullonglong.rel/
_divslonglong.rel/
_divulonglong.rel/
_modslonglong.rel/
_modulonglong.rel/
aligned_alloc.rel/
printf_large.rel/
atomic_flag_clear.rel/
div.rel/        0           0     0     644     3301      `
XL3
H 1 areas 15 global symbols
S .__.ABS. Def000000
A _CODE size 13F flags 0 addr 0
S __divuint Def000097
S __moduschar Def00002D
S __modsuchar Def00000F
S __divuschar Def00001B
S __divsuchar Def000000
S .modu16 Def0000FE
S .divu16 Def0000FE
S __modschar Def00004B
S __moduchar Def00008B
S __divschar Def00003D
S __divuchar Def00007D
S .mod16 Def0000C5
S .div16 Def0000C5
S .modu8 Def0000FB
S .divu8 Def0000FB
S .mod8 Def0000BD
S .div8 Def0000BD
S __modsint Def00006B
S __moduint Def0000AB
S __divsint Def000057
T 00 00 00
R 00 00 00 00
T 00 00 00 21 03 00 39 5E 2B 4E 06 00 CD C1 00 59
R 00 00 00 00 00 0D 00 00
T 0D 00 00 50 C9
R 00 00 00 00
T 0F 00 00
R 00 00 00 00
T 0F 00 00 21 03 00 39 5E 2B 4E 06 00 C3 C1 00
R 00 00 00 00 00 0D 00 00
T 1B 00 00
R 00 00 00 00
T 1B 00 00 21 03 00 54 39 5E 2B 4E 79 07 9F 47 CD
R 00 00 00 00
T 28 00 00 C5 00 59 50 C9
R 00 00 00 00 00 03 00 00
T 2D 00 00
R 00 00 00 00
T 2D 00 00 21 03 00 54 39 5E 2B 4E 79 07 9F 47 CD
R 00 00 00 00
T 3A 00 00 C5 00 C9
R 00 00 00 00 00 03 00 00
T 3D 00 00
R 00 00 00 00
T 3D 00 00 21 03 00 39 5E 2B 6E 4D CD BD 00 59 50
R 00 00 00 00 00 0C 00 00
T 4A 00 00 C9
R 00 00 00 00
T 4B 00 00
R 00 00 00 00
T 4B 00 00 21 03 00 39 5E 2B 6E 4D CD BD 00 C9
R 00 00 00 00 00 0C 00 00
T 57 00 00
R 00 00 00 00
T 57 00 00 21 05 00 39 56 2B 5E 2B 7E 2B 6E 67 44
R 00 00 00 00
T 64 00 00 4D CD C5 00 59 50 C9
R 00 00 00 00 00 05 00 00
T 6B 00 00
R 00 00 00 00
T 6B 00 00 21 05 00 39 56 2B 5E 2B 7E 2B 6E 67 44
R 00 00 00 00
T 78 00 00 4D CD C5 00 C9
R 00 00 00 00 00 05 00 00
T 7D 00 00
R 00 00 00 00
T 7D 00 00 21 03 00 39 5E 2B 6E 4D CD FB 00 59 50
R 00 00 00 00 00 0C 00 00
T 8A 00 00 C9
R 00 00 00 00
T 8B 00 00
R 00 00 00 00
T 8B 00 00 21 03 00 39 5E 2B 6E 4D CD FB 00 C9
R 00 00 00 00 00 0C 00 00
T 97 00 00
R 00 00 00 00
T 97 00 00 21 05 00 39 56 2B 5E 2B 7E 2B 6E 67 44
R 00 00 00 00
T A4 00 00 4D CD FE 00 59 50 C9
R 00 00 00 00 00 05 00 00
T AB 00 00
R 00 00 00 00
T AB 00 00 21 05 00 39 56 2B 5E 2B 7E 2B 6E 67 44
R 00 00 00 00
T B8 00 00 4D CD FE 00 C9
R 00 00 00 00 00 05 00 00
T BD 00 00
R 00 00 00 00
T BD 00 00
R 00 00 00 00
T BD 00 00 79 07 9F 47
R 00 00 00 00
T C1 00 00
R 00 00 00 00
T C1 00 00 7B 07 9F 57
R 00 00 00 00
T C5 00 00
R 00 00 00 00
T C5 00 00
R 00 00 00 00
T C5 00 00 78 F5 AA F5 CB 7A 28 06 97 93 5F 9F 92
R 00 00 00 00
T D2 00 00 57
R 00 00 00 00
T D3 00 00
R 00 00 00 00
T D3 00 00 CB 78 28 06 97 91 4F 9F 90 47
R 00 00 00 00
T DD 00 00
R 00 00 00 00
T DD 00 00 CD FE 00 38 16 F1 E6 80 28 06 97 91 4F
R 00 00 00 00 00 04 00 00
T EA 00 00 9F 90 47
R 00 00 00 00
T ED 00 00
R 00 00 00 00
T ED 00 00 F1 E6 80 C8 97 93 5F 9F 92 57 C9
R 00 00 00 00
T F8 00 00
R 00 00 00 00
T F8 00 00 F1 F1 C9
R 00 00 00 00
T FB 00 00
R 00 00 00 00
T FB 00 00
R 00 00 00 00
T FB 00 00 06 00 50
R 00 00 00 00
T FE 00 00
R 00 00 00 00
T FE 00 00
R 00 00 00 00
T FE 00 00 7B B2 20 07 01 00 00 50 59 37 C9
R 00 00 00 00
T 09 01 00
R 00 00 00 00
T 09 01 00 69 60 01 00 00 B7 3E 10
R 00 00 00 00
T 11 01 00
R 00 00 00 00
T 11 01 00 F5 CB 15 CB 14 CB 11 CB 10 C5 79 9B 4F
R 00 00 00 00
T 1E 01 00 78 9A 47 3F 38 08 C1 F1 3D B7 20 E7 18
R 00 00 00 00
T 2B 01 00 09
R 00 00 00 00
T 2C 01 00
R 00 00 00 00
T 2C 01 00 33 33 F1 3D 37 20 DE 18 00
R 00 00 00 00
T 35 01 00
R 00 00 00 00
T 35 01 00 50 59 CB 15 4D CB 14 44 B7 C9
R 00 00 00 00

mul.rel/        0           0     0     644     1000      `
XL3
H 1 areas 6 global symbols
S .__.ABS. Def000000
A _CODE size 5D flags 0 addr 0
S __muluschar Def00000A
S __mulsuchar Def000000
S __mulint Def000034
S __mulschar Def000014
S __muluchar Def000027
T 00 00 00
R 00 00 00 00
T 00 00 00 21 03 00 44 39 5E 2B 4E 18 16
R 00 00 00 00
T 0A 00 00
R 00 00 00 00
T 0A 00 00 21 02 00 44 39 5E 23 4E 18 0C
R 00 00 00 00
T 14 00 00
R 00 00 00 00
T 14 00 00 21 02 00 39 5E 23 6E 4D 7D 17 9F 47
R 00 00 00 00
T 20 00 00
R 00 00 00 00
T 20 00 00 7B 17 9F 57 C3 42 00
R 00 00 00 00 00 08 00 00
T 27 00 00
R 00 00 00 00
T 27 00 00 21 02 00 39 5E 23 4E AF 57 47 C3 42 00
R 00 00 00 00 00 0E 00 00
T 34 00 00
R 00 00 00 00
T 34 00 00 21 02 00 39 5E 23 56 23 7E 23 66 6F 44
R 00 00 00 00
T 41 00 00 4D
R 00 00 00 00
T 42 00 00
R 00 00 00 00
T 42 00 00 21 00 00 78 06 10 B7 C2 4F 00 06 08 79
R 00 00 00 00 00 0B 00 00
T 4F 00 00
R 00 00 00 00
T 4F 00 00 29 CB 11 17 D2 57 00 19
R 00 00 00 00 00 08 00 00
T 57 00 00
R 00 00 00 00
T 57 00 00 05 20 F5 5D 54 C9
R 00 00 00 00
memcpy.rel/     0           0     0     644     486       `
XL3
H 1 areas 3 global symbols
S .__.ABS. Def000000
A _CODE size 25 flags 0 addr 0
S ___memcpy Def000000
S _memcpy Def000000
T 00 00 00
R 00 00 00 00
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 07 3A 57 3A 5F B2 28 16 C5 3A 47 3A
R 00 00 00 00
T 0D 00 00 4F 3A 6E 67 14 1C 18 03
R 00 00 00 00
T 15 00 00
R 00 00 00 00
T 15 00 00 0A 03 22
R 00 00 00 00
T 18 00 00
R 00 00 00 00
T 18 00 00 1D 20 FA 15 20 F7 C1
R 00 00 00 00
T 1F 00 00
R 00 00 00 00
T 1F 00 00 F8 02 5E 23 56 C9
R 00 00 00 00
abs.rel/        0           0     0     644     269       `
XL3
H 1 areas 2 global symbols
S .__.ABS. Def000000
A _CODE size F flags 0 addr 0
S _abs Def000000
T 00 00 00
R 00 00 00 00
T 00 00 00 E1 D1 D5 CB 7A 28 07 7B 2F 5F 7A 2F 57
R 00 00 00 00
T 0D 00 00 13
R 00 00 00 00
T 0E 00 00
R 00 00 00 00
T 0E 00 00 E9
R 00 00 00 00

/0              0           0     0     644     494       `
XL3
H 1 areas 2 global symbols
S .__.ABS. Def000000
A _CODE size 1C flags 0 addr 0
S __initrleblock Def000000
T 00 00 00
R 00 00 00 00
T 00 00 00 E1
R 00 00 00 00
T 01 00 00
R 00 00 00 00
T 01 00 00 4E 23 CB 79 28 08 2A
R 00 00 00 00
T 08 00 00
R 00 00 00 00
T 08 00 00 12 13 0C 20 FB 18 F2
R 00 00 00 00
T 0F 00 00
R 00 00 00 00
T 0F 00 00 0C 0D 28 08
R 00 00 00 00
T 13 00 00
R 00 00 00 00
T 13 00 00 2A 12 13 0D 20 FA 18 E6
R 00 00 00 00
T 1B 00 00
R 00 00 00 00
T 1B 00 00 E9
R 00 00 00 00
heap.rel/       0           0     0     644     410       `
XL3
H 4 areas 4 global symbols
S ___sdcc_heap_init Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _GSINIT size 3 flags 0 addr 0
A _HEAP size 3FF flags 0 addr 0
S ___sdcc_heap Def000000
A _HEAP_END size 1 flags 0 addr 0
S ___sdcc_heap_end Def000000
T 00 00 00 CD 00 00
R 00 00 01 00 02 04 00 00
T 00 00 00
R 00 00 02 00
T 00 00 00
R 00 00 02 00
T 00 00 00
R 00 00 03 00
T 00 00 00
R 00 00 03 00
/20             0           0     0     644     163       `
XL3
H 1 areas 2 global symbols
S .__.ABS. Def000000
A _CODE size 1 flags 0 addr 0
S ___sdcc_call_hl Def000000
T 00 00 00
R 00 00 00 00
T 00 00 00 E9
R 00 00 00 00

setjmp.rel/     0           0     0     644     464       `
XL3
H 1 areas 3 global symbols
S .__.ABS. Def000000
A _CODE size 2E flags 0 addr 0
S _longjmp Def000015
S ___setjmp Def000000
T 00 00 00
R 00 00 00 00
T 00 00 00 C1 D1 D5 C5 F8 00 D5 E5 D1 E1 73 23 72
R 00 00 00 00
T 0D 00 00 23 71 23 70 AF 5F 57 C9
R 00 00 00 00
T 15 00 00
R 00 00 00 00
T 15 00 00 F1 E1 D1 7B B2 20 01 13
R 00 00 00 00
T 1D 00 00
R 00 00 00 00
T 1D 00 00 4E 23 46 23 E5 C5 E1 C1 F9 C5 E1 4E 23
R 00 00 00 00
T 2A 00 00 46 F1 C5 C9
R 00 00 00 00
/40             0           0     0     644     203       `
XL3
H 1 areas 2 global symbols
S .__.ABS. Def000000
A _CODE size B flags 0 addr 0
S _atomic_flag_test_and_set Def000000
T 00 00 00
R 00 00 00 00
T 00 00 00 D1 E1 E5 D5 AF CB 3E 3F 17 5F C9
R 00 00 00 00

strlen.rel/     0           0     0     644     264       `
XL3
H 1 areas 3 global symbols
S .__.ABS. Def000000
A _CODE size E flags 0 addr 0
S .strlen Def000005
S _strlen Def000000
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 2A 66 6F
R 00 00 00 00
T 05 00 00
R 00 00 00 00
T 05 00 00 11 00 00 2A B7 C8 13 18 FA
R 00 00 00 00
_atof.rel/      0           0     0     644     4303      `
XL3
H 7 areas 8 global symbols
M _atof
O -mgbz80
S ___fsmul Ref000000
S _isspace Ref000000
S _atoi Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S ___sint2fs Ref000000
S _toupper Ref000000
A _CODE size 27C flags 0 addr 0
S _atof Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 EF F8 13 2A 5F 56
R 00 00 00 00
T 07 00 00
R 00 00 00 00
T 07 00 00 1A 4F 06 00 D5 C5 CD 00 00 E8 02 E5 F8
R 00 00 00 00 02 0A 01 00
T 14 00 00 13 73 F8 14 72 E1 D1 4B 42 03 F8 10 3A
R 00 00 00 00
T 21 00 00 B6 28 04 59 50 18 DF
R 00 00 00 00
T 28 00 00
R 00 00 00 00
T 28 00 00 F8 13 7B 22 72 1A 5F D6 2D 20 0B F8 04
R 00 00 00 00
T 35 00 00 36 01 F8 13 79 22 70 18 0E
R 00 00 00 00
T 3E 00 00
R 00 00 00 00
T 3E 00 00 AF F8 04 77 7B D6 2B 20 05 F8 13 79 22
R 00 00 00 00
T 4B 00 00 70
R 00 00 00 00
T 4C 00 00
R 00 00 00 00
T 4C 00 00 AF F8 0B 22 22 22 77 F8 13 2A 5F 56
R 00 00 00 00
T 58 00 00
R 00 00 00 00
T 58 00 00 1A F8 10 77 6E 4B 42 03 7D D6 30 DA
R 00 00 00 00
T 64 00 00 04 01 3E 39 95 DA 04 01 C5 F8 0F 2A 66
R 00 00 00 00 00 03 00 00 00 09 00 00
T 71 00 00 6F E5 F8 0F 2A 66 6F E5 21 20 41 E5 21
R 00 00 00 00
T 7E 00 00 00 00 E5 CD 00 00 E8 08 E5 F8 10 73 F8
R 00 00 00 00 02 07 00 00
T 8B 00 00 11 72 E1 E5 7D F8 12 77 E1 7C F8 11 77
R 00 00 00 00
T 98 00 00 C1 F8 10 7E 16 00 C6 D0 5F 7A CE FF 57
R 00 00 00 00
T A5 00 00 C5 D5 CD 00 00 E8 02 E5 F8 0C 73 F8 0D
R 00 00 00 00 02 06 05 00
T B2 00 00 72 E1 E5 7D F8 0E 77 E1 7C F8 0D 77 F8
R 00 00 00 00
T BF 00 00 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 F8 14
R 00 00 00 00
T CC 00 00 2A 66 6F E5 F8 14 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 04 00
T D9 00 00 E8 08 E5 F8 0A 73 F8 0B 72 E1 E5 7D F8
R 00 00 00 00
T E6 00 00 0C 77 E1 7C F8 0B 77 C1 F8 06 54 5D F8
R 00 00 00 00
T F3 00 00 0B 1A 22 13 1A 22 13 1A 22 13 1A 77 59
R 00 00 00 00
T 00 01 00 50 C3 58 00
R 00 00 00 00 00 05 00 00
T 04 01 00
R 00 00 00 00
T 04 01 00 F8 13 7B 22 72 F8 10 7E D6 2E C2 CE 01
R 00 00 00 00 00 0E 00 00
T 11 01 00 F8 05 3E CD 22 3E CC 22 22 36 3D F8 0F
R 00 00 00 00
T 1E 01 00 79 22 70
R 00 00 00 00
T 21 01 00
R 00 00 00 00
T 21 01 00 F8 0F 2A 5F 56 1A F8 09 77 2A 77 D6 30
R 00 00 00 00
T 2E 01 00 DA C6 01 3E 39 96 DA C6 01 2B 4E 06 00
R 00 00 00 00 00 04 00 00 00 0A 00 00
T 3B 01 00 11 30 00 79 93 5F 78 9A 23 32 73 2A 66
R 00 00 00 00
T 48 01 00 6F E5 CD 00 00 E8 02 33 33 D5 E5 7D F8
R 00 00 00 00 02 06 05 00
T 55 01 00 04 77 E1 7C F8 03 77 F8 07 2A 66 6F E5
R 00 00 00 00
T 62 01 00 F8 07 2A 66 6F E5 F8 06 2A 66 6F E5 F8
R 00 00 00 00
T 6F 01 00 06 2A 66 6F E5 CD 00 00 E8 08 E5 D5 F8
R 00 00 00 00 02 09 00 00
T 7C 01 00 11 2A 66 6F E5 F8 11 2A 66 6F E5 CD
R 00 00 00 00
T 88 01 00 00 00 E8 08 4D 44 F8 0B 7B 22 7A 22 79
R 00 00 00 00 02 03 04 00
T 95 01 00 22 70 F8 07 2A 66 6F E5 F8 07 2A 66 6F
R 00 00 00 00
T A2 01 00 E5 21 CC 3D E5 21 CD CC E5 CD 00 00 E8
R 00 00 00 00 02 0D 00 00
T AF 01 00 08 4D 44 F8 05 7B 22 7A 22 79 22 70 F8
R 00 00 00 00
T BC 01 00 0F 34 C2 21 01 23 34 C3 21 01
R 00 00 00 00 00 06 00 00 00 0B 00 00
T C6 01 00
R 00 00 00 00
T C6 01 00 F8 0F 2A 5E F8 13 22 73
R 00 00 00 00
T CE 01 00
R 00 00 00 00
T CE 01 00 F8 13 2A 5E F8 0F 22 7B 32 2A 5F 56 1A
R 00 00 00 00
T DB 01 00 4F 06 00 C5 CD 00 00 E8 02 7B D6 45 B2
R 00 00 00 00 02 08 06 00
T E8 01 00 20 7A F8 0F 2A 5F 56 6B 62 23 E5 7D F8
R 00 00 00 00
T F5 01 00 15 77 E1 7C F8 14 32 2A 66 6F E5 CD
R 00 00 00 00
T 01 02 00 00 00 E8 02 F8 10 73
R 00 00 00 00 02 03 02 00
T 08 02 00
R 00 00 00 00
T 08 02 00 F8 10 7E B7 28 56 CB 7E 28 29 F8 0D 2A
R 00 00 00 00
T 15 02 00 66 6F E5 F8 0D 2A 66 6F E5 21 CC 3D E5
R 00 00 00 00
T 22 02 00 21 CD CC E5 CD 00 00 E8 08 4D 44 F8 0B
R 00 00 00 00 02 08 00 00
T 2F 02 00 7B 22 7A 22 79 22 78 22 23 34 18 CD
R 00 00 00 00
T 3B 02 00
R 00 00 00 00
T 3B 02 00 F8 0D 2A 66 6F E5 F8 0D 2A 66 6F E5 21
R 00 00 00 00
T 48 02 00 20 41 E5 21 00 00 E5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 00 00
T 55 02 00 44 F8 0B 7B 22 7A 22 79 22 78 22 23 35
R 00 00 00 00
T 62 02 00 18 A4
R 00 00 00 00
T 64 02 00
R 00 00 00 00
T 64 02 00 F8 04 CB 46 28 06 F8 0E 7E EE 80 77
R 00 00 00 00
T 70 02 00
R 00 00 00 00
T 70 02 00 F8 0B 2A 5F 2A 57 2A 66 6F E8 11 C9
R 00 00 00 00

_schar2fs.rel/  0           0     0     644     476       `
XL3
H 7 areas 3 global symbols
M _schar2fs
O -mgbz80
S ___slong2fs Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 11 flags 0 addr 0
S ___schar2fs Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 F8 02 7E 4F 17 9F 47 5F 57 D5 C5 CD
R 00 00 03 00
T 0C 00 00 00 00 E8 04 C9
R 00 00 03 00 02 03 00 00
_sint2fs.rel/   0           0     0     644     477       `
XL3
H 7 areas 3 global symbols
M _sint2fs
O -mgbz80
S ___slong2fs Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 12 flags 0 addr 0
S ___sint2fs Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 F8 02 2A 4F 7E 47 17 9F 5F 57 D5 C5 CD
R 00 00 03 00
T 0D 00 00 00 00 E8 04 C9
R 00 00 03 00 02 03 00 00

_slong2fs.rel/  0           0     0     644     1339      `
XL3
H 7 areas 3 global symbols
M _slong2fs
O -mgbz80
S ___ulong2fs Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 9F flags 0 addr 0
S ___slong2fs Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F8 F8 0A 7E D6 00 23 7E DE 00 23 7E
R 00 00 03 00
T 0D 00 00 DE 00 23 7E DE 00 56 3E 00 CB 7F 28 07
R 00 00 03 00
T 1A 00 00 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 21 00 00
R 00 00 03 00
T 21 00 00 CB 7A 28 01 37
R 00 00 03 00
T 26 00 00
R 00 00 03 00
T 26 00 00 30 63 11 00 00 7B F8 0A 96 5F 7A 23 9E
R 00 00 03 00
T 33 00 00 F5 F8 07 32 73 11 00 00 F8 0E F1 7B 9E
R 00 00 03 00
T 40 00 00 5F 7A 23 9E F8 07 32 73 2A 66 6F E5 F8
R 00 00 03 00
T 4D 00 00 06 2A 66 6F E5 CD 00 00 E8 04 33 33 D5
R 00 00 03 00 02 09 00 00
T 5A 00 00 E5 7D F8 04 77 E1 7C F8 03 77 F8 03 7E
R 00 00 03 00
T 67 00 00 EE 80 F8 07 77 E5 F8 02 7E F8 06 77 F8
R 00 00 03 00
T 74 00 00 03 7E F8 07 77 F8 04 7E F8 08 77 E1 F8
R 00 00 03 00
T 81 00 00 04 2A 5F 2A 57 2A 66 6F 18 11
R 00 00 03 00
T 8B 00 00
R 00 00 03 00
T 8B 00 00 F8 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 CD
R 00 00 03 00
T 98 00 00 00 00 E8 04
R 00 00 03 00 02 03 00 00
T 9C 00 00
R 00 00 03 00
T 9C 00 00 E8 08 C9
R 00 00 03 00

_uchar2fs.rel/  0           0     0     644     473       `
XL3
H 7 areas 3 global symbols
M _uchar2fs
O -mgbz80
S ___ulong2fs Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 10 flags 0 addr 0
S ___uchar2fs Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 F8 02 4E 06 00 11 00 00 D5 C5 CD 00 00
R 00 00 03 00 02 0E 00 00
T 0D 00 00 E8 04 C9
R 00 00 03 00

_uint2fs.rel/   0           0     0     644     471       `
XL3
H 7 areas 3 global symbols
M _uint2fs
O -mgbz80
S ___ulong2fs Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 10 flags 0 addr 0
S ___uint2fs Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 F8 02 2A 4F 46 11 00 00 D5 C5 CD 00 00
R 00 00 03 00 02 0E 00 00
T 0D 00 00 E8 04 C9
R 00 00 03 00

_ulong2fs.rel/  0           0     0     644     1697      `
XL3
H 7 areas 2 global symbols
M _ulong2fs
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size CF flags 0 addr 0
S ___ulong2fs Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F6 F8 0F 3A B6 2B B6 2B B6 20 09 11
R 00 00 03 00
T 0D 00 00 00 00 21 00 00 C3 CC 00
R 00 00 03 00 00 09 03 00
T 15 00 00
R 00 00 03 00
T 15 00 00 0E 96
R 00 00 03 00
T 17 00 00
R 00 00 03 00
T 17 00 00 F8 0C 7E D6 00 23 7E DE 00 23 7E DE 80
R 00 00 03 00
T 24 00 00 23 7E DE 00 30 10 F8 0C CB 26 23 CB 16
R 00 00 03 00
T 31 00 00 23 CB 16 23 CB 16 0D 18 DD
R 00 00 03 00
T 3A 00 00
R 00 00 03 00
T 3A 00 00
R 00 00 03 00
T 3A 00 00 F8 0F 7E B7 28 34 F8 0C CB 46 28 1E F8
R 00 00 03 00
T 47 00 00 0C 2A 5F 56 7B C6 02 5F 7A CE 00 F5 32
R 00 00 03 00
T 54 00 00 73 F8 10 2A 5F 56 F1 7B CE 00 5F 7A CE
R 00 00 03 00
T 61 00 00 00 32 73
R 00 00 03 00
T 64 00 00
R 00 00 03 00
T 64 00 00 F8 0F CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 71 00 00 0C 18 C6
R 00 00 03 00
T 74 00 00
R 00 00 03 00
T 74 00 00 F8 0E 7E E6 7F 77 F8 00 7D 54 F8 04 22
R 00 00 03 00
T 81 00 00 72 06 00 11 00 00 3E 07
R 00 00 03 00
T 89 00 00
R 00 00 03 00
T 89 00 00 CB 21 CB 10 3D 20 F9 7B F8 0C B6 F8 06
R 00 00 03 00
T 96 00 00 77 7A F8 0D B6 F8 07 77 79 F8 0E B6 F8
R 00 00 03 00
T A3 00 00 08 77 78 F8 0F B6 F8 09 77 F8 04 2A 5F
R 00 00 03 00
T B0 00 00 2A 57 7E 12 13 23 7E 12 13 23 7E 12 13
R 00 00 03 00
T BD 00 00 23 7E 12 F8 00 2A 4F 2A 47 23 3A 6E 67
R 00 00 03 00
T CA 00 00 59 50
R 00 00 03 00
T CC 00 00
R 00 00 03 00
T CC 00 00 E8 0A C9
R 00 00 03 00

_fs2schar.rel/  0           0     0     644     937       `
XL3
H 7 areas 3 global symbols
M _fs2schar
O -mgbz80
S ___fs2slong Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 4F flags 0 addr 0
S ___fs2schar Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 F8 04 2A 66 6F E5 F8 04 2A 66 6F E5 CD
R 00 00 03 00
T 0D 00 00 00 00 E8 04 4D 44 6B 62 7D D6 7F 7C DE
R 00 00 03 00 02 03 00 00
T 1A 00 00 00 79 DE 00 78 17 3F 1F DE 80 38 03 1E
R 00 00 03 00
T 27 00 00 7F C9
R 00 00 03 00
T 29 00 00
R 00 00 03 00
T 29 00 00 58 16 FF 3E 80 BD 3E FF 9C 3E FF 99 3E
R 00 00 03 00
T 36 00 00 FF 98 CB 7B 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 43 00 00
R 00 00 03 00
T 43 00 00 CB 7A 28 01 37
R 00 00 03 00
T 48 00 00
R 00 00 03 00
T 48 00 00 38 03 1E 80 C9
R 00 00 03 00
T 4D 00 00
R 00 00 03 00
T 4D 00 00 5D C9
R 00 00 03 00

_fs2sint.rel/   0           0     0     644     941       `
XL3
H 7 areas 3 global symbols
M _fs2sint
O -mgbz80
S ___fs2slong Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 51 flags 0 addr 0
S ___fs2sint Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 F8 04 2A 66 6F E5 F8 04 2A 66 6F E5 CD
R 00 00 03 00
T 0D 00 00 00 00 E8 04 4D 44 6B 62 7D D6 FF 7C DE
R 00 00 03 00 02 03 00 00
T 1A 00 00 7F 79 DE 00 78 17 3F 1F DE 80 38 04 11
R 00 00 03 00
T 27 00 00 FF 7F C9
R 00 00 03 00
T 2A 00 00
R 00 00 03 00
T 2A 00 00 58 16 FF AF BD 3E 80 9C 3E FF 99 3E FF
R 00 00 03 00
T 37 00 00 98 CB 7B 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 43 00 00
R 00 00 03 00
T 43 00 00 CB 7A 28 01 37
R 00 00 03 00
T 48 00 00
R 00 00 03 00
T 48 00 00 38 04 11 00 80 C9
R 00 00 03 00
T 4E 00 00
R 00 00 03 00
T 4E 00 00 5D 54 C9
R 00 00 03 00

_fs2slong.rel/  0           0     0     644     1403      `
XL3
H 7 areas 4 global symbols
M _fs2slong
O -mgbz80
S ___fs2ulong Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size AE flags 0 addr 0
S ___fs2slong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F8 F8 0D 7E CB BF 2B B6 2B B6 2B B6
R 00 00 03 00
T 0D 00 00 20 09 11 00 00 21 00 00 C3 AB 00
R 00 00 03 00 00 0C 03 00
T 18 00 00
R 00 00 03 00
T 18 00 00 21 00 00 E5 21 00 00 E5 F8 10 2A 66 6F
R 00 00 03 00
T 25 00 00 E5 F8 10 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 03 00 02 0B 01 00
T 32 00 00 B7 28 65 F8 0D 7E EE 80 F8 07 77 E5 F8
R 00 00 03 00
T 3F 00 00 0C 7E F8 06 77 F8 0D 7E F8 07 77 F8 0E
R 00 00 03 00
T 4C 00 00 7E F8 08 77 E1 F8 06 2A 66 6F E5 F8 06
R 00 00 03 00
T 59 00 00 2A 66 6F E5 CD 00 00 E8 04 33 33 D5 E5
R 00 00 03 00 02 08 00 00
T 66 00 00 7D F8 04 77 E1 7C F8 03 77 11 00 00 7B
R 00 00 03 00
T 73 00 00 F8 00 96 5F 7A 23 9E F5 F8 07 32 73 11
R 00 00 03 00
T 80 00 00 00 00 2B 2B F1 7B 9E 5F 7A 23 9E F8 07
R 00 00 03 00
T 8D 00 00 32 7B 32 2B 2A 5F 2A 57 2A 66 6F 18 11
R 00 00 03 00
T 9A 00 00
R 00 00 03 00
T 9A 00 00 F8 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 CD
R 00 00 03 00
T A7 00 00 00 00 E8 04
R 00 00 03 00 02 03 00 00
T AB 00 00
R 00 00 03 00
T AB 00 00 E8 08 C9
R 00 00 03 00

_fs2uchar.rel/  0           0     0     644     593       `
XL3
H 7 areas 3 global symbols
M _fs2uchar
O -mgbz80
S ___fs2ulong Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 1F flags 0 addr 0
S ___fs2uchar Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 F8 04 2A 66 6F E5 F8 04 2A 66 6F E5 CD
R 00 00 03 00
T 0D 00 00 00 00 E8 04 4D 44 7A B1 B0 20 04 7B FE
R 00 00 03 00 02 03 00 00
T 1A 00 00 FF D8
R 00 00 03 00
T 1C 00 00
R 00 00 03 00
T 1C 00 00 1E FF C9
R 00 00 03 00

_fs2uint.rel/   0           0     0     644     600       `
XL3
H 7 areas 3 global symbols
M _fs2uint
O -mgbz80
S ___fs2ulong Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 22 flags 0 addr 0
S ___fs2uint Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 F8 04 2A 66 6F E5 F8 04 2A 66 6F E5 CD
R 00 00 03 00
T 0D 00 00 00 00 E8 04 4D 44 79 B0 20 07 7B D6 FF
R 00 00 03 00 02 03 00 00
T 1A 00 00 7A DE FF D8
R 00 00 03 00
T 1E 00 00
R 00 00 03 00
T 1E 00 00 11 FF FF C9
R 00 00 03 00
_fs2ulong.rel/  0           0     0     644     1283      `
XL3
H 7 areas 2 global symbols
M _fs2ulong
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 94 flags 0 addr 0
S ___fs2ulong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F6 F8 00 4D 44 F8 0C 2A 02 03 2A 02
R 00 00 03 00
T 0D 00 00 03 2A 02 03 7E 02 F8 00 2A 4F 2A 47 23
R 00 00 03 00
T 1A 00 00 3A 6E B5 B0 B1 28 0A F8 00 2A 2A 23 3A
R 00 00 03 00
T 27 00 00 6E 07 30 08
R 00 00 03 00
T 2B 00 00
R 00 00 03 00
T 2B 00 00 11 00 00 21 00 00 18 5E
R 00 00 03 00
T 33 00 00
R 00 00 03 00
T 33 00 00 F8 00 2A 4F 2A 47 23 3A 6E 67 3E 17
R 00 00 03 00
T 3F 00 00
R 00 00 03 00
T 3F 00 00 CB 3C CB 1D CB 18 CB 19 3D 20 F5 06 00
R 00 00 03 00
T 4C 00 00 11 96 00 79 93 5F 78 9A F8 05 32 73 F8
R 00 00 03 00
T 59 00 00 00 2A 4F 2A 47 23 3A 7E CB BF 1E 00 F8
R 00 00 03 00
T 66 00 00 06 71 23 70 F6 80 23 22 73 F8 04 4E AF
R 00 00 03 00
T 73 00 00 91 4F 0C 18 0D
R 00 00 03 00
T 78 00 00
R 00 00 03 00
T 78 00 00 F8 09 CB 2E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 85 00 00
R 00 00 03 00
T 85 00 00 0D 20 F0 F8 06 2A 5F 2A 57 2A 66 6F
R 00 00 03 00
T 91 00 00
R 00 00 03 00
T 91 00 00 E8 0A C9
R 00 00 03 00

_fsadd.rel/     0           0     0     644     7571      `
XL3
H 7 areas 2 global symbols
M _fsadd
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 466 flags 0 addr 0
S ___fsadd Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 EA F8 1C 7D 54 F8 14 22 7A 32 2A 5F
R 00 00 03 00
T 0D 00 00 56 1A F8 08 22 13 1A 22 13 1A 22 13 1A
R 00 00 03 00
T 1A 00 00 77 F8 08 54 5D F8 12 1A 22 13 1A 22 13
R 00 00 03 00
T 27 00 00 1A 22 13 1A 77 F8 14 2A 4F 46 3E 07
R 00 00 03 00
T 33 00 00
R 00 00 03 00
T 33 00 00 CB 38 CB 19 3D 20 F9 F8 00 71 AF 23 77
R 00 00 03 00
T 40 00 00 F8 08 2A 4E 23 5E CB BB 16 00 CB FB 23
R 00 00 03 00
T 4D 00 00 23 22 79 22 7B 22 72 3E 04
R 00 00 03 00
T 56 00 00
R 00 00 03 00
T 56 00 00 F8 0C CB 26 23 CB 16 23 CB 16 23 CB 16
R 00 00 03 00
T 63 00 00 3D 20 F0 F8 15 7E 07 30 1C 11 00 00 7B
R 00 00 03 00
T 70 00 00 F8 0C 96 5F 7A 23 9E F5 32 73 11 00 00
R 00 00 03 00
T 7D 00 00 23 23 F1 7B 9E 5F 7A 23 9E 32 73
R 00 00 03 00
T 88 00 00
R 00 00 03 00
T 88 00 00 F8 0B 3A B6 2B B6 2B B6 20 0C F8 18 2A
R 00 00 03 00
T 95 00 00 5F 2A 57 2A 66 6F C3 63 04
R 00 00 03 00 00 0A 03 00
T 9E 00 00
R 00 00 03 00
T 9E 00 00 F8 18 4D 44 F8 02 79 22 78 32 2A 5F 56
R 00 00 03 00
T AB 00 00 1A 23 22 13 1A 22 13 1A 22 13 1A 77 F8
R 00 00 03 00
T B8 00 00 04 54 5D F8 08 1A 22 13 1A 22 13 1A 22
R 00 00 03 00
T C5 00 00 13 1A 77 F8 0A 2A 4F 46 3E 07
R 00 00 03 00
T CF 00 00
R 00 00 03 00
T CF 00 00 CB 38 CB 19 3D 20 F9 F8 10 71 AF 23 77
R 00 00 03 00
T DC 00 00 F8 04 2A 4E 23 5E CB BB 16 00 CB FB F8
R 00 00 03 00
T E9 00 00 12 22 79 22 7B 22 72 3E 04
R 00 00 03 00
T F2 00 00
R 00 00 03 00
T F2 00 00 F8 12 CB 26 23 CB 16 23 CB 16 23 CB 16
R 00 00 03 00
T FF 00 00 3D 20 F0 F8 0B 7E 07 30 22 F8 07 CB 7E
R 00 00 03 00
T 0C 01 00 28 1C 11 00 00 7B F8 12 96 5F 7A 23 9E
R 00 00 03 00
T 19 01 00 F5 32 73 11 00 00 23 23 F1 7B 9E 5F 7A
R 00 00 03 00
T 26 01 00 23 9E 32 73
R 00 00 03 00
T 2A 01 00
R 00 00 03 00
T 2A 01 00 F8 07 3A B6 2B B6 2B B6 20 0C F8 1C 2A
R 00 00 03 00
T 37 01 00 5F 2A 57 2A 66 6F C3 63 04
R 00 00 03 00 00 0A 03 00
T 40 01 00
R 00 00 03 00
T 40 01 00 F8 10 2A 5F 56 E1 E5 7B 95 5F 7A 9C F8
R 00 00 03 00
T 4D 01 00 0B 32 73 3E 19 96 23 3E 00 9E 3E 00 57
R 00 00 03 00
T 5A 01 00 CB 7E 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 65 01 00
R 00 00 03 00
T 65 01 00 CB 7A 28 01 37
R 00 00 03 00
T 6A 01 00
R 00 00 03 00
T 6A 01 00 30 0C F8 18 2A 5F 2A 57 2A 66 6F C3
R 00 00 03 00
T 76 01 00 63 04
R 00 00 03 00 00 03 03 00
T 78 01 00
R 00 00 03 00
T 78 01 00 F8 0A 7E D6 E7 23 7E DE FF 56 3E FF CB
R 00 00 03 00
T 85 01 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 8F 01 00
R 00 00 03 00
T 8F 01 00 CB 7A 28 01 37
R 00 00 03 00
T 94 01 00
R 00 00 03 00
T 94 01 00 30 0C F8 1C 2A 5F 2A 57 2A 66 6F C3
R 00 00 03 00
T A0 01 00 63 04
R 00 00 03 00 00 03 03 00
T A2 01 00
R 00 00 03 00
T A2 01 00 F8 0A 7E D6 00 23 7E DE 00 56 3E 00 CB
R 00 00 03 00
T AF 01 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T B9 01 00
R 00 00 03 00
T B9 01 00 CB 7A 28 01 37
R 00 00 03 00
T BE 01 00
R 00 00 03 00
T BE 01 00 30 42 11 00 00 F8 0A 2A 66 6F 7B 95 5F
R 00 00 03 00
T CB 01 00 7A 9C F8 09 32 73 2A 5E 23 22 7B 32 2A
R 00 00 03 00
T D8 01 00 5F 56 F8 10 2A 66 6F 19 E5 7D F8 12 77
R 00 00 03 00
T E5 01 00 E1 7C F8 11 77 F8 0A 7E 3C 18 0D
R 00 00 03 00
T F0 01 00
R 00 00 03 00
T F0 01 00 F8 15 CB 2E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T FD 01 00
R 00 00 03 00
T FD 01 00 3D 20 F0 18 16
R 00 00 03 00
T 02 02 00
R 00 00 03 00
T 02 02 00 F8 0A 7E 3C 18 0D
R 00 00 03 00
T 08 02 00
R 00 00 03 00
T 08 02 00 F8 0F CB 2E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 15 02 00
R 00 00 03 00
T 15 02 00 3D 20 F0
R 00 00 03 00
T 18 02 00
R 00 00 03 00
T 18 02 00 F8 12 2A 5F 56 7B F8 0C 86 5F 7A 23 8E
R 00 00 03 00
T 25 02 00 F5 F8 0A 32 73 F8 16 2A 5F 56 F8 10 F1
R 00 00 03 00
T 32 02 00 7B 8E 5F 7A 23 8E F8 0A 32 7B 32 2B 54
R 00 00 03 00
T 3F 02 00 5D F8 0C 1A 22 13 1A 22 13 1A 22 13 1A
R 00 00 03 00
T 4C 02 00 77 AF F8 13 77 F8 0C 7E D6 00 23 7E DE
R 00 00 03 00
T 59 02 00 00 23 7E DE 00 23 7E DE 00 56 3E 00 CB
R 00 00 03 00
T 66 02 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 70 02 00
R 00 00 03 00
T 70 02 00 CB 7A 28 01 37
R 00 00 03 00
T 75 02 00
R 00 00 03 00
T 75 02 00 30 22 11 00 00 7B F8 0C 96 5F 7A 23 9E
R 00 00 03 00
T 82 02 00 F5 32 73 11 00 00 23 23 F1 7B 9E 5F 7A
R 00 00 03 00
T 8F 02 00 23 9E 32 73 F8 13 36 01 18 13
R 00 00 03 00
T 99 02 00
R 00 00 03 00
T 99 02 00 F8 0F 3A B6 2B B6 2B B6 20 09 11 00 00
R 00 00 03 00
T A6 02 00 21 00 00 C3 63 04
R 00 00 03 00 00 07 03 00
T AC 02 00
R 00 00 03 00
T AC 02 00 F8 10 2A 5E F8 14 22 73
R 00 00 03 00
T B4 02 00
R 00 00 03 00
T B4 02 00 F8 0C 54 5D F8 08 1A 22 13 1A 22 13 1A
R 00 00 03 00
T C1 02 00 22 13 1A 77 F8 08 7E D6 00 23 7E DE 00
R 00 00 03 00
T CE 02 00 23 7E DE 00 23 7E DE 08 30 19 F8 0C CB
R 00 00 03 00
T DB 02 00 26 23 CB 16 23 CB 16 23 CB 16 F8 14 2A
R 00 00 03 00
T E8 02 00 5F 56 1B 2B 7B 22 72 18 C3
R 00 00 03 00
T F1 02 00
R 00 00 03 00
T F1 02 00
R 00 00 03 00
T F1 02 00 F8 0F 7E E6 F0 28 3A F8 0C CB 46 28 1E
R 00 00 03 00
T FE 02 00 F8 0C 2A 5F 56 7B C6 02 5F 7A CE 00 F5
R 00 00 03 00
T 0B 03 00 32 73 F8 10 2A 5F 56 F1 7B CE 00 5F 7A
R 00 00 03 00
T 18 03 00 CE 00 32 73
R 00 00 03 00
T 1C 03 00
R 00 00 03 00
T 1C 03 00 F8 0F CB 2E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 29 03 00 F8 14 34 20 C3 23 34 18 BF
R 00 00 03 00
T 32 03 00
R 00 00 03 00
T 32 03 00 F8 14 2A 5E F8 11 22 73 F8 0C 7E F8 08
R 00 00 03 00
T 3F 03 00 77 F8 0D 7E F8 09 77 F8 0E 7E F8 0A 77
R 00 00 03 00
T 4C 03 00 F8 0F 7E E6 F7 F8 0B 77 F8 14 7E D6 00
R 00 00 03 00
T 59 03 00 23 7E DE 01 56 3E 01 CB 7F 28 07 CB 7A
R 00 00 03 00
T 66 03 00 20 08 BF 18 05
R 00 00 03 00
T 6B 03 00
R 00 00 03 00
T 6B 03 00 CB 7A 28 01 37
R 00 00 03 00
T 70 03 00
R 00 00 03 00
T 70 03 00 38 32 F8 13 CB 46 28 0B AF 2B 22 22 3E
R 00 00 03 00
T 7D 03 00 80 22 36 FF 18 0A
R 00 00 03 00
T 83 03 00
R 00 00 03 00
T 83 03 00 AF F8 12 22 22 3E 80 22 36 7F
R 00 00 03 00
T 8D 03 00
R 00 00 03 00
T 8D 03 00 C1 D1 D5 C5 F8 12 7E 12 13 23 7E 12 13
R 00 00 03 00
T 9A 03 00 23 7E 12 13 23 7E 12 C3 5A 04
R 00 00 03 00 00 0B 03 00
T A4 03 00
R 00 00 03 00
T A4 03 00 F8 14 7E D6 00 23 7E DE 00 56 3E 00 CB
R 00 00 03 00
T B1 03 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T BB 03 00
R 00 00 03 00
T BB 03 00 CB 7A 28 01 37
R 00 00 03 00
T C0 03 00
R 00 00 03 00
T C0 03 00 30 0C C1 E1 E5 C5 AF 22 22 22 77 C3
R 00 00 03 00
T CC 03 00 5A 04
R 00 00 03 00 00 03 03 00
T CE 03 00
R 00 00 03 00
T CE 03 00 F8 13 CB 46 28 0A AF F8 0D 22 22 22 36
R 00 00 03 00
T DB 03 00 80 18 07
R 00 00 03 00
T DE 03 00
R 00 00 03 00
T DE 03 00 AF F8 0D 22 22 22 77
R 00 00 03 00
T E5 03 00
R 00 00 03 00
T E5 03 00 F8 11 2A 5F 7E 57 17 01 00 00 3E 07
R 00 00 03 00
T F1 03 00
R 00 00 03 00
T F1 03 00 CB 23 CB 12 3D 20 F9 F8 0D 7E B1 F8 12
R 00 00 03 00
T FE 03 00 77 F8 0E 7E B0 F8 13 77 F8 0F 7E B3 F8
R 00 00 03 00
T 0B 04 00 14 77 F8 10 7E B2 F8 15 77 F8 08 2A 4F
R 00 00 03 00
T 18 04 00 2A 47 2A 5F 56 3E 04
R 00 00 03 00
T 1F 04 00
R 00 00 03 00
T 1F 04 00 CB 2A CB 1B CB 18 CB 19 3D 20 F5 F8 12
R 00 00 03 00
T 2C 04 00 7E B1 F8 0E 77 F8 13 7E B0 F8 0F 77 F8
R 00 00 03 00
T 39 04 00 14 7E B3 F8 10 77 F8 15 7E B2 F8 11 77
R 00 00 03 00
T 46 04 00 C1 D1 D5 C5 F8 0E 7E 12 13 23 7E 12 13
R 00 00 03 00
T 53 04 00 23 7E 12 13 23 7E 12
R 00 00 03 00
T 5A 04 00
R 00 00 03 00
T 5A 04 00 F8 18 2A 5F 2A 57 2A 66 6F
R 00 00 03 00
T 63 04 00
R 00 00 03 00
T 63 04 00 E8 16 C9
R 00 00 03 00

_fsdiv.rel/     0           0     0     644     6935      `
XL3
H 7 areas 3 global symbols
M _fsdiv
O -mgbz80
S ___fslt Ref000000
S .__.ABS. Def000000
A _CODE size 35F flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size D3 flags 0 addr 0
S ___fsdiv Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 FC F8 00 4D 44 F8 0D 7E CB BF 2B B6
R 00 00 03 00
T 0D 00 00 2B B6 2B B6 20 2E C5 2B 2B 2A 66 6F E5
R 00 00 03 00
T 1A 00 00 F8 0A 2A 66 6F E5 21 00 00 E5 21 00 00
R 00 00 03 00
T 27 00 00 E5 CD 00 00 E8 08 7B C1 B7 28 0F AF 02
R 00 00 03 00 02 05 00 00
T 34 00 00 03 02 03 3E 80 02 03 3E 7F 02 C3 C9 00
R 00 00 03 00 00 0E 03 00
T 41 00 00
R 00 00 03 00
T 41 00 00 F8 0D 7E CB BF 2B B6 2B B6 2B B6 20 2D
R 00 00 03 00
T 4E 00 00 C5 21 00 00 E5 21 00 00 E5 F8 0E 2A 66
R 00 00 03 00
T 5B 00 00 6F E5 F8 0E 2A 66 6F E5 CD 00 00 E8 08
R 00 00 03 00 02 0C 00 00
T 68 00 00 7B C1 B7 28 0E AF 02 03 02 03 3E 80 02
R 00 00 03 00
T 75 00 00 03 3E FF 02 18 4E
R 00 00 03 00
T 7B 00 00
R 00 00 03 00
T 7B 00 00 F8 0D 7E CB BF 2B B6 2B B6 2B B6 20 1A
R 00 00 03 00
T 88 00 00 2B 7E CB BF 2B B6 2B B6 2B B6 20 0E AF
R 00 00 03 00
T 95 00 00 02 03 02 03 3E C0 02 03 3E FF 02 18 27
R 00 00 03 00
T A2 00 00
R 00 00 03 00
T A2 00 00 F8 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 F8
R 00 00 03 00
T AF 00 00 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 CD
R 00 00 03 00
T BB 00 00 00 00 E8 08 4D 44 33 33 D5 F8 02 79 22
R 00 00 03 00 00 03 00 00
T C8 00 00 70
R 00 00 03 00
T C9 00 00
R 00 00 03 00
T C9 00 00 D1 D5 F8 02 2A 66 6F E8 04 C9
R 00 00 03 00
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 DD F8 04 4D 44 F8 25 2A 02 03 2A 02
R 00 00 00 00
T 0D 00 00 03 2A 02 03 7E 02 F8 08 4D 44 F8 29 2A
R 00 00 00 00
T 1A 00 00 02 03 2A 02 03 2A 02 03 7E 02 F8 04 2A
R 00 00 00 00
T 27 00 00 4F 2A 47 23 3A 6E 67 3E 17
R 00 00 00 00
T 30 00 00
R 00 00 00 00
T 30 00 00 CB 3C CB 1D CB 18 CB 19 3D 20 F5 F8 21
R 00 00 00 00
T 3D 00 00 71 AF 23 77 F8 08 2A 4F 2A 47 23 3A 6E
R 00 00 00 00
T 4A 00 00 67 3E 17
R 00 00 00 00
T 4D 00 00
R 00 00 00 00
T 4D 00 00 CB 3C CB 1D CB 18 CB 19 3D 20 F5 06 00
R 00 00 00 00
T 5A 00 00 F8 21 2A 5F 56 7B 91 4F 7A 98 47 2B 79
R 00 00 00 00
T 67 00 00 22 78 32 2A 5F 56 21 7E 00 19 E5 7D F8
R 00 00 00 00
T 74 00 00 23 77 E1 7C F8 22 77 F8 04 2A 2A 23 2A
R 00 00 00 00
T 81 00 00 2B 2B 6E 07 E6 01 F8 14 77 F8 08 2A 2A
R 00 00 00 00
T 8E 00 00 23 3A 6E 07 E6 01 F8 14 AE F8 10 77 F8
R 00 00 00 00
T 9B 00 00 08 4D 44 59 50 1A F8 11 22 13 1A 22 13
R 00 00 00 00
T A8 00 00 1A 22 13 1A 77 3A B6 2B B6 2B B6 20 35
R 00 00 00 00
T B5 00 00 F8 08 4D 44 AF 02 03 02 03 3E C0 02 03
R 00 00 00 00
T C2 00 00 3E 7F 02 F8 08 7D 54 F8 13 22 7A 32 2A
R 00 00 00 00
T CF 00 00 5F 56 1A F8 11 22 13 1A 22 13 1A 22 13
R 00 00 00 00
T DC 00 00 1A 32 2B 2B 2A 5F 2A 57 2A 66 6F C3
R 00 00 00 00
T E8 00 00 5C 03
R 00 00 00 00 00 03 00 00
T EA 00 00
R 00 00 00 00
T EA 00 00 F8 04 7D 54 F8 13 22 7A 32 2A 5F 56 1A
R 00 00 00 00
T F7 00 00 F8 11 22 13 1A 22 13 1A 22 13 1A 77 3A
R 00 00 00 00
T 04 01 00 B6 2B B6 2B B6 20 09 11 00 00 21 00 00
R 00 00 00 00
T 11 01 00 C3 5C 03
R 00 00 00 00 00 04 00 00
T 14 01 00
R 00 00 00 00
T 14 01 00 F8 04 2A 4F 2A 47 23 3A 7E CB BF 1E 00
R 00 00 00 00
T 21 01 00 F8 1D 71 23 70 F6 80 23 22 73 F8 08 2A
R 00 00 00 00
T 2E 01 00 4F 2A 47 23 3A 7E CB BF 1E 00 F8 0C 71
R 00 00 00 00
T 3B 01 00 23 70 F6 80 23 22 73 F8 1D 5D 54 F8 0C
R 00 00 00 00
T 48 01 00 1A 96 23 13 1A 9E 23 13 1A 9E 23 13 1A
R 00 00 00 00
T 55 01 00 9E 1A 57 CB 7E 28 07 CB 7A 20 08 BF 18
R 00 00 00 00
T 62 01 00 05
R 00 00 00 00
T 63 01 00
R 00 00 00 00
T 63 01 00 CB 7A 28 01 37
R 00 00 00 00
T 68 01 00
R 00 00 00 00
T 68 01 00 30 1B F8 1D CB 26 23 CB 16 23 CB 16 23
R 00 00 00 00
T 75 01 00 CB 16 23 2A 4F 46 11 01 00 79 93 5F 78
R 00 00 00 00
T 82 01 00 9A 32 73
R 00 00 00 00
T 85 01 00
R 00 00 00 00
T 85 01 00 AF F8 19 22 22 22 36 01 AF F8 15 22 22
R 00 00 00 00
T 92 01 00 22 77
R 00 00 00 00
T 94 01 00
R 00 00 00 00
T 94 01 00 F8 1C 3A B6 2B B6 2B B6 CA 26 02 F8 1D
R 00 00 00 00 00 0C 00 00
T A1 01 00 5D 54 F8 0C 1A 96 23 13 1A 9E 23 13 1A
R 00 00 00 00
T AE 01 00 9E 23 13 1A 9E 1A 57 CB 7E 28 07 CB 7A
R 00 00 00 00
T BB 01 00 20 08 BF 18 05
R 00 00 00 00
T C0 01 00
R 00 00 00 00
T C0 01 00 CB 7A 28 01 37
R 00 00 00 00
T C5 01 00
R 00 00 00 00
T C5 01 00 38 42 F8 15 7E F8 19 B6 F8 15 22 7E F8
R 00 00 00 00
T D2 01 00 1A B6 F8 16 22 7E F8 1B B6 F8 17 22 7E
R 00 00 00 00
T DF 01 00 F8 1C B6 F8 18 77 F8 1D 2A 5F 56 7B F8
R 00 00 00 00
T EC 01 00 0C 96 5F 7A 23 9E F5 F8 20 32 73 F8 21
R 00 00 00 00
T F9 01 00 2A 5F 56 F8 10 F1 7B 9E 5F 7A 23 9E F8
R 00 00 00 00
T 06 02 00 20 32 73
R 00 00 00 00
T 09 02 00
R 00 00 00 00
T 09 02 00 F8 1D CB 26 23 CB 16 23 CB 16 23 CB 16
R 00 00 00 00
T 16 02 00 F8 1C CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 00 00
T 23 02 00 C3 94 01
R 00 00 00 00 00 04 00 00
T 26 02 00
R 00 00 00 00
T 26 02 00 F8 15 34 20 0A 23 34 20 06 23 34 20 02
R 00 00 00 00
T 33 02 00 23 34
R 00 00 00 00
T 35 02 00
R 00 00 00 00
T 35 02 00 F8 21 2A 4F 46 03 2B 79 22 70 F8 18 CB
R 00 00 00 00
T 42 02 00 2E 2B CB 1E 2B CB 1E 2B CB 1E 23 23 7E
R 00 00 00 00
T 4F 02 00 E6 7F 77 F8 21 7E D6 00 23 7E DE 01 56
R 00 00 00 00
T 5C 02 00 3E 01 CB 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 69 02 00
R 00 00 00 00
T 69 02 00 CB 7A 28 01 37
R 00 00 00 00
T 6E 02 00
R 00 00 00 00
T 6E 02 00 38 42 F8 04 7D 54 F8 13 22 72 F8 10 7E
R 00 00 00 00
T 7B 02 00 B7 28 08 01 00 00 11 00 80 18 06
R 00 00 00 00
T 86 02 00
R 00 00 00 00
T 86 02 00 01 00 00 11 00 00
R 00 00 00 00
T 8C 02 00
R 00 00 00 00
T 8C 02 00 33 33 C5 7B F6 80 F8 02 77 7A F6 7F 23
R 00 00 00 00
T 99 02 00 77 F8 13 2A 5F 56 F8 00 7E 12 13 23 7E
R 00 00 00 00
T A6 02 00 12 13 23 7E 12 13 23 7E 12 C3 50 03
R 00 00 00 00 00 0D 00 00
T B2 02 00
R 00 00 00 00
T B2 02 00 F8 21 7E D6 00 23 7E DE 00 56 3E 00 CB
R 00 00 00 00
T BF 02 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T C9 02 00
R 00 00 00 00
T C9 02 00 CB 7A 28 01 37
R 00 00 00 00
T CE 02 00
R 00 00 00 00
T CE 02 00 30 0E F8 04 4D 44 AF 02 03 02 03 02 03
R 00 00 00 00
T DB 02 00 02 18 72
R 00 00 00 00
T DE 02 00
R 00 00 00 00
T DE 02 00 F8 04 7D 54 F8 13 22 72 F8 10 7E B7 28
R 00 00 00 00
T EB 02 00 0A AF F8 00 22 22 22 36 80 18 07
R 00 00 00 00
T F6 02 00
R 00 00 00 00
T F6 02 00 AF F8 00 22 22 22 77
R 00 00 00 00
T FD 02 00
R 00 00 00 00
T FD 02 00 F8 21 2A 5F 7E 57 17 AF 47 0E 07
R 00 00 00 00
T 08 03 00
R 00 00 00 00
T 08 03 00 CB 23 CB 12 0D 20 F9 F8 00 B6 4F 78 23
R 00 00 00 00
T 15 03 00 B6 47 7B 23 B6 5F 7A 23 B6 57 79 F8 15
R 00 00 00 00
T 22 03 00 B6 F8 00 77 78 F8 16 B6 F8 01 77 7B F8
R 00 00 00 00
T 2F 03 00 17 B6 F8 02 77 7A F8 18 B6 F8 03 77 F8
R 00 00 00 00
T 3C 03 00 13 2A 5F 56 F8 00 7E 12 13 23 7E 12 13
R 00 00 00 00
T 49 03 00 23 7E 12 13 23 7E 12
R 00 00 00 00
T 50 03 00
R 00 00 00 00
T 50 03 00 F8 04 2A 4F 2A 47 23 3A 6E 67 59 50
R 00 00 00 00
T 5C 03 00
R 00 00 00 00
T 5C 03 00 E8 23 C9
R 00 00 00 00

_fsmul.rel/     0           0     0     644     7279      `
XL3
H 7 areas 3 global symbols
M _fsmul
O -mgbz80
S .__.ABS. Def000000
S __mullong Ref000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 4C5 flags 0 addr 0
S ___fsmul Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 E9 F8 02 4D 44 F8 19 2A 02 03 2A 02
R 00 00 03 00
T 0D 00 00 03 2A 02 03 7E 02 F8 06 4D 44 F8 1D 2A
R 00 00 03 00
T 1A 00 00 02 03 2A 02 03 2A 02 03 7E 02 F8 02 2A
R 00 00 03 00
T 27 00 00 4F 2A 47 23 3A 6E B5 B0 B1 28 0E F8 06
R 00 00 03 00
T 34 00 00 2A 4F 2A 47 23 3A 6E B5 B0 B1 20 09
R 00 00 03 00
T 40 00 00
R 00 00 03 00
T 40 00 00 11 00 00 21 00 00 C3 C2 04
R 00 00 03 00 00 0A 03 00
T 49 00 00
R 00 00 03 00
T 49 00 00 F8 02 4D 44 59 50 1A F8 0F 22 13 1A 22
R 00 00 03 00
T 56 00 00 13 1A 22 13 1A 77 7E 07 E6 01 77 F8 06
R 00 00 03 00
T 63 00 00 2A 2A 23 3A 6E 07 E6 01 F8 12 AE F8 0A
R 00 00 03 00
T 70 00 00 77 F8 02 2A 4F 2A 47 23 3A 6E 67 3E 17
R 00 00 03 00
T 7D 00 00
R 00 00 03 00
T 7D 00 00 CB 3C CB 1D CB 18 CB 19 3D 20 F5 06 00
R 00 00 03 00
T 8A 00 00 11 7E 00 79 93 5F 78 9A F8 12 32 73 F8
R 00 00 03 00
T 97 00 00 06 2A 4F 2A 47 23 3A 6E 67 3E 17
R 00 00 03 00
T A2 00 00
R 00 00 03 00
T A2 00 00 CB 3C CB 1D CB 18 CB 19 3D 20 F5 06 00
R 00 00 03 00
T AF 00 00 F8 11 2A 66 6F 09 4D 44 F8 02 33 33 E5
R 00 00 03 00
T BC 00 00 F8 02 7D 54 F8 11 22 7A 32 2A 5F 56 1A
R 00 00 03 00
T C9 00 00 F8 0F 22 13 1A 22 13 1A 22 13 1A 77 F8
R 00 00 03 00
T D6 00 00 0F 7E F8 0B 77 F8 10 7E F8 0C 77 F8 11
R 00 00 03 00
T E3 00 00 7E E6 7F F8 0D 77 AF 23 77 F8 0B 7E F8
R 00 00 03 00
T F0 00 00 0F 77 F8 0C 7E F8 10 77 F8 0D 7E F6 80
R 00 00 03 00
T FD 00 00 F8 11 77 F8 0E 7E F8 12 77 D1 D5 F8 0F
R 00 00 03 00
T 0A 01 00 7E 12 13 23 7E 12 13 23 7E 12 13 23 7E
R 00 00 03 00
T 17 01 00 12 F8 06 33 33 E5 F8 06 7D 54 F8 11 22
R 00 00 03 00
T 24 01 00 7A 32 2A 5F 56 1A F8 0F 22 13 1A 22 13
R 00 00 03 00
T 31 01 00 1A 22 13 1A 77 F8 0F 7E F8 0B 77 F8 10
R 00 00 03 00
T 3E 01 00 7E F8 0C 77 F8 11 7E E6 7F F8 0D 77 AF
R 00 00 03 00
T 4B 01 00 23 77 F8 0B 7E F8 0F 77 F8 0C 7E F8 10
R 00 00 03 00
T 58 01 00 77 F8 0D 7E F6 80 F8 11 77 F8 0E 7E F8
R 00 00 03 00
T 65 01 00 12 77 D1 D5 F8 0F 7E 12 13 23 7E 12 13
R 00 00 03 00
T 72 01 00 23 7E 12 13 23 7E 12 F8 02 7D 54 F8 11
R 00 00 03 00
T 7F 01 00 22 7A 32 2A 5F 56 1A F8 0F 22 13 1A 22
R 00 00 03 00
T 8C 01 00 13 1A 22 13 1A 77 3E 08
R 00 00 03 00
T 94 01 00
R 00 00 03 00
T 94 01 00 F8 12 CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T A1 01 00 3D 20 F0 2A 5E F8 0B 22 73 AF 23 22 77
R 00 00 03 00
T AE 01 00 F8 06 7D 54 F8 11 22 7A 32 2A 5F 56 1A
R 00 00 03 00
T BB 01 00 F8 0F 22 13 1A 22 13 1A 22 13 1A 77 3E
R 00 00 03 00
T C8 01 00 08
R 00 00 03 00
T C9 01 00
R 00 00 03 00
T C9 01 00 F8 12 CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T D6 01 00 3D 20 F0 2A 5F 56 21 00 00 C5 E5 D5 F8
R 00 00 03 00
T E3 01 00 13 2A 66 6F E5 F8 13 2A 66 6F E5 CD
R 00 00 03 00
T EF 01 00 00 00 E8 08 E5 F8 13 73 F8 14 72 E1 E5
R 00 00 03 00 02 03 01 00
T FC 01 00 7D F8 15 77 E1 7C F8 14 77 C1 F8 0F 54
R 00 00 03 00
T 09 02 00 5D F8 13 1A 22 13 1A 22 13 1A 22 13 1A
R 00 00 03 00
T 16 02 00 77 F8 02 7D 54 F8 11 22 7A 32 2A 5F 56
R 00 00 03 00
T 23 02 00 1A F8 0F 22 13 1A 22 13 1A 22 13 1A 77
R 00 00 03 00
T 30 02 00 F8 0F 2A 5E 1E 00 F8 0B 22 73 AF 23 22
R 00 00 03 00
T 3D 02 00 77 F8 06 7D 54 F8 11 22 7A 32 2A 5F 56
R 00 00 03 00
T 4A 02 00 1A F8 0F 22 13 1A 22 13 1A 22 13 1A 77
R 00 00 03 00
T 57 02 00 3E 08
R 00 00 03 00
T 59 02 00
R 00 00 03 00
T 59 02 00 F8 12 CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 66 02 00 3D 20 F0 2A 5F 56 21 00 00 C5 E5 D5 F8
R 00 00 03 00
T 73 02 00 13 2A 66 6F E5 F8 13 2A 66 6F E5 CD
R 00 00 03 00
T 7F 02 00 00 00 E8 08 E5 F8 13 73 F8 14 72 E1 E5
R 00 00 03 00 02 03 01 00
T 8C 02 00 7D F8 15 77 E1 7C F8 14 77 C1 3E 08
R 00 00 03 00
T 98 02 00
R 00 00 03 00
T 98 02 00 F8 12 CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T A5 02 00 3D 20 F0 F8 13 2A 5F 56 7B F8 0F 86 5F
R 00 00 03 00
T B2 02 00 7A 23 8E F5 F8 16 32 73 F8 17 2A 5F 56
R 00 00 03 00
T BF 02 00 F8 13 F1 7B 8E 5F 7A 23 8E F8 16 32 73
R 00 00 03 00
T CC 02 00 F8 06 7D 54 F8 11 22 7A 32 2A 5F 56 1A
R 00 00 03 00
T D9 02 00 F8 0F 22 13 1A 22 13 1A 22 13 1A 77 F8
R 00 00 03 00
T E6 02 00 0F 2A 5E 1E 00 F8 0B 22 73 AF 23 22 77
R 00 00 03 00
T F3 02 00 F8 02 7D 54 F8 11 22 7A 32 2A 5F 56 1A
R 00 00 03 00
T 00 03 00 F8 0F 22 13 1A 22 13 1A 22 13 1A 77 3E
R 00 00 03 00
T 0D 03 00 08
R 00 00 03 00
T 0E 03 00
R 00 00 03 00
T 0E 03 00 F8 12 CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 1B 03 00 3D 20 F0 2A 5F 56 21 00 00 C5 E5 D5 F8
R 00 00 03 00
T 28 03 00 13 2A 66 6F E5 F8 13 2A 66 6F E5 CD
R 00 00 03 00
T 34 03 00 00 00 E8 08 E5 F8 13 73 F8 14 72 E1 E5
R 00 00 03 00 02 03 01 00
T 41 03 00 7D F8 15 77 E1 7C F8 14 77 C1 3E 08
R 00 00 03 00
T 4D 03 00
R 00 00 03 00
T 4D 03 00 F8 12 CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 5A 03 00 3D 20 F0 F8 13 2A 5F 56 7B F8 0F 86 5F
R 00 00 03 00
T 67 03 00 7A 23 8E F5 F8 16 32 73 F8 17 2A 5F 56
R 00 00 03 00
T 74 03 00 F8 13 F1 7B 8E 5F 7A 23 8E F8 16 32 7B
R 00 00 03 00
T 81 03 00 32 2B 2A 5F 56 7B C6 40 5F 7A CE 00 F5
R 00 00 03 00
T 8E 03 00 32 73 F8 17 2A 5F 56 F1 7B CE 00 5F 7A
R 00 00 03 00
T 9B 03 00 CE 00 32 7B 22 CB 7E 28 32 F8 13 2A 5F
R 00 00 03 00
T A8 03 00 56 7B C6 40 5F 7A CE 00 F5 32 73 F8 17
R 00 00 03 00
T B5 03 00 2A 5F 56 F1 7B CE 00 5F 7A CE 00 32 73
R 00 00 03 00
T C2 03 00 3E 08
R 00 00 03 00
T C4 03 00
R 00 00 03 00
T C4 03 00 F8 16 CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T D1 03 00 3D 20 F0 18 13
R 00 00 03 00
T D6 03 00
R 00 00 03 00
T D6 03 00 3E 07
R 00 00 03 00
T D8 03 00
R 00 00 03 00
T D8 03 00 F8 16 CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T E5 03 00 3D 20 F0 0B
R 00 00 03 00
T E9 03 00
R 00 00 03 00
T E9 03 00 F8 15 7E E6 7F 77 78 EE 80 D6 81 38 41
R 00 00 03 00
T F6 03 00 F8 02 7D 54 F8 11 22 72 F8 0A 7E B7 28
R 00 00 03 00
T 03 04 00 08 01 00 00 11 00 80 18 06
R 00 00 03 00
T 0C 04 00
R 00 00 03 00
T 0C 04 00 01 00 00 11 00 00
R 00 00 03 00
T 12 04 00
R 00 00 03 00
T 12 04 00 F8 0D 79 22 70 7B F6 80 23 77 7A F6 7F
R 00 00 03 00
T 1F 04 00 23 22 2A 5F 56 F8 0D 7E 12 13 23 7E 12
R 00 00 03 00
T 2C 04 00 13 23 7E 12 13 23 7E 12 C3 B6 04
R 00 00 03 00 00 0C 03 00
T 37 04 00
R 00 00 03 00
T 37 04 00 CB 78 28 0E F8 02 4D 44 AF 02 03 02 03
R 00 00 03 00
T 44 04 00 02 03 02 18 6D
R 00 00 03 00
T 49 04 00
R 00 00 03 00
T 49 04 00 F8 02 7D 54 F8 11 22 72 F8 0A 7E B7 28
R 00 00 03 00
T 56 04 00 0A AF F8 0D 22 22 22 36 80 18 07
R 00 00 03 00
T 61 04 00
R 00 00 03 00
T 61 04 00 AF F8 0D 22 22 22 77
R 00 00 03 00
T 68 04 00
R 00 00 03 00
T 68 04 00 78 17 11 00 00 3E 07
R 00 00 03 00
T 6F 04 00
R 00 00 03 00
T 6F 04 00 CB 21 CB 10 3D 20 F9 F8 0D 7E B3 F5 23
R 00 00 03 00
T 7C 04 00 7E B2 5F 23 7E B1 4F 23 7E B0 47 F1 F8
R 00 00 03 00
T 89 04 00 13 B6 F8 0D 77 7B F8 14 B6 F8 0E 77 79
R 00 00 03 00
T 96 04 00 F8 15 B6 F8 0F 77 78 F8 16 B6 F8 10 22
R 00 00 03 00
T A3 04 00 2A 5F 56 F8 0D 7E 12 13 23 7E 12 13 23
R 00 00 03 00
T B0 04 00 7E 12 13 23 7E 12
R 00 00 03 00
T B6 04 00
R 00 00 03 00
T B6 04 00 F8 02 2A 4F 2A 47 23 3A 6E 67 59 50
R 00 00 03 00
T C2 04 00
R 00 00 03 00
T C2 04 00 E8 17 C9
R 00 00 03 00

_fssub.rel/     0           0     0     644     924       `
XL3
H 7 areas 3 global symbols
M _fssub
O -mgbz80
S .__.ABS. Def000000
S ___fsadd Ref000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 6F flags 0 addr 0
S ___fssub Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F8 F8 0D 7E EE 80 F8 07 77 E5 F8 0C
R 00 00 03 00
T 0D 00 00 7E F8 06 77 F8 0D 7E F8 07 77 F8 0E 7E
R 00 00 03 00
T 1A 00 00 F8 08 77 E1 F8 04 2A 4F 2A 47 2A 5F 56
R 00 00 03 00
T 27 00 00 F8 10 2A 66 6F E5 F8 10 2A 66 6F E5 D5
R 00 00 03 00
T 34 00 00 C5 CD 00 00 E8 08 33 33 D5 E5 7D F8 04
R 00 00 03 00 02 05 01 00
T 41 00 00 77 E1 7C F8 03 77 F8 03 7E EE 80 F8 07
R 00 00 03 00
T 4E 00 00 77 E5 F8 02 7E F8 06 77 F8 03 7E F8 07
R 00 00 03 00
T 5B 00 00 77 F8 04 7E F8 08 77 E1 F8 04 2A 5F 2A
R 00 00 03 00
T 68 00 00 57 2A 66 6F E8 08 C9
R 00 00 03 00
_fseq.rel/      0           0     0     644     1282      `
XL3
H 7 areas 2 global symbols
M _fseq
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size A7 flags 0 addr 0
S ___fseq Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F0 F8 00 4D 44 F8 12 2A 02 03 2A 02
R 00 00 03 00
T 0D 00 00 03 2A 02 03 7E 02 F8 04 4D 44 F8 16 2A
R 00 00 03 00
T 1A 00 00 02 03 2A 02 03 2A 02 03 7E 02 F8 00 4D
R 00 00 03 00
T 27 00 00 44 59 50 1A F8 08 22 13 1A 22 13 1A 22
R 00 00 03 00
T 34 00 00 13 1A 77 F8 04 4D 44 59 50 1A F8 0C 22
R 00 00 03 00
T 41 00 00 13 1A 22 13 1A 22 13 1A 77 F8 08 7E F8
R 00 00 03 00
T 4E 00 00 0C 96 20 1C F8 09 7E F8 0D 96 20 14 F8
R 00 00 03 00
T 5B 00 00 0A 7E F8 0E 96 20 0C F8 0B 7E F8 0F 96
R 00 00 03 00
T 68 00 00 20 04 1E 01 18 36
R 00 00 03 00
T 6E 00 00
R 00 00 03 00
T 6E 00 00 F8 00 2A 4F 2A 47 23 3A 6E 67 79 B7 20
R 00 00 03 00
T 7B 00 00 26 B0 20 23 B5 20 20 7C E6 7F 20 1B F8
R 00 00 03 00
T 88 00 00 04 2A 4F 2A 47 23 3A 6E 67 79 B7 20 0D
R 00 00 03 00
T 95 00 00 B0 20 0A B5 20 07 7C E6 7F 1E 01 28 02
R 00 00 03 00
T A2 00 00
R 00 00 03 00
T A2 00 00 1E 00
R 00 00 03 00
T A4 00 00
R 00 00 03 00
T A4 00 00 E8 10 C9
R 00 00 03 00
_fslt.rel/      0           0     0     644     2292      `
XL3
H 7 areas 2 global symbols
M _fslt
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 13C flags 0 addr 0
S ___fslt Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F0 F8 00 4D 44 F8 12 2A 02 03 2A 02
R 00 00 03 00
T 0D 00 00 03 2A 02 03 7E 02 F8 04 4D 44 F8 16 2A
R 00 00 03 00
T 1A 00 00 02 03 2A 02 03 2A 02 03 7E 02 F8 00 4D
R 00 00 03 00
T 27 00 00 44 59 50 1A F8 08 22 13 1A 22 13 1A 22
R 00 00 03 00
T 34 00 00 13 1A 77 F8 04 4D 44 59 50 1A F8 0C 22
R 00 00 03 00
T 41 00 00 13 1A 22 13 1A 22 13 1A 77 F8 08 7E F8
R 00 00 03 00
T 4E 00 00 0C B6 F5 F8 0B 7E F8 0F B6 4F F8 0C 7E
R 00 00 03 00
T 5B 00 00 F8 10 B6 47 F8 0D 7E F8 11 B6 5F F1 B7
R 00 00 03 00
T 68 00 00 20 0F B1 20 0C B0 20 09 7B E6 7F 20 04
R 00 00 03 00
T 75 00 00 5F C3 39 01
R 00 00 03 00 00 05 03 00
T 79 00 00
R 00 00 03 00
T 79 00 00 F8 00 2A 2A 23 3A 6E CB 7F 28 61 F8 04
R 00 00 03 00
T 86 00 00 2A 2A 23 3A 6E CB 7F 28 56 F8 04 4D 44
R 00 00 03 00
T 93 00 00 59 50 1A F8 08 22 13 1A 22 13 1A 22 13
R 00 00 03 00
T A0 00 00 1A 77 F8 00 4D 44 59 50 1A F8 0C 22 13
R 00 00 03 00
T AD 00 00 1A 22 13 1A 22 13 1A 77 F8 08 5D 54 F8
R 00 00 03 00
T BA 00 00 0C 1A 96 23 13 1A 9E 23 13 1A 9E 23 13
R 00 00 03 00
T C7 00 00 1A 9E 1A 57 CB 7E 28 07 CB 7A 20 08 BF
R 00 00 03 00
T D4 00 00 18 05
R 00 00 03 00
T D6 00 00
R 00 00 03 00
T D6 00 00 CB 7A 28 01 37
R 00 00 03 00
T DB 00 00
R 00 00 03 00
T DB 00 00 30 04 1E 01 18 58
R 00 00 03 00
T E1 00 00
R 00 00 03 00
T E1 00 00 1E 00 18 54
R 00 00 03 00
T E5 00 00
R 00 00 03 00
T E5 00 00 F8 00 4D 44 59 50 1A F8 08 22 13 1A 22
R 00 00 03 00
T F2 00 00 13 1A 22 13 1A 77 F8 04 4D 44 59 50 1A
R 00 00 03 00
T FF 00 00 F8 0C 22 13 1A 22 13 1A 22 13 1A 77 F8
R 00 00 03 00
T 0C 01 00 08 5D 54 F8 0C 1A 96 23 13 1A 9E 23 13
R 00 00 03 00
T 19 01 00 1A 9E 23 13 1A 9E 1A 57 CB 7E 28 07 CB
R 00 00 03 00
T 26 01 00 7A 20 08 BF 18 05
R 00 00 03 00
T 2C 01 00
R 00 00 03 00
T 2C 01 00 CB 7A 28 01 37
R 00 00 03 00
T 31 01 00
R 00 00 03 00
T 31 01 00 30 04 1E 01 18 02
R 00 00 03 00
T 37 01 00
R 00 00 03 00
T 37 01 00 1E 00
R 00 00 03 00
T 39 01 00
R 00 00 03 00
T 39 01 00 E8 10 C9
R 00 00 03 00
_fsneq.rel/     0           0     0     644     1452      `
XL3
H 7 areas 2 global symbols
M _fsneq
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size C6 flags 0 addr 0
S ___fsneq Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F0 F8 00 4D 44 F8 12 2A 02 03 2A 02
R 00 00 03 00
T 0D 00 00 03 2A 02 03 7E 02 F8 04 4D 44 F8 16 2A
R 00 00 03 00
T 1A 00 00 02 03 2A 02 03 2A 02 03 7E 02 F8 00 4D
R 00 00 03 00
T 27 00 00 44 59 50 1A F8 08 22 13 1A 22 13 1A 22
R 00 00 03 00
T 34 00 00 13 1A 77 F8 04 4D 44 59 50 1A F8 0C 22
R 00 00 03 00
T 41 00 00 13 1A 22 13 1A 22 13 1A 77 F8 08 7E F8
R 00 00 03 00
T 4E 00 00 0C 96 20 1B F8 09 7E F8 0D 96 20 13 F8
R 00 00 03 00
T 5B 00 00 0A 7E F8 0E 96 20 0B F8 0B 7E F8 0F 96
R 00 00 03 00
T 68 00 00 20 03 5F 18 56
R 00 00 03 00
T 6D 00 00
R 00 00 03 00
T 6D 00 00 F8 00 4D 44 59 50 1A F8 08 22 13 1A 22
R 00 00 03 00
T 7A 00 00 13 1A 22 13 1A 77 F8 04 4D 44 59 50 1A
R 00 00 03 00
T 87 00 00 F8 0C 22 13 1A 22 13 1A 22 13 1A 77 F8
R 00 00 03 00
T 94 00 00 08 7E F8 0C B6 F5 F8 0B 7E F8 0F B6 4F
R 00 00 03 00
T A1 00 00 F8 0C 7E F8 10 B6 47 F8 0D 7E F8 11 B6
R 00 00 03 00
T AE 00 00 5F F1 B7 20 0E B1 20 0B B0 20 08 7B E6
R 00 00 03 00
T BB 00 00 7F 20 03 5F 18 02
R 00 00 03 00
T C1 00 00
R 00 00 03 00
T C1 00 00 1E 01
R 00 00 03 00
T C3 00 00
R 00 00 03 00
T C3 00 00 E8 10 C9
R 00 00 03 00
fabsf.rel/      0           0     0     644     806       `
XL3
H 7 areas 2 global symbols
M fabsf
O -mgbz80
S .__.ABS. Def000000
A _CODE size 5C flags 0 addr 0
S _fabsf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F4 F8 00 4D 44 F8 0E 2A 02 03 2A 02
R 00 00 00 00
T 0D 00 00 03 2A 02 03 7E 02 F8 00 4D 44 59 50 1A
R 00 00 00 00
T 1A 00 00 F8 04 22 13 1A 22 13 1A 22 13 1A 77 F8
R 00 00 00 00
T 27 00 00 04 7E F8 08 77 F8 05 7E F8 09 77 F8 06
R 00 00 00 00
T 34 00 00 7E F8 0A 77 F8 07 7E E6 7F F8 0B 77 F8
R 00 00 00 00
T 41 00 00 08 2A 02 03 2A 02 03 2A 02 03 7E 02 F8
R 00 00 00 00
T 4E 00 00 00 2A 4F 2A 47 23 3A 6E 67 59 50 E8 0C
R 00 00 00 00
T 5B 00 00 C9
R 00 00 00 00
frexpf.rel/     0           0     0     644     1616      `
XL3
H 7 areas 2 global symbols
M frexpf
O -mgbz80
S .__.ABS. Def000000
A _CODE size FD flags 0 addr 0
S _frexpf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F2 F8 00 4D 44 F8 10 2A 02 03 2A 02
R 00 00 00 00
T 0D 00 00 03 2A 02 03 7E 02 F8 00 7D 54 F8 04 22
R 00 00 00 00
T 1A 00 00 7A 32 2A 5F 56 1A 4F 13 1A 47 13 1A 6F
R 00 00 00 00
T 27 00 00 13 1A 67 5D 54 3E 17
R 00 00 00 00
T 2E 00 00
R 00 00 00 00
T 2E 00 00 CB 2A CB 1B CB 18 CB 19 3D 20 F5 F8 06
R 00 00 00 00
T 3B 00 00 71 AF 23 22 22 32 2B 2B 2A 5F 56 7B D6
R 00 00 00 00
T 48 00 00 7E 5F 7A DE 00 F5 F8 0D 32 7B 32 2B 2A
R 00 00 00 00
T 55 00 00 5F 56 F1 7B DE 00 5F 7A DE 00 F8 0D 32
R 00 00 00 00
T 62 00 00 73 F8 14 2A 4F 46 F8 0A 2A 5F 56 7B 02
R 00 00 00 00
T 6F 00 00 03 7A 02 F8 04 2A 5F 56 1A F8 0A 22 13
R 00 00 00 00
T 7C 00 00 1A 22 13 1A 22 13 1A 77 F8 0A 7E F8 06
R 00 00 00 00
T 89 00 00 77 F8 0B 7E F8 07 77 F8 0C 7E E6 7F F8
R 00 00 00 00
T 96 00 00 08 77 F8 0D 7E E6 80 F8 09 77 F8 04 2A
R 00 00 00 00
T A3 00 00 5F 2A 57 7E 12 13 23 7E 12 13 23 7E 12
R 00 00 00 00
T B0 00 00 13 23 7E 12 F8 04 2A 5F 56 1A 13 1A 13
R 00 00 00 00
T BD 00 00 1A 13 1A 23 7E F8 0A 77 F8 07 7E F8 0B
R 00 00 00 00
T CA 00 00 77 F8 08 7E F8 0C 77 F8 09 7E F6 3F F8
R 00 00 00 00
T D7 00 00 0D 77 F8 04 2A 5F 56 F8 0A 7E 12 13 23
R 00 00 00 00
T E4 00 00 7E 12 13 23 7E 12 13 23 7E 12 F8 00 2A
R 00 00 00 00
T F1 00 00 4F 2A 47 23 3A 6E 67 59 50 E8 0E C9
R 00 00 00 00
ldexpf.rel/     0           0     0     644     1587      `
XL3
H 7 areas 2 global symbols
M ldexpf
O -mgbz80
S .__.ABS. Def000000
A _CODE size EB flags 0 addr 0
S _ldexpf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 EE F8 00 4D 44 F8 14 2A 02 03 2A 02
R 00 00 00 00
T 0D 00 00 03 2A 02 03 7E 02 F8 00 7D 54 F8 04 22
R 00 00 00 00
T 1A 00 00 7A 32 2A 5F 56 1A 4F 13 1A 47 13 1A 6F
R 00 00 00 00
T 27 00 00 13 1A 67 5D 54 3E 17
R 00 00 00 00
T 2E 00 00
R 00 00 00 00
T 2E 00 00 CB 2A CB 1B CB 18 CB 19 3D 20 F5 F8 06
R 00 00 00 00
T 3B 00 00 71 AF 23 22 22 77 F8 18 7E F8 0A 77 F8
R 00 00 00 00
T 48 00 00 19 7E F8 0B 77 17 9F 23 22 77 F8 06 2A
R 00 00 00 00
T 55 00 00 5F 56 7B F8 0A 86 5F 7A 23 8E F5 F8 11
R 00 00 00 00
T 62 00 00 32 73 F8 0A 2A 5F 56 F8 0E F1 7B 8E 5F
R 00 00 00 00
T 6F 00 00 7A 23 8E F8 11 32 7B 32 2B 2A 4F 2A 2A
R 00 00 00 00
T 7C 00 00 56 AF F8 0C 71 23 77 F8 0A 3E 00 22 36
R 00 00 00 00
T 89 00 00 00 3E 07
R 00 00 00 00
T 8C 00 00
R 00 00 00 00
T 8C 00 00 F8 0C CB 26 23 CB 16 3D 20 F6 F8 04 2A
R 00 00 00 00
T 99 00 00 5F 56 1A 4F 13 1A 47 13 1A 6F 13 1A 5D
R 00 00 00 00
T A6 00 00 CB BB E6 80 F5 F8 0C 7E B1 F8 10 77 F8
R 00 00 00 00
T B3 00 00 0D 7E B0 F8 11 77 F8 0E 7E B3 F8 12 77
R 00 00 00 00
T C0 00 00 F1 F8 0D B6 F8 11 77 F8 04 2A 5F 56 F8
R 00 00 00 00
T CD 00 00 0E 7E 12 13 23 7E 12 13 23 7E 12 13 23
R 00 00 00 00
T DA 00 00 7E 12 F8 00 2A 4F 2A 47 23 3A 6E 67 59
R 00 00 00 00
T E7 00 00 50 E8 12 C9
R 00 00 00 00

expf.rel/       0           0     0     644     5512      `
XL3
H 7 areas B global symbols
M expf
O -mgbz80
S ___fssub Ref000000
S ___fsmul Ref000000
S _errno Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S _ldexpf Ref000000
S ___sint2fs Ref000000
S ___fs2sint Ref000000
S ___fsdiv Ref000000
A _CODE size 35D flags 0 addr 0
S _expf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F3 21 00 00 E5 21 00 00 E5 F8 15 2A
R 00 00 00 00
T 0D 00 00 66 6F E5 F8 15 2A 66 6F E5 CD 00 00 E8
R 00 00 00 00 02 0D 03 00
T 1A 00 00 08 CB 43 20 17 F8 0F 54 5D F8 07 1A 22
R 00 00 00 00
T 27 00 00 13 1A 22 13 1A 22 13 1A 77 AF F8 04 77
R 00 00 00 00
T 34 00 00 18 31
R 00 00 00 00
T 36 00 00
R 00 00 00 00
T 36 00 00 F8 12 7E EE 80 F8 05 77 E5 F8 11 7E F8
R 00 00 00 00
T 43 00 00 04 77 F8 12 7E F8 05 77 F8 13 7E F8 06
R 00 00 00 00
T 50 00 00 77 E1 F8 02 54 5D F8 07 1A 22 13 1A 22
R 00 00 00 00
T 5D 00 00 13 1A 22 13 1A 77 F8 04 36 01
R 00 00 00 00
T 67 00 00
R 00 00 00 00
T 67 00 00 21 D6 33 E5 21 95 BF E5 F8 0D 2A 66 6F
R 00 00 00 00
T 74 00 00 E5 F8 0D 2A 66 6F E5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 03 00
T 81 00 00 F8 0E 73 E1 F8 0C 7E B7 28 09 11 00 00
R 00 00 00 00
T 8E 00 00 21 80 3F C3 5A 03
R 00 00 00 00 00 07 00 00
T 94 00 00
R 00 00 00 00
T 94 00 00 F8 09 2A 66 6F E5 F8 09 2A 66 6F E5 21
R 00 00 00 00
T A1 00 00 B1 42 E5 21 18 72 E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 03 00
T AE 00 00 B7 28 20 F8 04 CB 46 28 11 21 00 00 3E
R 00 00 00 00 02 0D 02 00
T BB 00 00 22 22 36 00 11 FF FF 21 7F 7F C3 5A 03
R 00 00 00 00 00 0E 00 00
T C8 00 00
R 00 00 00 00
T C8 00 00 11 00 00 21 00 00 C3 5A 03
R 00 00 00 00 00 0A 00 00
T D1 00 00
R 00 00 00 00
T D1 00 00 F8 09 2A 66 6F E5 F8 09 2A 66 6F E5 21
R 00 00 00 00
T DE 00 00 B8 3F E5 21 3B AA E5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 01 00
T EB 00 00 44 33 33 D5 F8 02 79 22 70 C1 E1 E5 C5
R 00 00 00 00
T F8 00 00 4D 44 E1 E5 C5 E5 CD 00 00 E8 04 F8 0B
R 00 00 00 00 02 0A 08 00
T 05 01 00 7B 22 7A 32 7E D6 00 23 7E DE 00 56 3E
R 00 00 00 00
T 12 01 00 00 CB 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 1E 01 00
R 00 00 00 00
T 1E 01 00 CB 7A 28 01 37
R 00 00 00 00
T 23 01 00
R 00 00 00 00
T 23 01 00 30 0A F8 0B 2A 5F 56 1B 2B 7B 22 72
R 00 00 00 00
T 2F 01 00
R 00 00 00 00
T 2F 01 00 F8 0B 2A 66 6F E5 CD 00 00 E8 02 E5 D5
R 00 00 00 00 02 0A 07 00
T 3C 01 00 F8 06 2A 66 6F E5 F8 06 2A 66 6F E5 CD
R 00 00 00 00
T 49 01 00 00 00 E8 08 4D 44 21 00 3F E5 21 00 00
R 00 00 00 00 02 03 00 00
T 56 01 00 E5 C5 D5 CD 00 00 E8 08 CB 43 20 07 F8
R 00 00 00 00 02 07 03 00
T 63 01 00 0B 34 20 02 23 34
R 00 00 00 00
T 69 01 00
R 00 00 00 00
T 69 01 00
R 00 00 00 00
T 69 01 00 F8 0B 2A 66 6F E5 CD 00 00 E8 02 4D 44
R 00 00 00 00 02 0A 07 00
T 76 01 00 33 33 D5 F8 02 79 22 70 C1 E1 E5 C5 4D
R 00 00 00 00
T 83 01 00 44 E1 E5 C5 E5 21 31 3F E5 21 00 80 E5
R 00 00 00 00
T 90 01 00 CD 00 00 E8 08 E5 D5 F8 0D 2A 66 6F E5
R 00 00 00 00 02 04 01 00
T 9D 01 00 F8 0D 2A 66 6F E5 CD 00 00 E8 08 E5 F8
R 00 00 00 00 02 0A 00 00
T AA 01 00 09 73 F8 0A 72 E1 E5 7D F8 0B 77 E1 7C
R 00 00 00 00
T B7 01 00 F8 0A 77 C1 E1 E5 C5 4D 44 E1 E5 C5 E5
R 00 00 00 00
T C4 01 00 21 5E B9 E5 21 83 80 E5 CD 00 00 E8 08
R 00 00 00 00 02 0C 01 00
T D1 01 00 E5 D5 F8 0D 2A 66 6F E5 F8 0D 2A 66 6F
R 00 00 00 00
T DE 01 00 E5 CD 00 00 E8 08 4D 44 F8 07 7B 22 7A
R 00 00 00 00 02 05 00 00
T EB 01 00 22 79 22 78 32 2A 66 6F E5 F8 09 2A 66
R 00 00 00 00
T F8 01 00 6F E5 F8 0D 2A 66 6F E5 F8 0D 2A 66 6F
R 00 00 00 00
T 05 02 00 E5 CD 00 00 E8 08 4D 44 33 33 D5 F8 02
R 00 00 00 00 02 05 01 00
T 12 02 00 79 22 70 C1 E1 E5 C5 4D 44 E1 E5 C5 E5
R 00 00 00 00
T 1F 02 00 21 88 3B E5 21 08 53 E5 CD 00 00 E8 08
R 00 00 00 00 02 0C 01 00
T 2C 02 00 4D 44 21 80 3E E5 21 00 00 E5 C5 D5 CD
R 00 00 00 00
T 39 02 00 00 00 E8 08 4D 44 F8 09 2A 66 6F E5 F8
R 00 00 00 00 02 03 05 00
T 46 02 00 09 2A 66 6F E5 C5 D5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 01 00
T 53 02 00 44 F8 07 7B 22 7A 22 79 22 70 C1 E1 E5
R 00 00 00 00
T 60 02 00 C5 4D 44 E1 E5 C5 E5 21 4C 3D E5 21
R 00 00 00 00
T 6C 02 00 5B BF E5 CD 00 00 E8 08 4D 44 21 00 3F
R 00 00 00 00 02 07 01 00
T 79 02 00 E5 21 00 00 E5 C5 D5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 05 00
T 86 02 00 44 F8 09 2A 66 6F E5 F8 09 2A 66 6F E5
R 00 00 00 00
T 93 02 00 C5 D5 CD 00 00 E8 08 E5 D5 F8 0D 2A 66
R 00 00 00 00 02 06 00 00
T A0 02 00 6F E5 F8 0D 2A 66 6F E5 CD 00 00 E8 08
R 00 00 00 00 02 0C 09 00
T AD 02 00 4D 44 21 00 3F E5 21 00 00 E5 C5 D5 CD
R 00 00 00 00
T BA 02 00 00 00 E8 08 33 33 D5 E5 7D F8 04 77 E1
R 00 00 00 00 02 03 05 00
T C7 02 00 7C F8 03 77 F8 00 54 5D F8 05 1A 22 13
R 00 00 00 00
T D4 02 00 1A 22 13 1A 22 13 1A 77 F8 0B 2A 5F 56
R 00 00 00 00
T E1 02 00 6B 62 23 E5 7D F8 0B 77 E1 7C F8 0A 32
R 00 00 00 00
T EE 02 00 2A 66 6F E5 F8 09 2A 66 6F E5 F8 09 2A
R 00 00 00 00
T FB 02 00 66 6F E5 CD 00 00 E8 06 E5 F8 0B 73 F8
R 00 00 00 00 02 07 06 00
T 08 03 00 0C 72 E1 E5 7D F8 0D 77 E1 7C F8 0C 77
R 00 00 00 00
T 15 03 00 F8 04 CB 46 28 36 F8 0B 2A 66 6F E5 F8
R 00 00 00 00
T 22 03 00 0B 2A 66 6F E5 21 80 3F E5 21 00 00 E5
R 00 00 00 00
T 2F 03 00 CD 00 00 E8 08 E5 F8 0B 73 F8 0C 72 E1
R 00 00 00 00 02 04 09 00
T 3C 03 00 E5 7D F8 0D 77 E1 7C F8 0C 77 F8 09 2A
R 00 00 00 00
T 49 03 00 5F 2A 57 2A 66 6F 18 09
R 00 00 00 00
T 51 03 00
R 00 00 00 00
T 51 03 00 F8 09 2A 5F 2A 57 2A 66 6F
R 00 00 00 00
T 5A 03 00
R 00 00 00 00
T 5A 03 00 E8 0D C9
R 00 00 00 00
powf.rel/       0           0     0     644     1283      `
XL3
H 7 areas 7 global symbols
M powf
O -mgbz80
S ___fsmul Ref000000
S _logf Ref000000
S ___fseq Ref000000
S _expf Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
A _CODE size 8D flags 0 addr 0
S _powf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 09 7E CB BF 2B B6 2B B6 2B B6 20 07
R 00 00 00 00
T 0D 00 00 11 00 00 21 80 3F C9
R 00 00 00 00
T 14 00 00
R 00 00 00 00
T 14 00 00 21 80 3F E5 21 00 00 E5 F8 0C 2A 66 6F
R 00 00 00 00
T 21 00 00 E5 F8 0C 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 02 00
T 2E 00 00 B7 28 0A F8 02 2A 5F 2A 57 2A 66 6F C9
R 00 00 00 00
T 3B 00 00
R 00 00 00 00
T 3B 00 00 F8 04 2A 66 6F E5 F8 04 2A 66 6F E5 21
R 00 00 00 00
T 48 00 00 00 00 E5 21 00 00 E5 CD 00 00 E8 08 CB
R 00 00 00 00 02 0B 04 00
T 55 00 00 43 20 07 11 00 00 21 00 00 C9
R 00 00 00 00
T 5F 00 00
R 00 00 00 00
T 5F 00 00 F8 04 2A 66 6F E5 F8 04 2A 66 6F E5 CD
R 00 00 00 00
T 6C 00 00 00 00 E8 04 4D 44 F8 08 2A 66 6F E5 F8
R 00 00 00 00 02 03 01 00
T 79 00 00 08 2A 66 6F E5 C5 D5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 00 00
T 86 00 00 D5 CD 00 00 E8 04 C9
R 00 00 00 00 02 05 03 00

sincosf.rel/    0           0     0     644     6095      `
XL3
H 7 areas A global symbols
M sincosf
O -mgbz80
S ___fssub Ref000000
S ___fsmul Ref000000
S _errno Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S _fabsf Ref000000
S ___sint2fs Ref000000
S ___fs2sint Ref000000
A _CODE size 3D2 flags 0 addr 0
S _sincosf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F3 F8 13 CB 46 28 33 2B 2B 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 F8 11 2A 66 6F E5 CD 00 00 E8 04 4D
R 00 00 00 00 02 0B 06 00
T 1A 00 00 44 21 C9 3F E5 21 DB 0F E5 C5 D5 CD
R 00 00 00 00
T 26 00 00 00 00 E8 08 4D 44 F8 07 7B 22 7A 22 79
R 00 00 00 00 02 03 05 00
T 33 00 00 22 70 AF 23 23 77 18 54
R 00 00 00 00
T 3B 00 00
R 00 00 00 00
T 3B 00 00 21 00 00 E5 21 00 00 E5 F8 15 2A 66 6F
R 00 00 00 00
T 48 00 00 E5 F8 15 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 03 00
T 55 00 00 B7 28 22 F8 12 7E EE 80 F8 0A 77 E5 F8
R 00 00 00 00
T 62 00 00 11 7E F8 09 77 F8 12 7E F8 0A 77 F8 13
R 00 00 00 00
T 6F 00 00 7E F8 0B 77 E1 F8 0C 36 01 18 15
R 00 00 00 00
T 7A 00 00
R 00 00 00 00
T 7A 00 00 F8 0F 54 5D F8 07 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 87 00 00 22 13 1A 77 AF F8 0C 77
R 00 00 00 00
T 8F 00 00
R 00 00 00 00
T 8F 00 00 F8 09 2A 66 6F E5 F8 09 2A 66 6F E5 21
R 00 00 00 00
T 9C 00 00 49 46 E5 21 00 0C E5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 03 00
T A9 00 00 F8 0D 73 E1 F8 0B 7E B7 28 11 21 00 00
R 00 00 00 00 02 0E 02 00
T B6 00 00 3E 22 22 36 00 11 00 00 21 00 00 C3
R 00 00 00 00
T C2 00 00 CF 03
R 00 00 00 00 00 03 00 00
T C4 00 00
R 00 00 00 00
T C4 00 00 F8 09 2A 66 6F E5 F8 09 2A 66 6F E5 21
R 00 00 00 00
T D1 00 00 A2 3E E5 21 83 F9 E5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 01 00
T DE 00 00 F8 0A 73 F8 0B 72 E1 E5 7D F8 0C 77 E1
R 00 00 00 00
T EB 00 00 7C F8 0B 77 21 00 3F E5 21 00 00 E5 F8
R 00 00 00 00
T F8 00 00 0E 2A 66 6F E5 F8 0E 2A 66 6F E5 CD
R 00 00 00 00
T 04 01 00 00 00 E8 08 E5 F8 0A 73 F8 0B 72 E1 E5
R 00 00 00 00 02 03 05 00
T 11 01 00 7D F8 0C 77 E1 7C F8 0B 77 F8 0A 2A 66
R 00 00 00 00
T 1E 01 00 6F E5 F8 0A 2A 66 6F E5 CD 00 00 E8 04
R 00 00 00 00 02 0C 08 00
T 2B 01 00 F8 0A 7B 22 7A 32 CB 46 28 06 F8 0C 7E
R 00 00 00 00
T 38 01 00 EE 01 77
R 00 00 00 00
T 3B 01 00
R 00 00 00 00
T 3B 01 00 F8 0A 2A 66 6F E5 CD 00 00 E8 02 E5 F8
R 00 00 00 00 02 0A 07 00
T 48 01 00 0A 73 F8 0B 72 E1 E5 7D F8 0C 77 E1 7C
R 00 00 00 00
T 55 01 00 F8 0B 77 F8 08 54 5D F8 00 1A 22 13 1A
R 00 00 00 00
T 62 01 00 22 13 1A 22 13 1A 77 F8 13 CB 46 28 23
R 00 00 00 00
T 6F 01 00 21 00 3F E5 21 00 00 E5 F8 06 2A 66 6F
R 00 00 00 00
T 7C 01 00 E5 F8 06 2A 66 6F E5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 00 00
T 89 01 00 44 33 33 D5 F8 02 79 22 70
R 00 00 00 00
T 92 01 00
R 00 00 00 00
T 92 01 00 F8 11 2A 66 6F E5 F8 11 2A 66 6F E5 CD
R 00 00 00 00
T 9F 01 00 00 00 E8 04 4D 44 F8 04 7B 22 7A 22 79
R 00 00 00 00 02 03 06 00
T AC 01 00 22 78 32 2A 66 6F E5 F8 06 2A 66 6F E5
R 00 00 00 00
T B9 01 00 CD 00 00 E8 04 E5 F8 0C 73 F8 0D 72 E1
R 00 00 00 00 02 04 08 00
T C6 01 00 F8 0A 2A 66 6F E5 CD 00 00 E8 02 E5 F8
R 00 00 00 00 02 0A 07 00
T D3 01 00 0A 73 F8 0B 72 E1 E5 7D F8 0C 77 E1 7C
R 00 00 00 00
T E0 01 00 F8 0B 77 F8 0A 2A 66 6F E5 F8 0A 2A 66
R 00 00 00 00
T ED 01 00 6F E5 F8 0A 2A 66 6F E5 F8 0A 2A 66 6F
R 00 00 00 00
T FA 01 00 E5 CD 00 00 E8 08 4D 44 F8 04 7B 22 7A
R 00 00 00 00 02 05 00 00
T 07 02 00 22 79 22 70 C1 E1 E5 C5 4D 44 E1 E5 C5
R 00 00 00 00
T 14 02 00 E5 21 49 40 E5 21 00 00 E5 CD 00 00 E8
R 00 00 00 00 02 0D 01 00
T 21 02 00 08 E5 D5 F8 0E 2A 66 6F E5 F8 0E 2A 66
R 00 00 00 00
T 2E 02 00 6F E5 CD 00 00 E8 08 4D 44 F8 06 2A 66
R 00 00 00 00 02 06 00 00
T 3B 02 00 6F E5 F8 06 2A 66 6F E5 C5 D5 CD 00 00
R 00 00 00 00 02 0E 05 00
T 48 02 00 E8 08 E5 F8 0A 73 F8 0B 72 E1 E5 7D F8
R 00 00 00 00
T 55 02 00 0C 77 E1 7C F8 0B 77 C1 E1 E5 C5 4D 44
R 00 00 00 00
T 62 02 00 E1 E5 C5 E5 21 7D 3A E5 21 22 AA E5 CD
R 00 00 00 00
T 6F 02 00 00 00 E8 08 E5 D5 F8 0E 2A 66 6F E5 F8
R 00 00 00 00 02 03 01 00
T 7C 02 00 0E 2A 66 6F E5 CD 00 00 E8 08 4D 44 F8
R 00 00 00 00 02 09 00 00
T 89 02 00 04 7B 22 7A 22 79 22 78 32 2A 66 6F E5
R 00 00 00 00
T 96 02 00 F8 06 2A 66 6F E5 F8 0A 2A 66 6F E5 F8
R 00 00 00 00
T A3 02 00 0A 2A 66 6F E5 CD 00 00 E8 08 4D 44 F8
R 00 00 00 00 02 09 01 00
T B0 02 00 08 7B 22 7A 22 79 22 78 32 2A 66 6F E5
R 00 00 00 00
T BD 02 00 F8 0A 2A 66 6F E5 21 7F 33 E5 21 F3 FF
R 00 00 00 00
T CA 02 00 E5 CD 00 00 E8 08 7B B7 CA 91 03 F8 0A
R 00 00 00 00 02 05 03 00 00 0C 00 00
T D7 02 00 2A 66 6F E5 F8 0A 2A 66 6F E5 21 2E 36
R 00 00 00 00
T E4 02 00 E5 21 5B 9C E5 CD 00 00 E8 08 4D 44 21
R 00 00 00 00 02 09 01 00
T F1 02 00 4F B9 E5 21 22 B2 E5 C5 D5 CD 00 00 E8
R 00 00 00 00 02 0D 05 00
T FE 02 00 08 4D 44 F8 0A 2A 66 6F E5 F8 0A 2A 66
R 00 00 00 00
T 0B 03 00 6F E5 C5 D5 CD 00 00 E8 08 4D 44 21
R 00 00 00 00 02 08 01 00
T 17 03 00 08 3C E5 21 3E 87 E5 C5 D5 CD 00 00 E8
R 00 00 00 00 02 0D 05 00
T 24 03 00 08 4D 44 F8 0A 2A 66 6F E5 F8 0A 2A 66
R 00 00 00 00
T 31 03 00 6F E5 C5 D5 CD 00 00 E8 08 4D 44 21
R 00 00 00 00 02 08 01 00
T 3D 03 00 2A BE E5 21 A4 AA E5 C5 D5 CD 00 00 E8
R 00 00 00 00 02 0D 05 00
T 4A 03 00 08 4D 44 F8 0A 2A 66 6F E5 F8 0A 2A 66
R 00 00 00 00
T 57 03 00 6F E5 C5 D5 CD 00 00 E8 08 E5 D5 F8 0A
R 00 00 00 00 02 08 01 00
T 64 03 00 2A 66 6F E5 F8 0A 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 01 00
T 71 03 00 E8 08 E5 D5 F8 0A 2A 66 6F E5 F8 0A 2A
R 00 00 00 00
T 7E 03 00 66 6F E5 CD 00 00 E8 08 4D 44 F8 04 7B
R 00 00 00 00 02 07 05 00
T 8B 03 00 22 7A 22 79 22 70
R 00 00 00 00
T 91 03 00
R 00 00 00 00
T 91 03 00 F8 0C CB 46 28 1E F8 07 7E EE 80 F8 0C
R 00 00 00 00
T 9E 03 00 77 E5 F8 06 7E F8 0B 77 F8 07 7E F8 0C
R 00 00 00 00
T AB 03 00 77 F8 08 7E F8 0D 77 E1 18 11
R 00 00 00 00
T B5 03 00
R 00 00 00 00
T B5 03 00 F8 04 54 5D F8 09 1A 22 13 1A 22 13 1A
R 00 00 00 00
T C2 03 00 22 13 1A 77
R 00 00 00 00
T C6 03 00
R 00 00 00 00
T C6 03 00 F8 09 2A 5F 2A 57 2A 66 6F
R 00 00 00 00
T CF 03 00
R 00 00 00 00
T CF 03 00 E8 0D C9
R 00 00 00 00

sinf.rel/       0           0     0     644     609       `
XL3
H 7 areas 3 global symbols
M sinf
O -mgbz80
S _sincosf Ref000000
S .__.ABS. Def000000
A _CODE size 29 flags 0 addr 0
S _sinf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 05 7E CB BF 2B B6 2B B6 2B B6 20 07
R 00 00 00 00
T 0D 00 00 11 00 00 21 00 00 C9
R 00 00 00 00
T 14 00 00
R 00 00 00 00
T 14 00 00 AF F5 33 F8 05 2A 66 6F E5 F8 05 2A 66
R 00 00 00 00
T 21 00 00 6F E5 CD 00 00 E8 05 C9
R 00 00 00 00 02 06 00 00

cosf.rel/       0           0     0     644     612       `
XL3
H 7 areas 3 global symbols
M cosf
O -mgbz80
S _sincosf Ref000000
S .__.ABS. Def000000
A _CODE size 2A flags 0 addr 0
S _cosf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 05 7E CB BF 2B B6 2B B6 2B B6 20 07
R 00 00 00 00
T 0D 00 00 11 00 00 21 80 3F C9
R 00 00 00 00
T 14 00 00
R 00 00 00 00
T 14 00 00 3E 01 F5 33 F8 05 2A 66 6F E5 F8 05 2A
R 00 00 00 00
T 21 00 00 66 6F E5 CD 00 00 E8 05 C9
R 00 00 00 00 02 07 00 00
logf.rel/       0           0     0     644     3823      `
XL3
H 7 areas A global symbols
M logf
O -mgbz80
S ___fssub Ref000000
S ___fsmul Ref000000
S _errno Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S ___sint2fs Ref000000
S _frexpf Ref000000
S ___fsdiv Ref000000
A _CODE size 248 flags 0 addr 0
S _logf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F6 F8 0E 2A 66 6F E5 F8 0E 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 21 00 00 E5 21 00 00 E5 CD 00 00 E8
R 00 00 00 00 02 0D 03 00
T 1A 00 00 08 CB 43 20 11 21 00 00 3E 21 22 36 00
R 00 00 00 00 02 09 02 00
T 27 00 00 11 00 00 21 00 00 C3 45 02
R 00 00 00 00 00 0A 00 00
T 30 00 00
R 00 00 00 00
T 30 00 00 F8 08 E5 F8 10 2A 66 6F E5 F8 10 2A 66
R 00 00 00 00
T 3D 00 00 6F E5 CD 00 00 E8 06 4D 44 33 33 D5 F8
R 00 00 00 00 02 06 07 00
T 4A 00 00 02 79 22 70 21 00 3F E5 21 00 00 E5 F8
R 00 00 00 00
T 57 00 00 06 2A 66 6F E5 F8 06 2A 66 6F E5 CD
R 00 00 00 00
T 63 00 00 00 00 E8 08 4D 44 F8 04 7B 22 7A 22 79
R 00 00 00 00 02 03 00 00
T 70 00 00 22 70 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 21
R 00 00 00 00
T 7D 00 00 35 3F E5 21 F3 04 E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 03 00
T 8A 00 00 B7 28 52 21 00 3F E5 21 00 00 E5 F8 0A
R 00 00 00 00
T 97 00 00 2A 66 6F E5 F8 0A 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 00 00
T A4 00 00 E8 08 4D 44 F8 04 7B 22 7A 22 79 22 70
R 00 00 00 00
T B1 00 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 21 00 3F
R 00 00 00 00
T BE 00 00 E5 21 00 00 E5 CD 00 00 E8 08 4D 44 21
R 00 00 00 00 02 09 01 00
T CB 00 00 00 3F E5 21 00 00 E5 C5 D5 CD 00 00 E8
R 00 00 00 00 02 0D 05 00
T D8 00 00 08 4B 42 5D 54 18 38
R 00 00 00 00
T DF 00 00
R 00 00 00 00
T DF 00 00 F8 08 2A 5F 56 1B 2B 7B 22 72 F8 06 2A
R 00 00 00 00
T EC 00 00 66 6F E5 F8 06 2A 66 6F E5 21 00 3F E5
R 00 00 00 00
T F9 00 00 21 00 00 E5 CD 00 00 E8 08 4D 44 21
R 00 00 00 00 02 08 01 00
T 05 01 00 00 3F E5 21 00 00 E5 C5 D5 CD 00 00 E8
R 00 00 00 00 02 0D 05 00
T 12 01 00 08 4B 42 5D 54
R 00 00 00 00
T 17 01 00
R 00 00 00 00
T 17 01 00 D5 C5 F8 0A 2A 66 6F E5 F8 0A 2A 66 6F
R 00 00 00 00
T 24 01 00 E5 CD 00 00 E8 08 4D 44 33 33 D5 F8 02
R 00 00 00 00 02 05 08 00
T 31 01 00 79 22 70 C1 E1 E5 C5 4D 44 E1 E5 C5 E5
R 00 00 00 00
T 3E 01 00 F8 06 2A 66 6F E5 F8 06 2A 66 6F E5 CD
R 00 00 00 00
T 4B 01 00 00 00 E8 08 4D 44 C5 D5 C5 D5 21 0D BF
R 00 00 00 00 02 03 01 00
T 58 01 00 E5 21 3D 7E E5 CD 00 00 E8 08 E5 F8 0A
R 00 00 00 00 02 09 01 00
T 65 01 00 73 F8 0B 72 E1 E5 7D F8 0C 77 E1 7C F8
R 00 00 00 00
T 72 01 00 0B 77 D1 C1 21 D4 C0 E5 21 3A 3F E5 C5
R 00 00 00 00
T 7F 01 00 D5 CD 00 00 E8 08 E5 D5 F8 0A 2A 66 6F
R 00 00 00 00 02 05 05 00
T 8C 01 00 E5 F8 0A 2A 66 6F E5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 08 00
T 99 01 00 D5 F8 06 2A 66 6F E5 F8 06 2A 66 6F E5
R 00 00 00 00
T A6 01 00 CD 00 00 E8 08 E5 D5 F8 06 2A 66 6F E5
R 00 00 00 00 02 04 01 00
T B3 01 00 F8 06 2A 66 6F E5 CD 00 00 E8 08 4D 44
R 00 00 00 00 02 0A 05 00
T C0 01 00 F8 04 7B 22 7A 22 79 22 78 22 2A 66 6F
R 00 00 00 00
T CD 01 00 E5 CD 00 00 E8 02 4D 44 33 33 D5 F8 02
R 00 00 00 00 02 05 06 00
T DA 01 00 79 22 70 C1 E1 E5 C5 4D 44 E1 E5 C5 E5
R 00 00 00 00
T E7 01 00 21 5E B9 E5 21 83 80 E5 CD 00 00 E8 08
R 00 00 00 00 02 0C 01 00
T F4 01 00 4D 44 F8 06 2A 66 6F E5 F8 06 2A 66 6F
R 00 00 00 00
T 01 02 00 E5 C5 D5 CD 00 00 E8 08 E5 F8 06 73 F8
R 00 00 00 00 02 07 05 00
T 0E 02 00 07 72 E1 E5 7D F8 08 77 E1 7C F8 07 77
R 00 00 00 00
T 1B 02 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 21 31 3F
R 00 00 00 00
T 28 02 00 E5 21 00 80 E5 CD 00 00 E8 08 E5 D5 F8
R 00 00 00 00 02 09 01 00
T 35 02 00 0A 2A 66 6F E5 F8 0A 2A 66 6F E5 CD
R 00 00 00 00
T 41 02 00 00 00 E8 08
R 00 00 00 00 02 03 05 00
T 45 02 00
R 00 00 00 00
T 45 02 00 E8 0A C9
R 00 00 00 00

log10f.rel/     0           0     0     644     569       `
XL3
H 7 areas 4 global symbols
M log10f
O -mgbz80
S ___fsmul Ref000000
S _logf Ref000000
S .__.ABS. Def000000
A _CODE size 21 flags 0 addr 0
S _log10f Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 04 2A 66 6F E5 F8 04 2A 66 6F E5 CD
R 00 00 00 00
T 0D 00 00 00 00 E8 04 E5 D5 21 DE 3E E5 21 D9 5B
R 00 00 00 00 02 03 01 00
T 1A 00 00 E5 CD 00 00 E8 08 C9
R 00 00 00 00 02 05 00 00

sqrtf.rel/      0           0     0     644     2931      `
XL3
H 7 areas A global symbols
M sqrtf
O -mgbz80
S ___fsmul Ref000000
S _errno Ref000000
S ___fseq Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S _ldexpf Ref000000
S _frexpf Ref000000
S ___fsdiv Ref000000
A _CODE size 197 flags 0 addr 0
S _sqrtf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F6 F8 0F 7E CB BF 2B B6 2B B6 2B B6
R 00 00 00 00
T 0D 00 00 20 0A 2A 5F 2A 57 2A 66 6F C3 94 01
R 00 00 00 00 00 0D 00 00
T 19 00 00
R 00 00 00 00
T 19 00 00 21 80 3F E5 21 00 00 E5 F8 12 2A 66 6F
R 00 00 00 00
T 26 00 00 E5 F8 12 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 02 00
T 33 00 00 B7 28 09 11 00 00 21 80 3F C3 94 01
R 00 00 00 00 00 0D 00 00
T 3F 00 00
R 00 00 00 00
T 3F 00 00 21 00 00 E5 21 00 00 E5 F8 12 2A 66 6F
R 00 00 00 00
T 4C 00 00 E5 F8 12 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 03 00
T 59 00 00 B7 28 11 21 00 00 3E 21 22 36 00 11
R 00 00 00 00 02 07 01 00
T 65 00 00 00 00 21 00 00 C3 94 01
R 00 00 00 00 00 09 00 00
T 6D 00 00
R 00 00 00 00
T 6D 00 00 F8 08 E5 F8 10 2A 66 6F E5 F8 10 2A 66
R 00 00 00 00
T 7A 00 00 6F E5 CD 00 00 E8 06 4D 44 33 33 D5 F8
R 00 00 00 00 02 06 07 00
T 87 00 00 02 79 22 70 C1 E1 E5 C5 4D 44 E1 E5 C5
R 00 00 00 00
T 94 00 00 E5 21 17 3F E5 21 BA 14 E5 CD 00 00 E8
R 00 00 00 00 02 0D 00 00
T A1 00 00 08 4D 44 21 D5 3E E5 21 A8 A9 E5 C5 D5
R 00 00 00 00
T AE 00 00 CD 00 00 E8 08 4D 44 F8 04 7B 22 7A 22
R 00 00 00 00 02 04 05 00
T BB 00 00 79 22 78 32 2A 66 6F E5 F8 06 2A 66 6F
R 00 00 00 00
T C8 00 00 E5 F8 06 2A 66 6F E5 F8 06 2A 66 6F E5
R 00 00 00 00
T D5 00 00 CD 00 00 E8 08 E5 D5 F8 0A 2A 66 6F E5
R 00 00 00 00 02 04 08 00
T E2 00 00 F8 0A 2A 66 6F E5 CD 00 00 E8 08 4D 44
R 00 00 00 00 02 0A 05 00
T EF 00 00 C5 D5 21 FE FF E5 C5 D5 CD 00 00 E8 06
R 00 00 00 00 02 0C 06 00
T FC 00 00 E5 F8 0A 73 F8 0B 72 E1 E5 7D F8 0C 77
R 00 00 00 00
T 09 01 00 E1 7C F8 0B 77 F8 06 2A 66 6F E5 F8 06
R 00 00 00 00
T 16 01 00 2A 66 6F E5 CD 00 00 E8 08 E5 D5 F8 0A
R 00 00 00 00 02 08 08 00
T 23 01 00 2A 66 6F E5 F8 0A 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 05 00
T 30 01 00 E8 08 4D 44 F8 04 7B 22 7A 22 79 22 78
R 00 00 00 00
T 3D 01 00 22 CB 46 28 32 F8 06 2A 66 6F E5 F8 06
R 00 00 00 00
T 4A 01 00 2A 66 6F E5 21 35 3F E5 21 F3 04 E5 CD
R 00 00 00 00
T 57 01 00 00 00 E8 08 E5 F8 06 73 F8 07 72 E1 E5
R 00 00 00 00 02 03 00 00
T 64 01 00 7D F8 08 77 E1 7C F8 07 77 F8 08 34 20
R 00 00 00 00
T 71 01 00 02 23 34
R 00 00 00 00
T 74 01 00
R 00 00 00 00
T 74 01 00
R 00 00 00 00
T 74 01 00 F8 08 2A 4F 46 CB 78 28 01 03
R 00 00 00 00
T 7E 01 00
R 00 00 00 00
T 7E 01 00 CB 28 CB 19 C5 F8 08 2A 66 6F E5 F8 08
R 00 00 00 00
T 8B 01 00 2A 66 6F E5 CD 00 00 E8 06
R 00 00 00 00 02 08 06 00
T 94 01 00
R 00 00 00 00
T 94 01 00 E8 0A C9
R 00 00 00 00

tancotf.rel/    0           0     0     644     5512      `
XL3
H 7 areas B global symbols
M tancotf
O -mgbz80
S ___fssub Ref000000
S ___fsmul Ref000000
S _errno Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S _fabsf Ref000000
S ___sint2fs Ref000000
S ___fs2sint Ref000000
S ___fsdiv Ref000000
A _CODE size 358 flags 0 addr 0
S _tancotf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F2 F8 12 2A 66 6F E5 F8 12 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 CD 00 00 E8 04 E5 D5 21 C9 45 E5 21
R 00 00 00 00 02 05 06 00
T 1A 00 00 00 08 E5 CD 00 00 E8 08 7B B7 28 11 21
R 00 00 00 00 02 07 03 00
T 27 00 00 00 00 3E 22 22 36 00 11 00 00 21 00 00
R 00 00 00 00 02 03 02 00
T 34 00 00 C3 55 03
R 00 00 00 00 00 04 00 00
T 37 00 00
R 00 00 00 00
T 37 00 00 F8 12 2A 66 6F E5 F8 12 2A 66 6F E5 21
R 00 00 00 00
T 44 00 00 22 3F E5 21 83 F9 E5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 01 00
T 51 00 00 F8 0C 73 F8 0D 72 E1 E5 7D F8 0E 77 E1
R 00 00 00 00
T 5E 00 00 7C F8 0D 77 F8 12 2A 66 6F E5 F8 12 2A
R 00 00 00 00
T 6B 00 00 66 6F E5 21 00 00 E5 21 00 00 E5 CD
R 00 00 00 00
T 77 00 00 00 00 E8 08 7B B7 28 08 01 00 00 11
R 00 00 00 00 02 03 03 00
T 83 00 00 00 3F 18 06
R 00 00 00 00
T 87 00 00
R 00 00 00 00
T 87 00 00 01 00 00 11 00 BF
R 00 00 00 00
T 8D 00 00
R 00 00 00 00
T 8D 00 00 D5 C5 F8 10 2A 66 6F E5 F8 10 2A 66 6F
R 00 00 00 00
T 9A 00 00 E5 CD 00 00 E8 08 E5 D5 CD 00 00 E8 04
R 00 00 00 00 02 05 05 00 02 0C 08 00
T A7 00 00 F8 04 7B 22 7A 32 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 07 00
T B4 00 00 E8 02 4D 44 33 33 D5 F8 02 79 22 70 F8
R 00 00 00 00
T C1 00 00 12 2A 66 6F E5 F8 12 2A 66 6F E5 CD
R 00 00 00 00
T CD 00 00 00 00 E8 04 D5 CD 00 00 E8 02 4D 44 F8
R 00 00 00 00 02 03 08 00 02 09 07 00
T DA 00 00 06 7B 22 7A 22 79 22 78 32 2A 66 6F E5
R 00 00 00 00
T E7 00 00 F8 08 2A 66 6F E5 F8 16 2A 66 6F E5 F8
R 00 00 00 00
T F4 00 00 16 2A 66 6F E5 CD 00 00 E8 08 4D 44 F8
R 00 00 00 00 02 09 00 00
T 01 01 00 0A 7B 22 7A 22 79 22 70 C1 E1 E5 C5 4D
R 00 00 00 00
T 0E 01 00 44 E1 E5 C5 E5 21 C9 3F E5 21 00 00 E5
R 00 00 00 00
T 1B 01 00 CD 00 00 E8 08 E5 D5 F8 0C 2A 66 6F E5
R 00 00 00 00 02 04 01 00
T 28 01 00 F8 0C 2A 66 6F E5 CD 00 00 E8 08 4D 44
R 00 00 00 00 02 0A 00 00
T 35 01 00 F8 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 C5
R 00 00 00 00
T 42 01 00 D5 CD 00 00 E8 08 E5 F8 0C 73 F8 0D 72
R 00 00 00 00 02 05 05 00
T 4F 01 00 E1 E5 7D F8 0E 77 E1 7C F8 0D 77 C1 E1
R 00 00 00 00
T 5C 01 00 E5 C5 4D 44 E1 E5 C5 E5 21 FD 39 E5 21
R 00 00 00 00
T 69 01 00 22 AA E5 CD 00 00 E8 08 E5 D5 F8 10 2A
R 00 00 00 00 02 07 01 00
T 76 01 00 66 6F E5 F8 10 2A 66 6F E5 CD 00 00 E8
R 00 00 00 00 02 0D 00 00
T 83 01 00 08 4D 44 F8 06 7B 22 7A 22 79 22 78 32
R 00 00 00 00
T 90 01 00 2A 66 6F E5 F8 08 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 06 00
T 9D 01 00 E8 04 4D 44 21 80 39 E5 21 00 00 E5 C5
R 00 00 00 00
T AA 01 00 D5 CD 00 00 E8 08 7B B7 28 0D AF F8 0A
R 00 00 00 00 02 05 03 00
T B7 01 00 22 22 3E 80 22 36 3F C3 91 02
R 00 00 00 00 00 0B 00 00
T C1 01 00
R 00 00 00 00
T C1 01 00 F8 08 2A 66 6F E5 F8 08 2A 66 6F E5 F8
R 00 00 00 00
T CE 01 00 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 CD
R 00 00 00 00
T DA 01 00 00 00 E8 08 4D 44 F8 0A 7B 22 7A 22 79
R 00 00 00 00 02 03 01 00
T E7 01 00 22 78 32 2A 66 6F E5 F8 0C 2A 66 6F E5
R 00 00 00 00
T F4 01 00 21 C4 BD E5 21 B8 33 E5 CD 00 00 E8 08
R 00 00 00 00 02 0C 01 00
T 01 02 00 4D 44 F8 08 2A 66 6F E5 F8 08 2A 66 6F
R 00 00 00 00
T 0E 02 00 E5 C5 D5 CD 00 00 E8 08 4D 44 F8 08 2A
R 00 00 00 00 02 07 01 00
T 1B 02 00 66 6F E5 F8 08 2A 66 6F E5 C5 D5 CD
R 00 00 00 00
T 27 02 00 00 00 E8 08 4D 44 F8 06 7B 22 7A 22 79
R 00 00 00 00 02 03 05 00
T 34 02 00 22 70 F8 0C 2A 66 6F E5 F8 0C 2A 66 6F
R 00 00 00 00
T 41 02 00 E5 21 1F 3C E5 21 75 33 E5 CD 00 00 E8
R 00 00 00 00 02 0D 01 00
T 4E 02 00 08 4D 44 21 DB BE E5 21 AF B7 E5 C5 D5
R 00 00 00 00
T 5B 02 00 CD 00 00 E8 08 4D 44 F8 0C 2A 66 6F E5
R 00 00 00 00 02 04 05 00
T 68 02 00 F8 0C 2A 66 6F E5 C5 D5 CD 00 00 E8 08
R 00 00 00 00 02 0C 01 00
T 75 02 00 4D 44 21 80 3F E5 21 00 00 E5 C5 D5 CD
R 00 00 00 00
T 82 02 00 00 00 E8 08 4D 44 F8 0A 7B 22 7A 22 79
R 00 00 00 00 02 03 05 00
T 8F 02 00 22 70
R 00 00 00 00
T 91 02 00
R 00 00 00 00
T 91 02 00 F8 04 CB 46 28 7C F8 14 CB 46 28 3B F8
R 00 00 00 00
T 9E 02 00 09 7E EE 80 F8 05 77 E5 23 7E F8 04 77
R 00 00 00 00
T AB 02 00 F8 09 7E F8 05 77 F8 0A 7E F8 06 77 E1
R 00 00 00 00
T B8 02 00 F8 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 F8
R 00 00 00 00
T C5 02 00 08 2A 66 6F E5 F8 08 2A 66 6F E5 CD
R 00 00 00 00
T D1 02 00 00 00 E8 08 C3 55 03
R 00 00 00 00 02 03 09 00 00 08 00 00
T D8 02 00
R 00 00 00 00
T D8 02 00 F8 0D 7E EE 80 F8 05 77 E5 F8 0C 7E F8
R 00 00 00 00
T E5 02 00 04 77 F8 0D 7E F8 05 77 F8 0E 7E F8 06
R 00 00 00 00
T F2 02 00 77 E1 F8 08 2A 66 6F E5 F8 08 2A 66 6F
R 00 00 00 00
T FF 02 00 E5 F8 08 2A 66 6F E5 F8 08 2A 66 6F E5
R 00 00 00 00
T 0C 03 00 CD 00 00 E8 08 18 42
R 00 00 00 00 02 04 09 00
T 13 03 00
R 00 00 00 00
T 13 03 00 F8 14 CB 46 28 1F F8 08 2A 66 6F E5 F8
R 00 00 00 00
T 20 03 00 08 2A 66 6F E5 F8 10 2A 66 6F E5 F8 10
R 00 00 00 00
T 2D 03 00 2A 66 6F E5 CD 00 00 E8 08 18 1D
R 00 00 00 00 02 08 09 00
T 38 03 00
R 00 00 00 00
T 38 03 00 F8 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 F8
R 00 00 00 00
T 45 03 00 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 CD
R 00 00 00 00
T 51 03 00 00 00 E8 08
R 00 00 00 00 02 03 09 00
T 55 03 00
R 00 00 00 00
T 55 03 00 E8 0E C9
R 00 00 00 00
tanf.rel/       0           0     0     644     474       `
XL3
H 7 areas 3 global symbols
M tanf
O -mgbz80
S _tancotf Ref000000
S .__.ABS. Def000000
A _CODE size 15 flags 0 addr 0
S _tanf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 AF F5 33 F8 05 2A 66 6F E5 F8 05 2A 66
R 00 00 00 00
T 0D 00 00 6F E5 CD 00 00 E8 05 C9
R 00 00 00 00 02 06 00 00
cotf.rel/       0           0     0     644     1100      `
XL3
H 7 areas 6 global symbols
M cotf
O -mgbz80
S _errno Ref000000
S _tancotf Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S _fabsf Ref000000
A _CODE size 6F flags 0 addr 0
S _cotf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 04 2A 66 6F E5 F8 04 2A 66 6F E5 CD
R 00 00 00 00
T 0D 00 00 00 00 E8 04 4D 44 21 A2 0D E5 21 60 42
R 00 00 00 00 02 03 04 00
T 1A 00 00 E5 C5 D5 CD 00 00 E8 08 7B B7 28 33 21
R 00 00 00 00 02 07 02 00
T 27 00 00 00 00 3E 22 22 36 00 21 00 00 E5 21
R 00 00 00 00 02 03 00 00
T 33 00 00 00 00 E5 F8 08 2A 66 6F E5 F8 08 2A 66
R 00 00 00 00
T 40 00 00 6F E5 CD 00 00 E8 08 7B B7 28 07 11
R 00 00 00 00 02 06 02 00
T 4C 00 00 FF FF 21 7F FF C9
R 00 00 00 00
T 52 00 00
R 00 00 00 00
T 52 00 00 11 FF FF 21 7F 7F C9
R 00 00 00 00
T 59 00 00
R 00 00 00 00
T 59 00 00 3E 01 F5 33 F8 05 2A 66 6F E5 F8 05 2A
R 00 00 00 00
T 66 00 00 66 6F E5 CD 00 00 E8 05 C9
R 00 00 00 00 02 07 01 00
asincosf.rel/   0           0     0     644     6429      `
XL3
H 7 areas B global symbols
M asincosf
O -mgbz80
S ___fssub Ref000000
S ___fsmul Ref000000
S _errno Ref000000
S _sqrtf Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S _fabsf Ref000000
S _ldexpf Ref000000
S ___fsdiv Ref000000
A _CODE size 3FE flags 0 addr 0
S _asincosf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F2 F8 14 7E F8 0D 77 F8 12 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 F8 12 2A 66 6F E5 CD 00 00 E8 04 4D
R 00 00 00 00 02 0B 07 00
T 1A 00 00 44 F8 01 7B 22 7A 22 79 22 70 21 80 39
R 00 00 00 00
T 27 00 00 E5 21 00 00 E5 F8 07 2A 66 6F E5 F8 07
R 00 00 00 00
T 34 00 00 2A 66 6F E5 CD 00 00 E8 08 7B B7 28 14
R 00 00 00 00 02 08 04 00
T 41 00 00 F8 01 54 5D F8 09 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 4E 00 00 22 13 1A 77 C3 1F 02
R 00 00 00 00 00 08 00 00
T 55 00 00
R 00 00 00 00
T 55 00 00 F8 03 2A 66 6F E5 F8 03 2A 66 6F E5 21
R 00 00 00 00
T 62 00 00 00 3F E5 21 00 00 E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 04 00
T 6F 00 00 B7 CA 23 01 F8 0D 7E EE 01 77 F8 03 2A
R 00 00 00 00 00 05 00 00
T 7C 00 00 66 6F E5 F8 03 2A 66 6F E5 21 80 3F E5
R 00 00 00 00
T 89 00 00 21 00 00 E5 CD 00 00 E8 08 7B B7 28 11
R 00 00 00 00 02 08 04 00
T 96 00 00 21 00 00 3E 21 22 36 00 11 00 00 21
R 00 00 00 00 02 04 02 00
T A2 00 00 00 00 C3 EB 03
R 00 00 00 00 00 06 00 00
T A7 00 00
R 00 00 00 00
T A7 00 00 F8 03 2A 66 6F E5 F8 03 2A 66 6F E5 21
R 00 00 00 00
T B4 00 00 80 3F E5 21 00 00 E5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 00 00
T C1 00 00 44 21 FF FF E5 C5 D5 CD 00 00 E8 06 4D
R 00 00 00 00 02 0B 08 00
T CE 00 00 44 F8 05 7B 22 7A 22 79 22 78 32 2A 66
R 00 00 00 00
T DB 00 00 6F E5 F8 07 2A 66 6F E5 CD 00 00 E8 04
R 00 00 00 00 02 0C 03 00
T E8 00 00 4D 44 C5 D5 C5 D5 CD 00 00 E8 08 E5 F8
R 00 00 00 00 02 0A 06 00
T F5 00 00 0B 73 F8 0C 72 E1 E5 7D F8 0D 77 E1 7C
R 00 00 00 00
T 02 01 00 F8 0C 77 F8 0C 7E EE 80 F8 04 77 E5 F8
R 00 00 00 00
T 0F 01 00 0B 7E F8 03 77 F8 0C 7E F8 04 77 F8 0D
R 00 00 00 00
T 1C 01 00 7E F8 05 77 E1 18 28
R 00 00 00 00
T 23 01 00
R 00 00 00 00
T 23 01 00 F8 03 2A 66 6F E5 F8 03 2A 66 6F E5 F8
R 00 00 00 00
T 30 01 00 07 2A 66 6F E5 F8 07 2A 66 6F E5 CD
R 00 00 00 00
T 3C 01 00 00 00 E8 08 4D 44 F8 05 7B 22 7A 22 79
R 00 00 00 00 02 03 01 00
T 49 01 00 22 70
R 00 00 00 00
T 4B 01 00
R 00 00 00 00
T 4B 01 00 F8 07 2A 66 6F E5 F8 07 2A 66 6F E5 21
R 00 00 00 00
T 58 01 00 01 BF E5 21 65 20 E5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 01 00
T 65 01 00 44 21 6F 3F E5 21 6B 16 E5 C5 D5 CD
R 00 00 00 00
T 71 01 00 00 00 E8 08 4D 44 F8 07 2A 66 6F E5 F8
R 00 00 00 00 02 03 06 00
T 7E 01 00 07 2A 66 6F E5 C5 D5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 01 00
T 8B 01 00 F8 0B 73 F8 0C 72 E1 E5 7D F8 0D 77 E1
R 00 00 00 00
T 98 01 00 7C F8 0C 77 21 B1 C0 E5 21 0B 8D E5 F8
R 00 00 00 00
T A5 01 00 0B 2A 66 6F E5 F8 0B 2A 66 6F E5 CD
R 00 00 00 00
T B1 01 00 00 00 E8 08 4D 44 F8 07 2A 66 6F E5 F8
R 00 00 00 00 02 03 06 00
T BE 01 00 07 2A 66 6F E5 C5 D5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 01 00
T CB 01 00 44 21 B3 40 E5 21 F0 50 E5 C5 D5 CD
R 00 00 00 00
T D7 01 00 00 00 E8 08 E5 D5 F8 0F 2A 66 6F E5 F8
R 00 00 00 00 02 03 06 00
T E4 01 00 0F 2A 66 6F E5 CD 00 00 E8 08 E5 D5 F8
R 00 00 00 00 02 09 09 00
T F1 01 00 07 2A 66 6F E5 F8 07 2A 66 6F E5 CD
R 00 00 00 00
T FD 01 00 00 00 E8 08 E5 D5 F8 07 2A 66 6F E5 F8
R 00 00 00 00 02 03 01 00
T 0A 02 00 07 2A 66 6F E5 CD 00 00 E8 08 4D 44 F8
R 00 00 00 00 02 09 06 00
T 17 02 00 09 7B 22 7A 22 79 22 70
R 00 00 00 00
T 1F 02 00
R 00 00 00 00
T 1F 02 00 F8 0D 4E C5 21 00 00 E5 21 00 00 E5 F8
R 00 00 00 00
T 2C 02 00 18 2A 66 6F E5 F8 18 2A 66 6F E5 CD
R 00 00 00 00
T 38 02 00 00 00 E8 08 E5 F8 11 73 E1 C1 AF CB 21
R 00 00 00 00 02 03 04 00
T 45 02 00 8F CB 21 8F F8 07 71 23 77 F8 14 CB 46
R 00 00 00 00
T 52 02 00 CA 81 03 F8 0D 7E B7 CA EF 02 11 F6 03
R 00 00 00 00 00 04 00 00 00 0B 00 00 00 0E 00 00
T 5F 02 00 F8 07 2A 66 6F 19 E5 7D F8 07 77 E1 7C
R 00 00 00 00
T 6C 02 00 F8 06 32 2A 5F 56 1A F8 00 22 13 1A 22
R 00 00 00 00
T 79 02 00 13 1A 22 13 1A 77 F8 0B 2A 66 6F E5 F8
R 00 00 00 00
T 86 02 00 0B 2A 66 6F E5 F8 06 2A 66 6F E5 F8 06
R 00 00 00 00
T 93 02 00 2A 66 6F E5 CD 00 00 E8 08 E5 F8 0C 73
R 00 00 00 00 02 08 06 00
T A0 02 00 F8 0D 72 E1 E5 7D F8 0E 77 E1 7C F8 0D
R 00 00 00 00
T AD 02 00 77 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 F8 10
R 00 00 00 00
T BA 02 00 2A 66 6F E5 F8 10 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 06 00
T C7 02 00 E8 08 E5 F8 06 73 F8 07 72 E1 E5 7D F8
R 00 00 00 00
T D4 02 00 08 77 E1 7C F8 07 77 F8 04 54 5D F8 09
R 00 00 00 00
T E1 02 00 1A 22 13 1A 22 13 1A 22 13 1A 77 C3
R 00 00 00 00
T ED 02 00 E2 03
R 00 00 00 00 00 03 00 00
T EF 02 00
R 00 00 00 00
T EF 02 00 11 EE 03 F8 07 2A 66 6F 19 E5 7D F8 07
R 00 00 00 00 00 04 00 00
T FC 02 00 77 E1 7C F8 06 32 2A 5F 56 1A F8 00 22
R 00 00 00 00
T 09 03 00 13 1A 22 13 1A 22 13 1A 77 F8 0B 2A 66
R 00 00 00 00
T 16 03 00 6F E5 F8 0B 2A 66 6F E5 F8 06 2A 66 6F
R 00 00 00 00
T 23 03 00 E5 F8 06 2A 66 6F E5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 00 00
T 30 03 00 F8 0C 73 F8 0D 72 E1 E5 7D F8 0E 77 E1
R 00 00 00 00
T 3D 03 00 7C F8 0D 77 C1 E1 E5 C5 4D 44 E1 E5 C5
R 00 00 00 00
T 4A 03 00 E5 F8 10 2A 66 6F E5 F8 10 2A 66 6F E5
R 00 00 00 00
T 57 03 00 CD 00 00 E8 08 E5 F8 06 73 F8 07 72 E1
R 00 00 00 00 02 04 06 00
T 64 03 00 E5 7D F8 08 77 E1 7C F8 07 77 F8 04 54
R 00 00 00 00
T 71 03 00 5D F8 09 1A 22 13 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 7E 03 00 77 18 61
R 00 00 00 00
T 81 03 00
R 00 00 00 00
T 81 03 00 11 EE 03 F8 07 2A 66 6F 19 4D 44 59 50
R 00 00 00 00 00 04 00 00
T 8E 03 00 1A F8 05 22 13 1A 22 13 1A 22 13 1A 77
R 00 00 00 00
T 9B 03 00 F8 0B 2A 66 6F E5 F8 0B 2A 66 6F E5 F8
R 00 00 00 00
T A8 03 00 0B 2A 66 6F E5 F8 0B 2A 66 6F E5 CD
R 00 00 00 00
T B4 03 00 00 00 E8 08 4D 44 F8 07 2A 66 6F E5 F8
R 00 00 00 00 02 03 06 00
T C1 03 00 07 2A 66 6F E5 C5 D5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 06 00
T CE 03 00 44 F8 09 7B 22 7A 22 79 22 78 22 7E B7
R 00 00 00 00
T DB 03 00 28 05 2B 7E EE 80 77
R 00 00 00 00
T E2 03 00
R 00 00 00 00
T E2 03 00 F8 09 2A 5F 2A 57 2A 66 6F
R 00 00 00 00
T EB 03 00
R 00 00 00 00
T EB 03 00 E8 0E C9
R 00 00 00 00
T EE 03 00
R 00 00 00 00
T EE 03 00 00 00 00 00 DB 0F 49 3F
R 00 00 00 00
T F6 03 00
R 00 00 00 00
T F6 03 00 DB 0F C9 3F DB 0F 49 3F
R 00 00 00 00

asinf.rel/      0           0     0     644     1072      `
XL3
H 7 areas 4 global symbols
M asinf
O -mgbz80
S ___fseq Ref000000
S .__.ABS. Def000000
S _asincosf Ref000000
A _CODE size 71 flags 0 addr 0
S _asinf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 21 80 3F E5 21 00 00 E5 F8 08 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 F8 08 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 00 00
T 1A 00 00 B7 28 07 11 DB 0F 21 C9 3F C9
R 00 00 00 00
T 24 00 00
R 00 00 00 00
T 24 00 00 21 80 BF E5 21 00 00 E5 F8 08 2A 66 6F
R 00 00 00 00
T 31 00 00 E5 F8 08 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 00 00
T 3E 00 00 B7 28 07 11 DB 0F 21 C9 BF C9
R 00 00 00 00
T 48 00 00
R 00 00 00 00
T 48 00 00 F8 05 7E CB BF 2B B6 2B B6 2B B6 20 07
R 00 00 00 00
T 55 00 00 11 00 00 21 00 00 C9
R 00 00 00 00
T 5C 00 00
R 00 00 00 00
T 5C 00 00 AF F5 33 F8 05 2A 66 6F E5 F8 05 2A 66
R 00 00 00 00
T 69 00 00 6F E5 CD 00 00 E8 05 C9
R 00 00 00 00 02 06 02 00
acosf.rel/      0           0     0     644     1075      `
XL3
H 7 areas 4 global symbols
M acosf
O -mgbz80
S ___fseq Ref000000
S .__.ABS. Def000000
S _asincosf Ref000000
A _CODE size 72 flags 0 addr 0
S _acosf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 21 80 3F E5 21 00 00 E5 F8 08 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 F8 08 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 00 00
T 1A 00 00 B7 28 07 11 00 00 21 00 00 C9
R 00 00 00 00
T 24 00 00
R 00 00 00 00
T 24 00 00 21 80 BF E5 21 00 00 E5 F8 08 2A 66 6F
R 00 00 00 00
T 31 00 00 E5 F8 08 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 00 00
T 3E 00 00 B7 28 07 11 DB 0F 21 49 40 C9
R 00 00 00 00
T 48 00 00
R 00 00 00 00
T 48 00 00 F8 05 7E CB BF 2B B6 2B B6 2B B6 20 07
R 00 00 00 00
T 55 00 00 11 DB 0F 21 C9 3F C9
R 00 00 00 00
T 5C 00 00
R 00 00 00 00
T 5C 00 00 3E 01 F5 33 F8 05 2A 66 6F E5 F8 05 2A
R 00 00 00 00
T 69 00 00 66 6F E5 CD 00 00 E8 05 C9
R 00 00 00 00 02 07 02 00

atanf.rel/      0           0     0     644     4518      `
XL3
H 7 areas 8 global symbols
M atanf
O -mgbz80
S ___fssub Ref000000
S ___fsmul Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S _fabsf Ref000000
S ___fsdiv Ref000000
A _CODE size 2B4 flags 0 addr 0
S _atanf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F2 AF F8 0C 22 77 F8 12 2A 66 6F E5
R 00 00 00 00
T 0D 00 00 F8 12 2A 66 6F E5 CD 00 00 E8 04 4D 44
R 00 00 00 00 02 0A 05 00
T 1A 00 00 33 33 D5 F8 02 79 22 70 C1 E1 E5 C5 4D
R 00 00 00 00
T 27 00 00 44 E1 E5 C5 E5 21 80 3F E5 21 00 00 E5
R 00 00 00 00
T 34 00 00 CD 00 00 E8 08 7B B7 28 28 C1 E1 E5 C5
R 00 00 00 00 02 04 02 00
T 41 00 00 4D 44 E1 E5 C5 E5 21 80 3F E5 21 00 00
R 00 00 00 00
T 4E 00 00 E5 CD 00 00 E8 08 4D 44 33 33 D5 F8 02
R 00 00 00 00 02 05 06 00
T 5B 00 00 79 22 70 F8 0C 36 02 AF 23 77
R 00 00 00 00
T 65 00 00
R 00 00 00 00
T 65 00 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 21 89 3E
R 00 00 00 00
T 72 00 00 E5 21 A3 30 E5 CD 00 00 E8 08 7B B7 CA
R 00 00 00 00 02 09 02 00
T 7F 00 00 0D 01 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 21
R 00 00 00 00 00 03 00 00
T 8C 00 00 3B 3F E5 21 AF 67 E5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 01 00
T 99 00 00 44 21 80 3F E5 21 00 00 E5 C5 D5 CD
R 00 00 00 00
T A5 00 00 00 00 E8 08 4D 44 F8 02 2A 66 6F E5 F8
R 00 00 00 00 02 03 00 00
T B2 00 00 02 2A 66 6F E5 C5 D5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 04 00
T BF 00 00 F8 0A 73 F8 0B 72 E1 E5 7D F8 0C 77 E1
R 00 00 00 00
T CC 00 00 7C F8 0B 77 21 DD 3F E5 21 D7 B3 E5 F8
R 00 00 00 00
T D9 00 00 06 2A 66 6F E5 F8 06 2A 66 6F E5 CD
R 00 00 00 00
T E5 00 00 00 00 E8 08 E5 D5 F8 0E 2A 66 6F E5 F8
R 00 00 00 00 02 03 04 00
T F2 00 00 0E 2A 66 6F E5 CD 00 00 E8 08 4D 44 33
R 00 00 00 00 02 09 06 00
T FF 00 00 33 D5 F8 02 79 22 70 F8 0C 34 20 02 23
R 00 00 00 00
T 0C 01 00 34
R 00 00 00 00
T 0D 01 00
R 00 00 00 00
T 0D 01 00
R 00 00 00 00
T 0D 01 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 CD 00 00
R 00 00 00 00 02 0E 05 00
T 1A 01 00 E8 04 4D 44 21 80 39 E5 21 00 00 E5 C5
R 00 00 00 00
T 27 01 00 D5 CD 00 00 E8 08 7B B7 28 14 F8 00 54
R 00 00 00 00 02 05 02 00
T 34 01 00 5D F8 08 1A 22 13 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 41 01 00 77 C3 1A 02
R 00 00 00 00 00 05 00 00
T 45 01 00
R 00 00 00 00
T 45 01 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 F8 06 2A
R 00 00 00 00
T 52 01 00 66 6F E5 F8 06 2A 66 6F E5 CD 00 00 E8
R 00 00 00 00 02 0D 01 00
T 5F 01 00 08 4D 44 F8 04 7B 22 7A 22 79 22 78 32
R 00 00 00 00
T 6C 01 00 2A 66 6F E5 F8 06 2A 66 6F E5 21 50 BD
R 00 00 00 00
T 79 01 00 E5 21 91 86 E5 CD 00 00 E8 08 4D 44 21
R 00 00 00 00 02 09 01 00
T 86 01 00 F1 BE E5 21 F6 10 E5 C5 D5 CD 00 00 E8
R 00 00 00 00 02 0D 04 00
T 93 01 00 08 4D 44 F8 06 2A 66 6F E5 F8 06 2A 66
R 00 00 00 00
T A0 01 00 6F E5 C5 D5 CD 00 00 E8 08 4D 44 F8 02
R 00 00 00 00 02 08 01 00
T AD 01 00 2A 66 6F E5 F8 02 2A 66 6F E5 C5 D5 CD
R 00 00 00 00
T BA 01 00 00 00 E8 08 E5 F8 0A 73 F8 0B 72 E1 E5
R 00 00 00 00 02 03 01 00
T C7 01 00 7D F8 0C 77 E1 7C F8 0B 77 21 B4 3F E5
R 00 00 00 00
T D4 01 00 21 D3 CC E5 F8 0A 2A 66 6F E5 F8 0A 2A
R 00 00 00 00
T E1 01 00 66 6F E5 CD 00 00 E8 08 E5 D5 F8 0E 2A
R 00 00 00 00 02 07 04 00
T EE 01 00 66 6F E5 F8 0E 2A 66 6F E5 CD 00 00 E8
R 00 00 00 00 02 0D 06 00
T FB 01 00 08 E5 D5 F8 06 2A 66 6F E5 F8 06 2A 66
R 00 00 00 00
T 08 02 00 6F E5 CD 00 00 E8 08 4D 44 F8 08 7B 22
R 00 00 00 00 02 06 04 00
T 15 02 00 7A 22 79 22 70
R 00 00 00 00
T 1A 02 00
R 00 00 00 00
T 1A 02 00 F8 0C 3E 01 96 23 3E 00 9E 3E 00 57 CB
R 00 00 00 00
T 27 02 00 7E 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 31 02 00
R 00 00 00 00
T 31 02 00 CB 7A 28 01 37
R 00 00 00 00
T 36 02 00
R 00 00 00 00
T 36 02 00 30 06 F8 0B 7E EE 80 77
R 00 00 00 00
T 3E 02 00
R 00 00 00 00
T 3E 02 00 F8 0C 2A 4F 46 CB 21 CB 10 CB 21 CB 10
R 00 00 00 00
T 4B 02 00 21 A4 02 09 2A 4F 2A 47 23 3A 6E 67 E5
R 00 00 00 00 00 04 00 00
T 58 02 00 C5 F8 0E 2A 66 6F E5 F8 0E 2A 66 6F E5
R 00 00 00 00
T 65 02 00 CD 00 00 E8 08 4D 44 F8 0A 7B 22 7A 22
R 00 00 00 00 02 04 04 00
T 72 02 00 79 22 70 21 00 00 E5 21 00 00 E5 F8 16
R 00 00 00 00
T 7F 02 00 2A 66 6F E5 F8 16 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 02 00
T 8C 02 00 E8 08 7B B7 28 06 F8 0D 7E EE 80 77
R 00 00 00 00
T 98 02 00
R 00 00 00 00
T 98 02 00 F8 0A 2A 5F 2A 57 2A 66 6F E8 0E C9
R 00 00 00 00
T A4 02 00
R 00 00 00 00
T A4 02 00 00 00 00 00 92 0A 06 3F DB 0F C9 3F 92
R 00 00 00 00
T B1 02 00 0A 86 3F
R 00 00 00 00
atan2f.rel/     0           0     0     644     3057      `
XL3
H 7 areas 8 global symbols
M atan2f
O -mgbz80
S _errno Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S _fabsf Ref000000
S _atanf Ref000000
S ___fsdiv Ref000000
A _CODE size 1A5 flags 0 addr 0
S _atan2f Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F7 F8 0E 7E CB BF 2B B6 2B B6 2B B6
R 00 00 00 00
T 0D 00 00 20 1E F8 12 7E CB BF 2B B6 2B B6 2B B6
R 00 00 00 00
T 1A 00 00 20 11 21 00 00 3E 21 22 36 00 11 00 00
R 00 00 00 00 02 06 00 00
T 27 00 00 21 00 00 C3 A2 01
R 00 00 00 00 00 07 00 00
T 2D 00 00
R 00 00 00 00
T 2D 00 00 F8 11 2A 66 6F E5 F8 11 2A 66 6F E5 CD
R 00 00 00 00
T 3A 00 00 00 00 E8 04 E5 F8 07 73 F8 08 72 E1 E5
R 00 00 00 00 02 03 04 00
T 47 00 00 7D F8 09 77 E1 7C F8 08 77 F8 0D 2A 66
R 00 00 00 00
T 54 00 00 6F E5 F8 0D 2A 66 6F E5 CD 00 00 E8 04
R 00 00 00 00 02 0C 04 00
T 61 00 00 E5 D5 21 00 00 E5 21 00 00 E5 F8 15 2A
R 00 00 00 00
T 6E 00 00 66 6F E5 F8 15 2A 66 6F E5 CD 00 00 E8
R 00 00 00 00 02 0D 01 00
T 7B 00 00 08 E5 F8 0A 73 E1 F8 0B 2A 66 6F E5 F8
R 00 00 00 00
T 88 00 00 0B 2A 66 6F E5 CD 00 00 E8 08 43 CB 40
R 00 00 00 00 02 09 01 00
T 95 00 00 C2 1A 01 F8 11 2A 66 6F E5 F8 11 2A 66
R 00 00 00 00 00 04 00 00
T A2 00 00 6F E5 F8 11 2A 66 6F E5 F8 11 2A 66 6F
R 00 00 00 00
T AF 00 00 E5 CD 00 00 E8 08 E5 D5 CD 00 00 E8 04
R 00 00 00 00 02 05 06 00 02 0C 05 00
T BC 00 00 4D 44 F8 05 7B 22 7A 22 79 22 70 21
R 00 00 00 00
T C8 00 00 00 00 E5 21 00 00 E5 F8 15 2A 66 6F E5
R 00 00 00 00
T D5 00 00 F8 15 2A 66 6F E5 CD 00 00 E8 08 7B B7
R 00 00 00 00 02 0A 01 00
T E2 00 00 CA 99 01 F8 04 CB 46 20 08 01 DB 0F 11
R 00 00 00 00 00 04 00 00
T EF 00 00 49 40 18 06
R 00 00 00 00
T F3 00 00
R 00 00 00 00
T F3 00 00 01 DB 0F 11 49 C0
R 00 00 00 00
T F9 00 00
R 00 00 00 00
T F9 00 00 D5 C5 F8 0B 2A 66 6F E5 F8 0B 2A 66 6F
R 00 00 00 00
T 06 01 00 E5 CD 00 00 E8 08 4D 44 F8 05 7B 22 7A
R 00 00 00 00 02 05 03 00
T 13 01 00 22 79 22 70 C3 99 01
R 00 00 00 00 00 08 00 00
T 1A 01 00
R 00 00 00 00
T 1A 01 00 F8 0D 2A 66 6F E5 F8 0D 2A 66 6F E5 F8
R 00 00 00 00
T 27 01 00 15 2A 66 6F E5 F8 15 2A 66 6F E5 CD
R 00 00 00 00
T 33 01 00 00 00 E8 08 E5 D5 CD 00 00 E8 04 33 33
R 00 00 00 00 02 03 06 00 02 0A 05 00
T 40 01 00 D5 E5 7D F8 04 77 E1 7C F8 03 77 F8 03
R 00 00 00 00
T 4D 01 00 7E EE 80 F8 08 77 E5 F8 02 7E F8 07 77
R 00 00 00 00
T 5A 01 00 F8 03 7E F8 08 77 F8 04 7E F8 09 77 E1
R 00 00 00 00
T 67 01 00 F8 04 7E B7 28 08 01 DB 0F 11 C9 BF 18
R 00 00 00 00
T 74 01 00 06
R 00 00 00 00
T 75 01 00
R 00 00 00 00
T 75 01 00 01 DB 0F 11 C9 3F
R 00 00 00 00
T 7B 01 00
R 00 00 00 00
T 7B 01 00 D5 C5 F8 0B 2A 66 6F E5 F8 0B 2A 66 6F
R 00 00 00 00
T 88 01 00 E5 CD 00 00 E8 08 4D 44 F8 05 7B 22 7A
R 00 00 00 00 02 05 03 00
T 95 01 00 22 79 22 70
R 00 00 00 00
T 99 01 00
R 00 00 00 00
T 99 01 00 F8 05 2A 5F 2A 57 2A 66 6F
R 00 00 00 00
T A2 01 00
R 00 00 00 00
T A2 01 00 E8 09 C9
R 00 00 00 00

sincoshf.rel/   0           0     0     644     6458      `
XL3
H 7 areas 9 global symbols
M sincoshf
O -mgbz80
S ___fssub Ref000000
S ___fsmul Ref000000
S _errno Ref000000
S _expf Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S ___fsdiv Ref000000
A _CODE size 42D flags 0 addr 0
S _sincoshf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F3 F8 0F 54 5D F8 09 1A 22 13 1A 22
R 00 00 00 00
T 0D 00 00 13 1A 22 13 1A 77 21 00 00 E5 21 00 00
R 00 00 00 00
T 1A 00 00 E5 F8 15 2A 66 6F E5 F8 15 2A 66 6F E5
R 00 00 00 00
T 27 00 00 CD 00 00 E8 08 E5 F8 0A 73 E1 F8 08 7E
R 00 00 00 00 02 04 04 00
T 34 00 00 B7 28 33 F8 12 7E EE 80 F8 08 77 E5 F8
R 00 00 00 00
T 41 00 00 11 7E F8 07 77 F8 12 7E F8 08 77 F8 13
R 00 00 00 00
T 4E 00 00 7E F8 09 77 E1 F8 05 54 5D F8 00 1A 22
R 00 00 00 00
T 5B 00 00 13 1A 22 13 1A 22 13 1A 77 F8 04 36 01
R 00 00 00 00
T 68 00 00 18 15
R 00 00 00 00
T 6A 00 00
R 00 00 00 00
T 6A 00 00 F8 09 54 5D F8 00 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 77 00 00 22 13 1A 77 AF F8 04 77
R 00 00 00 00
T 7F 00 00
R 00 00 00 00
T 7F 00 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 21 80 3F
R 00 00 00 00
T 8C 00 00 E5 21 00 00 E5 CD 00 00 E8 08 E5 F8 0A
R 00 00 00 00 02 09 04 00
T 99 00 00 73 E1 F8 08 7E B7 20 07 F8 13 CB 46 CA
R 00 00 00 00
T A6 00 00 86 02
R 00 00 00 00 00 03 00 00
T A8 00 00
R 00 00 00 00
T A8 00 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 21 10 41
R 00 00 00 00
T B5 00 00 E5 21 00 00 E5 CD 00 00 E8 08 E5 F8 0E
R 00 00 00 00 02 09 04 00
T C2 00 00 73 E1 F8 0C 7E B7 CA BA 01 21 31 3F E5
R 00 00 00 00 00 0A 00 00
T CF 00 00 21 00 73 E5 F8 06 2A 66 6F E5 F8 06 2A
R 00 00 00 00
T DC 00 00 66 6F E5 CD 00 00 E8 08 E5 F8 0B 73 F8
R 00 00 00 00 02 07 00 00
T E9 00 00 0C 72 E1 E5 7D F8 0D 77 E1 7C F8 0C 77
R 00 00 00 00
T F6 00 00 F8 0B 2A 66 6F E5 F8 0B 2A 66 6F E5 21
R 00 00 00 00
T 03 01 00 33 42 E5 21 CF BD E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 04 00
T 10 01 00 B7 28 16 21 00 00 3E 22 22 36 00 F8 09
R 00 00 00 00 02 07 02 00
T 1D 01 00 3E FF 22 22 3E 7F 22 36 7F C3 76 02
R 00 00 00 00 00 0D 00 00
T 29 01 00
R 00 00 00 00
T 29 01 00 F8 0B 2A 66 6F E5 F8 0B 2A 66 6F E5 CD
R 00 00 00 00
T 36 01 00 00 00 E8 04 E5 F8 0B 73 F8 0C 72 E1 E5
R 00 00 00 00 02 03 03 00
T 43 01 00 7D F8 0D 77 E1 7C F8 0C 77 F8 09 54 5D
R 00 00 00 00
T 50 01 00 F8 05 1A 22 13 1A 22 13 1A 22 13 1A 77
R 00 00 00 00
T 5D 01 00 F8 07 2A 66 6F E5 F8 07 2A 66 6F E5 21
R 00 00 00 00
T 6A 01 00 68 37 E5 21 97 08 E5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 01 00
T 77 01 00 F8 0B 73 F8 0C 72 E1 E5 7D F8 0D 77 E1
R 00 00 00 00
T 84 01 00 7C F8 0C 77 F8 0B 2A 66 6F E5 F8 0B 2A
R 00 00 00 00
T 91 01 00 66 6F E5 F8 0B 2A 66 6F E5 F8 0B 2A 66
R 00 00 00 00
T 9E 01 00 6F E5 CD 00 00 E8 08 E5 F8 0B 73 F8 0C
R 00 00 00 00 02 06 06 00
T AB 01 00 72 E1 E5 7D F8 0D 77 E1 7C F8 0C 77 C3
R 00 00 00 00
T B8 01 00 76 02
R 00 00 00 00 00 03 00 00
T BA 01 00
R 00 00 00 00
T BA 01 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 CD 00 00
R 00 00 00 00 02 0E 03 00
T C7 01 00 E8 04 E5 F8 0B 73 F8 0C 72 E1 E5 7D F8
R 00 00 00 00
T D4 01 00 0D 77 E1 7C F8 0C 77 F8 09 54 5D F8 05
R 00 00 00 00
T E1 01 00 1A 22 13 1A 22 13 1A 22 13 1A 77 F8 07
R 00 00 00 00
T EE 01 00 2A 66 6F E5 F8 07 2A 66 6F E5 21 80 3F
R 00 00 00 00
T FB 01 00 E5 21 00 00 E5 CD 00 00 E8 08 E5 F8 0B
R 00 00 00 00 02 09 07 00
T 08 02 00 73 F8 0C 72 E1 E5 7D F8 0D 77 E1 7C F8
R 00 00 00 00
T 15 02 00 0C 77 F8 13 CB 46 20 06 F8 0C 7E EE 80
R 00 00 00 00
T 22 02 00 77
R 00 00 00 00
T 23 02 00
R 00 00 00 00
T 23 02 00 F8 0B 2A 66 6F E5 F8 0B 2A 66 6F E5 F8
R 00 00 00 00
T 30 02 00 0B 2A 66 6F E5 F8 0B 2A 66 6F E5 CD
R 00 00 00 00
T 3C 02 00 00 00 E8 08 E5 F8 0B 73 F8 0C 72 E1 E5
R 00 00 00 00 02 03 06 00
T 49 02 00 7D F8 0D 77 E1 7C F8 0C 77 F8 0B 2A 66
R 00 00 00 00
T 56 02 00 6F E5 F8 0B 2A 66 6F E5 21 00 3F E5 21
R 00 00 00 00
T 63 02 00 00 00 E5 CD 00 00 E8 08 4D 44 F8 09 7B
R 00 00 00 00 02 07 01 00
T 70 02 00 22 7A 22 79 22 70
R 00 00 00 00
T 76 02 00
R 00 00 00 00
T 76 02 00 F8 04 CB 46 CA 21 04 F8 0C 7E EE 80 77
R 00 00 00 00 00 08 00 00
T 83 02 00 C3 21 04
R 00 00 00 00 00 04 00 00
T 86 02 00
R 00 00 00 00
T 86 02 00 21 80 39 E5 21 00 00 E5 F8 06 2A 66 6F
R 00 00 00 00
T 93 02 00 E5 F8 06 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 04 00
T A0 02 00 B7 C2 21 04 F8 11 2A 66 6F E5 F8 11 2A
R 00 00 00 00 00 05 00 00
T AD 02 00 66 6F E5 F8 15 2A 66 6F E5 F8 15 2A 66
R 00 00 00 00
T BA 02 00 6F E5 CD 00 00 E8 08 E5 F8 0B 73 F8 0C
R 00 00 00 00 02 06 01 00
T C7 02 00 72 E1 E5 7D F8 0D 77 E1 7C F8 0C 77 F8
R 00 00 00 00
T D4 02 00 09 54 5D F8 01 1A 22 13 1A 22 13 1A 22
R 00 00 00 00
T E1 02 00 13 1A 77 F8 03 2A 66 6F E5 F8 03 2A 66
R 00 00 00 00
T EE 02 00 6F E5 F8 15 2A 66 6F E5 F8 15 2A 66 6F
R 00 00 00 00
T FB 02 00 E5 CD 00 00 E8 08 E5 F8 07 73 F8 08 72
R 00 00 00 00 02 05 01 00
T 08 03 00 E1 E5 7D F8 09 77 E1 7C F8 08 77 F8 03
R 00 00 00 00
T 15 03 00 2A 66 6F E5 F8 03 2A 66 6F E5 21 42 BE
R 00 00 00 00
T 22 03 00 E5 21 EA E6 E5 CD 00 00 E8 08 E5 F8 0B
R 00 00 00 00 02 09 01 00
T 2F 03 00 73 F8 0C 72 E1 E5 7D F8 0D 77 E1 7C F8
R 00 00 00 00
T 3C 03 00 0C 77 21 E4 C0 E5 21 F0 69 E5 F8 0F 2A
R 00 00 00 00
T 49 03 00 66 6F E5 F8 0F 2A 66 6F E5 CD 00 00 E8
R 00 00 00 00 02 0D 06 00
T 56 03 00 08 E5 F8 0B 73 F8 0C 72 E1 E5 7D F8 0D
R 00 00 00 00
T 63 03 00 77 E1 7C F8 0C 77 F8 0B 2A 66 6F E5 F8
R 00 00 00 00
T 70 03 00 0B 2A 66 6F E5 F8 0B 2A 66 6F E5 F8 0B
R 00 00 00 00
T 7D 03 00 2A 66 6F E5 CD 00 00 E8 08 E5 F8 0B 73
R 00 00 00 00 02 08 01 00
T 8A 03 00 F8 0C 72 E1 E5 7D F8 0D 77 E1 7C F8 0C
R 00 00 00 00
T 97 03 00 77 21 2B C2 E5 21 93 4F E5 F8 07 2A 66
R 00 00 00 00
T A4 03 00 6F E5 F8 07 2A 66 6F E5 CD 00 00 E8 08
R 00 00 00 00 02 0C 06 00
T B1 03 00 E5 F8 07 73 F8 08 72 E1 E5 7D F8 09 77
R 00 00 00 00
T BE 03 00 E1 7C F8 08 77 F8 07 2A 66 6F E5 F8 07
R 00 00 00 00
T CB 03 00 2A 66 6F E5 F8 0F 2A 66 6F E5 F8 0F 2A
R 00 00 00 00
T D8 03 00 66 6F E5 CD 00 00 E8 08 E5 F8 0B 73 F8
R 00 00 00 00 02 07 07 00
T E5 03 00 0C 72 E1 E5 7D F8 0D 77 E1 7C F8 0C 77
R 00 00 00 00
T F2 03 00 F8 0B 2A 66 6F E5 F8 0B 2A 66 6F E5 F8
R 00 00 00 00
T FF 03 00 15 2A 66 6F E5 F8 15 2A 66 6F E5 CD
R 00 00 00 00
T 0B 04 00 00 00 E8 08 E5 F8 0B 73 F8 0C 72 E1 E5
R 00 00 00 00 02 03 06 00
T 18 04 00 7D F8 0D 77 E1 7C F8 0C 77
R 00 00 00 00
T 21 04 00
R 00 00 00 00
T 21 04 00 F8 09 2A 5F 2A 57 2A 66 6F E8 0D C9
R 00 00 00 00
sinhf.rel/      0           0     0     644     477       `
XL3
H 7 areas 3 global symbols
M sinhf
O -mgbz80
S .__.ABS. Def000000
S _sincoshf Ref000000
A _CODE size 15 flags 0 addr 0
S _sinhf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 AF F5 33 F8 05 2A 66 6F E5 F8 05 2A 66
R 00 00 00 00
T 0D 00 00 6F E5 CD 00 00 E8 05 C9
R 00 00 00 00 02 06 01 00

coshf.rel/      0           0     0     644     480       `
XL3
H 7 areas 3 global symbols
M coshf
O -mgbz80
S .__.ABS. Def000000
S _sincoshf Ref000000
A _CODE size 16 flags 0 addr 0
S _coshf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 3E 01 F5 33 F8 05 2A 66 6F E5 F8 05 2A
R 00 00 00 00
T 0D 00 00 66 6F E5 CD 00 00 E8 05 C9
R 00 00 00 00 02 07 01 00
tanhf.rel/      0           0     0     644     4032      `
XL3
H 7 areas 9 global symbols
M tanhf
O -mgbz80
S ___fssub Ref000000
S ___fsmul Ref000000
S _expf Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
S ___fsadd Ref000000
S _fabsf Ref000000
S ___fsdiv Ref000000
A _CODE size 278 flags 0 addr 0
S _tanhf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F4 F8 10 2A 66 6F E5 F8 10 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 CD 00 00 E8 04 4D 44 33 33 D5 F8 02
R 00 00 00 00 02 05 06 00
T 1A 00 00 79 22 70 C1 E1 E5 C5 4D 44 E1 E5 C5 E5
R 00 00 00 00
T 27 00 00 21 10 41 E5 21 B0 2C E5 CD 00 00 E8 08
R 00 00 00 00 02 0C 03 00
T 34 00 00 E5 F8 0D 73 E1 F8 0B 7E B7 28 0D AF F8
R 00 00 00 00
T 41 00 00 08 22 22 3E 80 22 36 3F C3 49 02
R 00 00 00 00 00 0C 00 00
T 4C 00 00
R 00 00 00 00
T 4C 00 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 21 0C 3F
R 00 00 00 00
T 59 00 00 E5 21 54 9F E5 CD 00 00 E8 08 7B B7 28
R 00 00 00 00 02 09 03 00
T 66 00 00 6A C1 E1 E5 C5 4D 44 E1 E5 C5 E5 F8 06
R 00 00 00 00
T 73 00 00 2A 66 6F E5 F8 06 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 05 00
T 80 00 00 E8 08 E5 D5 CD 00 00 E8 04 4D 44 21
R 00 00 00 00 02 08 02 00
T 8C 00 00 80 3F E5 21 00 00 E5 C5 D5 CD 00 00 E8
R 00 00 00 00 02 0D 05 00
T 99 00 00 08 E5 D5 21 80 3F E5 21 00 00 E5 CD
R 00 00 00 00
T A5 00 00 00 00 E8 08 E5 D5 21 00 3F E5 21 00 00
R 00 00 00 00 02 03 07 00
T B2 00 00 E5 CD 00 00 E8 08 4D 44 C5 D5 C5 D5 CD
R 00 00 00 00 02 05 00 00
T BF 00 00 00 00 E8 08 4D 44 F8 08 7B 22 7A 22 79
R 00 00 00 00 02 03 05 00
T CC 00 00 22 70 C3 49 02
R 00 00 00 00 00 06 00 00
T D1 00 00
R 00 00 00 00
T D1 00 00 21 80 39 E5 21 00 00 E5 F8 06 2A 66 6F
R 00 00 00 00
T DE 00 00 E5 F8 06 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 03 00
T EB 00 00 B7 28 14 F8 00 54 5D F8 08 1A 22 13 1A
R 00 00 00 00
T F8 00 00 22 13 1A 22 13 1A 77 C3 49 02
R 00 00 00 00 00 0B 00 00
T 02 01 00
R 00 00 00 00
T 02 01 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 F8 06 2A
R 00 00 00 00
T 0F 01 00 66 6F E5 F8 06 2A 66 6F E5 CD 00 00 E8
R 00 00 00 00 02 0D 01 00
T 1C 01 00 08 E5 F8 0A 73 F8 0B 72 E1 E5 7D F8 0C
R 00 00 00 00
T 29 01 00 77 E1 7C F8 0B 77 F8 0A 2A 66 6F E5 F8
R 00 00 00 00
T 36 01 00 0A 2A 66 6F E5 21 7B BB E5 21 B2 11 E5
R 00 00 00 00
T 43 01 00 CD 00 00 E8 08 E5 F8 06 73 F8 07 72 E1
R 00 00 00 00 02 04 01 00
T 50 01 00 E5 7D F8 08 77 E1 7C F8 07 77 21 52 BF
R 00 00 00 00
T 5D 01 00 E5 21 C6 E2 E5 F8 0A 2A 66 6F E5 F8 0A
R 00 00 00 00
T 6A 01 00 2A 66 6F E5 CD 00 00 E8 08 E5 F8 06 73
R 00 00 00 00 02 08 05 00
T 77 01 00 F8 07 72 E1 E5 7D F8 08 77 E1 7C F8 07
R 00 00 00 00
T 84 01 00 77 F8 0A 2A 66 6F E5 F8 0A 2A 66 6F E5
R 00 00 00 00
T 91 01 00 F8 0A 2A 66 6F E5 F8 0A 2A 66 6F E5 CD
R 00 00 00 00
T 9E 01 00 00 00 E8 08 E5 F8 06 73 F8 07 72 E1 E5
R 00 00 00 00 02 03 01 00
T AB 01 00 7D F8 08 77 E1 7C F8 07 77 21 1E 40 E5
R 00 00 00 00
T B8 01 00 21 1A 2A E5 F8 0E 2A 66 6F E5 F8 0E 2A
R 00 00 00 00
T C5 01 00 66 6F E5 CD 00 00 E8 08 E5 F8 0A 73 F8
R 00 00 00 00 02 07 05 00
T D2 01 00 0B 72 E1 E5 7D F8 0C 77 E1 7C F8 0B 77
R 00 00 00 00
T DF 01 00 F8 0A 2A 66 6F E5 F8 0A 2A 66 6F E5 F8
R 00 00 00 00
T EC 01 00 0A 2A 66 6F E5 F8 0A 2A 66 6F E5 CD
R 00 00 00 00
T F8 01 00 00 00 E8 08 E5 F8 0A 73 F8 0B 72 E1 E5
R 00 00 00 00 02 03 07 00
T 05 02 00 7D F8 0C 77 E1 7C F8 0B 77 F8 0A 2A 66
R 00 00 00 00
T 12 02 00 6F E5 F8 0A 2A 66 6F E5 F8 06 2A 66 6F
R 00 00 00 00
T 1F 02 00 E5 F8 06 2A 66 6F E5 CD 00 00 E8 08 E5
R 00 00 00 00 02 0B 01 00
T 2C 02 00 D5 F8 06 2A 66 6F E5 F8 06 2A 66 6F E5
R 00 00 00 00
T 39 02 00 CD 00 00 E8 08 4D 44 F8 08 7B 22 7A 22
R 00 00 00 00 02 04 05 00
T 46 02 00 79 22 70
R 00 00 00 00
T 49 02 00
R 00 00 00 00
T 49 02 00 21 00 00 E5 21 00 00 E5 F8 14 2A 66 6F
R 00 00 00 00
T 56 02 00 E5 F8 14 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 03 00
T 63 02 00 B7 28 06 F8 0B 7E EE 80 77
R 00 00 00 00
T 6C 02 00
R 00 00 00 00
T 6C 02 00 F8 08 2A 5F 2A 57 2A 66 6F E8 0C C9
R 00 00 00 00
floorf.rel/     0           0     0     644     1765      `
XL3
H 7 areas 5 global symbols
M floorf
O -mgbz80
S ___slong2fs Ref000000
S ___fs2slong Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
A _CODE size D6 flags 0 addr 0
S _floorf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F4 F8 10 2A 66 6F E5 F8 10 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 CD 00 00 E8 04 4D 44 33 33 D5 F8 02
R 00 00 00 00 02 05 01 00
T 1A 00 00 79 22 70 C1 E1 E5 C5 4D 44 E1 E5 C5 E5
R 00 00 00 00
T 27 00 00 CD 00 00 E8 04 E5 F8 0A 73 F8 0B 72 E1
R 00 00 00 00 02 04 00 00
T 34 00 00 E5 7D F8 0C 77 E1 7C F8 0B 77 F8 00 3E
R 00 00 00 00
T 41 00 00 00 96 23 3E 00 9E 23 3E 00 9E 23 3E 00
R 00 00 00 00
T 4E 00 00 9E 3E 00 57 CB 7E 28 07 CB 7A 20 08 BF
R 00 00 00 00
T 5B 00 00 18 05
R 00 00 00 00
T 5D 00 00
R 00 00 00 00
T 5D 00 00 CB 7A 28 01 37
R 00 00 00 00
T 62 00 00
R 00 00 00 00
T 62 00 00 38 66 F8 0A 2A 66 6F E5 F8 0A 2A 66 6F
R 00 00 00 00
T 6F 00 00 E5 F8 14 2A 66 6F E5 F8 14 2A 66 6F E5
R 00 00 00 00
T 7C 00 00 CD 00 00 E8 08 7B B7 28 05 01 FF FF 18
R 00 00 00 00 02 04 02 00
T 89 00 00 03
R 00 00 00 00
T 8A 00 00
R 00 00 00 00
T 8A 00 00 01 00 00
R 00 00 00 00
T 8D 00 00
R 00 00 00 00
T 8D 00 00 F8 04 71 78 23 77 17 9F 23 22 77 D1 D5
R 00 00 00 00
T 9A 00 00 7B F8 04 86 5F 7A 23 8E F5 F8 0B 32 73
R 00 00 00 00
T A7 00 00 F8 04 2A 5F 56 F8 08 F1 7B 8E 5F 7A 23
R 00 00 00 00
T B4 00 00 8E F8 0B 32 73 2A 66 6F E5 F8 0A 2A 66
R 00 00 00 00
T C1 00 00 6F E5 CD 00 00 E8 04 18 09
R 00 00 00 00 02 06 00 00
T CA 00 00
R 00 00 00 00
T CA 00 00 F8 08 2A 5F 2A 57 2A 66 6F
R 00 00 00 00
T D3 00 00
R 00 00 00 00
T D3 00 00 E8 0C C9
R 00 00 00 00

ceilf.rel/      0           0     0     644     1738      `
XL3
H 7 areas 5 global symbols
M ceilf
O -mgbz80
S ___slong2fs Ref000000
S ___fs2slong Ref000000
S ___fslt Ref000000
S .__.ABS. Def000000
A _CODE size D6 flags 0 addr 0
S _ceilf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F4 F8 10 2A 66 6F E5 F8 10 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 CD 00 00 E8 04 4D 44 33 33 D5 F8 02
R 00 00 00 00 02 05 01 00
T 1A 00 00 79 22 70 C1 E1 E5 C5 4D 44 E1 E5 C5 E5
R 00 00 00 00
T 27 00 00 CD 00 00 E8 04 E5 F8 0A 73 F8 0B 72 E1
R 00 00 00 00 02 04 00 00
T 34 00 00 E5 7D F8 0C 77 E1 7C F8 0B 77 F8 00 7E
R 00 00 00 00
T 41 00 00 D6 00 23 7E DE 00 23 7E DE 00 23 7E DE
R 00 00 00 00
T 4E 00 00 00 56 3E 00 CB 7F 28 07 CB 7A 20 08 BF
R 00 00 00 00
T 5B 00 00 18 05
R 00 00 00 00
T 5D 00 00
R 00 00 00 00
T 5D 00 00 CB 7A 28 01 37
R 00 00 00 00
T 62 00 00
R 00 00 00 00
T 62 00 00 30 0B F8 08 2A 5F 2A 57 2A 66 6F 18 64
R 00 00 00 00
T 6F 00 00
R 00 00 00 00
T 6F 00 00 F8 10 2A 66 6F E5 F8 10 2A 66 6F E5 F8
R 00 00 00 00
T 7C 00 00 0E 2A 66 6F E5 F8 0E 2A 66 6F E5 CD
R 00 00 00 00
T 88 00 00 00 00 E8 08 7B B7 28 05 01 01 00 18 03
R 00 00 00 00 02 03 02 00
T 95 00 00
R 00 00 00 00
T 95 00 00 01 00 00
R 00 00 00 00
T 98 00 00
R 00 00 00 00
T 98 00 00 F8 04 71 78 23 77 17 9F 23 22 77 D1 D5
R 00 00 00 00
T A5 00 00 7B F8 04 86 5F 7A 23 8E F5 F8 0B 32 73
R 00 00 00 00
T B2 00 00 F8 04 2A 5F 56 F8 08 F1 7B 8E 5F 7A 23
R 00 00 00 00
T BF 00 00 8E F8 0B 32 73 2A 66 6F E5 F8 0A 2A 66
R 00 00 00 00
T CC 00 00 6F E5 CD 00 00 E8 04
R 00 00 00 00 02 06 00 00
T D3 00 00
R 00 00 00 00
T D3 00 00 E8 0C C9
R 00 00 00 00
modff.rel/      0           0     0     644     938       `
XL3
H 7 areas 5 global symbols
M modff
O -mgbz80
S ___fssub Ref000000
S ___slong2fs Ref000000
S ___fs2slong Ref000000
S .__.ABS. Def000000
A _CODE size 65 flags 0 addr 0
S _modff Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FA F8 0C 2A 5E F8 00 22 73 F8 0A 2A
R 00 00 00 00
T 0D 00 00 66 6F E5 F8 0A 2A 66 6F E5 CD 00 00 E8
R 00 00 00 00 02 0D 02 00
T 1A 00 00 04 E5 D5 CD 00 00 E8 04 E5 F8 04 73 F8
R 00 00 00 00 02 07 01 00
T 27 00 00 05 72 E1 E5 7D F8 06 77 E1 7C F8 05 77
R 00 00 00 00
T 34 00 00 D1 D5 F8 02 7E 12 13 23 7E 12 13 23 7E
R 00 00 00 00
T 41 00 00 12 13 23 7E 12 2B 2A 66 6F E5 F8 04 2A
R 00 00 00 00
T 4E 00 00 66 6F E5 F8 0E 2A 66 6F E5 F8 0E 2A 66
R 00 00 00 00
T 5B 00 00 6F E5 CD 00 00 E8 08 E8 06 C9
R 00 00 00 00 02 06 00 00
errno.rel/      0           0     0     644     354       `
XL3
H 7 areas 2 global symbols
M errno
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 2 flags 0 addr 0
S _errno Def000000
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 01 00
isinf.rel/      0           0     0     644     721       `
XL3
H 7 areas 2 global symbols
M isinf
O -mgbz80
S .__.ABS. Def000000
A _CODE size 2F flags 0 addr 0
S _isinf Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 2A 4F 2A 47 23 3A 6E 67 79 B7 B0
R 00 00 00 00
T 0D 00 00 20 0A 7D D6 80 20 05 7C D6 7F 28 11
R 00 00 00 00
T 19 00 00
R 00 00 00 00
T 19 00 00 79 B7 B0 20 08 7D D6 80 20 03 24 28 04
R 00 00 00 00
T 26 00 00
R 00 00 00 00
T 26 00 00 1E 00 18 02
R 00 00 00 00
T 2A 00 00
R 00 00 00 00
T 2A 00 00 1E 01
R 00 00 00 00
T 2C 00 00
R 00 00 00 00
T 2C 00 00 16 00 C9
R 00 00 00 00

isnan.rel/      0           0     0     644     486       `
XL3
H 7 areas 2 global symbols
M isnan
O -mgbz80
S .__.ABS. Def000000
A _CODE size 1B flags 0 addr 0
S _isnan Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 2A 4F 2A 47 2A 6E 5F CB BD AF B9
R 00 00 00 00
T 0D 00 00 98 3E 80 9B 3E 7F 9D 3E 00 17 5F 16 00
R 00 00 00 00
T 1A 00 00 C9
R 00 00 00 00
_divslong.rel/  0           0     0     644     2371      `
XL3
H 7 areas 3 global symbols
M _divslong
O -mgbz80
S .__.ABS. Def000000
S __divulong Ref000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 144 flags 0 addr 0
S __divslong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F6 F8 0C 7E D6 00 23 7E DE 00 23 7E
R 00 00 03 00
T 0D 00 00 DE 00 23 7E DE 00 56 3E 00 CB 7F 28 07
R 00 00 03 00
T 1A 00 00 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 21 00 00
R 00 00 03 00
T 21 00 00 CB 7A 28 01 37
R 00 00 03 00
T 26 00 00
R 00 00 03 00
T 26 00 00 3E 00 17 F8 04 77 B7 28 22 11 00 00 7B
R 00 00 03 00
T 33 00 00 F8 0C 96 5F 7A 23 9E F5 F8 09 32 73 11
R 00 00 03 00
T 40 00 00 00 00 F8 10 F1 7B 9E 5F 7A 23 9E F8 09
R 00 00 03 00
T 4D 00 00 32 73 18 11
R 00 00 03 00
T 51 00 00
R 00 00 03 00
T 51 00 00 F8 0C 54 5D F8 06 1A 22 13 1A 22 13 1A
R 00 00 03 00
T 5E 00 00 22 13 1A 77
R 00 00 03 00
T 62 00 00
R 00 00 03 00
T 62 00 00 F8 06 54 5D F8 00 1A 22 13 1A 22 13 1A
R 00 00 03 00
T 6F 00 00 22 13 1A 77 F8 10 7E D6 00 23 7E DE 00
R 00 00 03 00
T 7C 00 00 23 7E DE 00 23 7E DE 00 56 3E 00 CB 7F
R 00 00 03 00
T 89 00 00 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 92 00 00
R 00 00 03 00
T 92 00 00 CB 7A 28 01 37
R 00 00 03 00
T 97 00 00
R 00 00 03 00
T 97 00 00 3E 00 17 F8 09 77 B7 28 22 11 00 00 7B
R 00 00 03 00
T A4 00 00 F8 10 96 5F 7A 23 9E F5 F8 08 32 73 11
R 00 00 03 00
T B1 00 00 00 00 F8 14 F1 7B 9E 5F 7A 23 9E F8 08
R 00 00 03 00
T BE 00 00 32 73 18 11
R 00 00 03 00
T C2 00 00
R 00 00 03 00
T C2 00 00 F8 10 54 5D F8 05 1A 22 13 1A 22 13 1A
R 00 00 03 00
T CF 00 00 22 13 1A 77
R 00 00 03 00
T D3 00 00
R 00 00 03 00
T D3 00 00 F8 05 2A 4F 2A 47 2A 5F 56 D5 C5 F8 06
R 00 00 03 00
T E0 00 00 2A 66 6F E5 F8 06 2A 66 6F E5 CD 00 00
R 00 00 03 00 02 0E 01 00
T ED 00 00 E8 08 E5 F8 07 73 F8 08 72 E1 E5 7D F8
R 00 00 03 00
T FA 00 00 09 77 E1 7C F8 08 77 F8 09 7E F8 04 AE
R 00 00 03 00
T 07 01 00 F8 09 77 B7 28 2B 11 00 00 7B F8 05 96
R 00 00 03 00
T 14 01 00 5F 7A 23 9E F5 F8 04 32 73 11 00 00 F8
R 00 00 03 00
T 21 01 00 09 F1 7B 9E 5F 7A 23 9E F8 04 32 7B 32
R 00 00 03 00
T 2E 01 00 2B 2A 5F 2A 57 2A 66 6F 18 09
R 00 00 03 00
T 38 01 00
R 00 00 03 00
T 38 01 00 F8 05 2A 5F 2A 57 2A 66 6F
R 00 00 03 00
T 41 01 00
R 00 00 03 00
T 41 01 00 E8 0A C9
R 00 00 03 00

_modslong.rel/  0           0     0     644     2261      `
XL3
H 7 areas 3 global symbols
M _modslong
O -mgbz80
S .__.ABS. Def000000
S __modulong Ref000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 130 flags 0 addr 0
S __modslong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F7 F8 0B 7E D6 00 23 7E DE 00 23 7E
R 00 00 03 00
T 0D 00 00 DE 00 23 7E DE 00 56 3E 00 CB 7F 28 07
R 00 00 03 00
T 1A 00 00 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 21 00 00
R 00 00 03 00
T 21 00 00 CB 7A 28 01 37
R 00 00 03 00
T 26 00 00
R 00 00 03 00
T 26 00 00 3E 00 17 F8 00 77 B7 28 22 11 00 00 7B
R 00 00 03 00
T 33 00 00 F8 0B 96 5F 7A 23 9E F5 F8 08 32 73 11
R 00 00 03 00
T 40 00 00 00 00 F8 0F F1 7B 9E 5F 7A 23 9E F8 08
R 00 00 03 00
T 4D 00 00 32 73 18 11
R 00 00 03 00
T 51 00 00
R 00 00 03 00
T 51 00 00 F8 0B 54 5D F8 05 1A 22 13 1A 22 13 1A
R 00 00 03 00
T 5E 00 00 22 13 1A 77
R 00 00 03 00
T 62 00 00
R 00 00 03 00
T 62 00 00 F8 05 54 5D F8 01 1A 22 13 1A 22 13 1A
R 00 00 03 00
T 6F 00 00 22 13 1A 77 F8 0F 7E D6 00 23 7E DE 00
R 00 00 03 00
T 7C 00 00 23 7E DE 00 23 7E DE 00 56 3E 00 CB 7F
R 00 00 03 00
T 89 00 00 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 92 00 00
R 00 00 03 00
T 92 00 00 CB 7A 28 01 37
R 00 00 03 00
T 97 00 00
R 00 00 03 00
T 97 00 00 30 22 11 00 00 7B F8 0F 96 5F 7A 23 9E
R 00 00 03 00
T A4 00 00 F5 F8 08 32 73 11 00 00 F8 13 F1 7B 9E
R 00 00 03 00
T B1 00 00 5F 7A 23 9E F8 08 32 73 18 11
R 00 00 03 00
T BB 00 00
R 00 00 03 00
T BB 00 00 F8 0F 54 5D F8 05 1A 22 13 1A 22 13 1A
R 00 00 03 00
T C8 00 00 22 13 1A 77
R 00 00 03 00
T CC 00 00
R 00 00 03 00
T CC 00 00 F8 05 2A 4F 2A 47 2A 5F 56 D5 C5 F8 07
R 00 00 03 00
T D9 00 00 2A 66 6F E5 F8 07 2A 66 6F E5 CD 00 00
R 00 00 03 00 02 0E 01 00
T E6 00 00 E8 08 4D 44 F8 05 7B 22 7A 22 79 22 70
R 00 00 03 00
T F3 00 00 F8 00 7E B7 28 2B 11 00 00 7B F8 05 96
R 00 00 03 00
T 00 01 00 5F 7A 23 9E F5 F8 04 32 73 11 00 00 F8
R 00 00 03 00
T 0D 01 00 09 F1 7B 9E 5F 7A 23 9E F8 04 32 7B 32
R 00 00 03 00
T 1A 01 00 2B 2A 5F 2A 57 2A 66 6F 18 09
R 00 00 03 00
T 24 01 00
R 00 00 03 00
T 24 01 00 F8 05 2A 5F 2A 57 2A 66 6F
R 00 00 03 00
T 2D 01 00
R 00 00 03 00
T 2D 01 00 E8 09 C9
R 00 00 03 00

_modulong.rel/  0           0     0     644     1285      `
XL3
H 7 areas 2 global symbols
M _modulong
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 95 flags 0 addr 0
S __modulong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 01 00 00
R 00 00 03 00
T 03 00 00
R 00 00 03 00
T 03 00 00 F8 09 7E 07 38 36 F8 06 CB 26 23 CB 16
R 00 00 03 00
T 10 00 00 23 CB 16 23 CB 16 F8 02 5D 54 F8 06 1A
R 00 00 03 00
T 1D 00 00 96 23 13 1A 9E 23 13 1A 9E 23 13 1A 9E
R 00 00 03 00
T 2A 00 00 30 0F F8 09 CB 3E 2B CB 1E 2B CB 1E 2B
R 00 00 03 00
T 37 00 00 CB 1E 18 04
R 00 00 03 00
T 3B 00 00
R 00 00 03 00
T 3B 00 00 04 48 18 C4
R 00 00 03 00
T 3F 00 00
R 00 00 03 00
T 3F 00 00
R 00 00 03 00
T 3F 00 00 F8 02 5D 54 F8 06 1A 96 23 13 1A 9E 23
R 00 00 03 00
T 4C 00 00 13 1A 9E 23 13 1A 9E 38 24 F8 02 2A 5F
R 00 00 03 00
T 59 00 00 56 7B F8 06 96 5F 7A 23 9E F5 F8 05 32
R 00 00 03 00
T 66 00 00 73 F8 06 2A 5F 56 F8 0A F1 7B 9E 5F 7A
R 00 00 03 00
T 73 00 00 23 9E F8 05 32 73
R 00 00 03 00
T 79 00 00
R 00 00 03 00
T 79 00 00 F8 09 CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 86 00 00 79 0D B7 20 B4 F8 02 2A 5F 2A 57 2A 66
R 00 00 03 00
T 93 00 00 6F C9
R 00 00 03 00

_divulong.rel/  0           0     0     644     1103      `
XL3
H 7 areas 2 global symbols
M _divulong
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 82 flags 0 addr 0
S __divulong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 FC AF F8 00 22 22 22 77 0E 20
R 00 00 03 00
T 0B 00 00
R 00 00 03 00
T 0B 00 00 F8 09 7E 07 E6 01 47 F8 06 CB 26 23 CB
R 00 00 03 00
T 18 00 00 16 23 CB 16 23 CB 16 F8 00 CB 26 23 CB
R 00 00 03 00
T 25 00 00 16 23 CB 16 23 CB 16 CB 40 28 06 F8 00
R 00 00 03 00
T 32 00 00 7E F6 01 77
R 00 00 03 00
T 36 00 00
R 00 00 03 00
T 36 00 00 F8 00 5D 54 F8 0A 1A 96 23 13 1A 9E 23
R 00 00 03 00
T 43 00 00 13 1A 9E 23 13 1A 9E 38 27 D1 D5 7B F8
R 00 00 03 00
T 50 00 00 0A 96 5F 7A 23 9E F5 F8 03 32 73 F8 04
R 00 00 03 00
T 5D 00 00 2A 5F 56 F8 0E F1 7B 9E 5F 7A 23 9E F8
R 00 00 03 00
T 6A 00 00 03 32 73 F8 06 7E F6 01 77
R 00 00 03 00
T 73 00 00
R 00 00 03 00
T 73 00 00 0D 20 95 F8 06 2A 5F 2A 57 2A 66 6F E8
R 00 00 03 00
T 80 00 00 04 C9
R 00 00 03 00

_mullong.rel/   0           0     0     644     2480      `
XL3
H 7 areas 4 global symbols
M _mullong
O -mgbz80
S __mulint Ref000000
S .__.ABS. Def000000
S __muluchar Ref000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 199 flags 0 addr 0
S __mullong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F6 F8 0C 33 33 4D 44 C5 03 03 F8 06
R 00 00 03 00
T 0D 00 00 79 22 70 C1 C5 03 03 59 50 1A 23 22 13
R 00 00 03 00
T 1A 00 00 1A 77 F8 10 7D 54 F8 02 22 7A 32 2A 4F
R 00 00 03 00
T 27 00 00 46 69 60 2A 4F 46 C5 F8 0A 2A 66 6F E5
R 00 00 03 00
T 34 00 00 CD 00 00 E8 04 4B 42 F8 06 2A 66 6F 79
R 00 00 03 00 02 04 00 00
T 41 00 00 22 70 C1 C5 03 03 F8 06 79 22 70 C1 C5
R 00 00 03 00
T 4E 00 00 03 03 59 50 1A 23 22 13 1A 77 F8 02 2A
R 00 00 03 00
T 5B 00 00 4F 46 03 03 60 69 2A 4F 46 D1 D5 6B 62
R 00 00 03 00
T 68 00 00 2A 66 6F E5 C5 CD 00 00 E8 04 F8 08 2A
R 00 00 03 00 02 09 00 00
T 75 00 00 66 6F 19 4D 44 F8 06 2A 66 6F 79 22 70
R 00 00 03 00
T 82 00 00 C1 C5 03 03 F8 07 79 22 70 C1 C5 03 03
R 00 00 03 00
T 8F 00 00 60 69 2A 4F 46 D1 D5 13 1A F8 09 77 F8
R 00 00 03 00
T 9C 00 00 02 2A 5F 56 13 1A C5 F5 33 F8 0C 7E F5
R 00 00 03 00
T A9 00 00 33 CD 00 00 E8 02 C1 6B 62 09 4D 44 F8
R 00 00 03 00 02 05 02 00
T B6 00 00 07 2A 66 6F 79 22 70 F8 02 2A 4F 46 0A
R 00 00 03 00
T C3 00 00 47 D1 D5 13 1A F5 33 C5 33 CD 00 00 E8
R 00 00 03 00 02 0D 02 00
T D0 00 00 02 F8 04 7B 22 7A 32 2B 2B 2A 4F 46 03
R 00 00 03 00
T DD 00 00 D1 D5 1A F8 09 77 F8 02 2A 5F 56 13 1A
R 00 00 03 00
T EA 00 00 C5 F5 33 F8 0C 7E F5 33 CD 00 00 E8 02
R 00 00 03 00 02 0C 02 00
T F7 00 00 C1 7B 02 03 7A 02 F8 02 2A 4F 46 03 03
R 00 00 03 00
T 04 01 00 03 F8 06 79 22 70 F8 02 2A 4F 46 03 F8
R 00 00 03 00
T 11 01 00 08 79 22 70 F8 02 2A 4F 46 69 60 23 2A
R 00 00 03 00
T 1E 01 00 4F 46 F8 04 2A 66 6F 09 4D 44 F8 08 2A
R 00 00 03 00
T 2B 01 00 66 6F 79 22 70 F8 04 79 96 23 78 9E 3E
R 00 00 03 00
T 38 01 00 00 17 4F F8 06 2A 66 6F 71 C1 C5 D1 D5
R 00 00 03 00
T 45 01 00 1A F8 09 77 F8 02 2A 5F 56 1A C5 F5 33
R 00 00 03 00
T 52 01 00 F8 0C 7E F5 33 CD 00 00 E8 02 C1 7B 02
R 00 00 03 00 02 09 02 00
T 5F 01 00 03 7A 02 F8 02 2A 4F 46 AF 02 F8 0C 2A
R 00 00 03 00
T 6C 01 00 5F 56 7B F8 10 86 5F 7A 23 8E F5 F8 09
R 00 00 03 00
T 79 01 00 32 73 F8 10 2A 5F 56 F8 14 F1 7B 8E 5F
R 00 00 03 00
T 86 01 00 7A 23 8E F8 09 32 7B 32 2B 2A 5F 2A 57
R 00 00 03 00
T 93 01 00 2A 66 6F E8 0A C9
R 00 00 03 00
/70             0           0     0     644     2765      `
XL3
H 7 areas 3 global symbols
M _mullonglong
O -mgbz80
S .__.ABS. Def000000
S __muluchar Ref000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 198 flags 0 addr 0
S __mullonglong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 EF AF F8 09 22 22 22 22 22 22 22 77
R 00 00 03 00
T 0D 00 00 0E 00
R 00 00 03 00
T 0F 00 00
R 00 00 03 00
T 0F 00 00 79 87 87 87 47 F8 15 7E F8 01 77 F8 16
R 00 00 03 00
T 1C 00 00 7E F8 02 77 F8 17 7E F8 03 77 F8 18 7E
R 00 00 03 00
T 29 00 00 F8 04 77 F8 19 7E F8 05 77 F8 1A 7E F8
R 00 00 03 00
T 36 00 00 06 77 F8 1B 7E F8 07 77 F8 1C 7E F8 08
R 00 00 03 00
T 43 00 00 77 04 18 19
R 00 00 03 00
T 47 00 00
R 00 00 03 00
T 47 00 00 F8 08 CB 2E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 54 00 00 2B CB 1E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 60 00 00
R 00 00 03 00
T 60 00 00 05 20 E4 F8 01 7E F8 08 77 06 00
R 00 00 03 00
T 6B 00 00
R 00 00 03 00
T 6B 00 00 79 16 00 68 26 00 5F 19 7D D6 08 7C 17
R 00 00 03 00
T 78 00 00 3F 1F DE 80 D2 70 01 78 87 87 87 5F F8
R 00 00 03 00 00 08 03 00
T 85 00 00 1D 7E F8 00 77 F8 1E 7E F8 01 77 F8 1F
R 00 00 03 00
T 92 00 00 7E F8 02 77 F8 20 7E F8 03 77 F8 21 7E
R 00 00 03 00
T 9F 00 00 F8 04 77 F8 22 7E F8 05 77 F8 23 7E F8
R 00 00 03 00
T AC 00 00 06 77 F8 24 7E F8 07 77 1C 18 19
R 00 00 03 00
T B7 00 00
R 00 00 03 00
T B7 00 00 F8 07 CB 2E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T C4 00 00 2B CB 1E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T D0 00 00
R 00 00 03 00
T D0 00 00 1D 20 E4 F8 00 7E C5 F5 33 F8 0B 7E F5
R 00 00 03 00
T DD 00 00 33 CD 00 00 E8 02 C1 F8 00 7B 22 72 AF
R 00 00 03 00 02 05 01 00
T EA 00 00 23 22 22 22 22 22 77 79 80 87 87 87 5F
R 00 00 03 00
T F7 00 00 1C 18 19
R 00 00 03 00
T FA 00 00
R 00 00 03 00
T FA 00 00 F8 00 CB 26 23 CB 16 23 CB 16 23 CB 16
R 00 00 03 00
T 07 01 00 23 CB 16 23 CB 16 23 CB 16 23 CB 16
R 00 00 03 00
T 13 01 00
R 00 00 03 00
T 13 01 00 1D 20 E4 F8 09 7E F8 00 86 F5 F8 0B F1
R 00 00 03 00
T 20 01 00 22 7E F5 F8 03 F1 8E F5 F8 0C F1 22 7E
R 00 00 03 00
T 2D 01 00 F5 F8 04 F1 8E F5 F8 0D F1 22 7E F5 F8
R 00 00 03 00
T 3A 01 00 05 F1 8E F5 F8 0E F1 22 7E F5 F8 06 F1
R 00 00 03 00
T 47 01 00 8E F5 F8 0F F1 22 7E F5 F8 07 F1 8E F5
R 00 00 03 00
T 54 01 00 F8 10 F1 22 7E F5 F8 08 F1 8E F5 F8 11
R 00 00 03 00
T 61 01 00 F1 22 7E F5 F8 09 F1 8E F8 10 77 04 C3
R 00 00 03 00
T 6E 01 00 6B 00
R 00 00 03 00 00 03 03 00
T 70 01 00
R 00 00 03 00
T 70 01 00 0C 79 D6 08 DA 0F 00 F8 13 2A 4F 46 F8
R 00 00 03 00 00 08 03 00
T 7D 01 00 09 2A 02 03 2A 02 03 2A 02 03 2A 02 03
R 00 00 03 00
T 8A 01 00 2A 02 03 2A 02 03 2A 02 03 7E 02 E8 11
R 00 00 03 00
T 97 01 00 C9
R 00 00 03 00

/88             0           0     0     644     3566      `
XL3
H 7 areas 3 global symbols
M _divslonglong
O -mgbz80
S __divulonglong Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 249 flags 0 addr 0
S __divslonglong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F0 F8 14 7E D6 00 23 7E DE 00 23 7E
R 00 00 03 00
T 0D 00 00 DE 00 23 7E DE 00 23 7E DE 00 23 7E DE
R 00 00 03 00
T 1A 00 00 00 23 7E DE 00 23 7E DE 00 56 3E 00 CB
R 00 00 03 00
T 27 00 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 31 00 00
R 00 00 03 00
T 31 00 00 CB 7A 28 01 37
R 00 00 03 00
T 36 00 00
R 00 00 03 00
T 36 00 00 3E 00 17 4F F8 1C 7E D6 00 23 7E DE 00
R 00 00 03 00
T 43 00 00 23 7E DE 00 23 7E DE 00 23 7E DE 00 23
R 00 00 03 00
T 50 00 00 7E DE 00 23 7E DE 00 23 7E DE 00 56 3E
R 00 00 03 00
T 5D 00 00 00 CB 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 69 00 00
R 00 00 03 00
T 69 00 00 CB 7A 28 01 37
R 00 00 03 00
T 6E 00 00
R 00 00 03 00
T 6E 00 00 3E 00 17 47 CB 41 28 28 AF F8 14 96 77
R 00 00 03 00
T 7B 00 00 3E 00 23 9E 77 3E 00 23 9E 77 3E 00 23
R 00 00 03 00
T 88 00 00 9E 77 3E 00 23 9E 77 3E 00 23 9E 77 3E
R 00 00 03 00
T 95 00 00 00 23 9E 77 3E 00 23 9E 77
R 00 00 03 00
T 9E 00 00
R 00 00 03 00
T 9E 00 00 CB 40 28 28 AF F8 1C 96 77 3E 00 23 9E
R 00 00 03 00
T AB 00 00 77 3E 00 23 9E 77 3E 00 23 9E 77 3E 00
R 00 00 03 00
T B8 00 00 23 9E 77 3E 00 23 9E 77 3E 00 23 9E 77
R 00 00 03 00
T C5 00 00 3E 00 23 9E 77
R 00 00 03 00
T CA 00 00
R 00 00 03 00
T CA 00 00 F8 14 7E F8 00 77 F8 15 7E F8 01 77 F8
R 00 00 03 00
T D7 00 00 16 7E F8 02 77 F8 17 7E F8 03 77 F8 18
R 00 00 03 00
T E4 00 00 7E F8 04 77 F8 19 7E F8 05 77 F8 1A 7E
R 00 00 03 00
T F1 00 00 F8 06 77 F8 1B 7E F8 07 77 F8 1C 7E F8
R 00 00 03 00
T FE 00 00 08 77 F8 1D 7E F8 09 77 F8 1E 7E F8 0A
R 00 00 03 00
T 0B 01 00 77 F8 1F 7E F8 0B 77 F8 20 7E F8 0C 77
R 00 00 03 00
T 18 01 00 F8 21 7E F8 0D 77 F8 22 7E F8 0E 77 F8
R 00 00 03 00
T 25 01 00 23 7E F8 0F 77 C5 2B 2A 66 6F E5 F8 10
R 00 00 03 00
T 32 01 00 2A 66 6F E5 F8 10 2A 66 6F E5 F8 10 2A
R 00 00 03 00
T 3F 01 00 66 6F E5 F8 10 2A 66 6F E5 F8 10 2A 66
R 00 00 03 00
T 4C 01 00 6F E5 F8 10 2A 66 6F E5 F8 10 2A 66 6F
R 00 00 03 00
T 59 01 00 E5 21 1A 00 39 E5 CD 00 00 E8 12 C1 F8
R 00 00 03 00 02 0A 00 00
T 66 01 00 08 7E F8 00 77 F8 09 7E F8 01 77 F8 0A
R 00 00 03 00
T 73 01 00 7E F8 02 77 F8 0B 7E F8 03 77 F8 0C 7E
R 00 00 03 00
T 80 01 00 F8 04 77 F8 0D 7E F8 05 77 F8 0E 7E F8
R 00 00 03 00
T 8D 01 00 06 77 F8 0F 7E F8 07 77 79 A8 CB 47 28
R 00 00 03 00
T 9A 01 00 5D AF F8 00 96 F5 F8 0A F1 77 3E 00 F5
R 00 00 03 00
T A7 01 00 F8 03 F1 9E F5 F8 0B F1 77 3E 00 F5 F8
R 00 00 03 00
T B4 01 00 04 F1 9E F5 F8 0C F1 77 3E 00 F5 F8 05
R 00 00 03 00
T C1 01 00 F1 9E F5 F8 0D F1 77 3E 00 F5 F8 06 F1
R 00 00 03 00
T CE 01 00 9E F5 F8 0E F1 77 3E 00 F5 F8 07 F1 9E
R 00 00 03 00
T DB 01 00 F5 F8 0F F1 77 3E 00 F5 F8 08 F1 9E F5
R 00 00 03 00
T E8 01 00 F8 10 F1 77 3E 00 F5 F8 09 F1 9E F8 0F
R 00 00 03 00
T F5 01 00 77 18 30
R 00 00 03 00
T F8 01 00
R 00 00 03 00
T F8 01 00 F8 00 7E F8 08 77 F8 01 7E F8 09 77 F8
R 00 00 03 00
T 05 02 00 02 7E F8 0A 77 F8 03 7E F8 0B 77 F8 04
R 00 00 03 00
T 12 02 00 7E F8 0C 77 F8 05 7E F8 0D 77 F8 06 7E
R 00 00 03 00
T 1F 02 00 F8 0E 77 F8 07 7E F8 0F 77
R 00 00 03 00
T 28 02 00
R 00 00 03 00
T 28 02 00 F8 12 2A 4F 46 F8 08 2A 02 03 2A 02 03
R 00 00 03 00
T 35 02 00 2A 02 03 2A 02 03 2A 02 03 2A 02 03 2A
R 00 00 03 00
T 42 02 00 02 03 7E 02 E8 10 C9
R 00 00 03 00
/107            0           0     0     644     1705      `
XL3
H 7 areas 2 global symbols
M _divulonglong
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size F9 flags 0 addr 0
S __divulonglong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F8 AF F8 00 22 22 22 22 22 22 22 77
R 00 00 03 00
T 0D 00 00 0E 40
R 00 00 03 00
T 0F 00 00
R 00 00 03 00
T 0F 00 00 F8 13 7E 07 E6 01 47 F8 0C CB 26 23 CB
R 00 00 03 00
T 1C 00 00 16 23 CB 16 23 CB 16 23 CB 16 23 CB 16
R 00 00 03 00
T 29 00 00 23 CB 16 23 CB 16 F8 00 CB 26 23 CB 16
R 00 00 03 00
T 36 00 00 23 CB 16 23 CB 16 23 CB 16 23 CB 16 23
R 00 00 03 00
T 43 00 00 CB 16 23 CB 16 CB 40 28 06 F8 00 7E F6
R 00 00 03 00
T 50 00 00 01 77
R 00 00 03 00
T 52 00 00
R 00 00 03 00
T 52 00 00 F8 00 5D 54 F8 14 1A 96 23 13 1A 9E 23
R 00 00 03 00
T 5F 00 00 13 1A 9E 23 13 1A 9E 23 13 1A 9E 23 13
R 00 00 03 00
T 6C 00 00 1A 9E 23 13 1A 9E 23 13 1A 9E 38 5C F8
R 00 00 03 00
T 79 00 00 00 7E F8 14 96 F5 F8 02 F1 22 7E F5 F8
R 00 00 03 00
T 86 00 00 17 F1 9E F5 F8 03 F1 22 7E F5 F8 18 F1
R 00 00 03 00
T 93 00 00 9E F5 F8 04 F1 22 7E F5 F8 19 F1 9E F5
R 00 00 03 00
T A0 00 00 F8 05 F1 22 7E F5 F8 1A F1 9E F5 F8 06
R 00 00 03 00
T AD 00 00 F1 22 7E F5 F8 1B F1 9E F5 F8 07 F1 22
R 00 00 03 00
T BA 00 00 7E F5 F8 1C F1 9E F5 F8 08 F1 22 7E F5
R 00 00 03 00
T C7 00 00 F8 1D F1 9E F8 07 77 F8 0C 7E F6 01 77
R 00 00 03 00
T D4 00 00
R 00 00 03 00
T D4 00 00 0D C2 0F 00 F8 0A 2A 4F 46 F8 0C 2A 02
R 00 00 03 00 00 05 03 00
T E1 00 00 03 2A 02 03 2A 02 03 2A 02 03 2A 02 03
R 00 00 03 00
T EE 00 00 2A 02 03 2A 02 03 7E 02 E8 08 C9
R 00 00 03 00

/126            0           0     0     644     3560      `
XL3
H 7 areas 3 global symbols
M _modslonglong
O -mgbz80
S __modulonglong Ref000000
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 247 flags 0 addr 0
S __modslonglong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 E8 F0 F8 14 7E D6 00 23 7E DE 00 23 7E
R 00 00 03 00
T 0D 00 00 DE 00 23 7E DE 00 23 7E DE 00 23 7E DE
R 00 00 03 00
T 1A 00 00 00 23 7E DE 00 23 7E DE 00 56 3E 00 CB
R 00 00 03 00
T 27 00 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 31 00 00
R 00 00 03 00
T 31 00 00 CB 7A 28 01 37
R 00 00 03 00
T 36 00 00
R 00 00 03 00
T 36 00 00 3E 00 17 4F F8 1C 7E D6 00 23 7E DE 00
R 00 00 03 00
T 43 00 00 23 7E DE 00 23 7E DE 00 23 7E DE 00 23
R 00 00 03 00
T 50 00 00 7E DE 00 23 7E DE 00 23 7E DE 00 56 3E
R 00 00 03 00
T 5D 00 00 00 CB 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 03 00
T 69 00 00
R 00 00 03 00
T 69 00 00 CB 7A 28 01 37
R 00 00 03 00
T 6E 00 00
R 00 00 03 00
T 6E 00 00 3E 00 17 47 CB 41 28 28 AF F8 14 96 77
R 00 00 03 00
T 7B 00 00 3E 00 23 9E 77 3E 00 23 9E 77 3E 00 23
R 00 00 03 00
T 88 00 00 9E 77 3E 00 23 9E 77 3E 00 23 9E 77 3E
R 00 00 03 00
T 95 00 00 00 23 9E 77 3E 00 23 9E 77
R 00 00 03 00
T 9E 00 00
R 00 00 03 00
T 9E 00 00 CB 40 28 28 AF F8 1C 96 77 3E 00 23 9E
R 00 00 03 00
T AB 00 00 77 3E 00 23 9E 77 3E 00 23 9E 77 3E 00
R 00 00 03 00
T B8 00 00 23 9E 77 3E 00 23 9E 77 3E 00 23 9E 77
R 00 00 03 00
T C5 00 00 3E 00 23 9E 77
R 00 00 03 00
T CA 00 00
R 00 00 03 00
T CA 00 00 F8 14 7E F8 00 77 F8 15 7E F8 01 77 F8
R 00 00 03 00
T D7 00 00 16 7E F8 02 77 F8 17 7E F8 03 77 F8 18
R 00 00 03 00
T E4 00 00 7E F8 04 77 F8 19 7E F8 05 77 F8 1A 7E
R 00 00 03 00
T F1 00 00 F8 06 77 F8 1B 7E F8 07 77 F8 1C 7E F8
R 00 00 03 00
T FE 00 00 08 77 F8 1D 7E F8 09 77 F8 1E 7E F8 0A
R 00 00 03 00
T 0B 01 00 77 F8 1F 7E F8 0B 77 F8 20 7E F8 0C 77
R 00 00 03 00
T 18 01 00 F8 21 7E F8 0D 77 F8 22 7E F8 0E 77 F8
R 00 00 03 00
T 25 01 00 23 7E F8 0F 77 C5 2B 2A 66 6F E5 F8 10
R 00 00 03 00
T 32 01 00 2A 66 6F E5 F8 10 2A 66 6F E5 F8 10 2A
R 00 00 03 00
T 3F 01 00 66 6F E5 F8 10 2A 66 6F E5 F8 10 2A 66
R 00 00 03 00
T 4C 01 00 6F E5 F8 10 2A 66 6F E5 F8 10 2A 66 6F
R 00 00 03 00
T 59 01 00 E5 21 1A 00 39 E5 CD 00 00 E8 12 C1 F8
R 00 00 03 00 02 0A 00 00
T 66 01 00 08 7E F8 00 77 F8 09 7E F8 01 77 F8 0A
R 00 00 03 00
T 73 01 00 7E F8 02 77 F8 0B 7E F8 03 77 F8 0C 7E
R 00 00 03 00
T 80 01 00 F8 04 77 F8 0D 7E F8 05 77 F8 0E 7E F8
R 00 00 03 00
T 8D 01 00 06 77 F8 0F 7E F8 07 77 CB 41 28 5D AF
R 00 00 03 00
T 9A 01 00 F8 00 96 F5 F8 0A F1 77 3E 00 F5 F8 03
R 00 00 03 00
T A7 01 00 F1 9E F5 F8 0B F1 77 3E 00 F5 F8 04 F1
R 00 00 03 00
T B4 01 00 9E F5 F8 0C F1 77 3E 00 F5 F8 05 F1 9E
R 00 00 03 00
T C1 01 00 F5 F8 0D F1 77 3E 00 F5 F8 06 F1 9E F5
R 00 00 03 00
T CE 01 00 F8 0E F1 77 3E 00 F5 F8 07 F1 9E F5 F8
R 00 00 03 00
T DB 01 00 0F F1 77 3E 00 F5 F8 08 F1 9E F5 F8 10
R 00 00 03 00
T E8 01 00 F1 77 3E 00 F5 F8 09 F1 9E F8 0F 77 18
R 00 00 03 00
T F5 01 00 30
R 00 00 03 00
T F6 01 00
R 00 00 03 00
T F6 01 00 F8 00 7E F8 08 77 F8 01 7E F8 09 77 F8
R 00 00 03 00
T 03 02 00 02 7E F8 0A 77 F8 03 7E F8 0B 77 F8 04
R 00 00 03 00
T 10 02 00 7E F8 0C 77 F8 05 7E F8 0D 77 F8 06 7E
R 00 00 03 00
T 1D 02 00 F8 0E 77 F8 07 7E F8 0F 77
R 00 00 03 00
T 26 02 00
R 00 00 03 00
T 26 02 00 F8 12 2A 4F 46 F8 08 2A 02 03 2A 02 03
R 00 00 03 00
T 33 02 00 2A 02 03 2A 02 03 2A 02 03 2A 02 03 2A
R 00 00 03 00
T 40 02 00 02 03 7E 02 E8 10 C9
R 00 00 03 00
/145            0           0     0     644     1976      `
XL3
H 7 areas 2 global symbols
M _modulonglong
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 121 flags 0 addr 0
S __modulonglong Def000000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 03 00
T 00 00 00 01 00 00
R 00 00 03 00
T 03 00 00
R 00 00 03 00
T 03 00 00 F8 13 7E 07 38 5E F8 0C CB 26 23 CB 16
R 00 00 03 00
T 10 00 00 23 CB 16 23 CB 16 23 CB 16 23 CB 16 23
R 00 00 03 00
T 1D 00 00 CB 16 23 CB 16 F8 04 5D 54 F8 0C 1A 96
R 00 00 03 00
T 2A 00 00 23 13 1A 9E 23 13 1A 9E 23 13 1A 9E 23
R 00 00 03 00
T 37 00 00 13 1A 9E 23 13 1A 9E 23 13 1A 9E 23 13
R 00 00 03 00
T 44 00 00 1A 9E 30 1B F8 13 CB 3E 2B CB 1E 2B CB
R 00 00 03 00
T 51 00 00 1E 2B CB 1E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T 5E 00 00 2B CB 1E 18 04
R 00 00 03 00
T 63 00 00
R 00 00 03 00
T 63 00 00 04 48 18 9C
R 00 00 03 00
T 67 00 00
R 00 00 03 00
T 67 00 00
R 00 00 03 00
T 67 00 00 F8 04 5D 54 F8 0C 1A 96 23 13 1A 9E 23
R 00 00 03 00
T 74 00 00 13 1A 9E 23 13 1A 9E 23 13 1A 9E 23 13
R 00 00 03 00
T 81 00 00 1A 9E 23 13 1A 9E 23 13 1A 9E 38 56 F8
R 00 00 03 00
T 8E 00 00 04 7E F8 0C 96 F5 F8 06 F1 22 7E F5 F8
R 00 00 03 00
T 9B 00 00 0F F1 9E F5 F8 07 F1 22 7E F5 F8 10 F1
R 00 00 03 00
T A8 00 00 9E F5 F8 08 F1 22 7E F5 F8 11 F1 9E F5
R 00 00 03 00
T B5 00 00 F8 09 F1 22 7E F5 F8 12 F1 9E F5 F8 0A
R 00 00 03 00
T C2 00 00 F1 22 7E F5 F8 13 F1 9E F5 F8 0B F1 22
R 00 00 03 00
T CF 00 00 7E F5 F8 14 F1 9E F5 F8 0C F1 22 7E F5
R 00 00 03 00
T DC 00 00 F8 15 F1 9E F8 0B 77
R 00 00 03 00
T E3 00 00
R 00 00 03 00
T E3 00 00 F8 13 CB 3E 2B CB 1E 2B CB 1E 2B CB 1E
R 00 00 03 00
T F0 00 00 2B CB 1E 2B CB 1E 2B CB 1E 2B CB 1E 79
R 00 00 03 00
T FD 00 00 0D B7 C2 67 00 F8 02 2A 4F 46 F8 04 2A
R 00 00 03 00 00 06 03 00
T 0A 01 00 02 03 2A 02 03 2A 02 03 2A 02 03 2A 02
R 00 00 03 00
T 17 01 00 03 2A 02 03 2A 02 03 7E 02 C9
R 00 00 03 00
isalnum.rel/    0           0     0     644     703       `
XL3
H 7 areas 3 global symbols
M isalnum
O -mgbz80
S _isalpha Ref000000
S .__.ABS. Def000000
A _CODE size 25 flags 0 addr 0
S _isalnum Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 C1 E1 E5 C5 E5 CD 00 00 E8 02 7A B3 20
R 00 00 00 00 02 09 00 00
T 0D 00 00 12 C1 D1 D5 C5 7B D6 30 38 05 3E 39 93
R 00 00 00 00
T 1A 00 00 30 04
R 00 00 00 00
T 1C 00 00
R 00 00 00 00
T 1C 00 00 1E 00 18 02
R 00 00 00 00
T 20 00 00
R 00 00 00 00
T 20 00 00 1E 01
R 00 00 00 00
T 22 00 00
R 00 00 00 00
T 22 00 00 16 00 C9
R 00 00 00 00

isalpha.rel/    0           0     0     644     683       `
XL3
H 7 areas 2 global symbols
M isalpha
O -mgbz80
S .__.ABS. Def000000
A _CODE size 21 flags 0 addr 0
S _isalpha Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 C1 D1 D5 C5 7B D6 41 38 05 3E 5A 93 30
R 00 00 00 00
T 0D 00 00 0E
R 00 00 00 00
T 0E 00 00
R 00 00 00 00
T 0E 00 00 7B D6 61 38 05 3E 7A 93 30 04
R 00 00 00 00
T 18 00 00
R 00 00 00 00
T 18 00 00 1E 00 18 02
R 00 00 00 00
T 1C 00 00
R 00 00 00 00
T 1C 00 00 1E 01
R 00 00 00 00
T 1E 00 00
R 00 00 00 00
T 1E 00 00 16 00 C9
R 00 00 00 00

isblank.rel/    0           0     0     644     513       `
XL3
H 7 areas 2 global symbols
M isblank
O -mgbz80
S .__.ABS. Def000000
A _CODE size 12 flags 0 addr 0
S _isblank Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 7E FE 20 28 06 D6 09 1E 00 20 02
R 00 00 00 00
T 0D 00 00
R 00 00 00 00
T 0D 00 00 1E 01
R 00 00 00 00
T 0F 00 00
R 00 00 00 00
T 0F 00 00 16 00 C9
R 00 00 00 00

iscntrl.rel/    0           0     0     644     722       `
XL3
H 7 areas 2 global symbols
M iscntrl
O -mgbz80
S .__.ABS. Def000000
A _CODE size 2E flags 0 addr 0
S _iscntrl Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 7E D6 20 23 7E DE 00 56 3E 00 CB
R 00 00 00 00
T 0D 00 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 17 00 00
R 00 00 00 00
T 17 00 00 CB 7A 28 01 37
R 00 00 00 00
T 1C 00 00
R 00 00 00 00
T 1C 00 00 38 0B F8 02 7E D6 7F 23 B6 1E 00 20 02
R 00 00 00 00
T 29 00 00
R 00 00 00 00
T 29 00 00 1E 01
R 00 00 00 00
T 2B 00 00
R 00 00 00 00
T 2B 00 00 16 00 C9
R 00 00 00 00
isdigit.rel/    0           0     0     644     575       `
XL3
H 7 areas 2 global symbols
M isdigit
O -mgbz80
S .__.ABS. Def000000
A _CODE size 16 flags 0 addr 0
S _isdigit Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 4E 79 D6 30 38 05 3E 39 91 30 04
R 00 00 00 00
T 0D 00 00
R 00 00 00 00
T 0D 00 00 1E 00 18 02
R 00 00 00 00
T 11 00 00
R 00 00 00 00
T 11 00 00 1E 01
R 00 00 00 00
T 13 00 00
R 00 00 00 00
T 13 00 00 16 00 C9
R 00 00 00 00

isgraph.rel/    0           0     0     644     966       `
XL3
H 7 areas 2 global symbols
M isgraph
O -mgbz80
S .__.ABS. Def000000
A _CODE size 45 flags 0 addr 0
S _isgraph Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 3E 20 96 23 3E 00 9E 3E 00 57 CB
R 00 00 00 00
T 0D 00 00 7E 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 17 00 00
R 00 00 00 00
T 17 00 00 CB 7A 28 01 37
R 00 00 00 00
T 1C 00 00
R 00 00 00 00
T 1C 00 00 30 1E F8 02 3E 7E 96 23 3E 00 9E 3E 00
R 00 00 00 00
T 29 00 00 57 CB 7E 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 35 00 00
R 00 00 00 00
T 35 00 00 CB 7A 28 01 37
R 00 00 00 00
T 3A 00 00
R 00 00 00 00
T 3A 00 00 30 04
R 00 00 00 00
T 3C 00 00
R 00 00 00 00
T 3C 00 00 1E 00 18 02
R 00 00 00 00
T 40 00 00
R 00 00 00 00
T 40 00 00 1E 01
R 00 00 00 00
T 42 00 00
R 00 00 00 00
T 42 00 00 16 00 C9
R 00 00 00 00
islower.rel/    0           0     0     644     575       `
XL3
H 7 areas 2 global symbols
M islower
O -mgbz80
S .__.ABS. Def000000
A _CODE size 16 flags 0 addr 0
S _islower Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 4E 79 D6 61 38 05 3E 7A 91 30 04
R 00 00 00 00
T 0D 00 00
R 00 00 00 00
T 0D 00 00 1E 00 18 02
R 00 00 00 00
T 11 00 00
R 00 00 00 00
T 11 00 00 1E 01
R 00 00 00 00
T 13 00 00
R 00 00 00 00
T 13 00 00 16 00 C9
R 00 00 00 00

isprint.rel/    0           0     0     644     966       `
XL3
H 7 areas 2 global symbols
M isprint
O -mgbz80
S .__.ABS. Def000000
A _CODE size 45 flags 0 addr 0
S _isprint Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 7E D6 20 23 7E DE 00 56 3E 00 CB
R 00 00 00 00
T 0D 00 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 17 00 00
R 00 00 00 00
T 17 00 00 CB 7A 28 01 37
R 00 00 00 00
T 1C 00 00
R 00 00 00 00
T 1C 00 00 38 1E F8 02 3E 7E 96 23 3E 00 9E 3E 00
R 00 00 00 00
T 29 00 00 57 CB 7E 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 35 00 00
R 00 00 00 00
T 35 00 00 CB 7A 28 01 37
R 00 00 00 00
T 3A 00 00
R 00 00 00 00
T 3A 00 00 30 04
R 00 00 00 00
T 3C 00 00
R 00 00 00 00
T 3C 00 00 1E 00 18 02
R 00 00 00 00
T 40 00 00
R 00 00 00 00
T 40 00 00 1E 01
R 00 00 00 00
T 42 00 00
R 00 00 00 00
T 42 00 00 16 00 C9
R 00 00 00 00
ispunct.rel/    0           0     0     644     836       `
XL3
H 7 areas 5 global symbols
M ispunct
O -mgbz80
S _isspace Ref000000
S _isalnum Ref000000
S .__.ABS. Def000000
S _isprint Ref000000
A _CODE size 33 flags 0 addr 0
S _ispunct Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 C1 E1 E5 C5 E5 CD 00 00 E8 02 7A B3 28
R 00 00 00 00 02 09 03 00
T 0D 00 00 1C C1 E1 E5 C5 E5 CD 00 00 E8 02 7A B3
R 00 00 00 00 02 0A 00 00
T 1A 00 00 20 0E C1 E1 E5 C5 E5 CD 00 00 E8 02 7A
R 00 00 00 00 02 0B 01 00
T 27 00 00 B3 28 04
R 00 00 00 00
T 2A 00 00
R 00 00 00 00
T 2A 00 00 1E 00 18 02
R 00 00 00 00
T 2E 00 00
R 00 00 00 00
T 2E 00 00 1E 01
R 00 00 00 00
T 30 00 00
R 00 00 00 00
T 30 00 00 16 00 C9
R 00 00 00 00
isspace.rel/    0           0     0     644     742       `
XL3
H 7 areas 2 global symbols
M isspace
O -mgbz80
S .__.ABS. Def000000
A _CODE size 3D flags 0 addr 0
S _isspace Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 7E D6 20 23 B6 28 2F F8 02 7E D6
R 00 00 00 00
T 0D 00 00 0C 23 B6 28 26 F8 02 7E D6 0A 23 B6 28
R 00 00 00 00
T 1A 00 00 1D F8 02 7E D6 0D 23 B6 28 14 F8 02 7E
R 00 00 00 00
T 27 00 00 D6 09 23 B6 28 0B F8 02 7E D6 0B 23 B6
R 00 00 00 00
T 34 00 00 1E 00 20 02
R 00 00 00 00
T 38 00 00
R 00 00 00 00
T 38 00 00 1E 01
R 00 00 00 00
T 3A 00 00
R 00 00 00 00
T 3A 00 00 16 00 C9
R 00 00 00 00
isupper.rel/    0           0     0     644     575       `
XL3
H 7 areas 2 global symbols
M isupper
O -mgbz80
S .__.ABS. Def000000
A _CODE size 16 flags 0 addr 0
S _isupper Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 4E 79 D6 41 38 05 3E 5A 91 30 04
R 00 00 00 00
T 0D 00 00
R 00 00 00 00
T 0D 00 00 1E 00 18 02
R 00 00 00 00
T 11 00 00
R 00 00 00 00
T 11 00 00 1E 01
R 00 00 00 00
T 13 00 00
R 00 00 00 00
T 13 00 00 16 00 C9
R 00 00 00 00

isxdigit.rel/   0           0     0     644     1928      `
XL3
H 7 areas 2 global symbols
M isxdigit
O -mgbz80
S .__.ABS. Def000000
A _CODE size BD flags 0 addr 0
S _isxdigit Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 7E D6 30 23 7E DE 00 56 3E 00 CB
R 00 00 00 00
T 0D 00 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 17 00 00
R 00 00 00 00
T 17 00 00 CB 7A 28 01 37
R 00 00 00 00
T 1C 00 00
R 00 00 00 00
T 1C 00 00 38 1E F8 02 3E 39 96 23 3E 00 9E 3E 00
R 00 00 00 00
T 29 00 00 57 CB 7E 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 35 00 00
R 00 00 00 00
T 35 00 00 CB 7A 28 01 37
R 00 00 00 00
T 3A 00 00
R 00 00 00 00
T 3A 00 00 30 7C
R 00 00 00 00
T 3C 00 00
R 00 00 00 00
T 3C 00 00 F8 02 7E D6 61 23 7E DE 00 56 3E 00 CB
R 00 00 00 00
T 49 00 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 53 00 00
R 00 00 00 00
T 53 00 00 CB 7A 28 01 37
R 00 00 00 00
T 58 00 00
R 00 00 00 00
T 58 00 00 38 1E F8 02 3E 66 96 23 3E 00 9E 3E 00
R 00 00 00 00
T 65 00 00 57 CB 7E 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 71 00 00
R 00 00 00 00
T 71 00 00 CB 7A 28 01 37
R 00 00 00 00
T 76 00 00
R 00 00 00 00
T 76 00 00 30 40
R 00 00 00 00
T 78 00 00
R 00 00 00 00
T 78 00 00 F8 02 7E D6 41 23 7E DE 00 56 3E 00 CB
R 00 00 00 00
T 85 00 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 8F 00 00
R 00 00 00 00
T 8F 00 00 CB 7A 28 01 37
R 00 00 00 00
T 94 00 00
R 00 00 00 00
T 94 00 00 38 1E F8 02 3E 46 96 23 3E 00 9E 3E 00
R 00 00 00 00
T A1 00 00 57 CB 7E 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T AD 00 00
R 00 00 00 00
T AD 00 00 CB 7A 28 01 37
R 00 00 00 00
T B2 00 00
R 00 00 00 00
T B2 00 00 30 04
R 00 00 00 00
T B4 00 00
R 00 00 00 00
T B4 00 00 1E 00 18 02
R 00 00 00 00
T B8 00 00
R 00 00 00 00
T B8 00 00 1E 01
R 00 00 00 00
T BA 00 00
R 00 00 00 00
T BA 00 00 16 00 C9
R 00 00 00 00
tolower.rel/    0           0     0     644     444       `
XL3
H 7 areas 2 global symbols
M tolower
O -mgbz80
S .__.ABS. Def000000
A _CODE size 14 flags 0 addr 0
S _tolower Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 C1 D1 D5 C5 4B 79 D6 41 D8 3E 5A 91 D8
R 00 00 00 00
T 0D 00 00 21 20 00 19 5D 54 C9
R 00 00 00 00
toupper.rel/    0           0     0     644     444       `
XL3
H 7 areas 2 global symbols
M toupper
O -mgbz80
S .__.ABS. Def000000
A _CODE size 14 flags 0 addr 0
S _toupper Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 C1 D1 D5 C5 4B 79 D6 61 D8 3E 7A 91 D8
R 00 00 00 00
T 0D 00 00 21 E0 FF 19 5D 54 C9
R 00 00 00 00
atoi.rel/       0           0     0     644     1582      `
XL3
H 7 areas 2 global symbols
M atoi
O -mgbz80
S .__.ABS. Def000000
A _CODE size A8 flags 0 addr 0
S _atoi Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FB 01 00 00 F8 07 2A 5F 56
R 00 00 00 00
T 0A 00 00
R 00 00 00 00
T 0A 00 00 1A F8 02 77 3A 77 D5 6B 62 23 D1 E5 7D
R 00 00 00 00
T 17 00 00 F8 05 77 E1 7C F8 04 77 F8 01 7E D6 20
R 00 00 00 00
T 24 00 00 28 07 F8 01 7E D6 09 20 07
R 00 00 00 00
T 2D 00 00
R 00 00 00 00
T 2D 00 00 F8 03 2A 5F 56 18 D6
R 00 00 00 00
T 34 00 00
R 00 00 00 00
T 34 00 00 F8 07 7B 22 72 F8 02 7E D6 2D 3E 01 28
R 00 00 00 00
T 41 00 00 01 AF
R 00 00 00 00
T 43 00 00
R 00 00 00 00
T 43 00 00 F8 00 77 B7 20 07 23 23 7E D6 2B 20 08
R 00 00 00 00
T 50 00 00
R 00 00 00 00
T 50 00 00 F8 03 2A 5E F8 07 22 73
R 00 00 00 00
T 58 00 00
R 00 00 00 00
T 58 00 00 F8 07 2A 5E F8 03 22 73
R 00 00 00 00
T 60 00 00
R 00 00 00 00
T 60 00 00 F8 03 2A 5F 56 1A F8 01 77 2A 77 D6 30
R 00 00 00 00
T 6D 00 00 38 25 3E 39 96 38 20 69 60 29 29 09 29
R 00 00 00 00
T 7A 00 00 4D 44 F8 03 34 20 02 23 34
R 00 00 00 00
T 83 00 00
R 00 00 00 00
T 83 00 00 F8 01 7E 1E 00 C6 D0 6F 7B CE FF 67 09
R 00 00 00 00
T 90 00 00 4D 44 18 CC
R 00 00 00 00
T 94 00 00
R 00 00 00 00
T 94 00 00 F8 00 CB 46 28 09 AF 91 5F 3E 00 98 57
R 00 00 00 00
T A1 00 00 18 02
R 00 00 00 00
T A3 00 00
R 00 00 00 00
T A3 00 00 59 50
R 00 00 00 00
T A5 00 00
R 00 00 00 00
T A5 00 00 E8 05 C9
R 00 00 00 00
atol.rel/       0           0     0     644     2235      `
XL3
H 7 areas 3 global symbols
M atol
O -mgbz80
S .__.ABS. Def000000
S __mullong Ref000000
A _CODE size 11F flags 0 addr 0
S _atol Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F2 AF F8 03 22 22 22 77 F8 10 2A 4F
R 00 00 00 00
T 0D 00 00 46
R 00 00 00 00
T 0E 00 00
R 00 00 00 00
T 0E 00 00 0A F8 0D 77 59 50 13 FE 20 28 04 D6 09
R 00 00 00 00
T 1B 00 00 20 04
R 00 00 00 00
T 1D 00 00
R 00 00 00 00
T 1D 00 00 4B 42 18 ED
R 00 00 00 00
T 21 00 00
R 00 00 00 00
T 21 00 00 F8 10 79 22 70 F8 0D 7E D6 2D 3E 01 28
R 00 00 00 00
T 2E 00 00 01 AF
R 00 00 00 00
T 30 00 00
R 00 00 00 00
T 30 00 00 4F B7 20 07 F8 0D 7E D6 2B 20 05
R 00 00 00 00
T 3B 00 00
R 00 00 00 00
T 3B 00 00 F8 10 7B 22 72
R 00 00 00 00
T 40 00 00
R 00 00 00 00
T 40 00 00 F8 10 2A 5E F8 0C 22 73
R 00 00 00 00
T 48 00 00
R 00 00 00 00
T 48 00 00 F8 0C 2A 5F 56 1A 2B 2B 77 3A 77 D6 30
R 00 00 00 00
T 55 00 00 DA DC 00 3E 39 96 DA DC 00 C5 F8 07 2A
R 00 00 00 00 00 04 00 00 00 0A 00 00
T 62 00 00 66 6F E5 F8 07 2A 66 6F E5 21 00 00 E5
R 00 00 00 00
T 6F 00 00 21 0A 00 E5 CD 00 00 E8 08 E5 F8 04 73
R 00 00 00 00 02 08 01 00
T 7C 00 00 F8 05 72 E1 E5 7D F8 06 77 E1 7C F8 05
R 00 00 00 00
T 89 00 00 77 C1 F8 0C 34 20 02 23 34
R 00 00 00 00
T 92 00 00
R 00 00 00 00
T 92 00 00 F8 0B 7E 1E 00 C6 D0 47 7B CE FF F8 04
R 00 00 00 00
T 9F 00 00 70 23 77 17 9F 23 22 77 D1 D5 7B F8 04
R 00 00 00 00
T AC 00 00 86 5F 7A 23 8E F5 F8 0B 32 73 F8 04 2A
R 00 00 00 00
T B9 00 00 5F 56 F8 08 F1 7B 8E 5F 7A 23 8E F8 0B
R 00 00 00 00
T C6 00 00 32 7B 32 2B 54 5D F8 03 1A 22 13 1A 22
R 00 00 00 00
T D3 00 00 13 1A 22 13 1A 77 C3 48 00
R 00 00 00 00 00 0A 00 00
T DC 00 00
R 00 00 00 00
T DC 00 00 CB 41 28 22 11 00 00 7B F8 03 96 5F 7A
R 00 00 00 00
T E9 00 00 23 9E F5 F8 0D 32 73 11 00 00 F8 07 F1
R 00 00 00 00
T F6 00 00 7B 9E 5F 7A 23 9E F8 0D 32 73 18 11
R 00 00 00 00
T 02 01 00
R 00 00 00 00
T 02 01 00 F8 03 54 5D F8 0A 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 0F 01 00 22 13 1A 77
R 00 00 00 00
T 13 01 00
R 00 00 00 00
T 13 01 00 F8 0A 2A 5F 2A 57 2A 66 6F E8 0E C9
R 00 00 00 00

atoll.rel/      0           0     0     644     285       `
XL3
H 7 areas 1 global symbols
M atoll
O -mgbz80
S .__.ABS. Def000000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0

strtol.rel/     0           0     0     644     2847      `
XL3
H 7 areas 4 global symbols
M strtol
O -mgbz80
S _errno Ref000000
S .__.ABS. Def000000
S _strtoul Ref000000
A _CODE size 16B flags 0 addr 0
S _strtol Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F5 F8 0D 2A 5F 56
R 00 00 00 00
T 07 00 00
R 00 00 00 00
T 07 00 00 1A F8 0A 77 4B 42 03 FE 20 28 04 D6 09
R 00 00 00 00
T 14 00 00 20 04
R 00 00 00 00
T 16 00 00
R 00 00 00 00
T 16 00 00 59 50 18 ED
R 00 00 00 00
T 1A 00 00
R 00 00 00 00
T 1A 00 00 F8 02 7B 22 72 F8 0A 7E D6 2D 20 0B F8
R 00 00 00 00
T 27 00 00 04 3E 01 32 2B 79 22 70 18 04
R 00 00 00 00
T 31 00 00
R 00 00 00 00
T 31 00 00 AF F8 04 77
R 00 00 00 00
T 35 00 00
R 00 00 00 00
T 35 00 00 F8 0F 2A 5E F8 05 22 7B 32 2B CB 46 28
R 00 00 00 00
T 42 00 00 34 2B 2B 2A 5F 56 1A 4F FE 20 28 0D D6
R 00 00 00 00
T 4F 00 00 09 28 09 79 FE 2D 28 04 D6 2B 20 1C
R 00 00 00 00
T 5B 00 00
R 00 00 00 00
T 5B 00 00 F8 10 3A B6 28 0D F8 05 2A 5F 56 F8 0D
R 00 00 00 00
T 68 00 00 7E 12 13 23 7E 12
R 00 00 00 00
T 6E 00 00
R 00 00 00 00
T 6E 00 00 11 00 00 21 00 00 C3 68 01
R 00 00 00 00 00 0A 00 00
T 77 00 00
R 00 00 00 00
T 77 00 00 F8 00 4D 44 F8 11 2A 66 6F E5 C5 F8 06
R 00 00 00 00
T 84 00 00 2A 66 6F E5 CD 00 00 E8 06 4D 44 F8 07
R 00 00 00 00 02 08 02 00
T 91 00 00 7B 22 7A 22 79 22 70 F8 00 2A 23 96 20
R 00 00 00 00
T 9E 00 00 22 2B 2A 23 96 20 1C F8 10 3A B6 28 0D
R 00 00 00 00
T AB 00 00 F8 05 2A 5F 56 F8 0D 7E 12 13 23 7E 12
R 00 00 00 00
T B8 00 00
R 00 00 00 00
T B8 00 00 11 00 00 21 00 00 C3 68 01
R 00 00 00 00 00 0A 00 00
T C1 00 00
R 00 00 00 00
T C1 00 00 F8 10 3A B6 28 0D F8 05 2A 5F 56 F8 00
R 00 00 00 00
T CE 00 00 7E 12 13 23 7E 12
R 00 00 00 00
T D4 00 00
R 00 00 00 00
T D4 00 00 F8 04 CB 46 20 23 F8 07 3E FF 96 23 3E
R 00 00 00 00
T E1 00 00 FF 9E 23 3E FF 9E 23 3E 7F 9E 30 10 21
R 00 00 00 00
T EE 00 00 00 00 3E 22 22 36 00 11 FF FF 21 FF 7F
R 00 00 00 00 02 03 00 00
T FB 00 00 18 6B
R 00 00 00 00
T FD 00 00
R 00 00 00 00
T FD 00 00 F8 04 CB 46 28 23 F8 07 3E 00 96 23 3E
R 00 00 00 00
T 0A 01 00 00 9E 23 3E 00 9E 23 3E 80 9E 30 10 21
R 00 00 00 00
T 17 01 00 00 00 3E 22 22 36 00 11 00 00 21 00 80
R 00 00 00 00 02 03 00 00
T 24 01 00 18 42
R 00 00 00 00
T 26 01 00
R 00 00 00 00
T 26 01 00 F8 04 CB 46 28 22 11 00 00 7B F8 07 96
R 00 00 00 00
T 33 01 00 5F 7A 23 9E F5 F8 06 32 73 11 00 00 F8
R 00 00 00 00
T 40 01 00 0B F1 7B 9E 5F 7A 23 9E F8 06 32 73 18
R 00 00 00 00
T 4D 01 00 11
R 00 00 00 00
T 4E 01 00
R 00 00 00 00
T 4E 01 00 F8 07 54 5D F8 03 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 5B 01 00 22 13 1A 77
R 00 00 00 00
T 5F 01 00
R 00 00 00 00
T 5F 01 00 F8 03 2A 5F 2A 57 2A 66 6F
R 00 00 00 00
T 68 01 00
R 00 00 00 00
T 68 01 00 E8 0B C9
R 00 00 00 00

strtoul.rel/    0           0     0     644     4737      `
XL3
H 7 areas 5 global symbols
M strtoul
O -mgbz80
S _errno Ref000000
S .__.ABS. Def000000
S _strncmp Ref000000
S __mullong Ref000000
A _CODE size 268 flags 0 addr 0
S _strtoul Def000042
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 7E 4F D6 30 38 0B 3E 39 96 38 06
R 00 00 00 00
T 0D 00 00 79 C6 D0 5F 18 27
R 00 00 00 00
T 13 00 00
R 00 00 00 00
T 13 00 00 F8 02 7E D6 61 38 0B 3E 7A 96 38 06 79
R 00 00 00 00
T 20 00 00 C6 A9 5F 18 15
R 00 00 00 00
T 25 00 00
R 00 00 00 00
T 25 00 00 F8 02 7E D6 41 38 0B 3E 5A 96 38 06 79
R 00 00 00 00
T 32 00 00 C6 C9 5F 18 03
R 00 00 00 00
T 37 00 00
R 00 00 00 00
T 37 00 00 1E FF C9
R 00 00 00 00
T 3A 00 00
R 00 00 00 00
T 3A 00 00 7B F8 03 96 D8 1E FF C9
R 00 00 00 00
T 42 00 00
R 00 00 00 00
T 42 00 00 E8 EC F8 16 2A 4F 46 AF F8 00 77 AF 23
R 00 00 00 00
T 4F 00 00 77
R 00 00 00 00
T 50 00 00
R 00 00 00 00
T 50 00 00 0A 5F FE 20 28 04 D6 09 20 03
R 00 00 00 00
T 5A 00 00
R 00 00 00 00
T 5A 00 00 03 18 F3
R 00 00 00 00
T 5D 00 00
R 00 00 00 00
T 5D 00 00 7B FE 2B 28 08 D6 2D 20 05 F8 01 36 01
R 00 00 00 00
T 6A 00 00
R 00 00 00 00
T 6A 00 00 03
R 00 00 00 00
T 6B 00 00
R 00 00 00 00
T 6B 00 00 21 02 00 09 E5 7D F8 14 77 E1 7C F8 13
R 00 00 00 00
T 78 00 00 77 F8 1B 3A B6 20 4E C5 21 02 00 E5 21
R 00 00 00 00
T 85 00 00 62 02 E5 C5 CD 00 00 E8 06 C1 7A B3 28
R 00 00 00 00 00 03 00 00 02 08 02 00
T 92 00 00 14 C5 21 02 00 E5 21 65 02 E5 C5 CD
R 00 00 00 00 00 0A 00 00
T 9E 00 00 00 00 E8 06 C1 7A B3 20 0E
R 00 00 00 00 02 03 02 00
T A7 00 00
R 00 00 00 00
T A7 00 00 F8 1A 36 10 AF 23 77 F8 12 2A 4F 46 18
R 00 00 00 00
T B4 00 00 4E
R 00 00 00 00
T B5 00 00
R 00 00 00 00
T B5 00 00 0A D6 30 20 0A F8 1A 36 08 AF 23 77 03
R 00 00 00 00
T C2 00 00 18 3F
R 00 00 00 00
T C4 00 00
R 00 00 00 00
T C4 00 00 F8 1A 36 0A AF 23 77 18 36
R 00 00 00 00
T CD 00 00
R 00 00 00 00
T CD 00 00 F8 1A 7E D6 10 23 B6 20 2D C5 21 02 00
R 00 00 00 00
T DA 00 00 E5 21 62 02 E5 C5 CD 00 00 E8 06 C1 7A
R 00 00 00 00 00 05 00 00 02 0A 02 00
T E7 00 00 B3 28 14 C5 21 02 00 E5 21 65 02 E5 C5
R 00 00 00 00 00 0C 00 00
T F4 00 00 CD 00 00 E8 06 C1 7A B3 20 05
R 00 00 00 00 02 04 02 00
T FE 00 00
R 00 00 00 00
T FE 00 00 F8 12 2A 4F 46
R 00 00 00 00
T 03 01 00
R 00 00 00 00
T 03 01 00 F8 1A 7E F8 02 77 0A C5 66 E5 33 F5 33
R 00 00 00 00
T 10 01 00 CD 00 00 E8 02 E5 F8 17 73 E1 C1 F8 18
R 00 00 00 00 00 04 00 00
T 1D 01 00 2A 5E F8 03 22 73 F8 13 CB 7E 28 1C F8
R 00 00 00 00
T 2A 01 00 19 3A B6 28 0D F8 03 2A 5F 56 F8 16 7E
R 00 00 00 00
T 37 01 00 12 13 23 7E 12
R 00 00 00 00
T 3C 01 00
R 00 00 00 00
T 3C 01 00 11 00 00 21 00 00 C3 5F 02
R 00 00 00 00 00 0A 00 00
T 45 01 00
R 00 00 00 00
T 45 01 00 AF F8 05 22 22 22 77 F8 12 79 22 70
R 00 00 00 00
T 51 01 00
R 00 00 00 00
T 51 01 00 F8 12 2A 5F 56 1A F8 02 66 E5 33 F5 33
R 00 00 00 00
T 5E 01 00 CD 00 00 E8 02 F8 09 73 CB 7E C2 F4 01
R 00 00 00 00 00 04 00 00 00 0E 00 00
T 6B 01 00 F8 05 54 5D F8 0A 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 78 01 00 22 13 1A 77 F8 1A 2A 4F 7E 47 17 9F 5F
R 00 00 00 00
T 85 01 00 57 D5 C5 F8 0B 2A 66 6F E5 F8 0B 2A 66
R 00 00 00 00
T 92 01 00 6F E5 CD 00 00 E8 08 4D 44 F8 0E 7B 22
R 00 00 00 00 02 06 03 00
T 9F 01 00 7A 22 79 22 70 F8 0E 5D 54 F8 0A 1A 96
R 00 00 00 00
T AC 01 00 23 13 1A 9E 23 13 1A 9E 23 13 1A 9E 30
R 00 00 00 00
T B9 01 00 04 F8 00 36 01
R 00 00 00 00
T BE 01 00
R 00 00 00 00
T BE 01 00 F8 09 2A 77 AF 23 22 22 22 2A 5F 56 7B
R 00 00 00 00
T CB 01 00 F8 0A 86 5F 7A 23 8E F5 F8 08 32 73 F8
R 00 00 00 00
T D8 01 00 12 2A 5F 56 F8 0E F1 7B 8E 5F 7A 23 8E
R 00 00 00 00
T E5 01 00 F8 08 32 73 F8 12 34 C2 51 01 23 34 C3
R 00 00 00 00 00 0B 00 00
T F2 01 00 51 01
R 00 00 00 00 00 03 00 00
T F4 01 00
R 00 00 00 00
T F4 01 00 F8 19 3A B6 28 0D F8 03 2A 5F 56 F8 12
R 00 00 00 00
T 01 02 00 7E 12 13 23 7E 12
R 00 00 00 00
T 07 02 00
R 00 00 00 00
T 07 02 00 F8 00 CB 46 28 10 21 00 00 3E 22 22 36
R 00 00 00 00 02 0A 00 00
T 14 02 00 00 11 FF FF 21 FF FF 18 42
R 00 00 00 00
T 1D 02 00
R 00 00 00 00
T 1D 02 00 F8 01 CB 46 28 22 11 00 00 7B F8 05 96
R 00 00 00 00
T 2A 02 00 5F 7A 23 9E F5 F8 13 32 73 11 00 00 F8
R 00 00 00 00
T 37 02 00 09 F1 7B 9E 5F 7A 23 9E F8 13 32 73 18
R 00 00 00 00
T 44 02 00 11
R 00 00 00 00
T 45 02 00
R 00 00 00 00
T 45 02 00 F8 05 54 5D F8 10 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 52 02 00 22 13 1A 77
R 00 00 00 00
T 56 02 00
R 00 00 00 00
T 56 02 00 F8 10 2A 5F 2A 57 2A 66 6F
R 00 00 00 00
T 5F 02 00
R 00 00 00 00
T 5F 02 00 E8 14 C9
R 00 00 00 00
T 62 02 00
R 00 00 00 00
T 62 02 00 30 78 00
R 00 00 00 00
T 65 02 00
R 00 00 00 00
T 65 02 00 30 58 00
R 00 00 00 00

bsearch.rel/    0           0     0     644     1750      `
XL3
H 7 areas 4 global symbols
M bsearch
O -mgbz80
S __mulint Ref000000
S .__.ABS. Def000000
S ___sdcc_call_hl Ref000000
A _CODE size C6 flags 0 addr 0
S _bsearch Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F8 F8 0C 2A 5E F8 00 22 73
R 00 00 00 00
T 0A 00 00
R 00 00 00 00
T 0A 00 00 F8 0F 3A B6 CA C0 00 2A 4F 46 CB 38 CB
R 00 00 00 00 00 08 00 00
T 17 00 00 19 C5 23 2A 66 6F E5 C5 CD 00 00 E8 04
R 00 00 00 00 02 0C 00 00
T 24 00 00 C1 E1 E5 19 5D 54 F8 02 7B 22 7A 32 2A
R 00 00 00 00
T 31 00 00 5E 23 22 73 C5 2B 2A 66 6F E5 F8 0E 2A
R 00 00 00 00
T 3E 00 00 66 6F E5 F8 18 2A 66 6F CD 00 00 E8 04
R 00 00 00 00 02 0C 02 00
T 4B 00 00 E5 F8 0A 73 F8 0B 72 E1 C1 F8 06 7E D6
R 00 00 00 00
T 58 00 00 00 23 7E DE 00 56 3E 00 CB 7F 28 07 CB
R 00 00 00 00
T 65 00 00 7A 20 08 BF 18 05
R 00 00 00 00
T 6B 00 00
R 00 00 00 00
T 6B 00 00 CB 7A 28 01 37
R 00 00 00 00
T 70 00 00
R 00 00 00 00
T 70 00 00 30 07 F8 0E 79 22 70 18 91
R 00 00 00 00
T 79 00 00
R 00 00 00 00
T 79 00 00 F8 06 3E 00 96 23 3E 00 9E 3E 00 57 CB
R 00 00 00 00
T 86 00 00 7E 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 90 00 00
R 00 00 00 00
T 90 00 00 CB 7A 28 01 37
R 00 00 00 00
T 95 00 00
R 00 00 00 00
T 95 00 00 30 22 F8 02 2A 5F 56 F8 10 2A 66 6F 19
R 00 00 00 00
T A2 00 00 4D 44 33 33 C5 F8 0E 2A 4F 46 0B 2B 79
R 00 00 00 00
T AF 00 00 22 70 CB 3E 2B CB 1E C3 0A 00
R 00 00 00 00 00 0B 00 00
T B9 00 00
R 00 00 00 00
T B9 00 00 F8 04 2A 5F 56 18 03
R 00 00 00 00
T C0 00 00
R 00 00 00 00
T C0 00 00 11 00 00
R 00 00 00 00
T C3 00 00
R 00 00 00 00
T C3 00 00 E8 08 C9
R 00 00 00 00
qsort.rel/      0           0     0     644     2160      `
XL3
H 7 areas 4 global symbols
M qsort
O -mgbz80
S __mulint Ref000000
S .__.ABS. Def000000
S ___sdcc_call_hl Ref000000
A _CODE size 11E flags 0 addr 0
S _qsort Def000050
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FB F8 07 2A 5E F8 01 22 73 F8 09 2A
R 00 00 00 00
T 0D 00 00 5E F8 03 22 73 F8 0B 2A 4F 46
R 00 00 00 00
T 17 00 00
R 00 00 00 00
T 17 00 00 59 50 0B 7A B3 28 2F F8 01 2A 5F 56 1A
R 00 00 00 00
T 24 00 00 2B 2B 77 F8 03 2A 5F 56 1A F8 01 F5 2A
R 00 00 00 00
T 31 00 00 66 6F F1 77 F8 03 2A 5F 56 F8 00 7E 12
R 00 00 00 00
T 3E 00 00 23 34 20 02 23 34
R 00 00 00 00
T 44 00 00
R 00 00 00 00
T 44 00 00 F8 03 34 20 CE 23 34 18 CA
R 00 00 00 00
T 4D 00 00
R 00 00 00 00
T 4D 00 00 E8 05 C9
R 00 00 00 00
T 50 00 00
R 00 00 00 00
T 50 00 00 E8 F4 F8 0E 2A 4F 46 33 33 C5 23 3E 01
R 00 00 00 00
T 5D 00 00 96 23 3E 00 9E D2 1B 01 F8 0A 79 22 70
R 00 00 00 00 00 09 00 00
T 6A 00 00 F8 12 2A 5E F8 02 22 73 C1 E1 E5 C5 E5
R 00 00 00 00
T 77 00 00 F8 12 2A 66 6F E5 CD 00 00 E8 04 E1 E5
R 00 00 00 00 02 0A 00 00
T 84 00 00 19 E5 7D F8 06 77 E1 7C F8 05 77
R 00 00 00 00
T 8F 00 00
R 00 00 00 00
T 8F 00 00 F8 0A 5D 54 F8 04 1A 96 23 13 1A 9E D2
R 00 00 00 00
T 9C 00 00 1B 01 F8 0A 2A 5E F8 08 22 73
R 00 00 00 00 00 03 00 00
T A6 00 00
R 00 00 00 00
T A6 00 00 F8 00 5D 54 F8 08 1A 96 23 13 1A 9E 30
R 00 00 00 00
T B3 00 00 4F F8 08 2A 5F 56 F8 02 2A 66 6F 7B 95
R 00 00 00 00
T C0 00 00 5F 7A 9C F8 07 32 7B 22 2B 2A 4F 46 C5
R 00 00 00 00
T CD 00 00 23 2A 66 6F E5 F8 18 2A 66 6F CD 00 00
R 00 00 00 00 02 0E 02 00
T DA 00 00 E8 04 42 CB 78 28 22 F8 06 2A 4F 46 F8
R 00 00 00 00
T E7 00 00 02 2A 66 6F E5 C5 F8 0C 2A 66 6F E5 CD
R 00 00 00 00
T F4 00 00 00 00 E8 06 F8 06 2A 4F 2A 47 79 22 70
R 00 00 00 00 00 03 00 00
T 01 01 00 18 A3
R 00 00 00 00
T 03 01 00
R 00 00 00 00
T 03 01 00 F8 02 2A 5F 56 F8 0A 2A 66 6F 19 E5 7D
R 00 00 00 00
T 10 01 00 F8 0C 77 E1 7C F8 0B 77 C3 8F 00
R 00 00 00 00 00 0C 00 00
T 1B 01 00
R 00 00 00 00
T 1B 01 00 E8 0C C9
R 00 00 00 00
abs.rel/        0           0     0     644     269       `
XL3
H 1 areas 2 global symbols
S .__.ABS. Def000000
A _CODE size F flags 0 addr 0
S _abs Def000000
T 00 00 00
R 00 00 00 00
T 00 00 00 E1 D1 D5 CB 7A 28 07 7B 2F 5F 7A 2F 57
R 00 00 00 00
T 0D 00 00 13
R 00 00 00 00
T 0E 00 00
R 00 00 00 00
T 0E 00 00 E9
R 00 00 00 00

labs.rel/       0           0     0     644     981       `
XL3
H 7 areas 2 global symbols
M labs
O -mgbz80
S .__.ABS. Def000000
A _CODE size 65 flags 0 addr 0
S _labs Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FC F8 06 7E D6 00 23 7E DE 00 23 7E
R 00 00 00 00
T 0D 00 00 DE 00 23 7E DE 00 56 3E 00 CB 7F 28 07
R 00 00 00 00
T 1A 00 00 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 21 00 00
R 00 00 00 00
T 21 00 00 CB 7A 28 01 37
R 00 00 00 00
T 26 00 00
R 00 00 00 00
T 26 00 00 30 22 11 00 00 7B F8 06 96 5F 7A 23 9E
R 00 00 00 00
T 33 00 00 F5 F8 03 32 73 11 00 00 F8 0A F1 7B 9E
R 00 00 00 00
T 40 00 00 5F 7A 23 9E F8 03 32 73 18 11
R 00 00 00 00
T 4A 00 00
R 00 00 00 00
T 4A 00 00 F8 06 54 5D F8 00 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 57 00 00 22 13 1A 77
R 00 00 00 00
T 5B 00 00
R 00 00 00 00
T 5B 00 00 D1 D5 F8 02 2A 66 6F E8 04 C9
R 00 00 00 00

rand.rel/       0           0     0     644     1353      `
XL3
H 7 areas 3 global symbols
M rand
O -mgbz80
S .__.ABS. Def000000
A _CODE size 93 flags 0 addr 0
S _rand Def000000
S _srand Def00007F
A _DATA size 4 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size E flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 01 00
T 00 00 00 21 00 00 36 01 23 36 00 23 36 00 23 36
R 00 00 04 00 00 04 01 00
T 0D 00 00 80
R 00 00 04 00
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FC 21 00 00 54 5D F8 00 1A 22 13 1A
R 00 00 00 00 00 06 01 00
T 0D 00 00 22 13 1A 22 13 1A 77 F8 01 2A 4F 2A 47
R 00 00 00 00
T 1A 00 00 5E 16 00 3E 02
R 00 00 00 00
T 1F 00 00
R 00 00 00 00
T 1F 00 00 CB 3B CB 18 CB 19 3D 20 F7 F8 00 7E A9
R 00 00 00 00
T 2C 00 00 22 7E A8 22 7E AB 22 7E AA 77 F8 00 2A
R 00 00 00 00
T 39 00 00 57 2A 46 1E 00 CB 22 8F CB 10 F5 2B 2B
R 00 00 00 00
T 46 00 00 7E AB 5F 23 7E AA 57 F1 23 AE 4F 23 7E
R 00 00 00 00
T 53 00 00 A8 47 F8 00 70 AF 23 22 22 77 F8 00 CB
R 00 00 00 00
T 60 00 00 3E 7B AE 5F 7A 23 AE 57 79 23 AE 4F 78
R 00 00 00 00
T 6D 00 00 23 AE 47 21 00 00 7B 22 7A 22 79 22 70
R 00 00 00 00 00 07 01 00
T 7A 00 00 CB BA E8 04 C9
R 00 00 00 00
T 7F 00 00
R 00 00 00 00
T 7F 00 00 F8 02 2A 4E 11 00 00 21 00 00 22 79 22
R 00 00 00 00 00 0B 01 00
T 8C 00 00 73 7A F6 80 23 77 C9
R 00 00 00 00

_strcat.rel/    0           0     0     644     595       `
XL3
H 7 areas 2 global symbols
M _strcat
O -mgbz80
S .__.ABS. Def000000
A _CODE size 1D flags 0 addr 0
S _strcat Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 C1 D1 D5 C5
R 00 00 00 00
T 04 00 00
R 00 00 00 00
T 04 00 00 1A B7 28 03 13 18 F9
R 00 00 00 00
T 0B 00 00
R 00 00 00 00
T 0B 00 00 F8 04 2A 4F 46
R 00 00 00 00
T 10 00 00
R 00 00 00 00
T 10 00 00 0A 03 12 13 B7 20 F9 F8 02 2A 5F 56 C9
R 00 00 00 00

_strchr.rel/    0           0     0     644     808       `
XL3
H 7 areas 2 global symbols
M _strchr
O -mgbz80
S .__.ABS. Def000000
A _CODE size 32 flags 0 addr 0
S _strchr Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 3B F8 03 2A 5F 56
R 00 00 00 00
T 06 00 00
R 00 00 00 00
T 06 00 00 1A F8 00 77 4E 06 00 F8 05 7E 91 20 07
R 00 00 00 00
T 13 00 00 23 7E 90 3E 01 28 01
R 00 00 00 00
T 1A 00 00
R 00 00 00 00
T 1A 00 00 AF
R 00 00 00 00
T 1B 00 00
R 00 00 00 00
T 1B 00 00 4F F8 00 7E B7 28 07 CB 41 20 03 13 18
R 00 00 00 00
T 28 00 00 DD
R 00 00 00 00
T 29 00 00
R 00 00 00 00
T 29 00 00 79 B7 20 03 11 00 00
R 00 00 00 00
T 30 00 00
R 00 00 00 00
T 30 00 00 33 C9
R 00 00 00 00
_strcspn.rel/   0           0     0     644     757       `
XL3
H 7 areas 3 global symbols
M _strcspn
O -mgbz80
S .__.ABS. Def000000
S _strchr Ref000000
A _CODE size 37 flags 0 addr 0
S _strcspn Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FE AF F8 00 22 77 F8 04 2A 4F 46
R 00 00 00 00
T 0C 00 00
R 00 00 00 00
T 0C 00 00 0A 5F B7 28 1E 16 00 C5 D5 F8 0A 2A 66
R 00 00 00 00
T 19 00 00 6F E5 CD 00 00 E8 04 C1 7A B3 20 0A F8
R 00 00 00 00 02 06 01 00
T 26 00 00 00 34 20 02 23 34
R 00 00 00 00
T 2C 00 00
R 00 00 00 00
T 2C 00 00 03 18 DD
R 00 00 00 00
T 2F 00 00
R 00 00 00 00
T 2F 00 00 F8 00 2A 5F 56 E8 02 C9
R 00 00 00 00

strdup.rel/     0           0     0     644     608       `
XL3
H 7 areas 5 global symbols
M strdup
O -mgbz80
S _strcpy Ref000000
S _malloc Ref000000
S .__.ABS. Def000000
S _strlen Ref000000
A _CODE size 23 flags 0 addr 0
S _strdup Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 C1 E1 E5 C5 E5 CD 00 00 E8 02 13 D5 CD
R 00 00 00 00 02 09 03 00
T 0D 00 00 00 00 E8 02 7A B3 C8 D5 F8 04 2A 66 6F
R 00 00 00 00 02 03 01 00
T 1A 00 00 E5 D5 CD 00 00 E8 04 D1 C9
R 00 00 00 00 02 06 00 00
strndup.rel/    0           0     0     644     946       `
XL3
H 7 areas 5 global symbols
M strndup
O -mgbz80
S _malloc Ref000000
S .__.ABS. Def000000
S ___memcpy Ref000000
S _strlen Ref000000
A _CODE size 58 flags 0 addr 0
S _strndup Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FC F8 06 2A 66 6F E5 CD 00 00 E8 02
R 00 00 00 00 02 0C 03 00
T 0D 00 00 4B 42 F8 08 7E 91 23 7E 98 30 05 F8 08
R 00 00 00 00
T 1A 00 00 2A 4F 46
R 00 00 00 00
T 1D 00 00
R 00 00 00 00
T 1D 00 00 59 50 13 C5 D5 CD 00 00 E8 02 C1 33 33
R 00 00 00 00 02 09 00 00
T 2A 00 00 D5 F8 01 3A B6 28 1F F8 06 2A 5E F8 02
R 00 00 00 00
T 37 00 00 22 73 D1 D5 C5 C5 2B 2A 66 6F E5 D5 CD
R 00 00 00 00
T 44 00 00 00 00 E8 06 C1 E1 E5 09 4D 44 AF 02
R 00 00 00 00 02 03 02 00
T 50 00 00
R 00 00 00 00
T 50 00 00 F8 00 2A 5F 56 E8 04 C9
R 00 00 00 00
_strncat.rel/   0           0     0     644     1203      `
XL3
H 7 areas 2 global symbols
M _strncat
O -mgbz80
S .__.ABS. Def000000
A _CODE size 83 flags 0 addr 0
S _strncat Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F8 F8 0A 2A 5E F8 00 22 73 C1 C5
R 00 00 00 00
T 0C 00 00
R 00 00 00 00
T 0C 00 00 0A 03 B7 20 FB 11 01 00 79 93 5F 78 9A
R 00 00 00 00
T 19 00 00 F8 0B 32 7B 22 23 2A 5E F8 02 22 73 F8
R 00 00 00 00
T 26 00 00 0A 2A 5E F8 04 22 73 F8 0E 2A 5E F8 06
R 00 00 00 00
T 33 00 00 22 73
R 00 00 00 00
T 35 00 00
R 00 00 00 00
T 35 00 00 F8 06 2A 4F 3A 47 2A 5F 56 1B 2B 7B 22
R 00 00 00 00
T 42 00 00 72 78 B1 28 2D F8 02 2A 5F 56 1A 4F 2B
R 00 00 00 00
T 4F 00 00 34 20 02 23 34
R 00 00 00 00
T 54 00 00
R 00 00 00 00
T 54 00 00 F8 04 2A 66 6F 71 F8 04 34 20 02 23 34
R 00 00 00 00
T 61 00 00
R 00 00 00 00
T 61 00 00 F8 04 2A 5E F8 0A 22 73 79 B7 20 C8 F8
R 00 00 00 00
T 6E 00 00 00 2A 5F 56 18 0C
R 00 00 00 00
T 74 00 00
R 00 00 00 00
T 74 00 00 F8 0A 2A 5F 56 AF 12 F8 00 2A 5F 56
R 00 00 00 00
T 80 00 00
R 00 00 00 00
T 80 00 00 E8 08 C9
R 00 00 00 00

_strncmp.rel/   0           0     0     644     1007      `
XL3
H 7 areas 2 global symbols
M _strncmp
O -mgbz80
S .__.ABS. Def000000
A _CODE size 63 flags 0 addr 0
S _strncmp Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FA F8 0D 3A B6 20 05 11 00 00 18 53
R 00 00 00 00
T 0D 00 00
R 00 00 00 00
T 0D 00 00 F8 08 2A 5E F8 02 22 73 F8 0A 2A 5E F8
R 00 00 00 00
T 1A 00 00 04 22 73 F8 0C 2A 4F 46
R 00 00 00 00
T 22 00 00
R 00 00 00 00
T 22 00 00 0B F8 02 2A 5F 56 1A F8 00 77 F8 04 2A
R 00 00 00 00
T 2F 00 00 5F 56 1A F8 01 77 78 B1 28 19 2B 7E B7
R 00 00 00 00
T 3C 00 00 28 14 2A 96 20 10 F8 02 34 20 02 23 34
R 00 00 00 00
T 49 00 00
R 00 00 00 00
T 49 00 00 F8 04 34 20 D4 23 34 18 D0
R 00 00 00 00
T 52 00 00
R 00 00 00 00
T 52 00 00 F8 00 7E 0E 00 23 46 16 00 90 5F 79 9A
R 00 00 00 00
T 5F 00 00 57
R 00 00 00 00
T 60 00 00
R 00 00 00 00
T 60 00 00 E8 06 C9
R 00 00 00 00

strxfrm.rel/    0           0     0     644     582       `
XL3
H 7 areas 4 global symbols
M strxfrm
O -mgbz80
S .__.ABS. Def000000
S _strncpy Ref000000
S _strlen Ref000000
A _CODE size 24 flags 0 addr 0
S _strxfrm Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 06 2A 66 6F E5 F8 06 2A 66 6F E5 F8
R 00 00 00 00
T 0D 00 00 06 2A 66 6F E5 CD 00 00 E8 06 F8 04 2A
R 00 00 00 00 02 09 01 00
T 1A 00 00 66 6F E5 CD 00 00 E8 02 13 C9
R 00 00 00 00 02 07 02 00
_strncpy.rel/   0           0     0     644     989       `
XL3
H 7 areas 2 global symbols
M _strncpy
O -mgbz80
S .__.ABS. Def000000
A _CODE size 5D flags 0 addr 0
S _strncpy Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FA F8 08 2A 5E F8 00 22 73 F8 0C 2A
R 00 00 00 00
T 0D 00 00 4F 46 F8 0A 2A 5E F8 02 22 73 F8 00 2A
R 00 00 00 00
T 1A 00 00 5E F8 04 22 73
R 00 00 00 00
T 1F 00 00
R 00 00 00 00
T 1F 00 00 78 B1 28 21 F8 02 2A 5F 56 1A B7 28 18
R 00 00 00 00
T 2C 00 00 0B 2B 34 20 02 23 34
R 00 00 00 00
T 33 00 00
R 00 00 00 00
T 33 00 00 F8 04 F5 2A 66 6F F1 77 F8 04 34 20 DF
R 00 00 00 00
T 40 00 00 23 34 18 DB
R 00 00 00 00
T 44 00 00
R 00 00 00 00
T 44 00 00 F8 04 2A 5F 56
R 00 00 00 00
T 49 00 00
R 00 00 00 00
T 49 00 00 69 60 0B 7C B5 28 05 AF 12 13 18 F4
R 00 00 00 00
T 55 00 00
R 00 00 00 00
T 55 00 00 F8 00 2A 5F 56 E8 06 C9
R 00 00 00 00

_strpbrk.rel/   0           0     0     644     834       `
XL3
H 7 areas 3 global symbols
M _strpbrk
O -mgbz80
S .__.ABS. Def000000
S _strchr Ref000000
A _CODE size 40 flags 0 addr 0
S _strpbrk Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FE AF F8 00 22 77 F8 06 2A 4F 46
R 00 00 00 00
T 0C 00 00
R 00 00 00 00
T 0C 00 00 0A 5F B7 28 27 16 00 C5 D5 F8 08 2A 66
R 00 00 00 00
T 19 00 00 6F E5 CD 00 00 E8 04 C1 7A B3 28 10 F8
R 00 00 00 00 02 06 01 00
T 26 00 00 01 3A B6 28 07 7B 96 23 7A 9E 30 03
R 00 00 00 00
T 32 00 00
R 00 00 00 00
T 32 00 00 33 33 D5
R 00 00 00 00
T 35 00 00
R 00 00 00 00
T 35 00 00 03 18 D4
R 00 00 00 00
T 38 00 00
R 00 00 00 00
T 38 00 00 F8 00 2A 5F 56 E8 02 C9
R 00 00 00 00
_strrchr.rel/   0           0     0     644     921       `
XL3
H 7 areas 2 global symbols
M _strrchr
O -mgbz80
S .__.ABS. Def000000
A _CODE size 3E flags 0 addr 0
S _strrchr Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FE F8 04 2A 5E F8 00 22 73 D1 D5
R 00 00 00 00
T 0C 00 00
R 00 00 00 00
T 0C 00 00 1A 13 B7 20 FB
R 00 00 00 00
T 11 00 00
R 00 00 00 00
T 11 00 00 1B 1A 4F 06 00 F8 06 7E 91 20 07 23 7E
R 00 00 00 00
T 1E 00 00 90 3E 01 28 01
R 00 00 00 00
T 23 00 00
R 00 00 00 00
T 23 00 00 AF
R 00 00 00 00
T 24 00 00
R 00 00 00 00
T 24 00 00 4F F8 00 7E 93 20 05 23 7E 92 28 04
R 00 00 00 00
T 30 00 00
R 00 00 00 00
T 30 00 00 CB 41 28 DD
R 00 00 00 00
T 34 00 00
R 00 00 00 00
T 34 00 00 79 B7 20 03 11 00 00
R 00 00 00 00
T 3B 00 00
R 00 00 00 00
T 3B 00 00 E8 02 C9
R 00 00 00 00

_strspn.rel/    0           0     0     644     755       `
XL3
H 7 areas 3 global symbols
M _strspn
O -mgbz80
S .__.ABS. Def000000
S _strchr Ref000000
A _CODE size 37 flags 0 addr 0
S _strspn Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FE AF F8 00 22 77 F8 04 2A 4F 46
R 00 00 00 00
T 0C 00 00
R 00 00 00 00
T 0C 00 00 0A 5F B7 28 1E 16 00 C5 D5 F8 0A 2A 66
R 00 00 00 00
T 19 00 00 6F E5 CD 00 00 E8 04 C1 7A B3 28 0A F8
R 00 00 00 00 02 06 01 00
T 26 00 00 00 34 20 02 23 34
R 00 00 00 00
T 2C 00 00
R 00 00 00 00
T 2C 00 00 03 18 DD
R 00 00 00 00
T 2F 00 00
R 00 00 00 00
T 2F 00 00 F8 00 2A 5F 56 E8 02 C9
R 00 00 00 00

_strstr.rel/    0           0     0     644     1511      `
XL3
H 7 areas 2 global symbols
M _strstr
O -mgbz80
S .__.ABS. Def000000
A _CODE size AC flags 0 addr 0
S _strstr Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F3 F8 0F 2A 5E F8 00 22 73 F8 11 2A
R 00 00 00 00
T 0D 00 00 5E F8 02 22 7B 32 2A 5F 56 1A B7 20 08
R 00 00 00 00
T 1A 00 00 F8 00 2A 5F 56 C3 A9 00
R 00 00 00 00 00 09 00 00
T 22 00 00
R 00 00 00 00
T 22 00 00 F8 00 2A 5E F8 07 22 73
R 00 00 00 00
T 2A 00 00
R 00 00 00 00
T 2A 00 00 F8 07 2A 5F 56 1A B7 28 73 F8 02 2A 5E
R 00 00 00 00
T 37 00 00 F8 09 22 73 F8 07 2A 5E F8 0B 22 73
R 00 00 00 00
T 43 00 00
R 00 00 00 00
T 43 00 00 F8 0B 2A 5F 56 1A F8 06 77 F8 09 2A 5F
R 00 00 00 00
T 50 00 00 56 1A F8 04 22 23 7E B7 28 2E 2B 2B 7E
R 00 00 00 00
T 5D 00 00 B7 28 28 23 23 3A 77 AF 23 32 2B 4E 06
R 00 00 00 00
T 6A 00 00 00 23 2A 5F 56 7B 91 5F 7A 98 4B B1 20
R 00 00 00 00
T 77 00 00 10 F8 0B 34 20 02 23 34
R 00 00 00 00
T 7F 00 00
R 00 00 00 00
T 7F 00 00 F8 09 34 20 BF 23 34 18 BB
R 00 00 00 00
T 88 00 00
R 00 00 00 00
T 88 00 00 F8 04 7E B7 20 07 F8 00 2A 5F 56 18 14
R 00 00 00 00
T 95 00 00
R 00 00 00 00
T 95 00 00 F8 07 34 20 02 23 34
R 00 00 00 00
T 9C 00 00
R 00 00 00 00
T 9C 00 00 F8 07 2A 5E F8 00 22 73 18 84
R 00 00 00 00
T A6 00 00
R 00 00 00 00
T A6 00 00 11 00 00
R 00 00 00 00
T A9 00 00
R 00 00 00 00
T A9 00 00 E8 0D C9
R 00 00 00 00

_strtok.rel/    0           0     0     644     1470      `
XL3
H 7 areas 3 global symbols
M _strtok
O -mgbz80
S .__.ABS. Def000000
S _strchr Ref000000
A _CODE size 91 flags 0 addr 0
S _strtok Def000000
A _DATA size 2 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 03 3A B6 28 07 2A 5E 21 00 00 22 73
R 00 00 00 00 00 0C 01 00
T 0D 00 00
R 00 00 00 00
T 0D 00 00 21 01 00 3A B6 20 04 11 00 00 C9
R 00 00 00 00 00 04 01 00
T 18 00 00
R 00 00 00 00
T 18 00 00 21 01 00 2B 2A 4F 46 0A B7 28 1D 4F 06
R 00 00 00 00 00 04 01 00
T 25 00 00 00 C5 F8 06 2A 66 6F E5 CD 00 00 E8 04
R 00 00 00 00 02 0C 01 00
T 32 00 00 7A B3 28 0A 21 00 00 34 20 DC 23 34 18
R 00 00 00 00 00 08 01 00
T 3F 00 00 D8
R 00 00 00 00
T 40 00 00
R 00 00 00 00
T 40 00 00 21 01 00 2B 2A 5F 56
R 00 00 00 00 00 04 01 00
T 47 00 00
R 00 00 00 00
T 47 00 00 21 01 00 2B 2A 4F 46 0A B7 28 30 4F 06
R 00 00 00 00 00 04 01 00
T 54 00 00 00 D5 C5 F8 08 2A 66 6F E5 CD 00 00 E8
R 00 00 00 00 02 0D 01 00
T 61 00 00 04 4B 42 D1 78 B1 28 0F 21 01 00 2B 2A
R 00 00 00 00 00 0C 01 00
T 6E 00 00 4F 46 AF 02 2B 34 C0 23 34 C9
R 00 00 00 00
T 78 00 00
R 00 00 00 00
T 78 00 00 21 00 00 34 20 C9 23 34 18 C5
R 00 00 00 00 00 04 01 00
T 82 00 00
R 00 00 00 00
T 82 00 00 21 00 00 3E 00 22 36 00 1A B7 C0 11
R 00 00 00 00 00 04 01 00
T 8E 00 00 00 00 C9
R 00 00 00 00
memccpy.rel/    0           0     0     644     985       `
XL3
H 7 areas 2 global symbols
M memccpy
O -mgbz80
S .__.ABS. Def000000
A _CODE size 5C flags 0 addr 0
S _memccpy Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F9 F8 09 2A 5E F8 03 22 73 F8 0B 2A
R 00 00 00 00
T 0D 00 00 5E F8 05 22 73 F8 0F 2A 4F 46
R 00 00 00 00
T 17 00 00
R 00 00 00 00
T 17 00 00 59 50 0B 7A B3 28 38 F8 05 2A 5F 56 1A
R 00 00 00 00
T 24 00 00 F8 00 77 F8 05 34 20 02 23 34
R 00 00 00 00
T 2E 00 00
R 00 00 00 00
T 2E 00 00 F8 03 2A 5F 56 F8 00 7E 12 F8 03 34 20
R 00 00 00 00
T 3B 00 00 02 23 34
R 00 00 00 00
T 3E 00 00
R 00 00 00 00
T 3E 00 00 F8 03 2A 5E F8 01 22 73 F8 0D 5E F8 00
R 00 00 00 00
T 4B 00 00 7E 93 20 C8 F8 01 2A 5F 56 18 03
R 00 00 00 00
T 56 00 00
R 00 00 00 00
T 56 00 00 11 00 00
R 00 00 00 00
T 59 00 00
R 00 00 00 00
T 59 00 00 E8 07 C9
R 00 00 00 00

_memchr.rel/    0           0     0     644     838       `
XL3
H 7 areas 2 global symbols
M _memchr
O -mgbz80
S .__.ABS. Def000000
A _CODE size 3C flags 0 addr 0
S _memchr Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FC F8 06 2A 5F 56 D5 F8 0C 2A 66 6F
R 00 00 00 00
T 0D 00 00 19 D1 4D 44 33 33 C5 4B 42
R 00 00 00 00
T 16 00 00
R 00 00 00 00
T 16 00 00 F8 00 7E 91 20 05 23 7E 90 28 15
R 00 00 00 00
T 21 00 00
R 00 00 00 00
T 21 00 00 0A F8 02 77 F8 08 7E F8 03 32 2A 96 28
R 00 00 00 00
T 2E 00 00 0A 18 00
R 00 00 00 00
T 31 00 00
R 00 00 00 00
T 31 00 00 03 59 50 18 E0
R 00 00 00 00
T 36 00 00
R 00 00 00 00
T 36 00 00 11 00 00
R 00 00 00 00
T 39 00 00
R 00 00 00 00
T 39 00 00 E8 04 C9
R 00 00 00 00
_memcmp.rel/    0           0     0     644     928       `
XL3
H 7 areas 2 global symbols
M _memcmp
O -mgbz80
S .__.ABS. Def000000
A _CODE size 5A flags 0 addr 0
S _memcmp Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FC F8 0B 3A B6 20 05 11 00 00 18 4A
R 00 00 00 00
T 0D 00 00
R 00 00 00 00
T 0D 00 00 F8 0A 2A 5E F8 02 22 73
R 00 00 00 00
T 15 00 00
R 00 00 00 00
T 15 00 00 F8 02 2A 5F 56 1B 2B 7B 22 72 F8 06 2A
R 00 00 00 00
T 22 00 00 5F 2A 57 2A 4F 46 1A F8 00 77 0A 23 22
R 00 00 00 00
T 2F 00 00 23 3A B6 28 15 2B 2B 2A 96 20 0F 13 7A
R 00 00 00 00
T 3C 00 00 F8 06 73 23 77 03 78 23 71 23 77 18 CC
R 00 00 00 00
T 49 00 00
R 00 00 00 00
T 49 00 00 F8 00 7E 0E 00 23 46 16 00 90 5F 79 9A
R 00 00 00 00
T 56 00 00 57
R 00 00 00 00
T 57 00 00
R 00 00 00 00
T 57 00 00 E8 04 C9
R 00 00 00 00
_memset.rel/    0           0     0     644     561       `
XL3
H 7 areas 2 global symbols
M _memset
O -mgbz80
S .__.ABS. Def000000
A _CODE size 1A flags 0 addr 0
S _memset Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 5E 23 56 23 7E 23 23 4E 23 46 6B
R 00 00 00 00
T 0D 00 00 62 04 0C 18 01
R 00 00 00 00
T 12 00 00
R 00 00 00 00
T 12 00 00 22
R 00 00 00 00
T 13 00 00
R 00 00 00 00
T 13 00 00 0D 20 FC 05 20 F9 C9
R 00 00 00 00

/164            0           0     0     644     438       `
XL3
H 7 areas 3 global symbols
M aligned_alloc
O -mgbz80
S _malloc Ref000000
S .__.ABS. Def000000
A _CODE size C flags 0 addr 0
S _aligned_alloc Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 04 2A 66 6F E5 CD 00 00 E8 02 C9
R 00 00 00 00 02 0A 00 00
calloc.rel/     0           0     0     644     1079      `
XL3
H 7 areas 5 global symbols
M calloc
O -mgbz80
S _malloc Ref000000
S .__.ABS. Def000000
S _memset Ref000000
S __mullong Ref000000
A _CODE size 6C flags 0 addr 0
S _calloc Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FC F8 06 7E F8 00 77 F8 07 7E F8 01
R 00 00 00 00
T 0D 00 00 77 AF 23 22 77 F8 08 2A 4F 46 11 00 00
R 00 00 00 00
T 1A 00 00 D5 C5 F8 06 2A 66 6F E5 F8 06 2A 66 6F
R 00 00 00 00
T 27 00 00 E5 CD 00 00 E8 08 4D 44 3E FF BB 9A 3E
R 00 00 00 00 02 05 03 00
T 34 00 00 00 99 3E 00 98 30 05 11 00 00 18 29
R 00 00 00 00
T 40 00 00
R 00 00 00 00
T 40 00 00 F8 02 7B 22 72 C1 E1 E5 C5 E5 CD 00 00
R 00 00 00 00 02 0E 00 00
T 4D 00 00 E8 02 4B 42 59 78 57 B1 28 12 D5 F8 04
R 00 00 00 00
T 5A 00 00 2A 66 6F E5 21 00 00 E5 D5 CD 00 00 E8
R 00 00 00 00 02 0D 02 00
T 67 00 00 06 D1
R 00 00 00 00
T 69 00 00
R 00 00 00 00
T 69 00 00
R 00 00 00 00
T 69 00 00 E8 04 C9
R 00 00 00 00

malloc.rel/     0           0     0     644     2543      `
XL3
H 7 areas 6 global symbols
M malloc
O -mgbz80
S ___sdcc_heap_end Ref000000
S .__.ABS. Def000000
S ___sdcc_heap Ref000000
A _CODE size 12D flags 0 addr 0
S ___sdcc_heap_init Def000000
S _malloc Def00001E
A _DATA size 2 flags 0 addr 0
S ___sdcc_heap_free Def000000
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 00 00
T 00 00 00 21 00 00 3E 00 00 00 22 3E 00 00 00 32
R 00 00 00 00 00 04 01 00 0B 07 02 00 8B 0C 02 00
T 09 00 00 2A 4F 46 3E 00 00 00 02 03 3E 00 00 00
R 00 00 00 00 0B 07 00 00 8B 0D 00 00
T 12 00 00 02 2B 2A 4F 46 03 03 AF 02 03 02 C9
R 00 00 00 00
T 1E 00 00
R 00 00 00 00
T 1E 00 00 E8 F6 F8 0D 3A B6 28 0D 2A 5F 56 13 13
R 00 00 00 00
T 2B 00 00 2B 7B 96 23 7A 9E 30 06
R 00 00 00 00
T 33 00 00
R 00 00 00 00
T 33 00 00 11 00 00 C3 2A 01
R 00 00 00 00 00 07 00 00
T 39 00 00
R 00 00 00 00
T 39 00 00 F8 0C 7B 22 7A 32 7E D6 04 23 7E DE 00
R 00 00 00 00
T 46 00 00 30 07 F8 0C 36 04 AF 23 77
R 00 00 00 00
T 4F 00 00
R 00 00 00 00
T 4F 00 00 21 00 00 2A 5E F8 00 22 73 23 36
R 00 00 00 00 00 04 01 00
T 5A 00 00 00 00 00 23 36 00 00 00
R 00 00 00 00 09 03 01 00 89 08 01 00
T 5E 00 00
R 00 00 00 00
T 5E 00 00 F8 01 3A B6 CA 27 01 D1 D5 1A F8 06 22
R 00 00 00 00 00 08 00 00
T 6B 00 00 13 1A 32 2A 56 C1 C5 91 5F 7A 98 57 D5
R 00 00 00 00
T 78 00 00 F8 02 2A 5F 56 21 02 00 19 D1 E5 7D F8
R 00 00 00 00
T 85 00 00 06 77 E1 7C F8 05 77 F8 0C 7B 96 23 7A
R 00 00 00 00
T 92 00 00 9E 38 7C D5 F8 0E 2A 5F 56 21 04 00 19
R 00 00 00 00
T 9F 00 00 D1 E5 7D F8 0A 77 E1 7C F8 09 32 7B 96
R 00 00 00 00
T AC 00 00 23 7A 9E 38 47 F8 0C 2A 66 6F 09 4D 44
R 00 00 00 00
T B9 00 00 59 50 F8 06 7E 12 13 23 7E 12 21 02 00
R 00 00 00 00
T C6 00 00 09 E5 7D F8 08 77 E1 7C F8 07 32 2B 2B
R 00 00 00 00
T D3 00 00 2A 5F 56 1A F8 08 22 13 1A 32 2B 2B 2A
R 00 00 00 00
T E0 00 00 5F 2A 57 7E 12 13 23 7E 12 F8 02 2A 66
R 00 00 00 00
T ED 00 00 6F 79 22 70 E1 E5 79 22 70 18 12
R 00 00 00 00
T F8 00 00
R 00 00 00 00
T F8 00 00 F8 04 2A 5F 56 1A 4F 13 1A 47 F8 02 2A
R 00 00 00 00
T 05 01 00 66 6F 79 22 70
R 00 00 00 00
T 0A 01 00
R 00 00 00 00
T 0A 01 00 F8 04 2A 5F 56 18 19
R 00 00 00 00
T 11 01 00
R 00 00 00 00
T 11 01 00 F8 04 2A 5E F8 02 22 7B 22 2A 5F 56 1A
R 00 00 00 00
T 1E 01 00 F8 00 22 13 1A 77 C3 5E 00
R 00 00 00 00 00 0A 00 00
T 27 01 00
R 00 00 00 00
T 27 01 00 11 00 00
R 00 00 00 00
T 2A 01 00
R 00 00 00 00
T 2A 01 00 E8 0A C9
R 00 00 00 00

realloc.rel/    0           0     0     644     4720      `
XL3
H 7 areas 7 global symbols
M realloc
O -mgbz80
S _free Ref000000
S _memmove Ref000000
S _malloc Ref000000
S .__.ABS. Def000000
S ___memcpy Ref000000
S ___sdcc_heap_free Ref000000
A _CODE size 2BE flags 0 addr 0
S _realloc Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 EC F8 17 3A B6 20 0E 23 23 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 CD 00 00 E8 02 C3 BB 02
R 00 00 00 00 02 05 02 00 00 0A 00 00
T 16 00 00
R 00 00 00 00
T 16 00 00 F8 19 3A B6 20 11 2B 2B 2A 66 6F E5 CD
R 00 00 00 00
T 23 00 00 00 00 E8 02 11 00 00 C3 BB 02
R 00 00 00 00 02 03 00 00 00 0B 00 00
T 2D 00 00
R 00 00 00 00
T 2D 00 00 AF F8 00 22 77 AF 23 22 77 21 01 00 2B
R 00 00 00 00 02 0D 05 00
T 3A 00 00 4E 23 46 F8 04 36 00 00 00 23 36
R 00 00 00 00 0B 09 05 00
T 43 00 00 00 00 00
R 00 00 00 00 8B 03 05 00
T 44 00 00
R 00 00 00 00
T 44 00 00 78 B1 28 28 F8 16 2A 5E F8 12 22 7B 32
R 00 00 00 00
T 51 00 00 79 96 23 78 9E 30 18 33 33 C5 F8 04 2A
R 00 00 00 00
T 5E 00 00 5E F8 02 22 73 03 03 23 79 22 70 69 60
R 00 00 00 00
T 6B 00 00 2A 4F 46 18 D4
R 00 00 00 00
T 70 00 00
R 00 00 00 00
T 70 00 00 F8 06 79 22 70 F8 18 2A 4F 46 03 03 2B
R 00 00 00 00
T 7D 00 00 79 96 23 78 9E 30 06 11 00 00 C3 BB 02
R 00 00 00 00 00 0E 00 00
T 8A 00 00
R 00 00 00 00
T 8A 00 00 F8 08 79 22 78 32 7E D6 04 23 7E DE 00
R 00 00 00 00
T 97 00 00 30 07 F8 08 36 04 AF 23 77
R 00 00 00 00
T A0 00 00
R 00 00 00 00
T A0 00 00 F8 16 2A 5F 56 1B 1B F8 0A 7B 22 7A 32
R 00 00 00 00
T AD 00 00 2A 5F 56 1A 23 22 13 1A 32 2A 56 2B 2B
R 00 00 00 00
T BA 00 00 2B 4E 23 46 91 5F 7A 98 57 F8 0E 7B 22
R 00 00 00 00
T C7 00 00 7A 32 2A 5E F8 12 22 73 F8 01 3A B6 28
R 00 00 00 00
T D4 00 00 2E D1 D5 1A F8 10 22 13 1A 77 F8 0A 7E
R 00 00 00 00
T E1 00 00 F8 10 96 20 1D F8 0B 7E F8 11 96 20 15
R 00 00 00 00
T EE 00 00 D1 D5 79 93 4F 78 9A 47 F8 0E 2A 66 6F
R 00 00 00 00
T FB 00 00 09 4D 44 F8 12 79 22 70
R 00 00 00 00
T 03 01 00
R 00 00 00 00
T 03 01 00 F8 06 7E F8 0C 96 20 2C F8 07 7E F8 0D
R 00 00 00 00
T 10 01 00 96 20 24 F8 06 2A 5F 56 1A 4F 13 1A 47
R 00 00 00 00
T 1D 01 00 79 2B 4E 23 5E 91 4F 78 9B 47 F8 12 2A
R 00 00 00 00
T 2A 01 00 66 6F 09 E5 7D F8 14 77 E1 7C F8 13 77
R 00 00 00 00
T 37 01 00
R 00 00 00 00
T 37 01 00 F8 12 5D 54 F8 08 1A 96 23 13 1A 9E DA
R 00 00 00 00
T 44 01 00 6B 02 F8 01 3A B6 28 64 D1 D5 1A F8 10
R 00 00 00 00 00 03 00 00
T 51 01 00 22 13 1A 77 F8 0A 7E F8 10 96 20 53 F8
R 00 00 00 00
T 5E 01 00 0B 7E F8 11 96 20 4B F8 0E 5D 54 F8 08
R 00 00 00 00
T 6B 01 00 1A 96 23 13 1A 9E 38 07 F8 08 2A 4F 46
R 00 00 00 00
T 78 01 00 18 05
R 00 00 00 00
T 7A 01 00
R 00 00 00 00
T 7A 01 00 F8 0E 2A 4F 46
R 00 00 00 00
T 7F 01 00
R 00 00 00 00
T 7F 01 00 F8 0A 2A 5E F8 10 22 73 D1 D5 C5 2B 2A
R 00 00 00 00
T 8C 01 00 66 6F E5 D5 CD 00 00 E8 06 F8 00 2A 5E
R 00 00 00 00 02 08 01 00
T 99 01 00 F8 0A 22 73 C1 D1 D5 C5 F8 06 7E 12 13
R 00 00 00 00
T A6 01 00 23 7E 12 F8 02 2A 5E 23 22 73
R 00 00 00 00
T B0 01 00
R 00 00 00 00
T B0 01 00 F8 07 3A B6 28 40 F8 0A 2A 5F 56 1A F8
R 00 00 00 00
T BD 01 00 10 22 13 1A 77 F8 06 7E F8 10 96 20 2C
R 00 00 00 00
T CA 01 00 F8 07 7E F8 11 96 20 24 F8 06 2A 5F 56
R 00 00 00 00
T D7 01 00 1A 4F 13 1A 47 F8 0A 2A 66 6F 79 22 70
R 00 00 00 00
T E4 01 00 F8 06 2A 66 6F 23 23 2A 4F 46 F8 04 2A
R 00 00 00 00
T F1 01 00 66 6F 79 22 70
R 00 00 00 00
T F6 01 00
R 00 00 00 00
T F6 01 00 F8 08 2A 5F 56 21 04 00 19 4D 44 F8 12
R 00 00 00 00
T 03 02 00 7E 91 23 7E 98 38 58 F8 0A 2A 4F 46 F8
R 00 00 00 00
T 10 02 00 08 2A 66 6F 09 4D 44 F8 0A 2A 5F 56 1A
R 00 00 00 00
T 1D 02 00 F8 12 22 13 1A 77 59 50 2B 7E 12 13 23
R 00 00 00 00
T 2A 02 00 7E 12 21 02 00 09 E5 7D F8 12 77 E1 7C
R 00 00 00 00
T 37 02 00 F8 11 77 F8 04 2A 5F 56 1A F8 12 22 13
R 00 00 00 00
T 44 02 00 1A 32 2B 2B 2A 5F 2A 57 7E 12 13 23 7E
R 00 00 00 00
T 51 02 00 12 F8 04 2A 66 6F 79 22 70 F8 0A 2A 66
R 00 00 00 00
T 5E 02 00 6F 79 22 70
R 00 00 00 00
T 62 02 00
R 00 00 00 00
T 62 02 00 F8 0A 2A 5F 56 13 13 18 50
R 00 00 00 00
T 6B 02 00
R 00 00 00 00
T 6B 02 00 F8 18 2A 66 6F E5 CD 00 00 E8 02 F8 12
R 00 00 00 00 02 0A 02 00
T 78 02 00 7B 22 7A 77 B3 28 39 F8 0E 2A 4F 46 0B
R 00 00 00 00
T 85 02 00 0B F8 18 79 96 23 78 9E 38 05 F8 18 2A
R 00 00 00 00
T 92 02 00 4F 46
R 00 00 00 00
T 94 02 00
R 00 00 00 00
T 94 02 00 C5 F8 18 2A 66 6F E5 F8 16 2A 66 6F E5
R 00 00 00 00
T A1 02 00 CD 00 00 E8 06 F8 16 2A 66 6F E5 CD
R 00 00 00 00 02 04 04 00
T AD 02 00 00 00 E8 02 F8 12 2A 5F 56 18 03
R 00 00 00 00 02 03 00 00
T B8 02 00
R 00 00 00 00
T B8 02 00 11 00 00
R 00 00 00 00
T BB 02 00
R 00 00 00 00
T BB 02 00 E8 14 C9
R 00 00 00 00
free.rel/       0           0     0     644     1696      `
XL3
H 7 areas 3 global symbols
M free
O -mgbz80
S .__.ABS. Def000000
S ___sdcc_heap_free Ref000000
A _CODE size E2 flags 0 addr 0
S _free Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F8 F8 0B 3A B6 CA DF 00 AF F8 00 22
R 00 00 00 00 00 0A 00 00
T 0D 00 00 77 21 01 00 2B 4E 23 46 F8 02 36
R 00 00 00 00 02 05 01 00
T 18 00 00 00 00 00 23 36 00 00 00
R 00 00 00 00 0B 03 01 00 8B 08 01 00
T 1C 00 00
R 00 00 00 00
T 1C 00 00 78 B1 28 21 F8 0A 2A 5E F8 06 22 7B 32
R 00 00 00 00
T 29 00 00 79 96 23 78 9E 30 11 33 33 C5 03 03 F8
R 00 00 00 00
T 36 00 00 02 79 22 70 69 60 2A 4F 46 18 DB
R 00 00 00 00
T 41 00 00
R 00 00 00 00
T 41 00 00 F8 0A 2A 5F 56 1B 1B F8 04 7B 22 7A 32
R 00 00 00 00
T 4E 00 00 2A 5F 56 21 02 00 19 E5 7D F8 08 77 E1
R 00 00 00 00
T 5B 00 00 7C F8 07 32 2A 66 6F 79 22 70 F8 02 2A
R 00 00 00 00
T 68 00 00 5F 2A 57 7E 12 13 23 7E 12 2B 2A 5F 56
R 00 00 00 00
T 75 00 00 1A 6F 13 1A 67 7D 91 20 26 7C 90 20 22
R 00 00 00 00
T 82 00 00 23 23 2A 4F 46 F8 06 2A 66 6F 79 22 70
R 00 00 00 00
T 8F 00 00 F8 04 2A 5F 56 1A 6F 13 1A 67 2A 4F 46
R 00 00 00 00
T 9C 00 00 F8 04 2A 66 6F 79 22 70
R 00 00 00 00
T A4 00 00
R 00 00 00 00
T A4 00 00 F8 01 3A B6 28 35 D1 D5 1A 4F 13 1A 47
R 00 00 00 00
T B1 00 00 F8 04 7E 91 20 28 23 7E 90 20 23 F8 04
R 00 00 00 00
T BE 00 00 2A 5F 56 1A 4F 13 1A 47 E1 E5 79 22 70
R 00 00 00 00
T CB 00 00 C1 C5 03 03 F8 06 2A 5F 56 1A 2B 22 13
R 00 00 00 00
T D8 00 00 1A 32 2A 02 03 7E 02
R 00 00 00 00
T DF 00 00
R 00 00 00 00
T DF 00 00 E8 08 C9
R 00 00 00 00
mblen.rel/      0           0     0     644     1195      `
XL3
H 7 areas 2 global symbols
M mblen
O -mgbz80
S .__.ABS. Def000000
A _CODE size 69 flags 0 addr 0
S _mblen Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 3B F8 04 3A B6 20 05 11 00 00 18 5B
R 00 00 00 00
T 0C 00 00
R 00 00 00 00
T 0C 00 00 F8 06 3A B6 20 05 11 FF FF 18 50
R 00 00 00 00
T 17 00 00
R 00 00 00 00
T 17 00 00 F8 03 2A 4F 46 0A 5F B7 20 05 11 00 00
R 00 00 00 00
T 24 00 00 18 41
R 00 00 00 00
T 26 00 00
R 00 00 00 00
T 26 00 00 3E 7F 93 38 05 11 01 00 18 37
R 00 00 00 00
T 30 00 00
R 00 00 00 00
T 30 00 00 AF F8 00 77
R 00 00 00 00
T 34 00 00
R 00 00 00 00
T 34 00 00 CB 7B 28 07 CB 23 F8 00 34 18 F5
R 00 00 00 00
T 3F 00 00
R 00 00 00 00
T 3F 00 00 F8 00 5E 16 00 F8 05 7E 93 23 7E 9A 30
R 00 00 00 00
T 4C 00 00 05 11 FF FF 18 15
R 00 00 00 00
T 52 00 00
R 00 00 00 00
T 52 00 00
R 00 00 00 00
T 52 00 00 F8 00 35 28 10 03 0A E6 C0 67 2E 00 7C
R 00 00 00 00
T 5F 00 00 D6 80 B5 28 EE 11 FF FF
R 00 00 00 00
T 67 00 00
R 00 00 00 00
T 67 00 00
R 00 00 00 00
T 67 00 00 33 C9
R 00 00 00 00

mbtowc.rel/     0           0     0     644     3062      `
XL3
H 7 areas 2 global symbols
M mbtowc
O -mgbz80
S .__.ABS. Def000000
A _CODE size 17D flags 0 addr 0
S _mbtowc Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F3 F8 12 3A B6 20 06 11 00 00 C3
R 00 00 00 00
T 0C 00 00 7A 01
R 00 00 00 00 00 03 00 00
T 0E 00 00
R 00 00 00 00
T 0E 00 00 F8 00 36 01 F8 11 2A 5E F8 0B 22 7B 32
R 00 00 00 00
T 1B 00 00 2A 5F 56 1A 4F CB 79 28 34 1E 01
R 00 00 00 00
T 26 00 00
R 00 00 00 00
T 26 00 00 7B F5 21 80 00 F1 3C 18 04
R 00 00 00 00
T 2F 00 00
R 00 00 00 00
T 2F 00 00 CB 2C CB 1D
R 00 00 00 00
T 33 00 00
R 00 00 00 00
T 33 00 00 3D 20 F9 79 16 00 43 04 A5 6F 7A A4 B5
R 00 00 00 00
T 40 00 00 28 03 58 18 E1
R 00 00 00 00
T 45 00 00
R 00 00 00 00
T 45 00 00 F8 00 73 11 FF 00 04 18 04
R 00 00 00 00
T 4E 00 00
R 00 00 00 00
T 4E 00 00 CB 2A CB 1B
R 00 00 00 00
T 52 00 00
R 00 00 00 00
T 52 00 00 05 20 F9 7B A1 4F
R 00 00 00 00
T 58 00 00
R 00 00 00 00
T 58 00 00 3E 04 F8 00 96 38 0C 46 1E 00 F8 13 7E
R 00 00 00 00
T 65 00 00 90 23 7E 9B 30 06
R 00 00 00 00
T 6B 00 00
R 00 00 00 00
T 6B 00 00 11 FF FF C3 7A 01
R 00 00 00 00 00 07 00 00
T 71 00 00
R 00 00 00 00
T 71 00 00 06 01
R 00 00 00 00
T 73 00 00
R 00 00 00 00
T 73 00 00 78 F8 00 96 30 20 F8 0B 2A 5F 56 68 26
R 00 00 00 00
T 80 00 00 00 19 5D 54 1A E6 C0 5F 16 00 7B D6 80
R 00 00 00 00
T 8D 00 00 B2 28 06 11 FF FF C3 7A 01
R 00 00 00 00 00 0A 00 00
T 96 00 00
R 00 00 00 00
T 96 00 00 04 18 DA
R 00 00 00 00
T 99 00 00
R 00 00 00 00
T 99 00 00 F8 01 71 AF 23 22 22 77 F8 0B 2A 5F 56
R 00 00 00 00
T A6 00 00 6B 62 23 E5 7D F8 13 77 E1 7C F8 12 77
R 00 00 00 00
T B3 00 00 F8 00 4E 0D F8 11 2A 5F 56
R 00 00 00 00
T BC 00 00
R 00 00 00 00
T BC 00 00 79 B7 28 63 F5 F8 03 7E F8 07 77 F8 04
R 00 00 00 00
T C9 00 00 7E F8 08 77 F8 05 7E F8 09 77 F8 06 7E
R 00 00 00 00
T D6 00 00 F8 0A 77 F1 3E 06
R 00 00 00 00
T DC 00 00
R 00 00 00 00
T DC 00 00 F8 05 CB 26 23 CB 16 23 CB 16 23 CB 16
R 00 00 00 00
T E9 00 00 3D 20 F0 1A E6 3F 06 00 23 77 78 23 77
R 00 00 00 00
T F6 00 00 17 9F 23 22 77 F8 05 7E F8 09 B6 F8 01
R 00 00 00 00
T 03 01 00 77 F8 06 7E F8 0A B6 F8 02 77 F8 07 7E
R 00 00 00 00
T 10 01 00 F8 0B B6 F8 03 77 F8 08 7E F8 0C B6 F8
R 00 00 00 00
T 1D 01 00 04 77 13 0D 18 99
R 00 00 00 00
T 23 01 00
R 00 00 00 00
T 23 01 00 F8 01 7E D6 00 23 7E DE D8 23 7E DE 00
R 00 00 00 00
T 30 01 00 23 7E DE 00 38 18 F8 01 3E FF 96 23 3E
R 00 00 00 00
T 3D 01 00 DF 9E 23 3E 00 9E 23 3E 00 9E 38 05 11
R 00 00 00 00
T 4A 01 00 FF FF 18 2C
R 00 00 00 00
T 4E 01 00
R 00 00 00 00
T 4E 01 00 F8 10 3A B6 28 13 2A 5F 56 F8 01 7E 12
R 00 00 00 00
T 5B 01 00 13 23 7E 12 13 23 7E 12 13 23 7E 12
R 00 00 00 00
T 67 01 00
R 00 00 00 00
T 67 01 00 F8 04 3A B6 2B B6 2B B6 28 06 2B 5E 16
R 00 00 00 00
T 74 01 00 00 18 03
R 00 00 00 00
T 77 01 00
R 00 00 00 00
T 77 01 00 11 00 00
R 00 00 00 00
T 7A 01 00
R 00 00 00 00
T 7A 01 00
R 00 00 00 00
T 7A 01 00 E8 0D C9
R 00 00 00 00
wctomb.rel/     0           0     0     644     2575      `
XL3
H 7 areas 2 global symbols
M wctomb
O -mgbz80
S .__.ABS. Def000000
A _CODE size 175 flags 0 addr 0
S _wctomb Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F6 F8 0D 3A B6 20 06 11 00 00 C3
R 00 00 00 00
T 0C 00 00 72 01
R 00 00 00 00 00 03 00 00
T 0E 00 00
R 00 00 00 00
T 0E 00 00 F8 0C 2A 4F 2A 47 7E F8 09 77 F8 0E 7E
R 00 00 00 00
T 1B 00 00 D6 80 23 7E DE 00 23 7E DE 00 23 7E DE
R 00 00 00 00
T 28 00 00 00 30 0A F8 09 7E 02 11 01 00 C3 72 01
R 00 00 00 00 00 0E 00 00
T 35 00 00
R 00 00 00 00
T 35 00 00 F8 0E 2A 57 5E CB 3B CB 1A CB 3B CB 1A
R 00 00 00 00
T 42 00 00 CB 3B CB 1A CB 3B CB 1A CB 3B CB 1A CB
R 00 00 00 00
T 4F 00 00 3B CB 1A 69 60 23 33 33 E5 F8 09 7E E6
R 00 00 00 00
T 5C 00 00 3F F6 80 F8 02 77 F8 0E 7E D6 00 23 7E
R 00 00 00 00
T 69 00 00 DE 08 23 7E DE 00 23 7E DE 00 30 12 7A
R 00 00 00 00
T 76 00 00 E6 1F F6 C0 02 D1 D5 F8 02 7E 12 11
R 00 00 00 00
T 82 00 00 02 00 C3 72 01
R 00 00 00 00 00 06 00 00
T 87 00 00
R 00 00 00 00
T 87 00 00 F8 0E 7E D6 00 23 7E DE D8 23 7E DE 00
R 00 00 00 00
T 94 00 00 23 7E DE 00 38 19 F8 0E 7E D6 00 23 7E
R 00 00 00 00
T A1 00 00 DE E0 23 7E DE 00 23 7E DE 00 30 06 11
R 00 00 00 00
T AE 00 00 FF FF C3 72 01
R 00 00 00 00 00 06 00 00
T B3 00 00
R 00 00 00 00
T B3 00 00 F8 0F 7E F8 06 77 F8 10 7E F8 07 77 F8
R 00 00 00 00
T C0 00 00 11 7E F8 08 77 AF 23 77 3E 04
R 00 00 00 00
T CA 00 00
R 00 00 00 00
T CA 00 00 F8 08 CB 3E 2B CB 1E 2B CB 1E 3D 20 F3
R 00 00 00 00
T D7 00 00 21 02 00 09 E5 7D F8 05 77 E1 7C F8 04
R 00 00 00 00
T E4 00 00 22 23 5E 7A E6 3F F6 80 2B 77 F8 0E 7E
R 00 00 00 00
T F1 00 00 D6 00 23 7E DE 00 23 7E DE 01 23 7E DE
R 00 00 00 00
T FE 00 00 00 30 1A 7B E6 0F F6 E0 02 D1 D5 F8 05
R 00 00 00 00
T 0B 01 00 7E 12 2B 2B 2A 5F 3A 57 2B 7E 12 11
R 00 00 00 00
T 17 01 00 03 00 18 57
R 00 00 00 00
T 1B 01 00
R 00 00 00 00
T 1B 01 00 F8 0E 7E D6 00 23 7E DE 00 23 7E DE 11
R 00 00 00 00
T 28 01 00 23 7E DE 00 30 41 F8 10 7E F8 06 77 F8
R 00 00 00 00
T 35 01 00 11 7E F8 07 77 AF 23 22 77 3E 02
R 00 00 00 00
T 40 01 00
R 00 00 00 00
T 40 01 00 F8 07 CB 3E 2B CB 1E 3D 20 F6 7E E6 07
R 00 00 00 00
T 4D 01 00 F6 F0 02 7B E6 3F CB FF E1 E5 77 F8 03
R 00 00 00 00
T 5A 01 00 2A 5F 2A 57 7E 12 03 03 03 78 59 57 F8
R 00 00 00 00
T 67 01 00 02 7E 12 11 04 00 18 03
R 00 00 00 00
T 6F 01 00
R 00 00 00 00
T 6F 01 00 11 FF FF
R 00 00 00 00
T 72 01 00
R 00 00 00 00
T 72 01 00 E8 0A C9
R 00 00 00 00

mbstowcs.rel/   0           0     0     644     1281      `
XL3
H 7 areas 3 global symbols
M mbstowcs
O -mgbz80
S .__.ABS. Def000000
S _mbtowc Ref000000
A _CODE size 92 flags 0 addr 0
S _mbstowcs Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F6 AF F8 00 22 77 F8 0C 2A 5E F8 04
R 00 00 00 00
T 0D 00 00 22 73 AF 23 22 77 F8 10 2A 5E F8 08 22
R 00 00 00 00
T 1A 00 00 73
R 00 00 00 00
T 1B 00 00
R 00 00 00 00
T 1B 00 00 F8 08 2A 5E F8 02 22 73 F8 08 2A 5F 56
R 00 00 00 00
T 28 00 00 1B 2B 7B 22 72 F8 03 3A B6 28 57 F8 04
R 00 00 00 00
T 35 00 00 2A 4F 3A 47 2A 5F 56 21 04 00 19 E5 7D
R 00 00 00 00
T 42 00 00 F8 06 77 E1 7C F8 05 77 21 04 00 E5 F8
R 00 00 00 00
T 4F 00 00 10 2A 66 6F E5 C5 CD 00 00 E8 06 4B 42
R 00 00 00 00 02 0A 01 00
T 5C 00 00 78 B1 28 2A CB 78 28 05 11 FF FF 18 26
R 00 00 00 00
T 69 00 00
R 00 00 00 00
T 69 00 00 F8 0E 2A 66 6F 09 E5 7D F8 10 77 E1 7C
R 00 00 00 00
T 76 00 00 F8 0F 77 F8 06 34 20 02 23 34
R 00 00 00 00
T 80 00 00
R 00 00 00 00
T 80 00 00 F8 06 2A 5E F8 00 22 73 18 91
R 00 00 00 00
T 8A 00 00
R 00 00 00 00
T 8A 00 00 F8 00 2A 5F 56
R 00 00 00 00
T 8F 00 00
R 00 00 00 00
T 8F 00 00 E8 0A C9
R 00 00 00 00

wcstombs.rel/   0           0     0     644     1766      `
XL3
H 7 areas 3 global symbols
M wcstombs
O -mgbz80
S .__.ABS. Def000000
S _wctomb Ref000000
A _CODE size E5 flags 0 addr 0
S _wcstombs Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F0 AF F8 0C 22 77 F8 04 7D 54 F8 08
R 00 00 00 00
T 0D 00 00 22 72 F8 14 2A 5E F8 0E 22 73
R 00 00 00 00
T 17 00 00
R 00 00 00 00
T 17 00 00 F8 16 3E 04 96 23 3E 00 9E 38 33 F8 0E
R 00 00 00 00
T 24 00 00 2A 5F 56 1A F8 00 22 13 1A 22 13 1A 22
R 00 00 00 00
T 31 00 00 13 1A 77 F8 08 2A 4F 46 F8 02 2A 66 6F
R 00 00 00 00
T 3E 00 00 E5 F8 02 2A 66 6F E5 C5 CD 00 00 E8 06
R 00 00 00 00 02 0C 01 00
T 4B 00 00 F8 16 7E 93 23 7E 9A DA DD 00
R 00 00 00 00 00 0B 00 00
T 55 00 00
R 00 00 00 00
T 55 00 00 F8 0E 2A 5F 56 1A 4F 13 1A 47 13 1A 6F
R 00 00 00 00
T 62 00 00 13 1A 67 E5 C5 F8 16 2A 66 6F E5 CD
R 00 00 00 00
T 6E 00 00 00 00 E8 06 4B 42 79 3D B0 20 09 F8 12
R 00 00 00 00 02 03 01 00
T 7B 00 00 2A 5F 56 1A B7 28 5B
R 00 00 00 00
T 82 00 00
R 00 00 00 00
T 82 00 00 CB 78 28 05 11 FF FF 18 57
R 00 00 00 00
T 8B 00 00
R 00 00 00 00
T 8B 00 00 F8 0A 79 22 70 F8 16 2A 5F 56 F8 0A 2A
R 00 00 00 00
T 98 00 00 66 6F 7B 95 5F 7A 9C F8 17 32 73 F8 0A
R 00 00 00 00
T A5 00 00 2A 5F 2A 57 2A 66 6F 19 E5 7D F8 0E 77
R 00 00 00 00
T B2 00 00 E1 7C F8 0D 77 F8 12 2A 66 6F 09 E5 7D
R 00 00 00 00
T BF 00 00 F8 14 77 E1 7C F8 13 77 F8 0E 2A 5F 56
R 00 00 00 00
T CC 00 00 21 04 00 19 E5 7D F8 10 77 E1 7C F8 0F
R 00 00 00 00
T D9 00 00 77 C3 17 00
R 00 00 00 00 00 05 00 00
T DD 00 00
R 00 00 00 00
T DD 00 00 F8 0C 2A 5F 56
R 00 00 00 00
T E2 00 00
R 00 00 00 00
T E2 00 00 E8 10 C9
R 00 00 00 00
mbrtoc16.rel/   0           0     0     644     3097      `
XL3
H 7 areas 3 global symbols
M mbrtoc16
O -mgbz80
S _mbrtowc Ref000000
S .__.ABS. Def000000
A _CODE size 1A7 flags 0 addr 0
S _mbrtoc16 Def000000
A _DATA size 3 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F2 F8 13 3A B6 20 1A F8 16 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 21 01 00 E5 21 A6 01 E5 21 00 00 E5
R 00 00 00 00 00 09 00 00
T 1A 00 00 CD 00 00 E8 08 C3 A3 01
R 00 00 00 00 00 04 00 00 00 09 00 00
T 22 00 00
R 00 00 00 00
T 22 00 00 F8 17 3A B6 20 05 3E 00 00 00 22 36
R 00 00 00 00 09 0A 01 00
T 2C 00 00 00 00 00
R 00 00 00 00 89 03 01 00
T 2D 00 00
R 00 00 00 00
T 2D 00 00 F8 16 2A 5E F8 00 22 73 D1 D5 1A 4F F8
R 00 00 00 00
T 3A 00 00 10 2A 5E F8 08 22 73 D1 D5 6B 62 23 E5
R 00 00 00 00
T 47 00 00 7D F8 04 77 E1 7C F8 03 77 D1 D5 21
R 00 00 00 00
T 53 00 00 02 00 19 E5 7D F8 06 77 E1 7C F8 05 77
R 00 00 00 00
T 60 00 00 79 B7 20 60 2B 2B 2B 2A 5F 56 1A B7 20
R 00 00 00 00
T 6D 00 00 08 23 2A 5F 56 1A B7 28 4E
R 00 00 00 00
T 76 00 00
R 00 00 00 00
T 76 00 00 F8 16 2A 5F 56 4B 42 03 13 13 F8 02 7B
R 00 00 00 00
T 83 00 00 22 72 F8 11 3A B6 28 2A 0A F8 04 77 AF
R 00 00 00 00
T 90 00 00 23 32 2B 2B 2A 5F 56 1A 57 1E 00 23 2A
R 00 00 00 00
T 9D 00 00 66 6F 19 E5 7D F8 08 77 E1 7C F8 07 22
R 00 00 00 00
T AA 00 00 2A 5F 56 F8 06 7E 12 13 23 7E 12
R 00 00 00 00
T B5 00 00
R 00 00 00 00
T B5 00 00 F8 02 2A 66 6F 36 00 AF 02 11 FD FF C3
R 00 00 00 00
T C2 00 00 A3 01
R 00 00 00 00 00 03 00 00
T C4 00 00
R 00 00 00 00
T C4 00 00 F8 0A 4D 44 F8 16 2A 66 6F E5 F8 16 2A
R 00 00 00 00
T D1 00 00 66 6F E5 F8 16 2A 66 6F E5 C5 CD 00 00
R 00 00 00 00 02 0E 00 00
T DE 00 00 E8 08 F8 06 7B 22 7A 32 3E 04 96 23 3E
R 00 00 00 00
T EB 00 00 00 9E 30 08 F8 06 2A 5F 56 C3 A3 01
R 00 00 00 00 00 0D 00 00
T F7 00 00
R 00 00 00 00
T F7 00 00 F8 0A 3E FF 96 23 3E FF 9E 23 3E 00 9E
R 00 00 00 00
T 04 01 00 23 3E 00 9E 38 1B F8 11 3A B6 28 0D F8
R 00 00 00 00
T 11 01 00 0A 2A 4F 46 F8 08 2A 66 6F 79 22 70
R 00 00 00 00
T 1D 01 00
R 00 00 00 00
T 1D 01 00 F8 06 2A 5F 56 C3 A3 01
R 00 00 00 00 00 09 00 00
T 25 01 00
R 00 00 00 00
T 25 01 00 F8 0A 2A 5F 56 7B D6 00 5F 7A DE 00 F5
R 00 00 00 00
T 32 01 00 32 73 F8 0E 2A 5F 56 F1 7B DE 10 5F 7A
R 00 00 00 00
T 3F 01 00 DE 00 32 73 F8 11 3A B6 28 24 F8 0B 2A
R 00 00 00 00
T 4C 01 00 4F 2A 47 5E 3E 02
R 00 00 00 00
T 52 01 00
R 00 00 00 00
T 52 01 00 CB 3B CB 18 CB 19 3D 20 F7 69 78 E6 03
R 00 00 00 00
T 5F 01 00 67 4D 7C C6 D8 47 F8 08 2A 66 6F 79 22
R 00 00 00 00
T 6C 01 00 70
R 00 00 00 00
T 6D 01 00
R 00 00 00 00
T 6D 01 00 F8 0A 2A 4F 7E E6 03 47 21 00 DC 09 E5
R 00 00 00 00
T 7A 01 00 7D F8 0A 77 E1 7C F8 09 77 E1 E5 36 00
R 00 00 00 00
T 87 01 00 F8 08 4E F8 02 2A 66 6F 71 F8 09 3A 22
R 00 00 00 00
T 94 01 00 3E 00 32 4E F8 04 2A 66 6F 71 F8 06 2A
R 00 00 00 00
T A1 01 00 5F 56
R 00 00 00 00
T A3 01 00
R 00 00 00 00
T A3 01 00 E8 0E C9
R 00 00 00 00
T A6 01 00
R 00 00 00 00
T A6 01 00 00
R 00 00 00 00

c16rtomb.rel/   0           0     0     644     2562      `
XL3
H 7 areas 4 global symbols
M c16rtomb
O -mgbz80
S _errno Ref000000
S .__.ABS. Def000000
S _wctomb Ref000000
A _CODE size 14A flags 0 addr 0
S _c16rtomb Def000000
A _DATA size 3 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F4 F8 0F 3A B6 20 09 F8 04 4D 44 F8
R 00 00 00 00
T 0D 00 00 0E 79 22 70
R 00 00 00 00
T 11 00 00
R 00 00 00 00
T 11 00 00 F8 13 3A B6 20 05 3E 00 00 00 22 36
R 00 00 00 00 09 0A 01 00
T 1B 00 00 00 00 00
R 00 00 00 00 89 03 01 00
T 1C 00 00
R 00 00 00 00
T 1C 00 00 F8 12 2A 4F 46 69 60 23 E5 7D F8 0C 77
R 00 00 00 00
T 29 00 00 E1 7C F8 0B 77 03 03 F8 08 79 22 70 F8
R 00 00 00 00
T 36 00 00 11 3A B6 20 18 F8 08 2A 66 6F 36 00 F8
R 00 00 00 00
T 43 00 00 0A 2A 66 6F 36 00 AF F8 00 22 22 22 77
R 00 00 00 00
T 50 00 00 C3 25 01
R 00 00 00 00 00 04 00 00
T 53 00 00
R 00 00 00 00
T 53 00 00 F8 0A 2A 5F 56 1A 4F B7 20 0A 2B 2B 2B
R 00 00 00 00
T 60 00 00 2A 5F 56 1A B7 28 69
R 00 00 00 00
T 67 00 00
R 00 00 00 00
T 67 00 00 F8 10 7E D6 00 23 7E DE DC DA 3C 01 F8
R 00 00 00 00 00 0D 00 00
T 74 00 00 10 3E FF 96 23 3E DF 9E DA 3C 01 06 00
R 00 00 00 00 00 0C 00 00
T 81 00 00 F8 08 2A 5F 56 1A 67 2E 00 09 4D F8 08
R 00 00 00 00
T 8E 00 00 2A 66 6F 36 00 F8 0A 2A 66 6F 36 00 79
R 00 00 00 00
T 9B 00 00 87 87 47 0E 00 F8 10 2A 66 6F 09 4D 7C
R 00 00 00 00
T A8 00 00 F8 08 71 23 77 AF 23 22 32 2B 2B 2A 5F
R 00 00 00 00
T B5 00 00 7E C6 24 F5 F8 03 32 73 F8 0C 2A 5F 56
R 00 00 00 00
T C2 00 00 F1 7B CE 00 5F 7A CE 00 F8 03 32 73 18
R 00 00 00 00
T CF 00 00 55
R 00 00 00 00
T D0 00 00
R 00 00 00 00
T D0 00 00 F8 10 7E D6 FF 23 7E DE D7 38 0B F8 10
R 00 00 00 00
T DD 00 00 7E D6 00 23 7E DE E0 38 12
R 00 00 00 00
T E6 00 00
R 00 00 00 00
T E6 00 00 F8 10 7E F8 00 77 F8 11 7E F8 01 77 AF
R 00 00 00 00
T F3 00 00 23 22 77 18 2D
R 00 00 00 00
T F8 00 00
R 00 00 00 00
T F8 00 00 F8 10 3E FF 96 23 3E DB 9E 38 39 F8 10
R 00 00 00 00
T 05 01 00 4E F8 0A 2A 66 6F 71 F8 11 7E F8 0A 22
R 00 00 00 00
T 12 01 00 3E 00 32 2A 32 2B 2B 2A 5F 2A 57 23 7E
R 00 00 00 00
T 1F 01 00 12 11 00 00 18 22
R 00 00 00 00
T 25 01 00
R 00 00 00 00
T 25 01 00 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 F8 12 2A
R 00 00 00 00
T 32 01 00 66 6F E5 CD 00 00 E8 06 18 0B
R 00 00 00 00 02 07 02 00
T 3C 01 00
R 00 00 00 00
T 3C 01 00 21 00 00 3E 54 22 36 00 11 FF FF
R 00 00 00 00 02 04 00 00
T 47 01 00
R 00 00 00 00
T 47 01 00 E8 0C C9
R 00 00 00 00
mbrtoc32.rel/   0           0     0     644     1157      `
XL3
H 7 areas 3 global symbols
M mbrtoc32
O -mgbz80
S _mbrtowc Ref000000
S .__.ABS. Def000000
A _CODE size 69 flags 0 addr 0
S _mbrtoc32 Def000000
A _DATA size 3 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FC F8 0D 3A B6 20 05 3E 00 00 00 22
R 00 00 00 00 09 0C 01 00
T 0B 00 00 36 00 00 00
R 00 00 00 00 89 04 01 00
T 0D 00 00
R 00 00 00 00
T 0D 00 00 F8 07 3A B6 20 1D F8 0C 2A 66 6F E5 F8
R 00 00 00 00
T 1A 00 00 0C 2A 66 6F E5 F8 0C 2A 66 6F E5 21
R 00 00 00 00
T 26 00 00 00 00 E5 CD 00 00 E8 08 18 36
R 00 00 00 00 02 07 00 00
T 30 00 00
R 00 00 00 00
T 30 00 00 F8 00 4D 44 F8 0C 2A 66 6F E5 F8 0C 2A
R 00 00 00 00
T 3D 00 00 66 6F E5 F8 0C 2A 66 6F E5 C5 CD 00 00
R 00 00 00 00 02 0E 00 00
T 4A 00 00 E8 08 3E 04 BB 3E 00 9A 38 12 F8 06 2A
R 00 00 00 00
T 57 00 00 4F 46 F8 00 2A 02 03 2A 02 03 2A 02 03
R 00 00 00 00
T 64 00 00 7E 02
R 00 00 00 00
T 66 00 00
R 00 00 00 00
T 66 00 00
R 00 00 00 00
T 66 00 00 E8 04 C9
R 00 00 00 00

c32rtomb.rel/   0           0     0     644     490       `
XL3
H 7 areas 3 global symbols
M c32rtomb
O -mgbz80
S .__.ABS. Def000000
S _wctomb Ref000000
A _CODE size 18 flags 0 addr 0
S _c32rtomb Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 06 2A 66 6F E5 F8 06 2A 66 6F E5 F8
R 00 00 00 00
T 0D 00 00 06 2A 66 6F E5 CD 00 00 E8 06 C9
R 00 00 00 00 02 09 01 00
mbstoc16s.rel/  0           0     0     644     2606      `
XL3
H 7 areas 3 global symbols
M mbstoc16s
O -mgbz80
S .__.ABS. Def000000
S _mbtowc Ref000000
A _CODE size 166 flags 0 addr 0
S ___mbstoc16s Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F3 AF F8 0B 22 77
R 00 00 00 00
T 07 00 00
R 00 00 00 00
T 07 00 00 F8 07 4D 44 21 04 00 E5 F8 13 2A 66 6F
R 00 00 00 00
T 14 00 00 E5 C5 CD 00 00 E8 06 33 33 D5 F8 00 7E
R 00 00 00 00 02 06 01 00
T 21 00 00 D6 00 23 7E DE 00 56 3E 00 CB 7F 28 07
R 00 00 00 00
T 2E 00 00 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 35 00 00
R 00 00 00 00
T 35 00 00 CB 7A 28 01 37
R 00 00 00 00
T 3A 00 00
R 00 00 00 00
T 3A 00 00 30 06 11 FF FF C3 63 01
R 00 00 00 00 00 09 00 00
T 42 00 00
R 00 00 00 00
T 42 00 00 F8 0B 5D 54 F8 13 1A 96 23 13 1A 9E 3E
R 00 00 00 00
T 4F 00 00 00 17 F8 02 77 F8 0F 2A 5E F8 03 22 73
R 00 00 00 00
T 5C 00 00 F8 01 3A B6 20 11 23 23 7E B7 CA 5E 01
R 00 00 00 00 00 0E 00 00
T 69 00 00 23 2A 66 6F AF 22 77 C3 5E 01
R 00 00 00 00 00 0B 00 00
T 73 00 00
R 00 00 00 00
T 73 00 00 F8 0B 2A 4F 46 03 F8 03 2A 5F 56 21
R 00 00 00 00
T 7F 00 00 02 00 19 E5 7D F8 07 77 E1 7C F8 06 22
R 00 00 00 00
T 8C 00 00 3E FF 96 23 3E FF 9E 23 3E 00 9E 23 3E
R 00 00 00 00
T 99 00 00 00 9E 38 2C F8 02 CB 46 CA 5E 01 F8 07
R 00 00 00 00 00 0C 00 00
T A6 00 00 2A 5E F8 0B 22 73 F8 03 2A 5F 56 F8 0B
R 00 00 00 00
T B3 00 00 7E 12 13 23 7E 12 F8 05 2A 5E F8 0F 22
R 00 00 00 00
T C0 00 00 73 F8 0B 79 22 70 C3 49 01
R 00 00 00 00 00 0A 00 00
T C9 00 00
R 00 00 00 00
T C9 00 00 F8 13 79 96 23 78 9E D2 5E 01 F8 07 2A
R 00 00 00 00 00 0B 00 00
T D6 00 00 5F 56 7B D6 00 5F 7A DE 00 F5 32 73 F8
R 00 00 00 00
T E3 00 00 0B 2A 5F 56 F1 7B DE 10 5F 7A DE 00 32
R 00 00 00 00
T F0 00 00 7B 32 2A 4F 2A 47 5E 3E 02
R 00 00 00 00
T F9 00 00
R 00 00 00 00
T F9 00 00 CB 3B CB 18 CB 19 3D 20 F7 78 E6 03 47
R 00 00 00 00
T 06 01 00 21 00 D8 09 4D 44 F8 03 2A 66 6F 79 22
R 00 00 00 00
T 13 01 00 70 F8 05 2A 5E F8 0F 22 7B 32 2A 5F 56
R 00 00 00 00
T 20 01 00 F8 07 2A 4F 7E E6 03 C6 DC 47 6B 62 79
R 00 00 00 00
T 2D 01 00 22 70 13 13 F8 0F 7B 22 72 F8 0B 2A 5F
R 00 00 00 00
T 3A 01 00 56 21 02 00 19 E5 7D F8 0D 77 E1 7C F8
R 00 00 00 00
T 47 01 00 0C 77
R 00 00 00 00
T 49 01 00
R 00 00 00 00
T 49 01 00 D1 D5 F8 11 2A 66 6F 19 E5 7D F8 13 77
R 00 00 00 00
T 56 01 00 E1 7C F8 12 77 C3 07 00
R 00 00 00 00 00 09 00 00
T 5E 01 00
R 00 00 00 00
T 5E 01 00 F8 0B 2A 5F 56
R 00 00 00 00
T 63 01 00
R 00 00 00 00
T 63 01 00 E8 0D C9
R 00 00 00 00
c16stombs.rel/  0           0     0     644     3269      `
XL3
H 7 areas 4 global symbols
M c16stombs
O -mgbz80
S .__.ABS. Def000000
S ___memcpy Ref000000
S _wctomb Ref000000
A _CODE size 1CB flags 0 addr 0
S ___c16stombs Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 EC AF F8 04 22 77
R 00 00 00 00
T 07 00 00
R 00 00 00 00
T 07 00 00 F8 18 2A 5E F8 06 22 7B 32 2A 5F 56 1A
R 00 00 00 00
T 14 00 00 4F 13 1A 47 2B 2A 5F 56 21 02 00 19 E5
R 00 00 00 00
T 21 00 00 7D F8 0C 77 E1 7C F8 0B 77 F8 10 79 22
R 00 00 00 00
T 2E 00 00 70 AF 23 22 77 78 FE D8 38 04 D6 E0 38
R 00 00 00 00
T 3B 00 00 1C
R 00 00 00 00
T 3C 00 00
R 00 00 00 00
T 3C 00 00 F8 10 54 5D F8 0C 1A 22 13 1A 22 13 1A
R 00 00 00 00
T 49 00 00 22 13 1A 77 F8 0A 2A 5E F8 18 22 73 C3
R 00 00 00 00
T 56 00 00 FF 00
R 00 00 00 00 00 03 00 00
T 58 00 00
R 00 00 00 00
T 58 00 00 3E FF B9 3E DB 98 38 16 F8 0A 2A 5F 56
R 00 00 00 00
T 65 00 00 1A 4F 13 1A 47 D6 DC 38 08 3E FF B9 3E
R 00 00 00 00
T 72 00 00 DF 98 30 06
R 00 00 00 00
T 76 00 00
R 00 00 00 00
T 76 00 00 11 FF FF C3 C8 01
R 00 00 00 00 00 07 00 00
T 7C 00 00
R 00 00 00 00
T 7C 00 00 F5 F8 12 7E F8 0B 77 F8 13 7E F8 0C 77
R 00 00 00 00
T 89 00 00 F8 14 7E F8 0D 77 F1 F8 08 36 00 3E 02
R 00 00 00 00
T 96 00 00
R 00 00 00 00
T 96 00 00 F8 09 CB 26 23 CB 16 23 CB 16 3D 20 F3
R 00 00 00 00
T A3 00 00 23 79 22 70 AF 23 22 77 F8 08 2A 5F 56
R 00 00 00 00
T B0 00 00 7B F8 0C 86 5F 7A 23 8E F5 F8 13 32 73
R 00 00 00 00
T BD 00 00 F8 0C 2A 5F 56 F8 10 F1 7B 8E 5F 7A 23
R 00 00 00 00
T CA 00 00 8E F8 13 32 7B 32 2B 2A 5F 7E C6 24 F5
R 00 00 00 00
T D7 00 00 F8 0F 32 73 F8 14 2A 5F 56 F1 7B CE A0
R 00 00 00 00
T E4 00 00 5F 7A CE FC F8 0F 32 73 F8 06 2A 5F 56
R 00 00 00 00
T F1 00 00 21 04 00 19 E5 7D F8 1A 77 E1 7C F8 19
R 00 00 00 00
T FE 00 00 77
R 00 00 00 00
T FF 00 00
R 00 00 00 00
T FF 00 00 F8 0F 3A B6 2B B6 2B B6 20 19 F8 04 5D
R 00 00 00 00
T 0C 01 00 54 F8 1A 1A 96 23 13 1A 9E D2 C3 01 F8
R 00 00 00 00 00 0D 00 00
T 19 01 00 16 2A 5F 56 AF 12 C3 C3 01
R 00 00 00 00 00 0A 00 00
T 22 01 00
R 00 00 00 00
T 22 01 00 F8 00 7D 54 F8 12 22 7A 32 2A 4F 46 F8
R 00 00 00 00
T 2F 01 00 0E 2A 66 6F E5 F8 0E 2A 66 6F E5 C5 CD
R 00 00 00 00
T 3C 01 00 00 00 E8 06 F8 0E 7B 22 7A 32 7E D6 00
R 00 00 00 00 02 03 02 00
T 49 01 00 23 7E DE 00 56 3E 00 CB 7F 28 07 CB 7A
R 00 00 00 00
T 56 01 00 20 08 BF 18 05
R 00 00 00 00
T 5B 01 00
R 00 00 00 00
T 5B 01 00 CB 7A 28 01 37
R 00 00 00 00
T 60 01 00
R 00 00 00 00
T 60 01 00 30 05 11 FF FF 18 61
R 00 00 00 00
T 67 01 00
R 00 00 00 00
T 67 01 00 F8 0E 2A 4F 46 F8 04 2A 66 6F 09 E5 7D
R 00 00 00 00
T 74 01 00 F8 12 77 E1 7C F8 11 77 F8 1A 5D 54 F8
R 00 00 00 00
T 81 01 00 10 1A 96 23 13 1A 9E 38 39 F8 12 2A 5F
R 00 00 00 00
T 8E 01 00 56 F8 16 2A 4F 46 F8 0E 2A 66 6F E5 D5
R 00 00 00 00
T 9B 01 00 C5 CD 00 00 E8 06 F8 16 2A 5F 56 F8 0E
R 00 00 00 00 02 05 01 00
T A8 01 00 2A 66 6F 19 E5 7D F8 18 77 E1 7C F8 17
R 00 00 00 00
T B5 01 00 77 F8 10 2A 4F 46 F8 04 79 22 70 C3
R 00 00 00 00
T C1 01 00 07 00
R 00 00 00 00 00 03 00 00
T C3 01 00
R 00 00 00 00
T C3 01 00 F8 04 2A 5F 56
R 00 00 00 00
T C8 01 00
R 00 00 00 00
T C8 01 00 E8 14 C9
R 00 00 00 00

wcscmp.rel/     0           0     0     644     1429      `
XL3
H 7 areas 2 global symbols
M wcscmp
O -mgbz80
S .__.ABS. Def000000
A _CODE size AE flags 0 addr 0
S _wcscmp Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F6 F8 0C 2A 4F 2A 47 2A 5E F8 08 22
R 00 00 00 00
T 0D 00 00 73
R 00 00 00 00
T 0E 00 00
R 00 00 00 00
T 0E 00 00 59 50 1A F8 00 22 13 1A 22 13 1A 22 13
R 00 00 00 00
T 1B 00 00 1A 77 F8 08 2A 5F 56 1A F8 04 22 13 1A
R 00 00 00 00
T 28 00 00 22 13 1A 22 13 1A 77 F8 00 7E F8 04 96
R 00 00 00 00
T 35 00 00 20 3B F8 01 7E F8 05 96 20 33 F8 02 7E
R 00 00 00 00
T 42 00 00 F8 06 96 20 2B F8 03 7E F8 07 96 20 23
R 00 00 00 00
T 4F 00 00 F8 03 3A B6 2B B6 2B B6 28 19 03 03 03
R 00 00 00 00
T 5C 00 00 03 F8 08 2A 5F 56 21 04 00 19 E5 7D F8
R 00 00 00 00
T 69 00 00 0A 77 E1 7C F8 09 77 18 9C
R 00 00 00 00
T 72 00 00
R 00 00 00 00
T 72 00 00 F8 00 5D 54 F8 04 1A 96 23 13 1A 9E 23
R 00 00 00 00
T 7F 00 00 13 1A 9E 23 13 1A 9E 30 05 11 FF FF 18
R 00 00 00 00
T 8C 00 00 1E
R 00 00 00 00
T 8D 00 00
R 00 00 00 00
T 8D 00 00 F8 04 5D 54 F8 00 1A 96 23 13 1A 9E 23
R 00 00 00 00
T 9A 00 00 13 1A 9E 23 13 1A 9E 30 05 11 01 00 18
R 00 00 00 00
T A7 00 00 03
R 00 00 00 00
T A8 00 00
R 00 00 00 00
T A8 00 00 11 00 00
R 00 00 00 00
T AB 00 00
R 00 00 00 00
T AB 00 00 E8 0A C9
R 00 00 00 00

wcslen.rel/     0           0     0     644     725       `
XL3
H 7 areas 2 global symbols
M wcslen
O -mgbz80
S .__.ABS. Def000000
A _CODE size 38 flags 0 addr 0
S _wcslen Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FA AF F8 04 22 77 F8 08 2A 4F 46
R 00 00 00 00
T 0C 00 00
R 00 00 00 00
T 0C 00 00 59 50 1A F8 00 22 13 1A 22 13 1A 22 13
R 00 00 00 00
T 19 00 00 1A 77 3A B6 2B B6 2B B6 28 0D F8 04 34
R 00 00 00 00
T 26 00 00 20 02 23 34
R 00 00 00 00
T 2A 00 00
R 00 00 00 00
T 2A 00 00 03 03 03 03 18 DC
R 00 00 00 00
T 30 00 00
R 00 00 00 00
T 30 00 00 F8 04 2A 5F 56 E8 06 C9
R 00 00 00 00

btowc.rel/      0           0     0     644     483       `
XL3
H 7 areas 2 global symbols
M btowc
O -mgbz80
S .__.ABS. Def000000
A _CODE size 1A flags 0 addr 0
S _btowc Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 CB 7E 28 07 11 FF FF 21 FF FF C9
R 00 00 00 00
T 0D 00 00
R 00 00 00 00
T 0D 00 00 F8 02 2A 5F 7E 57 17 9F 4F 47 69 60 C9
R 00 00 00 00

wctob.rel/      0           0     0     644     570       `
XL3
H 7 areas 2 global symbols
M wctob
O -mgbz80
S .__.ABS. Def000000
A _CODE size 1E flags 0 addr 0
S _wctob Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 CB 7E 20 0F 23 7E B7 20 0A 23 7E
R 00 00 00 00
T 0D 00 00 B7 20 05 23 7E B7 28 04
R 00 00 00 00
T 15 00 00
R 00 00 00 00
T 15 00 00 11 FF FF C9
R 00 00 00 00
T 19 00 00
R 00 00 00 00
T 19 00 00 C1 D1 D5 C5 C9
R 00 00 00 00
mbsinit.rel/    0           0     0     644     667       `
XL3
H 7 areas 2 global symbols
M mbsinit
O -mgbz80
S .__.ABS. Def000000
A _CODE size 24 flags 0 addr 0
S _mbsinit Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 03 3A B6 28 19 C1 D1 D5 C5 1A B7 20
R 00 00 00 00
T 0D 00 00 0D 4B 42 03 0A B7 20 06 13 13 1A B7 28
R 00 00 00 00
T 1A 00 00 04
R 00 00 00 00
T 1B 00 00
R 00 00 00 00
T 1B 00 00 1E 00 18 02
R 00 00 00 00
T 1F 00 00
R 00 00 00 00
T 1F 00 00 1E 01
R 00 00 00 00
T 21 00 00
R 00 00 00 00
T 21 00 00 16 00 C9
R 00 00 00 00

mbrlen.rel/     0           0     0     644     688       `
XL3
H 7 areas 3 global symbols
M mbrlen
O -mgbz80
S _mbrtowc Ref000000
S .__.ABS. Def000000
A _CODE size 25 flags 0 addr 0
S _mbrlen Def000000
A _DATA size 3 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 07 3A B6 28 05 2A 4F 46 18 03
R 00 00 00 00
T 0B 00 00
R 00 00 00 00
T 0B 00 00 01 00 00
R 00 00 00 00 00 04 01 00
T 0E 00 00
R 00 00 00 00
T 0E 00 00 C5 F8 06 2A 66 6F E5 F8 06 2A 66 6F E5
R 00 00 00 00
T 1B 00 00 21 00 00 E5 CD 00 00 E8 08 C9
R 00 00 00 00 02 08 00 00
mbrtowc.rel/    0           0     0     644     5296      `
XL3
H 7 areas 3 global symbols
M mbrtowc
O -mgbz80
S _errno Ref000000
S .__.ABS. Def000000
A _CODE size 2D0 flags 0 addr 0
S _mbrtowc Def000000
A _DATA size 3 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 F0 F8 15 3A B6 20 1A F8 18 2A 66 6F
R 00 00 00 00
T 0D 00 00 E5 21 01 00 E5 21 CF 02 E5 21 00 00 E5
R 00 00 00 00 00 09 00 00
T 1A 00 00 CD 00 00 E8 08 C3 CC 02
R 00 00 00 00 00 04 00 00 00 09 00 00
T 22 00 00
R 00 00 00 00
T 22 00 00 F8 17 3A B6 CA C1 02 F8 19 3A B6 20 05
R 00 00 00 00 00 08 00 00
T 2F 00 00 3E 00 00 00 22 36 00 00 00
R 00 00 00 00 09 04 01 00 89 09 01 00
T 34 00 00
R 00 00 00 00
T 34 00 00 F8 00 7D 54 F8 04 22 72 F8 18 2A 5E F8
R 00 00 00 00
T 41 00 00 06 22 7B 32 2A 5E F8 0E 22 73 1E 00
R 00 00 00 00
T 4D 00 00
R 00 00 00 00
T 4D 00 00 D5 16 00 F8 10 2A 66 6F 19 D1 4D 44 0A
R 00 00 00 00
T 5A 00 00 57 B7 28 16 7B D6 03 30 11 D5 16 00 F8
R 00 00 00 00
T 67 00 00 06 2A 66 6F 19 D1 4D 44 7A 02 1C 18 D9
R 00 00 00 00
T 74 00 00
R 00 00 00 00
T 74 00 00 F8 08 73 0E 01 F8 18 2A 5F 56 1A 47 F8
R 00 00 00 00
T 81 00 00 14 2A 5E F8 09 22 73 78 B7 20 07 F8 09
R 00 00 00 00
T 8E 00 00 2A 5F 56 1A 47
R 00 00 00 00
T 93 00 00
R 00 00 00 00
T 93 00 00 F8 0F 70 CB 7E 28 4B F8 0B 36 01
R 00 00 00 00
T 9E 00 00
R 00 00 00 00
T 9E 00 00 F8 0B 7E F5 01 80 00 F1 3C 18 04
R 00 00 00 00
T A9 00 00
R 00 00 00 00
T A9 00 00 CB 28 CB 19
R 00 00 00 00
T AD 00 00
R 00 00 00 00
T AD 00 00 3D 20 F9 F8 0F 5E 16 00 F8 0B 7E 3C 23
R 00 00 00 00
T BA 00 00 77 7B A1 23 77 7A A0 23 77 3A B6 28 05
R 00 00 00 00
T C7 00 00 2B 3A 77 18 D2
R 00 00 00 00
T CC 00 00
R 00 00 00 00
T CC 00 00 F8 0B 2A 4F 7E F5 11 FF 00 F1 3C 18 04
R 00 00 00 00
T D9 00 00
R 00 00 00 00
T D9 00 00 CB 2A CB 1B
R 00 00 00 00
T DD 00 00
R 00 00 00 00
T DD 00 00 3D 20 F9 7B F8 0F A6 77
R 00 00 00 00
T E5 00 00
R 00 00 00 00
T E5 00 00 3E 04 91 DA C1 02 F8 08 7E F8 0D 77 AF
R 00 00 00 00 00 07 00 00
T F2 00 00 23 32 2A 5F 56 F8 16 2A 66 6F 19 45 5C
R 00 00 00 00
T FF 00 00 51 2E 00 78 92 7B 9D 30 61 F8 06 2A 4F
R 00 00 00 00
T 0C 01 00 2A 47 23 2A 5E F8 0E 22 73 F8 08 7E F8
R 00 00 00 00
T 19 01 00 0D 77 F8 16 2A 5E F8 0B 22 73
R 00 00 00 00
T 23 01 00
R 00 00 00 00
T 23 01 00 F8 0B 2A 5E F8 09 22 7B 22 2A 5F 56 1B
R 00 00 00 00
T 30 01 00 2B 7B 22 7A 32 2B 3A B6 28 29 F8 0D 6E
R 00 00 00 00
T 3D 01 00 26 00 09 E5 7D F8 0B 77 E1 7C F8 0A 77
R 00 00 00 00
T 4A 01 00 F8 0E 2A 5F 56 1A 2B 34 20 02 23 34
R 00 00 00 00
T 56 01 00
R 00 00 00 00
T 56 01 00 F8 09 F5 2A 66 6F F1 77 F8 0D 34 18 C0
R 00 00 00 00
T 63 01 00
R 00 00 00 00
T 63 01 00 11 FE FF C3 CC 02
R 00 00 00 00 00 07 00 00
T 69 01 00
R 00 00 00 00
T 69 01 00 F8 06 2A 5F 56 06 00
R 00 00 00 00
T 70 01 00
R 00 00 00 00
T 70 01 00 78 F8 08 96 30 09 68 26 00 19 36 00 04
R 00 00 00 00
T 7D 01 00 18 F1
R 00 00 00 00
T 7F 01 00
R 00 00 00 00
T 7F 01 00 F8 16 36 01 AF 23 77 F8 08 7E B7 28 06
R 00 00 00 00
T 8C 01 00 F8 0D 2A 47 18 02
R 00 00 00 00
T 92 01 00
R 00 00 00 00
T 92 01 00 06 01
R 00 00 00 00
T 94 01 00
R 00 00 00 00
T 94 01 00 F8 04 2A 5E 23 23 22 7B 22 2A 5E F8 0D
R 00 00 00 00
T A1 01 00 22 73 F8 0B 36 01 AF 23 77
R 00 00 00 00
T AA 01 00
R 00 00 00 00
T AA 01 00 78 91 30 45 F8 07 2A 5F 56 68 26 00 19
R 00 00 00 00
T B7 01 00 E5 7D F8 0B 77 E1 7C F8 0A 77 F8 0D 2A
R 00 00 00 00
T C4 01 00 5F 56 1A 2B 34 20 02 23 34
R 00 00 00 00
T CD 01 00
R 00 00 00 00
T CD 01 00 F8 09 F5 2A 66 6F F1 77 E6 C0 57 1E 00
R 00 00 00 00
T DA 01 00 7A D6 80 B3 C2 C1 02 04 F8 0B 34 20 02
R 00 00 00 00 00 08 00 00
T E7 01 00 23 34
R 00 00 00 00
T E9 01 00
R 00 00 00 00
T E9 01 00 F8 0B 2A 5E F8 16 22 73 18 B7
R 00 00 00 00
T F3 01 00
R 00 00 00 00
T F3 01 00 F8 0F 7E F8 0C 77 AF 23 22 22 77 F8 04
R 00 00 00 00
T 00 02 00 2A 5F 56 13 F8 09 7B 22 72 79 C6 FF 23
R 00 00 00 00
T 0D 02 00 77
R 00 00 00 00
T 0E 02 00
R 00 00 00 00
T 0E 02 00 F8 0B 7E B7 28 62 F5 23 7E F8 07 77 F8
R 00 00 00 00
T 1B 02 00 0F 7E F8 08 77 F8 10 7E F8 09 77 F8 11
R 00 00 00 00
T 28 02 00 7E F8 0A 77 F1 3E 06
R 00 00 00 00
T 2F 02 00
R 00 00 00 00
T 2F 02 00 F8 05 CB 26 23 CB 16 23 CB 16 23 CB 16
R 00 00 00 00
T 3C 02 00 3D 20 F0 23 2A 5F 56 1A E6 3F 06 00 4F
R 00 00 00 00
T 49 02 00 78 17 9F 5F F5 F8 07 7E B1 F8 0E 77 F8
R 00 00 00 00
T 56 02 00 08 7E B0 F8 0F 77 F1 F8 07 B6 F8 0E 77
R 00 00 00 00
T 63 02 00 F8 08 7E B3 F8 0F 77 F8 09 34 20 02 23
R 00 00 00 00
T 70 02 00 34
R 00 00 00 00
T 71 02 00
R 00 00 00 00
T 71 02 00 F8 0B 35 18 98
R 00 00 00 00
T 76 02 00
R 00 00 00 00
T 76 02 00 F8 0C 7E D6 00 23 7E DE D8 23 7E DE 00
R 00 00 00 00
T 83 02 00 23 7E DE 00 38 18 F8 0C 3E FF 96 23 3E
R 00 00 00 00
T 90 02 00 DF 9E 23 3E 00 9E 23 3E 00 9E 38 05 11
R 00 00 00 00
T 9D 02 00 FF FF 18 2B
R 00 00 00 00
T A1 02 00
R 00 00 00 00
T A1 02 00 F8 13 3A B6 28 13 2A 5F 56 F8 0C 7E 12
R 00 00 00 00
T AE 02 00 13 23 7E 12 13 23 7E 12 13 23 7E 12
R 00 00 00 00
T BA 02 00
R 00 00 00 00
T BA 02 00 F8 16 2A 5F 56 18 0B
R 00 00 00 00
T C1 02 00
R 00 00 00 00
T C1 02 00 21 00 00 3E 54 22 36 00 11 FF FF
R 00 00 00 00 02 04 00 00
T CC 02 00
R 00 00 00 00
T CC 02 00 E8 10 C9
R 00 00 00 00
T CF 02 00
R 00 00 00 00
T CF 02 00 00
R 00 00 00 00
wcrtomb.rel/    0           0     0     644     580       `
XL3
H 7 areas 4 global symbols
M wcrtomb
O -mgbz80
S _errno Ref000000
S .__.ABS. Def000000
S _wctomb Ref000000
A _CODE size 24 flags 0 addr 0
S _wcrtomb Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 06 2A 66 6F E5 F8 06 2A 66 6F E5 F8
R 00 00 00 00
T 0D 00 00 06 2A 66 6F E5 CD 00 00 E8 06 7B A2 3C
R 00 00 00 00 02 09 02 00
T 1A 00 00 C0 21 00 00 3E 54 22 36 00 C9
R 00 00 00 00 02 05 00 00
/183            0           0     0     644     18679     `
XL3
H 7 areas 4 global symbols
M printf_large
O -mgbz80
S .__.ABS. Def000000
S ___sdcc_call_hl Ref000000
S _strlen Ref000000
A _CODE size B53 flags 0 addr 0
S __print_format Def0000D1
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 7E C6 30 47 3E 39 90 30 0D 78 C6
R 00 00 00 00
T 0D 00 00 07 47 23 CB 46 28 04 78 C6 20 47
R 00 00 00 00
T 18 00 00
R 00 00 00 00
T 18 00 00 F8 06 2A 66 6F E5 C5 33 F8 07 2A 66 6F
R 00 00 00 00
T 25 00 00 CD 00 00 E8 03 C9
R 00 00 00 00 02 04 01 00
T 2B 00 00
R 00 00 00 00
T 2B 00 00 F8 02 7E CB 37 E6 0F F8 06 F5 2A 66 6F
R 00 00 00 00
T 38 00 00 F1 E5 F8 06 F5 2A 66 6F F1 E5 F8 07 66
R 00 00 00 00
T 45 00 00 E5 33 F5 33 CD 00 00 E8 06 F8 02 7E E6
R 00 00 00 00 00 08 00 00
T 52 00 00 0F 47 F8 06 2A 66 6F E5 F8 06 2A 66 6F
R 00 00 00 00
T 5F 00 00 E5 F8 07 7E F5 33 C5 33 CD 00 00 E8 06
R 00 00 00 00 00 0C 00 00
T 6C 00 00 C9
R 00 00 00 00
T 6D 00 00
R 00 00 00 00
T 6D 00 00 E8 FA F8 08 2A 4F 46 59 50 1A F8 01 22
R 00 00 00 00
T 7A 00 00 13 1A 22 13 1A 22 13 1A 77 21 04 00 09
R 00 00 00 00
T 87 00 00 5D 54 F8 05 36 20
R 00 00 00 00
T 8D 00 00
R 00 00 00 00
T 8D 00 00 1A 87 F8 00 77 F8 04 7E 07 E6 01 F8 00
R 00 00 00 00
T 9A 00 00 B6 77 7E 12 23 CB 26 23 CB 16 23 CB 16
R 00 00 00 00
T A7 00 00 23 CB 16 F8 00 7E F8 0A 96 38 09 1A 96
R 00 00 00 00
T B4 00 00 12 F8 01 7E F6 01 77
R 00 00 00 00
T BB 00 00
R 00 00 00 00
T BB 00 00 F8 05 35 7E 20 CC F8 01 2A 02 03 2A 02
R 00 00 00 00
T C8 00 00 03 2A 02 03 7E 02 E8 06 C9
R 00 00 00 00
T D1 00 00
R 00 00 00 00
T D1 00 00 E8 CF AF F8 29 22 77 F8 04 7D 54 F8 0F
R 00 00 00 00
T DE 00 00 22 72 F8 0E 7D 54 F8 11 22 72 F8 04 7D
R 00 00 00 00
T EB 00 00 54 F8 13 22 7A 32 2A 5F 56 21 04 00 19
R 00 00 00 00
T F8 00 00 E5 7D F8 17 77 E1 7C F8 16 32 2A 5E 23
R 00 00 00 00
T 05 01 00 22 73 F8 15 2A 5E F8 19 22 73
R 00 00 00 00
T 0F 01 00
R 00 00 00 00
T 0F 01 00 F8 37 2A 5F 56 1A 4F 13 2B 7B 22 72 41
R 00 00 00 00
T 1C 01 00 79 B7 CA 40 0B 78 D6 25 C2 23 0B AF F8
R 00 00 00 00 00 06 00 00 00 0C 00 00
T 29 01 00 1B 77 AF 23 77 AF 23 77 AF 23 77 AF 23
R 00 00 00 00
T 36 01 00 77 AF 23 77 AF 23 77 AF 23 77 AF 23 77
R 00 00 00 00
T 43 01 00 AF F8 2B 22 22 3E FF 22 36 FF F8 37 2A
R 00 00 00 00
T 50 01 00 5E F8 27 22 73
R 00 00 00 00
T 55 01 00
R 00 00 00 00
T 55 01 00 F8 27 2A 5F 56 1A F8 30 77 F8 27 34 20
R 00 00 00 00
T 62 01 00 02 23 34
R 00 00 00 00
T 65 01 00
R 00 00 00 00
T 65 01 00 F8 27 2A 5E F8 37 22 73 F8 30 7E D6 25
R 00 00 00 00
T 72 01 00 20 20 F8 35 2A 66 6F E5 F8 32 7E F5 33
R 00 00 00 00
T 7F 01 00 F8 36 2A 66 6F CD 00 00 E8 03 F8 29 34
R 00 00 00 00 02 09 01 00
T 8C 01 00 C2 0F 01 23 34 C3 0F 01
R 00 00 00 00 00 04 00 00 00 09 00 00
T 94 01 00
R 00 00 00 00
T 94 01 00 F8 30 7E D6 30 38 72 3E 39 96 38 6D F8
R 00 00 00 00
T A1 01 00 2D 2A A6 3C 20 40 F8 2B 2A 4F 46 69 60
R 00 00 00 00
T AE 01 00 29 29 09 29 E5 7D F8 2D 77 E1 7C F8 2C
R 00 00 00 00
T BB 01 00 77 F8 30 3A 77 AF 23 32 2A 4F 46 F8 2B
R 00 00 00 00
T C8 01 00 2A 66 6F 09 4D 44 11 30 00 79 93 5F 78
R 00 00 00 00
T D5 01 00 9A F8 2C 32 7B 22 3A B6 C2 55 01 F8 1C
R 00 00 00 00 00 0C 00 00
T E2 01 00 36 01 C3 55 01
R 00 00 00 00 00 06 00 00
T E7 01 00
R 00 00 00 00
T E7 01 00 F8 2D 2A 4F 46 69 60 29 29 09 29 4D 44
R 00 00 00 00
T F4 01 00 F8 30 7E 1E 00 81 4F 7B 88 47 11 30 00
R 00 00 00 00
T 01 02 00 79 93 5F 78 9A 2B 2B 32 73 C3 55 01
R 00 00 00 00 00 0D 00 00
T 0D 02 00
R 00 00 00 00
T 0D 02 00 F8 30 7E D6 2E 20 10 F8 2D 2A A6 3C C2
R 00 00 00 00
T 1A 02 00 55 01 AF F8 2D 22 77 C3 55 01
R 00 00 00 00 00 03 00 00 00 0B 00 00
T 24 02 00
R 00 00 00 00
T 24 02 00 F8 30 7E D6 61 38 0F 3E 7A 96 38 0A 7E
R 00 00 00 00
T 31 02 00 E6 DF 77 F8 24 36 01 18 04
R 00 00 00 00
T 3A 02 00
R 00 00 00 00
T 3A 02 00 AF F8 24 77
R 00 00 00 00
T 3E 02 00
R 00 00 00 00
T 3E 02 00 F8 30 7E D6 20 CA DD 02 F8 30 7E D6 2B
R 00 00 00 00 00 09 00 00
T 4B 02 00 CA D6 02 F8 30 7E D6 2D 28 7A F8 30 7E
R 00 00 00 00 00 04 00 00
T 58 02 00 D6 42 CA E4 02 F8 30 7E D6 43 CA F2 02
R 00 00 00 00 00 06 00 00 00 0E 00 00
T 65 02 00 F8 30 7E D6 44 CA 40 05 F8 30 7E D6 46
R 00 00 00 00 00 09 00 00
T 72 02 00 CA 5C 05 F8 30 7E D6 48 CA 55 01 F8 30
R 00 00 00 00 00 04 00 00 00 0C 00 00
T 7F 02 00 7E D6 49 CA 40 05 F8 30 7E D6 4A CA
R 00 00 00 00 00 07 00 00
T 8B 02 00 55 01 F8 30 7E D6 4C 28 57 F8 30 7E D6
R 00 00 00 00 00 03 00 00
T 98 02 00 4F CA 4A 05 F8 30 7E D6 50 CA 9E 04 F8
R 00 00 00 00 00 05 00 00 00 0D 00 00
T A5 02 00 30 7E D6 53 CA 33 03 F8 30 7E D6 54 CA
R 00 00 00 00 00 08 00 00
T B2 02 00 55 01 F8 30 7E D6 55 CA 50 05 F8 30 7E
R 00 00 00 00 00 03 00 00 00 0B 00 00
T BF 02 00 D6 58 CA 56 05 F8 30 7E D6 5A CA 55 01
R 00 00 00 00 00 06 00 00 00 0E 00 00
T CC 02 00 C3 62 05
R 00 00 00 00 00 04 00 00
T CF 02 00
R 00 00 00 00
T CF 02 00 F8 1B 36 01 C3 55 01
R 00 00 00 00 00 08 00 00
T D6 02 00
R 00 00 00 00
T D6 02 00 F8 1D 36 01 C3 55 01
R 00 00 00 00 00 08 00 00
T DD 02 00
R 00 00 00 00
T DD 02 00 F8 1E 36 01 C3 55 01
R 00 00 00 00 00 08 00 00
T E4 02 00
R 00 00 00 00
T E4 02 00 F8 20 36 01 C3 55 01
R 00 00 00 00 00 08 00 00
T EB 02 00
R 00 00 00 00
T EB 02 00 F8 21 36 01 C3 55 01
R 00 00 00 00 00 08 00 00
T F2 02 00
R 00 00 00 00
T F2 02 00 F8 20 CB 46 28 0E F8 39 2A 4F 46 03 2B
R 00 00 00 00
T FF 02 00 79 22 70 0B 0A 18 0E
R 00 00 00 00
T 06 03 00
R 00 00 00 00
T 06 03 00 F8 39 2A 4F 46 03 03 2B 79 22 70 0B 0B
R 00 00 00 00
T 13 03 00 0A
R 00 00 00 00
T 14 03 00
R 00 00 00 00
T 14 03 00 F8 35 F5 2A 66 6F F1 E5 F5 33 F8 36 2A
R 00 00 00 00
T 21 03 00 66 6F CD 00 00 E8 03 F8 29 34 C2 8C 05
R 00 00 00 00 02 06 01 00 00 0E 00 00
T 2E 03 00 23 34 C3 8C 05
R 00 00 00 00 00 06 00 00
T 33 03 00
R 00 00 00 00
T 33 03 00 F8 04 7D 54 F8 25 22 72 F8 39 2A 4F 46
R 00 00 00 00
T 40 03 00 03 03 2B 79 22 70 0B 0B 69 60 2A 4F 46
R 00 00 00 00
T 4D 03 00 F8 25 2A 66 6F 79 22 70 C5 CD 00 00 E8
R 00 00 00 00 02 0D 02 00
T 5A 03 00 02 F8 27 7B 22 72 F8 2D 2A A6 3C 20 08
R 00 00 00 00
T 67 03 00 F8 27 2A 5E F8 2D 22 73
R 00 00 00 00
T 6F 03 00
R 00 00 00 00
T 6F 03 00 F8 1B CB 46 20 67 F8 27 5D 54 F8 2B 1A
R 00 00 00 00
T 7C 03 00 96 23 13 1A 9E 30 59 F8 2B 2A 5F 56 F8
R 00 00 00 00
T 89 03 00 27 2A 66 6F 7B 95 5F 7A 9C F8 30 32 73
R 00 00 00 00
T 96 03 00 F8 29 2A 5E 23 22 73
R 00 00 00 00
T 9D 03 00
R 00 00 00 00
T 9D 03 00 F8 2F 2A 4F 3A 47 2A 5F 56 1B 2B 7B 22
R 00 00 00 00
T AA 03 00 72 78 B1 28 1D F8 35 2A 66 6F E5 3E 20
R 00 00 00 00
T B7 03 00 F5 33 F8 36 2A 66 6F CD 00 00 E8 03 F8
R 00 00 00 00 02 0B 01 00
T C4 03 00 2B 34 20 D5 23 34 18 D1
R 00 00 00 00
T CC 03 00
R 00 00 00 00
T CC 03 00 F8 2B 2A 5E F8 29 22 73 F8 2F 2A 5E F8
R 00 00 00 00
T D9 03 00 2B 22 73
R 00 00 00 00
T DC 03 00
R 00 00 00 00
T DC 03 00 F8 29 2A 5E F8 2F 22 73
R 00 00 00 00
T E4 03 00
R 00 00 00 00
T E4 03 00 F8 25 2A 5F 56 1A 4F 13 1A 47 0A 47 B7
R 00 00 00 00
T F1 03 00 28 55 F8 2D 3E 00 96 23 3E 00 9E 3E 00
R 00 00 00 00
T FE 03 00 57 CB 7E 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 0A 04 00
R 00 00 00 00
T 0A 04 00 CB 7A 28 01 37
R 00 00 00 00
T 0F 04 00
R 00 00 00 00
T 0F 04 00 30 37 F8 2D 2A 5F 56 1B 2B 7B 22 72 F8
R 00 00 00 00
T 1C 04 00 35 2A 66 6F E5 C5 33 F8 36 2A 66 6F CD
R 00 00 00 00
T 29 04 00 00 00 E8 03 F8 2F 34 20 02 23 34
R 00 00 00 00 02 03 01 00
T 34 04 00
R 00 00 00 00
T 34 04 00 F8 25 2A 5F 56 1A 4F 13 1A 47 03 2B 2A
R 00 00 00 00
T 41 04 00 66 6F 79 22 70 18 9C
R 00 00 00 00
T 48 04 00
R 00 00 00 00
T 48 04 00 F8 2F 2A 5E F8 29 22 73 F8 1B CB 46 CA
R 00 00 00 00
T 55 04 00 8C 05 F8 27 5D 54 F8 2B 1A 96 23 13 1A
R 00 00 00 00 00 03 00 00
T 62 04 00 9E D2 8C 05 F8 2B 2A 5F 56 F8 27 2A 66
R 00 00 00 00 00 05 00 00
T 6F 04 00 6F 7B 95 5F 7A 9C 47 4B
R 00 00 00 00
T 77 04 00
R 00 00 00 00
T 77 04 00 59 50 0B 7A B3 CA 80 05 C5 F8 37 2A 66
R 00 00 00 00 00 09 00 00
T 84 04 00 6F E5 3E 20 F5 33 F8 38 2A 66 6F CD
R 00 00 00 00
T 90 04 00 00 00 E8 03 C1 F8 2F 34 20 DD 23 34 18
R 00 00 00 00 02 03 01 00
T 9D 04 00 D9
R 00 00 00 00
T 9E 04 00
R 00 00 00 00
T 9E 04 00 F8 04 7D 54 F8 2F 22 72 F8 39 2A 4F 46
R 00 00 00 00
T AB 04 00 03 03 2B 79 22 70 0B 0B 69 60 2A 4F 46
R 00 00 00 00
T B8 04 00 F8 2F 2A 66 6F 79 22 70 F8 35 2A 66 6F
R 00 00 00 00
T C5 04 00 E5 3E 30 F5 33 F8 36 2A 66 6F CD 00 00
R 00 00 00 00 02 0E 01 00
T D2 04 00 E8 03 F8 29 2A 4F 46 03 C5 F8 37 2A 66
R 00 00 00 00
T DF 04 00 6F E5 3E 78 F5 33 F8 38 2A 66 6F CD
R 00 00 00 00
T EB 04 00 00 00 E8 03 C1 03 F8 05 5D 54 1A 57 C5
R 00 00 00 00 02 03 01 00
T F8 04 00 F8 37 2A 66 6F E5 F8 37 2A 66 6F E5 F8
R 00 00 00 00
T 05 05 00 2A 7E F5 33 D5 33 CD 2B 00 E8 06 C1 03
R 00 00 00 00 00 0A 00 00
T 12 05 00 03 F8 0F 2A 5F 56 1A C5 F8 37 F5 2A 66
R 00 00 00 00
T 1F 05 00 6F F1 E5 F8 37 F5 2A 66 6F F1 E5 F8 2A
R 00 00 00 00
T 2C 05 00 66 E5 33 F5 33 CD 2B 00 E8 06 C1 03 03
R 00 00 00 00 00 09 00 00
T 39 05 00 F8 29 79 22 70 18 4C
R 00 00 00 00
T 40 05 00
R 00 00 00 00
T 40 05 00 F8 1F 36 01 F8 23 36 0A 18 42
R 00 00 00 00
T 4A 05 00
R 00 00 00 00
T 4A 05 00 F8 23 36 08 18 3C
R 00 00 00 00
T 50 05 00
R 00 00 00 00
T 50 05 00 F8 23 36 0A 18 36
R 00 00 00 00
T 56 05 00
R 00 00 00 00
T 56 05 00 F8 23 36 10 18 30
R 00 00 00 00
T 5C 05 00
R 00 00 00 00
T 5C 05 00 F8 22 36 01 18 2A
R 00 00 00 00
T 62 05 00
R 00 00 00 00
T 62 05 00 F8 35 2A 66 6F E5 F8 32 7E F5 33 F8 36
R 00 00 00 00
T 6F 05 00 2A 66 6F CD 00 00 E8 03 F8 29 34 20 10
R 00 00 00 00 02 07 01 00
T 7C 05 00 23 34 18 0C
R 00 00 00 00
T 80 05 00
R 00 00 00 00
T 80 05 00 F8 2F 2A 5E F8 29 22 7B 22 79 22 70
R 00 00 00 00
T 8C 05 00
R 00 00 00 00
T 8C 05 00 F8 22 CB 46 CA 3E 06 F8 04 7D 54 F8 2B
R 00 00 00 00 00 08 00 00
T 99 05 00 22 72 F8 39 2A 5F 56 21 04 00 19 E5 7D
R 00 00 00 00
T A6 05 00 F8 2F 77 E1 7C F8 2E 32 2A 5E F8 39 22
R 00 00 00 00
T B3 05 00 73 F8 2D 2A 5F 56 21 04 00 7B 95 5F 7A
R 00 00 00 00
T C0 05 00 9C F8 30 32 7B 22 2B 2A 5F 56 1A F8 2D
R 00 00 00 00
T CD 05 00 22 13 1A 22 13 1A 22 13 1A 77 F8 2B 2A
R 00 00 00 00
T DA 05 00 5F 2A 57 7E 12 13 23 7E 12 13 23 7E 12
R 00 00 00 00
T E7 05 00 13 23 7E 12 F8 04 4D 44 3E 48 0B 00 22
R 00 00 00 00 09 0C 00 00
T F2 05 00 36 48 0B 00 F8 29 2A 5E F8 2F 22 73
R 00 00 00 00 89 04 00 00
T FC 05 00
R 00 00 00 00
T FC 05 00 59 50 1A F8 2D 22 13 1A 32 2A 5F 56 13
R 00 00 00 00
T 09 06 00 69 60 7B 22 72 F8 2D 2A 5F 56 1A 57 B7
R 00 00 00 00
T 16 06 00 CA 0F 01 C5 F8 37 2A 66 6F E5 D5 33 F8
R 00 00 00 00 00 04 00 00
T 23 06 00 38 2A 66 6F CD 00 00 E8 03 C1 F8 2F 34
R 00 00 00 00 02 08 01 00
T 30 06 00 20 02 23 34
R 00 00 00 00
T 34 06 00
R 00 00 00 00
T 34 06 00 F8 2F 2A 5E F8 29 22 73 18 BE
R 00 00 00 00
T 3E 06 00
R 00 00 00 00
T 3E 06 00 F8 23 7E B7 CA 0F 01 F8 11 2A 5E F8 2E
R 00 00 00 00 00 08 00 00
T 4B 06 00 22 73 F8 20 CB 46 CA E8 06 F8 04 7D 54
R 00 00 00 00 00 0A 00 00
T 58 06 00 F8 21 22 72 F8 39 2A 5F 56 6B 62 23 E5
R 00 00 00 00
T 65 06 00 7D F8 27 77 E1 7C F8 26 32 2A 5E F8 39
R 00 00 00 00
T 72 06 00 22 73 F8 25 2A 5F 56 21 01 00 7B 95 5F
R 00 00 00 00
T 7F 06 00 7A 9C F8 28 32 7B 22 2B 2A 5F 56 1A F8
R 00 00 00 00
T 8C 06 00 30 77 7E F8 25 77 AF 23 22 22 77 F8 21
R 00 00 00 00
T 99 06 00 2A 5F 56 F8 25 7E 12 13 23 7E 12 13 23
R 00 00 00 00
T A6 06 00 7E 12 13 23 7E 12 F8 1F CB 46 C2 B4 07
R 00 00 00 00 00 0E 00 00
T B3 06 00 F8 21 2A 5F 56 1A F8 00 22 13 1A 22 13
R 00 00 00 00
T C0 06 00 1A 22 13 1A 77 F8 00 7E F8 25 77 AF 23
R 00 00 00 00
T CD 06 00 22 22 77 F8 21 2A 5F 56 F8 25 7E 12 13
R 00 00 00 00
T DA 06 00 23 7E 12 13 23 7E 12 13 23 7E 12 C3
R 00 00 00 00
T E6 06 00 B4 07
R 00 00 00 00 00 03 00 00
T E8 06 00
R 00 00 00 00
T E8 06 00 F8 21 CB 46 28 5B F8 04 7D 54 F8 21 22
R 00 00 00 00
T F5 06 00 72 F8 39 2A 5F 56 21 04 00 19 E5 7D F8
R 00 00 00 00
T 02 07 00 27 77 E1 7C F8 26 32 2A 5E F8 39 22 73
R 00 00 00 00
T 0F 07 00 F8 25 2A 5F 56 21 04 00 7B 95 5F 7A 9C
R 00 00 00 00
T 1C 07 00 F8 28 32 7B 22 2B 2A 5F 56 1A F8 25 22
R 00 00 00 00
T 29 07 00 13 1A 22 13 1A 22 13 1A 77 F8 21 2A 5F
R 00 00 00 00
T 36 07 00 56 F8 25 7E 12 13 23 7E 12 13 23 7E 12
R 00 00 00 00
T 43 07 00 13 23 7E 12 18 6B
R 00 00 00 00
T 49 07 00
R 00 00 00 00
T 49 07 00 F8 04 4D 44 F8 39 2A 5F 56 13 13 2B 7B
R 00 00 00 00
T 56 07 00 22 72 1B 1B 1A F8 27 22 13 1A 77 F8 27
R 00 00 00 00
T 63 07 00 3A 2B 77 F8 28 3A 2B 77 17 9F 23 22 77
R 00 00 00 00
T 70 07 00 59 50 F8 25 7E 12 13 23 7E 12 13 23 7E
R 00 00 00 00
T 7D 07 00 12 13 23 7E 12 F8 1F CB 46 20 2C 59 50
R 00 00 00 00
T 8A 07 00 1A F8 00 22 13 1A 22 13 1A 22 13 1A 77
R 00 00 00 00
T 97 07 00 F8 00 7E F8 25 77 F8 01 7E F8 26 77 AF
R 00 00 00 00
T A4 07 00 23 22 77 F8 25 2A 02 03 2A 02 03 2A 02
R 00 00 00 00
T B1 07 00 03 7E 02
R 00 00 00 00
T B4 07 00
R 00 00 00 00
T B4 07 00 F8 1F CB 46 CA 47 08 F8 04 7D 54 F8 21
R 00 00 00 00 00 08 00 00
T C1 07 00 22 7A 32 2A 5F 56 1A F8 25 22 13 1A 22
R 00 00 00 00
T CE 07 00 13 1A 22 13 1A 77 F8 25 7E D6 00 23 7E
R 00 00 00 00
T DB 07 00 DE 00 23 7E DE 00 23 7E DE 00 56 3E 00
R 00 00 00 00
T E8 07 00 CB 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T F3 07 00
R 00 00 00 00
T F3 07 00 CB 7A 28 01 37
R 00 00 00 00
T F8 07 00
R 00 00 00 00
T F8 07 00 30 49 F8 21 2A 5F 56 1A F8 00 22 13 1A
R 00 00 00 00
T 05 08 00 22 13 1A 22 13 1A 77 11 00 00 7B F8 00
R 00 00 00 00
T 12 08 00 96 5F 7A 23 9E F5 F8 28 32 73 11 00 00
R 00 00 00 00
T 1F 08 00 F8 04 F1 7B 9E 5F 7A 23 9E F8 28 32 73
R 00 00 00 00
T 2C 08 00 F8 21 2A 5F 56 F8 25 7E 12 13 23 7E 12
R 00 00 00 00
T 39 08 00 13 23 7E 12 13 23 7E 12 18 04
R 00 00 00 00
T 43 08 00
R 00 00 00 00
T 43 08 00 AF F8 1F 77
R 00 00 00 00
T 47 08 00
R 00 00 00 00
T 47 08 00 F8 30 3E 01 32 2B 2A 5E F8 27 22 73 AF
R 00 00 00 00
T 54 08 00 F8 2E 22 77
R 00 00 00 00
T 58 08 00
R 00 00 00 00
T 58 08 00 F8 08 4D 44 AF 02 F8 13 2A 4F 46 F8 23
R 00 00 00 00
T 65 08 00 7E F5 33 C5 CD 6D 00 E8 03 F8 30 CB 46
R 00 00 00 00 00 08 00 00
T 72 08 00 20 2F F8 17 2A 5F 56 1A CB 37 E6 F0 4F
R 00 00 00 00
T 7F 08 00 2B 2A 5F 56 1A CB 37 E6 0F B1 4F F8 27
R 00 00 00 00
T 8C 08 00 2A 5F 56 1A B1 4F 2B 2A 66 6F 71 F8 27
R 00 00 00 00
T 99 08 00 2A 5F 56 1B 2B 7B 22 72 18 0D
R 00 00 00 00
T A3 08 00
R 00 00 00 00
T A3 08 00 F8 15 2A 5F 56 1A 4F F8 27 2A 66 6F 71
R 00 00 00 00
T B0 08 00
R 00 00 00 00
T B0 08 00 F8 2E 34 20 02 23 34
R 00 00 00 00
T B7 08 00
R 00 00 00 00
T B7 08 00 F8 30 7E EE 01 77 F8 13 2A 5F 56 1A 4F
R 00 00 00 00
T C4 08 00 13 1A 47 13 1A 6F 13 1A B5 B0 B1 20 87
R 00 00 00 00
T D1 08 00 F8 27 2A 5E F8 25 22 73 F8 2E 2A 5E F8
R 00 00 00 00
T DE 08 00 27 22 73 F8 2C 3A B6 20 05 36 01 AF 23
R 00 00 00 00
T EB 08 00 77
R 00 00 00 00
T EC 08 00
R 00 00 00 00
T EC 08 00 F8 1C CB 46 20 4B 2B CB 46 20 46 F8 2B
R 00 00 00 00
T F9 08 00 2A 5E 23 23 22 73
R 00 00 00 00
T FF 08 00
R 00 00 00 00
T FF 08 00 F8 27 4E 0C 06 00 F8 2E 79 96 23 78 9E
R 00 00 00 00
T 0C 09 00 30 27 F8 35 2A 66 6F E5 3E 20 F5 33 F8
R 00 00 00 00
T 19 09 00 36 2A 66 6F CD 00 00 E8 03 F8 29 34 20
R 00 00 00 00 02 08 01 00
T 26 09 00 02 23 34
R 00 00 00 00
T 29 09 00
R 00 00 00 00
T 29 09 00 F8 2E 2A 5F 56 1B 2B 7B 22 72 18 CA
R 00 00 00 00
T 35 09 00
R 00 00 00 00
T 35 09 00 F8 2E 2A 5E F8 2B 22 73
R 00 00 00 00
T 3D 09 00
R 00 00 00 00
T 3D 09 00 F8 1F CB 46 28 27 F8 35 2A 66 6F E5 3E
R 00 00 00 00
T 4A 09 00 2D F5 33 F8 36 2A 66 6F CD 00 00 E8 03
R 00 00 00 00 02 0C 01 00
T 57 09 00 F8 29 34 20 02 23 34
R 00 00 00 00
T 5E 09 00
R 00 00 00 00
T 5E 09 00 F8 2B 2A 5F 56 1B 2B 7B 22 72 18 5E
R 00 00 00 00
T 6A 09 00
R 00 00 00 00
T 6A 09 00 F8 28 3A B6 28 58 F8 1D CB 46 28 27 F8
R 00 00 00 00
T 77 09 00 35 2A 66 6F E5 3E 2B F5 33 F8 36 2A 66
R 00 00 00 00
T 84 09 00 6F CD 00 00 E8 03 F8 29 34 20 02 23 34
R 00 00 00 00 02 05 01 00
T 91 09 00
R 00 00 00 00
T 91 09 00 F8 2B 2A 5F 56 1B 2B 7B 22 72 18 2B
R 00 00 00 00
T 9D 09 00
R 00 00 00 00
T 9D 09 00 F8 1E CB 46 28 25 F8 35 2A 66 6F E5 3E
R 00 00 00 00
T AA 09 00 20 F5 33 F8 36 2A 66 6F CD 00 00 E8 03
R 00 00 00 00 02 0C 01 00
T B7 09 00 F8 29 34 20 02 23 34
R 00 00 00 00
T BE 09 00
R 00 00 00 00
T BE 09 00 F8 2B 2A 5F 56 1B 2B 7B 22 72
R 00 00 00 00
T C8 09 00
R 00 00 00 00
T C8 09 00 F8 1B CB 46 20 53 F8 2B 2A 5E 23 23 22
R 00 00 00 00
T D5 09 00 73
R 00 00 00 00
T D6 09 00
R 00 00 00 00
T D6 09 00 F8 2E 2A 4F 3A 47 2A 5F 56 1B 2B 7B 22
R 00 00 00 00
T E3 09 00 72 F8 27 7E 91 23 7E 98 30 5C F8 1C CB
R 00 00 00 00
T F0 09 00 46 28 09 F8 2C 36 30 AF 23 77 18 07
R 00 00 00 00
T FC 09 00
R 00 00 00 00
T FC 09 00 F8 2C 36 20 AF 23 77
R 00 00 00 00
T 03 0A 00
R 00 00 00 00
T 03 0A 00 F8 2C 46 F8 35 2A 66 6F E5 C5 33 F8 36
R 00 00 00 00
T 10 0A 00 2A 66 6F CD 00 00 E8 03 F8 29 34 20 B9
R 00 00 00 00 02 07 01 00
T 1D 0A 00 23 34 18 B5
R 00 00 00 00
T 21 0A 00
R 00 00 00 00
T 21 0A 00 F8 27 5D 54 F8 2B 1A 96 23 13 1A 9E 30
R 00 00 00 00
T 2E 0A 00 15 F8 2B 2A 5F 56 F8 27 2A 66 6F 7B 95
R 00 00 00 00
T 3B 0A 00 5F 7A 9C F8 2F 32 73 18 05
R 00 00 00 00
T 44 0A 00
R 00 00 00 00
T 44 0A 00 AF F8 2E 22 77
R 00 00 00 00
T 49 0A 00
R 00 00 00 00
T 49 0A 00
R 00 00 00 00
T 49 0A 00 F8 25 2A 5E F8 2C 22 73 F8 29 2A 5E F8
R 00 00 00 00
T 56 0A 00 25 22 7B 22 2A 5E 23 23 22 73
R 00 00 00 00
T 60 0A 00
R 00 00 00 00
T 60 0A 00 F8 2A 2A 4F 3A 47 2A 5F 56 1B 2B 7B 22
R 00 00 00 00
T 6D 0A 00 72 78 B1 28 5B F8 30 7E EE 01 77 CB 46
R 00 00 00 00
T 7A 0A 00 20 1A F8 2C 34 20 02 23 34
R 00 00 00 00
T 83 0A 00
R 00 00 00 00
T 83 0A 00 F8 2C 2A 5F 56 1A CB 37 E6 0F 4F F8 15
R 00 00 00 00
T 90 0A 00 2A 66 6F 71 18 0F
R 00 00 00 00
T 96 0A 00
R 00 00 00 00
T 96 0A 00 F8 2C 2A 5F 56 1A E6 0F 4F F8 15 2A 66
R 00 00 00 00
T A3 0A 00 6F 71
R 00 00 00 00
T A5 0A 00
R 00 00 00 00
T A5 0A 00 F8 19 2A 5F 56 1A 47 F8 35 2A 66 6F E5
R 00 00 00 00
T B2 0A 00 F8 35 2A 66 6F E5 F8 28 7E F5 33 C5 33
R 00 00 00 00
T BF 0A 00 CD 00 00 E8 06 F8 25 34 20 97 23 34 18
R 00 00 00 00 00 04 00 00
T CC 0A 00 93
R 00 00 00 00
T CD 0A 00
R 00 00 00 00
T CD 0A 00 F8 25 2A 5E F8 29 22 73 F8 1B CB 46 CA
R 00 00 00 00
T DA 0A 00 0F 01 F8 25 2A 5E F8 2C 22 7B 22 2A 5E
R 00 00 00 00 00 03 00 00
T E7 0A 00 F8 27 22 73
R 00 00 00 00
T EB 0A 00
R 00 00 00 00
T EB 0A 00 F8 27 2A 4F 3A 47 2A 5F 56 1B 2B 7B 22
R 00 00 00 00
T F8 0A 00 72 78 B1 CA 0F 01 F8 35 2A 66 6F E5 3E
R 00 00 00 00 00 07 00 00
T 05 0B 00 20 F5 33 F8 36 2A 66 6F CD 00 00 E8 03
R 00 00 00 00 02 0C 01 00
T 12 0B 00 F8 2C 34 20 02 23 34
R 00 00 00 00
T 19 0B 00
R 00 00 00 00
T 19 0B 00 F8 2C 2A 5E F8 29 22 73 18 C8
R 00 00 00 00
T 23 0B 00
R 00 00 00 00
T 23 0B 00 F8 35 2A 66 6F E5 C5 33 F8 36 2A 66 6F
R 00 00 00 00
T 30 0B 00 CD 00 00 E8 03 F8 29 34 C2 0F 01 23 34
R 00 00 00 00 02 04 01 00 00 0C 00 00
T 3D 0B 00 C3 0F 01
R 00 00 00 00 00 04 00 00
T 40 0B 00
R 00 00 00 00
T 40 0B 00 F8 29 2A 5F 56 E8 31 C9
R 00 00 00 00
T 48 0B 00
R 00 00 00 00
T 48 0B 00 3C 4E 4F 20 46 4C 4F 41 54 3E 00
R 00 00 00 00

puts.rel/       0           0     0     644     643       `
XL3
H 7 areas 3 global symbols
M puts
O -mgbz80
S _putchar Ref000000
S .__.ABS. Def000000
A _CODE size 28 flags 0 addr 0
S _puts Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 2A 4F 46
R 00 00 00 00
T 05 00 00
R 00 00 00 00
T 05 00 00 0A B7 28 15 03 5F 16 00 C5 D5 CD 00 00
R 00 00 00 00 02 0E 00 00
T 12 00 00 E8 02 C1 7B A2 3C 20 EB 11 FF FF C9
R 00 00 00 00
T 1E 00 00
R 00 00 00 00
T 1E 00 00 21 0A 00 E5 CD 00 00 E8 02 C9
R 00 00 00 00 02 08 00 00

gets.rel/       0           0     0     644     1352      `
XL3
H 7 areas 4 global symbols
M gets
O -mgbz80
S _putchar Ref000000
S .__.ABS. Def000000
S _getchar Ref000000
A _CODE size 89 flags 0 addr 0
S _gets Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 3B 01 00 00
R 00 00 00 00
T 04 00 00
R 00 00 00 00
T 04 00 00 C5 CD 00 00 C1 F8 00 73 7E D6 08 28 15
R 00 00 00 00 02 05 02 00
T 11 00 00 F8 03 2A 5F 56 F8 00 7E D6 0A 28 37 F8
R 00 00 00 00
T 1E 00 00 00 7E D6 0D 28 30 18 46
R 00 00 00 00
T 26 00 00
R 00 00 00 00
T 26 00 00 78 B1 28 DA C5 21 08 00 E5 CD 00 00 E8
R 00 00 00 00 02 0D 00 00
T 33 00 00 02 21 20 00 E5 CD 00 00 E8 02 21 08 00
R 00 00 00 00 02 09 00 00
T 40 00 00 E5 CD 00 00 E8 02 C1 F8 03 2A 5F 56 1B
R 00 00 00 00 02 05 00 00
T 4D 00 00 2B 7B 22 72 0B 18 B0
R 00 00 00 00
T 54 00 00
R 00 00 00 00
T 54 00 00 D5 21 0D 00 E5 CD 00 00 E8 02 21 0A 00
R 00 00 00 00 02 09 00 00
T 61 00 00 E5 CD 00 00 E8 02 D1 AF 12 18 1B
R 00 00 00 00 02 05 00 00
T 6C 00 00
R 00 00 00 00
T 6C 00 00 F8 00 7E 12 13 F8 03 7B 22 72 03 F8 00
R 00 00 00 00
T 79 00 00 5E 16 00 C5 D5 CD 00 00 E8 02 C1 C3
R 00 00 00 00 02 09 00 00
T 85 00 00 04 00
R 00 00 00 00 00 03 00 00
T 87 00 00
R 00 00 00 00
T 87 00 00 33 C9
R 00 00 00 00
__assert.rel/   0           0     0     644     925       `
XL3
H 7 areas 3 global symbols
M __assert
O -mgbz80
S .__.ABS. Def000000
S _printf Ref000000
A _CODE size 5A flags 0 addr 0
S ___assert Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 06 2A 66 6F E5 F8 0A 2A 66 6F E5 F8
R 00 00 00 00
T 0D 00 00 08 2A 66 6F E5 F8 08 2A 66 6F E5 21
R 00 00 00 00
T 19 00 00 21 00 E5 CD 00 00
R 00 00 00 00 00 03 00 00 02 07 01 00
T 1F 00 00
R 00 00 00 00
T 1F 00 00 18 FE
R 00 00 00 00
T 21 00 00
R 00 00 00 00
T 21 00 00 41 73 73 65 72 74 28 25 73 29 20 66 61
R 00 00 00 00
T 2E 00 00 69 6C 65 64 20 69 6E 20 66 75 6E 63 74
R 00 00 00 00
T 3B 00 00 69 6F 6E 20 25 73 20 61 74 20 6C 69 6E
R 00 00 00 00
T 48 00 00 65 20 25 75 20 69 6E 20 66 69 6C 65 20
R 00 00 00 00
T 55 00 00 25 73 2E 0A 00
R 00 00 00 00

time.rel/       0           0     0     644     13017     `
XL3
H 7 areas F global symbols
M time
O -mgbz80
S .__.ABS. Def000000
S __modulong Ref000000
S _sprintf Ref000000
S __divulong Ref000000
S __modsint Ref000000
S __mullong Ref000000
A _CODE size 74C flags 0 addr 0
S ___month Def0000C6
S _RtcRead Def000000
S _asctime Def000138
S _time Def000003
S _localtime Def000211
S ___day Def0000DE
S _gmtime Def00021C
S _mktime Def0004BF
S _ctime Def000200
A _DATA size 2C flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 01 00
T 00 00 00
R 00 00 01 00
T 20 00 00
R 00 00 01 00
T 20 00 00
R 00 00 01 00
T 00 00 00
R 00 00 00 00
T 00 00 00 1E 00 C9
R 00 00 00 00
T 03 00 00
R 00 00 00 00
T 03 00 00 E8 F0 F8 0C 3E FF 22 22 3E FF 22 36 FF
R 00 00 00 00
T 10 00 00 F8 00 4D 44 59 50 C5 D5 CD 00 00 E8 02
R 00 00 00 00 00 0C 00 00
T 1D 00 00 7B C1 B7 28 11 C5 CD BF 04 E8 02 4D 44
R 00 00 00 00 00 0A 00 00
T 2A 00 00 F8 0C 7B 22 7A 22 79 22 70
R 00 00 00 00
T 33 00 00
R 00 00 00 00
T 33 00 00 F8 13 3A B6 28 13 2A 5F 56 F8 0C 7E 12
R 00 00 00 00
T 40 00 00 13 23 7E 12 13 23 7E 12 13 23 7E 12
R 00 00 00 00
T 4C 00 00
R 00 00 00 00
T 4C 00 00 F8 0C 2A 5F 2A 57 2A 66 6F E8 10 C9
R 00 00 00 00
T 58 00 00
R 00 00 00 00
T 58 00 00 F8 02 2A 4F 46 0A 5F 3E 3B BB 30 01 02
R 00 00 00 00
T 65 00 00
R 00 00 00 00
T 65 00 00 69 60 23 5E 3E 3B 93 30 02 36 3B
R 00 00 00 00
T 70 00 00
R 00 00 00 00
T 70 00 00 69 60 23 23 5E 3E 17 93 30 02 36 17
R 00 00 00 00
T 7C 00 00
R 00 00 00 00
T 7C 00 00 21 07 00 09 5E 3E 06 93 30 02 36 06
R 00 00 00 00
T 88 00 00
R 00 00 00 00
T 88 00 00 69 60 23 23 23 5E 7B D6 01 30 04 36 01
R 00 00 00 00
T 95 00 00 18 07
R 00 00 00 00
T 97 00 00
R 00 00 00 00
T 97 00 00 3E 1F 93 30 02 36 1F
R 00 00 00 00
T 9E 00 00
R 00 00 00 00
T 9E 00 00 21 04 00 09 5E 3E 0B 93 30 02 36 0B
R 00 00 00 00
T AA 00 00
R 00 00 00 00
T AA 00 00 03 03 03 03 03 69 60 2A CB 7E C8 AF 02
R 00 00 00 00
T B7 00 00 03 02 C9
R 00 00 00 00
T BA 00 00
R 00 00 00 00
T BA 00 00 1F 1C 1F 1E 1F 1E 1F 1F 1E 1F 1E 1F
R 00 00 00 00
T C6 00 00
R 00 00 00 00
T C6 00 00 EC 00 F0 00 F4 00
R 00 00 00 00 00 03 00 00 00 05 00 00 00 07 00 00
T CC 00 00 F8 00 FC 00 00 01
R 00 00 00 00 00 03 00 00 00 05 00 00 00 07 00 00
T D2 00 00 04 01 08 01 0C 01
R 00 00 00 00 00 03 00 00 00 05 00 00 00 07 00 00
T D8 00 00 10 01 14 01 18 01
R 00 00 00 00 00 03 00 00 00 05 00 00 00 07 00 00
T DE 00 00
R 00 00 00 00
T DE 00 00 1C 01 20 01 24 01
R 00 00 00 00 00 03 00 00 00 05 00 00 00 07 00 00
T E4 00 00 28 01 2C 01 30 01
R 00 00 00 00 00 03 00 00 00 05 00 00 00 07 00 00
T EA 00 00 34 01
R 00 00 00 00 00 03 00 00
T EC 00 00
R 00 00 00 00
T EC 00 00 4A 61 6E 00
R 00 00 00 00
T F0 00 00
R 00 00 00 00
T F0 00 00 46 65 62 00
R 00 00 00 00
T F4 00 00
R 00 00 00 00
T F4 00 00 4D 61 72 00
R 00 00 00 00
T F8 00 00
R 00 00 00 00
T F8 00 00 41 70 72 00
R 00 00 00 00
T FC 00 00
R 00 00 00 00
T FC 00 00 4D 61 79 00
R 00 00 00 00
T 00 01 00
R 00 00 00 00
T 00 01 00 4A 75 6E 00
R 00 00 00 00
T 04 01 00
R 00 00 00 00
T 04 01 00 4A 75 6C 00
R 00 00 00 00
T 08 01 00
R 00 00 00 00
T 08 01 00 41 75 67 00
R 00 00 00 00
T 0C 01 00
R 00 00 00 00
T 0C 01 00 53 65 70 00
R 00 00 00 00
T 10 01 00
R 00 00 00 00
T 10 01 00 4F 63 74 00
R 00 00 00 00
T 14 01 00
R 00 00 00 00
T 14 01 00 4E 6F 76 00
R 00 00 00 00
T 18 01 00
R 00 00 00 00
T 18 01 00 44 65 63 00
R 00 00 00 00
T 1C 01 00
R 00 00 00 00
T 1C 01 00 53 75 6E 00
R 00 00 00 00
T 20 01 00
R 00 00 00 00
T 20 01 00 4D 6F 6E 00
R 00 00 00 00
T 24 01 00
R 00 00 00 00
T 24 01 00 54 75 65 00
R 00 00 00 00
T 28 01 00
R 00 00 00 00
T 28 01 00 57 65 64 00
R 00 00 00 00
T 2C 01 00
R 00 00 00 00
T 2C 01 00 54 68 75 00
R 00 00 00 00
T 30 01 00
R 00 00 00 00
T 30 01 00 46 72 69 00
R 00 00 00 00
T 34 01 00
R 00 00 00 00
T 34 01 00 53 61 74 00
R 00 00 00 00
T 38 01 00
R 00 00 00 00
T 38 01 00 E8 F4 F8 0E 2A 66 6F E5 CD 58 00 E8 02
R 00 00 00 00 00 0C 00 00
T 45 01 00 F8 0E 2A 4F 46 21 05 00 09 5D 54 1A F8
R 00 00 00 00
T 52 01 00 0A 22 13 1A 77 F8 0A 2A 5F 56 21 6C 07
R 00 00 00 00
T 5F 01 00 19 33 33 E5 0A F8 02 77 AF 23 77 59 50
R 00 00 00 00
T 6C 01 00 13 1A 23 77 AF 23 77 59 50 13 13 1A 23
R 00 00 00 00
T 79 01 00 77 AF 23 77 59 50 13 13 13 1A 23 77 AF
R 00 00 00 00
T 86 01 00 23 77 21 04 00 09 6E 26 00 29 11 C6 00
R 00 00 00 00 00 0E 00 00
T 93 01 00 19 5D 54 1A F8 0A 22 13 1A 77 21 07 00
R 00 00 00 00
T A0 01 00 09 6E 26 00 29 11 DE 00 19 2A 4F 46 E1
R 00 00 00 00 00 09 00 00
T AD 01 00 E5 E5 F8 04 2A 66 6F E5 F8 08 2A 66 6F
R 00 00 00 00
T BA 01 00 E5 F8 0C 2A 66 6F E5 F8 10 2A 66 6F E5
R 00 00 00 00
T C7 01 00 F8 14 2A 66 6F E5 C5 21 E1 01 E5 21
R 00 00 00 00 00 0B 00 00
T D3 01 00 00 00 E5 CD 00 00 E8 12 11 00 00 E8 0C
R 00 00 00 00 00 03 01 00 02 07 02 00 00 0C 01 00
T E0 01 00 C9
R 00 00 00 00
T E1 01 00
R 00 00 00 00
T E1 01 00 25 73 20 25 73 20 25 32 64 20 25 30 32
R 00 00 00 00
T EE 01 00 64 3A 25 30 32 64 3A 25 30 32 64 20 25
R 00 00 00 00
T FB 01 00 30 34 64 0A 00
R 00 00 00 00
T 00 02 00
R 00 00 00 00
T 00 02 00 C1 E1 E5 C5 E5 CD 11 02 E8 02 D5 CD
R 00 00 00 00 00 09 00 00
T 0C 02 00 38 01 E8 02 C9
R 00 00 00 00 00 03 00 00
T 11 02 00
R 00 00 00 00
T 11 02 00 C1 E1 E5 C5 E5 CD 1C 02 E8 02 C9
R 00 00 00 00 00 09 00 00
T 1C 02 00
R 00 00 00 00
T 1C 02 00 E8 EE F8 14 2A 4F 46 59 50 1A F8 0E 22
R 00 00 00 00
T 29 02 00 13 1A 22 13 1A 22 13 1A 77 21 00 00 E5
R 00 00 00 00
T 36 02 00 21 3C 00 E5 F8 14 2A 66 6F E5 F8 14 2A
R 00 00 00 00
T 43 02 00 66 6F E5 CD 00 00 E8 08 7B EA 20 00 21
R 00 00 00 00 02 07 01 00 00 0D 01 00
T 50 02 00 00 00 E5 21 3C 00 E5 F8 14 2A 66 6F E5
R 00 00 00 00
T 5D 02 00 F8 14 2A 66 6F E5 CD 00 00 E8 08 4D 44
R 00 00 00 00 02 0A 03 00
T 6A 02 00 F8 0E 7B 22 7A 22 79 22 70 21 00 00 E5
R 00 00 00 00
T 77 02 00 21 3C 00 E5 F8 14 2A 66 6F E5 F8 14 2A
R 00 00 00 00
T 84 02 00 66 6F E5 CD 00 00 E8 08 7B EA 21 00 21
R 00 00 00 00 02 07 01 00 00 0D 01 00
T 91 02 00 00 00 E5 21 3C 00 E5 F8 14 2A 66 6F E5
R 00 00 00 00
T 9E 02 00 F8 14 2A 66 6F E5 CD 00 00 E8 08 4D 44
R 00 00 00 00 02 0A 03 00
T AB 02 00 F8 0E 7B 22 7A 22 79 22 70 21 00 00 E5
R 00 00 00 00
T B8 02 00 21 18 00 E5 F8 14 2A 66 6F E5 F8 14 2A
R 00 00 00 00
T C5 02 00 66 6F E5 CD 00 00 E8 08 7B EA 22 00 21
R 00 00 00 00 02 07 01 00 00 0D 01 00
T D2 02 00 00 00 E5 21 18 00 E5 F8 14 2A 66 6F E5
R 00 00 00 00
T DF 02 00 F8 14 2A 66 6F E5 CD 00 00 E8 08 4D 44
R 00 00 00 00 02 0A 03 00
T EC 02 00 F8 04 7B 22 7A 22 79 22 78 32 2B 2B 2A
R 00 00 00 00
T F9 02 00 5F 56 7B C6 04 5F 7A CE 00 F5 F8 11 32
R 00 00 00 00
T 06 03 00 73 F8 08 2A 5F 56 F1 7B CE 00 5F 7A CE
R 00 00 00 00
T 13 03 00 00 F8 11 32 73 21 00 00 E5 21 07 00 E5
R 00 00 00 00
T 20 03 00 F8 14 2A 66 6F E5 F8 14 2A 66 6F E5 CD
R 00 00 00 00
T 2D 03 00 00 00 E8 08 7B EA 27 00 AF F8 00 22 22
R 00 00 00 00 02 03 01 00 00 09 01 00
T 3A 03 00 22 77 01 B2 07
R 00 00 00 00
T 3F 03 00
R 00 00 00 00
T 3F 03 00 79 E6 03 F8 10 77 AF 23 77 3A B6 20 05
R 00 00 00 00
T 4C 03 00 11 6E 01 18 03
R 00 00 00 00
T 51 03 00
R 00 00 00 00
T 51 03 00 11 6D 01
R 00 00 00 00
T 54 03 00
R 00 00 00 00
T 54 03 00 F8 08 73 7A 23 77 17 9F 23 22 77 D1 D5
R 00 00 00 00
T 61 03 00 7B F8 08 86 5F 7A 23 8E F5 F8 0F 32 73
R 00 00 00 00
T 6E 03 00 F8 04 2A 5F 56 F8 0C F1 7B 8E 5F 7A 23
R 00 00 00 00
T 7B 03 00 8E F8 0F 32 7B 32 2B 54 5D F8 00 1A 22
R 00 00 00 00
T 88 03 00 13 1A 22 13 1A 22 13 1A 77 F8 04 5D 54
R 00 00 00 00
T 95 03 00 F8 0C 1A 96 23 13 1A 9E 23 13 1A 9E 23
R 00 00 00 00
T A2 03 00 13 1A 9E 38 03 03 18 95
R 00 00 00 00
T AA 03 00
R 00 00 00 00
T AA 03 00 21 25 00 79 C6 94 4F 78 CE F8 71 23 77
R 00 00 00 00 00 04 01 00
T B7 03 00 F8 10 2A 5E F8 08 22 73 F8 11 3A B6 20
R 00 00 00 00
T C4 03 00 05 01 6E 01 18 03
R 00 00 00 00
T CA 03 00
R 00 00 00 00
T CA 03 00 01 6D 01
R 00 00 00 00
T CD 03 00
R 00 00 00 00
T CD 03 00 F8 0A 71 78 23 77 17 9F 23 22 77 D1 D5
R 00 00 00 00
T DA 03 00 7B F8 0A 96 5F 7A 23 9E F5 F8 11 32 73
R 00 00 00 00
T E7 03 00 F8 04 2A 5F 56 F8 0E F1 7B 9E 5F 7A 23
R 00 00 00 00
T F4 03 00 9E F8 11 32 7B 32 2B 54 5D F8 0A 1A 22
R 00 00 00 00
T 01 04 00 13 1A 22 13 1A 22 13 1A 77 F8 04 2A 5F
R 00 00 00 00
T 0E 04 00 56 7B F8 0A 96 5F 7A 23 9E F5 F8 11 32
R 00 00 00 00
T 1B 04 00 73 F8 08 2A 5F 56 F8 0E F1 7B 9E 5F 7A
R 00 00 00 00
T 28 04 00 23 9E F8 11 32 7B 32 2B 2A 4F 46 21
R 00 00 00 00
T 34 04 00 28 00 79 22 70 AF F8 0D 77
R 00 00 00 00 00 03 01 00
T 3D 04 00
R 00 00 00 00
T 3D 04 00 F8 0D 7E 3D 20 0E F8 09 3A B6 20 04 3E
R 00 00 00 00
T 4A 04 00 1D 18 10
R 00 00 00 00
T 4D 04 00
R 00 00 00 00
T 4D 04 00 3E 1C 18 0C
R 00 00 00 00
T 51 04 00
R 00 00 00 00
T 51 04 00 11 BA 00 F8 0D 6E 26 00 19 4D 44 0A
R 00 00 00 00 00 04 00 00
T 5D 04 00
R 00 00 00 00
T 5D 04 00 F8 04 77 AF 23 22 22 77 F8 0E 5D 54 F8
R 00 00 00 00
T 6A 04 00 04 1A 96 23 13 1A 9E 23 13 1A 9E 23 13
R 00 00 00 00
T 77 04 00 1A 9E 38 2C F8 0E 2A 5F 56 7B F8 04 96
R 00 00 00 00
T 84 04 00 5F 7A 23 9E F5 F8 11 32 73 F8 12 2A 5F
R 00 00 00 00
T 91 04 00 56 F8 08 F1 7B 9E 5F 7A 23 9E F8 11 32
R 00 00 00 00
T 9E 04 00 73 F8 0D 34 7E D6 0C 38 96
R 00 00 00 00
T A7 04 00
R 00 00 00 00
T A7 04 00 11 24 00 F8 0D 7E 12 23 7E 3C EA 23 00
R 00 00 00 00 00 04 01 00 00 0E 01 00
T B4 04 00 21 2A 00 36 00 11 20 00 E8 12 C9
R 00 00 00 00 00 04 01 00 00 09 01 00
T BF 04 00
R 00 00 00 00
T BF 04 00 E8 F2 F8 10 2A 5E F8 00 22 73 D1 D5 21
R 00 00 00 00
T CC 04 00 05 00 19 2A 4F 46 21 6C 07 09 E5 7D F8
R 00 00 00 00
T D9 04 00 0A 77 E1 7C F8 09 77 D1 D5 21 04 00 19
R 00 00 00 00
T E6 04 00 4D 44 0A F8 02 77 AF 23 77 E1 E5 E5 CD
R 00 00 00 00
T F3 04 00 58 00 E8 02 F8 08 2A 5F 56 21 B2 07 7B
R 00 00 00 00 00 03 00 00
T 00 05 00 95 5F 7A 9C 4B 47 17 9F 5F 57 D5 C5 21
R 00 00 00 00
T 0D 05 00 E1 01 E5 21 80 33 E5 CD 00 00 E8 08 4D
R 00 00 00 00 02 0B 05 00
T 1A 05 00 44 F8 0A 7B 22 7A 22 79 22 70 01 B2 07
R 00 00 00 00
T 27 05 00
R 00 00 00 00
T 27 05 00 F8 08 79 96 23 78 9E 78 57 CB 7E 28 07
R 00 00 00 00
T 34 05 00 CB 7A 20 08 BF 18 05
R 00 00 00 00
T 3B 05 00
R 00 00 00 00
T 3B 05 00 CB 7A 28 01 37
R 00 00 00 00
T 40 05 00
R 00 00 00 00
T 40 05 00 30 31 C5 21 04 00 E5 C5 CD 00 00 E8 04
R 00 00 00 00 02 0C 04 00
T 4D 05 00 C1 7A B3 20 1E F8 0A 2A 5F 56 7B C6 80
R 00 00 00 00
T 5A 05 00 5F 7A CE 51 F5 32 73 F8 0E 2A 5F 56 F1
R 00 00 00 00
T 67 05 00 7B CE 01 5F 7A CE 00 32 73
R 00 00 00 00
T 70 05 00
R 00 00 00 00
T 70 05 00 03 18 B4
R 00 00 00 00
T 73 05 00
R 00 00 00 00
T 73 05 00 21 04 00 E5 F8 0A 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 04 00
T 80 05 00 E8 04 E5 F8 06 73 F8 07 72 E1 01 00 00
R 00 00 00 00
T 8D 05 00
R 00 00 00 00
T 8D 05 00 F8 02 79 96 23 78 9E 78 57 CB 7E 28 07
R 00 00 00 00
T 9A 05 00 CB 7A 20 08 BF 18 05
R 00 00 00 00
T A1 05 00
R 00 00 00 00
T A1 05 00 CB 7A 28 01 37
R 00 00 00 00
T A6 05 00
R 00 00 00 00
T A6 05 00 D2 29 06 79 3D B0 20 26 F8 05 3A B6 20
R 00 00 00 00 00 04 00 00
T B3 05 00 20 F8 0A 2A 5F 56 7B C6 80 5F 7A CE 3B
R 00 00 00 00
T C0 05 00 F5 32 73 F8 0E 2A 5F 56 F1 7B CE 26 5F
R 00 00 00 00
T CD 05 00 7A CE 00 32 73 18 51
R 00 00 00 00
T D4 05 00
R 00 00 00 00
T D4 05 00 21 BA 00 09 5E 16 00 21 00 00 C5 E5 D5
R 00 00 00 00 00 04 00 00
T E1 05 00 21 01 00 E5 21 80 51 E5 CD 00 00 E8 08
R 00 00 00 00 02 0C 05 00
T EE 05 00 E5 F8 0A 73 F8 0B 72 E1 E5 7D F8 0C 77
R 00 00 00 00
T FB 05 00 E1 7C F8 0B 77 C1 F8 0A 2A 5F 56 7B F8
R 00 00 00 00
T 08 06 00 06 86 5F 7A 23 8E F5 F8 0D 32 73 F8 0E
R 00 00 00 00
T 15 06 00 2A 5F 56 F8 0A F1 7B 8E 5F 7A 23 8E F8
R 00 00 00 00
T 22 06 00 0D 32 73
R 00 00 00 00
T 25 06 00
R 00 00 00 00
T 25 06 00 03 C3 8D 05
R 00 00 00 00 00 05 00 00
T 29 06 00
R 00 00 00 00
T 29 06 00 E1 E5 23 23 23 4E 06 00 0B 78 17 9F 5F
R 00 00 00 00
T 36 06 00 57 D5 C5 21 01 00 E5 21 80 51 E5 CD
R 00 00 00 00
T 42 06 00 00 00 E8 08 E5 F8 04 73 F8 05 72 E1 E5
R 00 00 00 00 02 03 05 00
T 4F 06 00 7D F8 06 77 E1 7C F8 05 77 F8 0A 2A 5F
R 00 00 00 00
T 5C 06 00 56 7B F8 02 86 5F 7A 23 8E F5 F8 09 32
R 00 00 00 00
T 69 06 00 73 F8 0E 2A 5F 56 F8 06 F1 7B 8E 5F 7A
R 00 00 00 00
T 76 06 00 23 8E F8 09 32 73 E1 E5 23 23 4E 06 00
R 00 00 00 00
T 83 06 00 11 00 00 D5 C5 21 00 00 E5 21 10 0E E5
R 00 00 00 00
T 90 06 00 CD 00 00 E8 08 E5 F8 0C 73 F8 0D 72 E1
R 00 00 00 00 02 04 05 00
T 9D 06 00 E5 7D F8 0E 77 E1 7C F8 0D 77 F8 06 2A
R 00 00 00 00
T AA 06 00 5F 56 7B F8 0A 86 5F 7A 23 8E F5 F8 05
R 00 00 00 00
T B7 06 00 32 73 F8 0A 2A 5F 56 F8 0E F1 7B 8E 5F
R 00 00 00 00
T C4 06 00 7A 23 8E F8 05 32 73 E1 E5 23 4E 06 00
R 00 00 00 00
T D1 06 00 69 60 29 09 29 09 29 09 29 29 4D 44 F8
R 00 00 00 00
T DE 06 00 06 71 78 23 77 17 9F 23 22 77 F8 02 2A
R 00 00 00 00
T EB 06 00 5F 56 7B F8 06 86 5F 7A 23 8E F5 F8 0D
R 00 00 00 00
T F8 06 00 32 73 F8 06 2A 5F 56 F8 0A F1 7B 8E 5F
R 00 00 00 00
T 05 07 00 7A 23 8E F8 0D 32 73 D1 D5 1A 0E 00 F8
R 00 00 00 00
T 12 07 00 02 77 79 23 77 17 9F 23 22 77 F8 0A 2A
R 00 00 00 00
T 1F 07 00 5F 56 7B F8 02 86 5F 7A 23 8E F5 F8 09
R 00 00 00 00
T 2C 07 00 32 73 F8 0E 2A 5F 56 F8 06 F1 7B 8E 5F
R 00 00 00 00
T 39 07 00 7A 23 8E F8 09 32 7B 32 2B 2A 5F 2A 57
R 00 00 00 00
T 46 07 00 2A 66 6F E8 0E C9
R 00 00 00 00

__itoa.rel/     0           0     0     644     2177      `
XL3
H 7 areas 5 global symbols
M __itoa
O -mgbz80
S __divuint Ref000000
S .__.ABS. Def000000
S __moduint Ref000000
A _CODE size 119 flags 0 addr 0
S ___itoa Def0000BF
S ___uitoa Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FD AF F8 02 77
R 00 00 00 00
T 06 00 00
R 00 00 00 00
T 06 00 00 F8 02 7E 4F 17 9F 47 F8 07 2A 66 6F 09
R 00 00 00 00
T 13 00 00 4D 44 F8 09 5E 16 00 C5 D5 D5 F8 0B 2A
R 00 00 00 00
T 20 00 00 66 6F E5 CD 00 00 E8 04 E5 F8 06 73 F8
R 00 00 00 00 02 07 02 00
T 2D 00 00 07 72 E1 D1 C1 F8 00 7E C6 30 02 6F 3E
R 00 00 00 00
T 3A 00 00 39 95 30 04 7D C6 07 02
R 00 00 00 00
T 42 00 00
R 00 00 00 00
T 42 00 00 D5 F8 07 2A 66 6F E5 CD 00 00 E8 04 F8
R 00 00 00 00 02 0B 00 00
T 4F 00 00 05 7B 22 72 F8 02 34 F8 06 3A B6 20 AA
R 00 00 00 00
T 5C 00 00 F8 02 7E C6 FF 2B 22 7E 4F 17 9F 47 F8
R 00 00 00 00
T 69 00 00 07 2A 66 6F 09 4D 44 AF 02 AF F8 02 77
R 00 00 00 00
T 76 00 00
R 00 00 00 00
T 76 00 00 F8 01 2A 5F 56 3A 96 CB 7B 28 07 CB 7A
R 00 00 00 00
T 83 00 00 20 08 BF 18 05
R 00 00 00 00
T 88 00 00
R 00 00 00 00
T 88 00 00 CB 7A 28 01 37
R 00 00 00 00
T 8D 00 00
R 00 00 00 00
T 8D 00 00 30 2D F8 02 7E 4F 17 9F 47 F8 07 2A 66
R 00 00 00 00
T 9A 00 00 6F 09 5D 54 1A F8 00 22 7E 4F 17 9F 47
R 00 00 00 00
T A7 00 00 F8 07 2A 66 6F 09 4D 44 0A 12 F8 00 7E
R 00 00 00 00
T B4 00 00 02 23 23 34 2B 35 18 BA
R 00 00 00 00
T BC 00 00
R 00 00 00 00
T BC 00 00 E8 03 C9
R 00 00 00 00
T BF 00 00
R 00 00 00 00
T BF 00 00 F8 02 7E D6 00 23 7E DE 00 56 3E 00 CB
R 00 00 00 00
T CC 00 00 7F 28 07 CB 7A 20 08 BF 18 05
R 00 00 00 00
T D6 00 00
R 00 00 00 00
T D6 00 00 CB 7A 28 01 37
R 00 00 00 00
T DB 00 00
R 00 00 00 00
T DB 00 00 30 25 F8 06 7E D6 0A 20 1E F8 04 2A 4F
R 00 00 00 00
T E8 00 00 46 3E 2D 02 03 2B 79 22 70 11 00 00 F8
R 00 00 00 00
T F5 00 00 02 2A 66 6F 7B 95 5F 7A 9C F8 03 32 73
R 00 00 00 00
T 02 01 00
R 00 00 00 00
T 02 01 00 F8 06 7E F5 33 2B 2B 2A 66 6F E5 F8 05
R 00 00 00 00
T 0F 01 00 2A 66 6F E5 CD 00 00 E8 05 C9
R 00 00 00 00 00 08 00 00

__ltoa.rel/     0           0     0     644     2027      `
XL3
H 7 areas 5 global symbols
M __ltoa
O -mgbz80
S .__.ABS. Def000000
S __modulong Ref000000
S __divulong Ref000000
A _CODE size 110 flags 0 addr 0
S ___ultoa Def000000
S ___ltoa Def00009D
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 D9 F8 04 7D 54 F8 24 22 7A 22 36 20
R 00 00 00 00
T 0D 00 00
R 00 00 00 00
T 0D 00 00 F8 2F 7E F8 00 77 AF 23 22 22 77 C1 E1
R 00 00 00 00
T 1A 00 00 E5 C5 4D 44 E1 E5 C5 E5 F8 2F 2A 66 6F
R 00 00 00 00
T 27 00 00 E5 F8 2F 2A 66 6F E5 CD 00 00 E8 08 7B
R 00 00 00 00 02 0B 01 00
T 34 00 00 C6 30 4F 3E 39 91 30 04 79 C6 07 4F
R 00 00 00 00
T 40 00 00
R 00 00 00 00
T 40 00 00 F8 26 35 2B 2B 2A 5F 2A 57 6E 26 00 19
R 00 00 00 00
T 4D 00 00 71 C1 E1 E5 C5 4D 44 E1 E5 C5 E5 F8 2F
R 00 00 00 00
T 5A 00 00 2A 66 6F E5 F8 2F 2A 66 6F E5 CD 00 00
R 00 00 00 00 02 0E 02 00
T 67 00 00 E8 08 4D 44 F8 29 7B 22 7A 22 79 22 70
R 00 00 00 00
T 74 00 00 3A B6 2B B6 2B B6 20 91 F8 2D 2A 4F 46
R 00 00 00 00
T 81 00 00
R 00 00 00 00
T 81 00 00 F8 24 2A 5F 2A 57 6E 26 00 19 5D 54 1A
R 00 00 00 00
T 8E 00 00 02 03 F8 26 34 7E D6 20 20 E9 AF 02 E8
R 00 00 00 00
T 9B 00 00 27 C9
R 00 00 00 00
T 9D 00 00
R 00 00 00 00
T 9D 00 00 F8 02 7E D6 00 23 7E DE 00 23 7E DE 00
R 00 00 00 00
T AA 00 00 23 7E DE 00 56 3E 00 CB 7F 28 07 CB 7A
R 00 00 00 00
T B7 00 00 20 08 BF 18 05
R 00 00 00 00
T BC 00 00
R 00 00 00 00
T BC 00 00 CB 7A 28 01 37
R 00 00 00 00
T C1 00 00
R 00 00 00 00
T C1 00 00 30 30 F8 08 7E D6 0A 20 29 F8 06 2A 4F
R 00 00 00 00
T CE 00 00 46 3E 2D 02 03 2B 79 22 70 11 00 00 7B
R 00 00 00 00
T DB 00 00 F8 02 96 5F 7A 23 9E F5 32 73 11 00 00
R 00 00 00 00
T E8 00 00 23 23 F1 7B 9E 5F 7A 23 9E 32 73
R 00 00 00 00
T F3 00 00
R 00 00 00 00
T F3 00 00 F8 08 7E F5 33 2B 2B 2A 66 6F E5 F8 07
R 00 00 00 00
T 00 01 00 2A 66 6F E5 F8 07 2A 66 6F E5 CD 00 00
R 00 00 00 00 00 0E 00 00
T 0D 01 00 E8 07 C9
R 00 00 00 00

_startup.rel/   0           0     0     644     383       `
XL3
H 7 areas 2 global symbols
M _startup
O -mgbz80
S .__.ABS. Def000000
A _CODE size 3 flags 0 addr 0
S __sdcc_external_startup Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 1E 00 C9
R 00 00 00 00

sprintf.rel/    0           0     0     644     1012      `
XL3
H 7 areas 4 global symbols
M sprintf
O -mgbz80
S __print_format Ref000000
S .__.ABS. Def000000
A _CODE size 66 flags 0 addr 0
S _vsprintf Def000021
S _sprintf Def000043
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FE F8 05 2A 4F 46 59 50 1A F8 00 22
R 00 00 00 00
T 0D 00 00 13 1A 77 D1 D5 13 7B 02 03 7A 02 D1 D5
R 00 00 00 00
T 1A 00 00 F8 04 7E 12 E8 02 C9
R 00 00 00 00
T 21 00 00
R 00 00 00 00
T 21 00 00 F8 02 4D 44 F8 06 2A 66 6F E5 F8 06 2A
R 00 00 00 00
T 2E 00 00 66 6F E5 C5 21 00 00 E5 CD 00 00 E8 08
R 00 00 00 00 00 08 00 00 02 0C 00 00
T 3B 00 00 F8 02 2A 4F 46 AF 02 C9
R 00 00 00 00
T 43 00 00
R 00 00 00 00
T 43 00 00 F8 04 23 23 5D 54 F8 02 4D 44 D5 F8 06
R 00 00 00 00
T 50 00 00 2A 66 6F E5 C5 21 00 00 E5 CD 00 00 E8
R 00 00 00 00 00 09 00 00 02 0D 00 00
T 5D 00 00 08 F8 02 2A 4F 46 AF 02 C9
R 00 00 00 00
vprintf.rel/    0           0     0     644     826       `
XL3
H 7 areas 5 global symbols
M vprintf
O -mgbz80
S __print_format Ref000000
S _putchar Ref000000
S .__.ABS. Def000000
A _CODE size 3F flags 0 addr 0
S _vprintf Def00000C
S _printf Def000026
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 F8 02 4E 06 00 C5 CD 00 00 E8 02 C9
R 00 00 00 00 02 0A 01 00
T 0C 00 00
R 00 00 00 00
T 0C 00 00 F8 04 2A 66 6F E5 F8 04 2A 66 6F E5 21
R 00 00 00 00
T 19 00 00 00 00 E5 21 00 00 E5 CD 00 00 E8 08 C9
R 00 00 00 00 00 07 00 00 02 0B 00 00
T 26 00 00
R 00 00 00 00
T 26 00 00 F8 02 23 23 E5 F8 04 2A 66 6F E5 21
R 00 00 00 00
T 32 00 00 00 00 E5 21 00 00 E5 CD 00 00 E8 08 C9
R 00 00 00 00 00 07 00 00 02 0B 00 00
_strcmp.rel/    0           0     0     644     736       `
XL3
H 7 areas 2 global symbols
M _strcmp
O -mgbz80
S .__.ABS. Def000000
A _CODE size 33 flags 0 addr 0
S _strcmp Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FE F8 04 2A 5E F8 00 22 73 F8 06 2A
R 00 00 00 00
T 0D 00 00 4F 46
R 00 00 00 00
T 0F 00 00
R 00 00 00 00
T 0F 00 00 D1 D5 1A 26 00 F5 0A 6F F1 5D 16 00 93
R 00 00 00 00
T 1C 00 00 5F 7C 9A 57 B3 20 0D B5 28 0A F8 00 34
R 00 00 00 00
T 29 00 00 20 02 23 34
R 00 00 00 00
T 2D 00 00
R 00 00 00 00
T 2D 00 00 03 18 DF
R 00 00 00 00
T 30 00 00
R 00 00 00 00
T 30 00 00 E8 02 C9
R 00 00 00 00
_strcpy.rel/    0           0     0     644     474       `
XL3
H 7 areas 2 global symbols
M _strcpy
O -mgbz80
S .__.ABS. Def000000
A _CODE size 16 flags 0 addr 0
S _strcpy Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 C1 D1 D5 C5 F8 04 2A 4F 46
R 00 00 00 00
T 09 00 00
R 00 00 00 00
T 09 00 00 0A 03 12 13 B7 20 F9 F8 02 2A 5F 56 C9
R 00 00 00 00
_memmove.rel/   0           0     0     644     1370      `
XL3
H 7 areas 2 global symbols
M _memmove
O -mgbz80
S .__.ABS. Def000000
A _CODE size 91 flags 0 addr 0
S _memmove Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 E8 FA F8 0C 2A 5E F8 00 22 73 3A B6 20
R 00 00 00 00
T 0D 00 00 07 F8 08 2A 5F 56 18 79
R 00 00 00 00
T 15 00 00
R 00 00 00 00
T 15 00 00 F8 08 2A 4F 2A 47 2A 5F 56 7B 91 7A 98
R 00 00 00 00
T 22 00 00 30 3A E1 E5 09 4D 44 E1 E5 19 E5 7D F8
R 00 00 00 00
T 2F 00 00 04 77 E1 7C F8 03 77 F8 00 2A 5E F8 04
R 00 00 00 00
T 3C 00 00 22 73
R 00 00 00 00
T 3E 00 00
R 00 00 00 00
T 3E 00 00 0B F8 02 2A 5F 56 1B 2B 7B 22 7A 32 2A
R 00 00 00 00
T 4B 00 00 5F 56 1A 02 23 2A 5F 56 1B 2B 7B 22 72
R 00 00 00 00
T 58 00 00 3A B6 20 E2 18 2B
R 00 00 00 00
T 5E 00 00
R 00 00 00 00
T 5E 00 00 F8 02 7B 22 7A 22 79 22 70 C1 C5
R 00 00 00 00
T 69 00 00
R 00 00 00 00
T 69 00 00 F8 02 2A 5F 56 1A 2B 34 20 02 23 34
R 00 00 00 00
T 75 00 00
R 00 00 00 00
T 75 00 00 F8 04 F5 2A 66 6F F1 77 F8 04 34 20 02
R 00 00 00 00
T 82 00 00 23 34
R 00 00 00 00
T 84 00 00
R 00 00 00 00
T 84 00 00 0B 78 B1 20 E0
R 00 00 00 00
T 89 00 00
R 00 00 00 00
T 89 00 00 F8 08 2A 5F 56
R 00 00 00 00
T 8E 00 00
R 00 00 00 00
T 8E 00 00 E8 06 C9
R 00 00 00 00
/201            0           0     0     644     402       `
XL3
H 7 areas 2 global symbols
M atomic_flag_clear
O -mgbz80
S .__.ABS. Def000000
A _CODE size 8 flags 0 addr 0
S _atomic_flag_clear Def000000
A _DATA size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00 00
R 00 00 00 00
T 00 00 00 C1 D1 D5 C5 3E 01 12 C9
R 00 00 00 00
XL3
H 12 areas 5 global symbols
S _main Ref000000
S .__.ABS. Def000000
A _CODE size A flags 0 addr 0
S __clock Def000000
S _exit Def000004
A _HEADER size 0 flags 8 addr 0
A _HEADER0 size 3 flags 8 addr 0
A _HEADER1 size 1 flags 8 addr 8
A _HEADER2 size 1 flags 8 addr 10
A _HEADER3 size 1 flags 8 addr 18
A _HEADER4 size 1 flags 8 addr 20
A _HEADER5 size 1 flags 8 addr 28
A _HEADER6 size 1 flags 8 addr 30
A _HEADER7 size 1 flags 8 addr 38
A _HEADER8 size 3 flags 8 addr 100
A _HEADER9 size D flags 8 addr 150
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
S gsinit Def000000
A _GSFINAL size 1 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _BSS size 0 flags 0 addr 0
A _HEAP size 0 flags 0 addr 0
T 00 00 00
R 00 00 02 00
T 00 00 00 C3 50 01
R 00 00 02 00 00 04 0B 00
T 08 00 00
R 00 00 03 00
T 08 00 00 D9
R 00 00 03 00
T 10 00 00
R 00 00 04 00
T 10 00 00 D9
R 00 00 04 00
T 18 00 00
R 00 00 05 00
T 18 00 00 D9
R 00 00 05 00
T 20 00 00
R 00 00 06 00
T 20 00 00 D9
R 00 00 06 00
T 28 00 00
R 00 00 07 00
T 28 00 00 D9
R 00 00 07 00
T 30 00 00
R 00 00 08 00
T 30 00 00 D9
R 00 00 08 00
T 38 00 00
R 00 00 09 00
T 38 00 00 D9
R 00 00 09 00
T 00 01 00
R 00 00 0A 00
T 00 01 00 C3 50 01
R 00 00 0A 00
T 50 01 00
R 00 00 0B 00
T 50 01 00
R 00 00 0B 00
T 50 01 00 F3 31 00 E0 CD 00 00 CD 00 00 C3 04 00
R 00 00 0B 00 00 08 0D 00 02 0B 00 00 00 0E 00 00
T 00 00 00
R 00 00 00 00
T 00 00 00 3E 02 CF C9
R 00 00 00 00
T 04 00 00
R 00 00 00 00
T 04 00 00 3E 00 CF
R 00 00 00 00
T 07 00 00
R 00 00 00 00
T 07 00 00 76 18 FD
R 00 00 00 00
T 00 00 00
R 00 00 0D 00
T 00 00 00 C9
R 00 00 0E 00
